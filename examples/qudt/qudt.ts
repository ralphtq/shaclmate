
> dev
> node --stack-size=4000 --stack-trace-limit=100 packages/cli/dist/cli.js generate examples/qudt/SCHEMA_QUDT_NoOWL_v3.ttl

import { DataFactory as dataFactory } from "n3"
import type * as rdfjs from "@rdfjs/types";
import { z as zod } from "zod";
import { zodToJsonSchema } from "zod-to-json-schema";
import * as purify from "purify-ts";
import * as rdfjsResource from "rdfjs-resource";
import * as sparqljs from "sparqljs";
import * as rdfLiteral from "rdf-literal";
export type EqualsResult = purify.Either<EqualsResult.Unequal, true>;

export namespace EqualsResult {
    export const Equal: EqualsResult = purify.Either.of<Unequal, true>(true);

    export function fromBooleanEqualsResult(
      left: any,
      right: any,
      equalsResult: boolean | EqualsResult,
    ): EqualsResult {
      if (typeof equalsResult !== "boolean") {
        return equalsResult;
      }

      if (equalsResult) {
        return Equal;
      }
      return purify.Left({
        left,
        right,
        type: "BooleanEquals",
      });
    }

    export type Unequal =
      | {
          readonly left: {
            readonly array: readonly any[];
            readonly element: any;
            readonly elementIndex: number;
          };
          readonly right: {
            readonly array: readonly any[];
            readonly unequals: readonly Unequal[];
          };
          readonly type: "ArrayElement";
        }
      | {
          readonly left: readonly any[];
          readonly right: readonly any[];
          readonly type: "ArrayLength";
        }
      | {
          readonly left: any;
          readonly right: any;
          readonly type: "BooleanEquals";
        }
      | {
          readonly left: any;
          readonly right: any;
          readonly type: "LeftError";
        }
      | {
          readonly right: any;
          readonly type: "LeftNull";
        }
      | {
          readonly left: bigint | boolean | number | string;
          readonly right: bigint | boolean | number | string;
          readonly type: "Primitive";
        }
      | {
          readonly left: object;
          readonly right: object;
          readonly propertyName: string;
          readonly propertyValuesUnequal: Unequal;
          readonly type: "Property";
        }
      | {
          readonly left: any;
          readonly right: any;
          readonly type: "RightError";
        }
      | {
          readonly left: any;
          readonly type: "RightNull";
        };
}
/**
 * Compare two objects with equals(other: T): boolean methods and return an EqualsResult.
 */
export function booleanEquals<T extends { equals: (other: T) => boolean }>(
  left: T,
  right: T,
): EqualsResult {
  return EqualsResult.fromBooleanEqualsResult(
    left,
    right,
    left.equals(right),
  );
}
/**
 * Compare two values for strict equality (===), returning an EqualsResult rather than a boolean.
 */
export function strictEquals<T extends bigint | boolean | number | string>(
  left: T,
  right: T,
): EqualsResult {
  return EqualsResult.fromBooleanEqualsResult(left, right, left === right);
}
export function arrayEquals<T>(
  leftArray: readonly T[],
  rightArray: readonly T[],
  elementEquals: (left: T, right: T) => boolean | EqualsResult,
): EqualsResult {
  if (leftArray.length !== rightArray.length) {
    return purify.Left({
      left: leftArray,
      right: rightArray,
      type: "ArrayLength",
    });
  }

  for (
    let leftElementIndex = 0;
    leftElementIndex < leftArray.length;
    leftElementIndex++
  ) {
    const leftElement = leftArray[leftElementIndex];

    const rightUnequals: EqualsResult.Unequal[] = [];
    for (
      let rightElementIndex = 0;
      rightElementIndex < rightArray.length;
      rightElementIndex++
    ) {
      const rightElement = rightArray[rightElementIndex];

      const leftElementEqualsRightElement =
        EqualsResult.fromBooleanEqualsResult(
          leftElement,
          rightElement,
          elementEquals(leftElement, rightElement),
        );
      if (leftElementEqualsRightElement.isRight()) {
        break; // left element === right element, break out of the right iteration
      }
      rightUnequals.push(
        leftElementEqualsRightElement.extract() as EqualsResult.Unequal,
      );
    }

    if (rightUnequals.length === rightArray.length) {
      // All right elements were unequal to the left element
      return purify.Left({
        left: {
          array: leftArray,
          element: leftElement,
          elementIndex: leftElementIndex,
        },
        right: {
          array: rightArray,
          unequals: rightUnequals,
        },
        type: "ArrayElement",
      });
    }
    // Else there was a right element equal to the left element, continue to the next left element
  }

  return EqualsResult.Equal;
}
export function maybeEquals<T>(
  leftMaybe: purify.Maybe<T>,
  rightMaybe: purify.Maybe<T>,
  valueEquals: (left: T, right: T) => boolean | EqualsResult,
): EqualsResult {
  if (leftMaybe.isJust()) {
    if (rightMaybe.isJust()) {
      return EqualsResult.fromBooleanEqualsResult(
        leftMaybe,
        rightMaybe,
        valueEquals(leftMaybe.unsafeCoerce(), rightMaybe.unsafeCoerce()),
      );
    }
    return purify.Left({
      left: leftMaybe.unsafeCoerce(),
      type: "RightNull",
    });
  }

  if (rightMaybe.isJust()) {
    return purify.Left({
      right: rightMaybe.unsafeCoerce(),
      type: "LeftNull",
    });
  }

  return EqualsResult.Equal;
}
type UnwrapR<T> = T extends purify.Either<any, infer R> ? R : never
export class qudt_ScoreListShape {
    private _identifier: (rdfjs.BlankNode | rdfjs.NamedNode) | undefined;
    readonly type = "qudt_ScoreListShape";

    constructor(parameters: { readonly identifier?: (rdfjs.BlankNode | rdfjs.NamedNode) | string }) {
        if (typeof parameters.identifier === "object") { this._identifier = parameters.identifier; } else if (typeof parameters.identifier === "string") { this._identifier = dataFactory.namedNode(parameters.identifier); } else if (typeof parameters.identifier === "undefined") { } else { this._identifier =( parameters.identifier) as never;
         }
    }

    get identifier(): (rdfjs.BlankNode | rdfjs.NamedNode) {
        if (typeof this._identifier === "undefined") { this._identifier = dataFactory.blankNode(); } return this._identifier;
    }

    equals(other: qudt_ScoreListShape): EqualsResult {
        return (booleanEquals)(this.identifier, other.identifier).mapLeft(propertyValuesUnequal => ({ left: this, right: other, propertyName: "identifier", propertyValuesUnequal, type: "Property" as const })).chain(() => (strictEquals)(this.type, other.type).mapLeft(propertyValuesUnequal => ({ left: this, right: other, propertyName: "type", propertyValuesUnequal, type: "Property" as const })));
    }

    hash<HasherT extends { update: (message: string | number[] | ArrayBuffer | Uint8Array) => void; }>(_hasher: HasherT): HasherT {
        _hasher.update(this.identifier.value);
        _hasher.update(this.type);
        this.hashShaclProperties(_hasher);
        return _hasher;
    }

    protected hashShaclProperties<HasherT extends { update: (message: string | number[] | ArrayBuffer | Uint8Array) => void; }>(_hasher: HasherT): HasherT {
        return _hasher;
    }

    toJson(): { readonly "@id": string; readonly "type": "qudt_ScoreListShape" } {
        return JSON.parse(JSON.stringify({ "@id": this.identifier.termType === "BlankNode" ? `_:${this.identifier.value}` : this.identifier.value,type: this.type } satisfies ReturnType<qudt_ScoreListShape["toJson"]>));
    }

    toRdf({ mutateGraph, resourceSet }: { ignoreRdfType?: boolean; mutateGraph?: rdfjsResource.MutableResource.MutateGraph, resourceSet: rdfjsResource.MutableResourceSet }): rdfjsResource.MutableResource {
        const _resource = resourceSet.mutableResource(this.identifier, { mutateGraph });
        return _resource;
    }

    toString(): string {
        return JSON.stringify(this.toJson());
    }
}

export namespace qudt_ScoreListShape {
    export function _propertiesFromJson(_json: unknown): purify.Either<zod.ZodError, { identifier: (rdfjs.BlankNode | rdfjs.NamedNode); }> {
        const _jsonSafeParseResult = jsonZodSchema().safeParse(_json);
        if (!_jsonSafeParseResult.success) { return purify.Left(_jsonSafeParseResult.error); }

        const _jsonObject = _jsonSafeParseResult.data;
        const identifier = (_jsonObject["@id"].startsWith("_:") ? dataFactory.blankNode(_jsonObject["@id"].substring(2)) : dataFactory.namedNode(_jsonObject["@id"]));
        return purify.Either.of({ identifier })
    }

    export function fromJson(json: unknown): purify.Either<zod.ZodError, qudt_ScoreListShape> {
        return qudt_ScoreListShape._propertiesFromJson(json).map(properties => new qudt_ScoreListShape(properties));
    }

    export function _propertiesFromRdf({ ignoreRdfType: _ignoreRdfType, languageIn: _languageIn, resource: _resource,
        // @ts-ignore
        ..._context }: { [_index: string]: any; ignoreRdfType?: boolean; languageIn?: readonly string[]; resource: rdfjsResource.Resource; }): purify.Either<rdfjsResource.Resource.ValueError, { identifier: (rdfjs.BlankNode | rdfjs.NamedNode); }> {
        const identifier = _resource.identifier
        return purify.Either.of({ identifier })
    }

    export function fromRdf(parameters: Parameters<typeof qudt_ScoreListShape._propertiesFromRdf>[0]): purify.Either<rdfjsResource.Resource.ValueError, qudt_ScoreListShape> {
        return qudt_ScoreListShape._propertiesFromRdf(parameters).map(properties => new qudt_ScoreListShape(properties));
    }

    export function jsonSchema() {
        return zodToJsonSchema(jsonZodSchema());
    }

    export function jsonUiSchema(parameters?: { scopePrefix?: string }) {
        const scopePrefix = parameters?.scopePrefix ?? "#";
        return { "elements": [ { label: "Identifier", scope: `${scopePrefix}/properties/@id`, type: "Control" }, { rule: { condition: { schema: { const: "qudt_ScoreListShape" }, scope: `${scopePrefix}/properties/type` }, effect: "HIDE" }, scope: `${scopePrefix}/properties/type`, type: "Control" } ], label: "qudt_ScoreListShape", type: "Group" }
    }

    export function jsonZodSchema() {
        return zod.object({ "@id": zod.string().min(1),"type": zod.literal("qudt_ScoreListShape") });
    }

    export function sparqlConstructQuery(parameters?: { ignoreRdfType?: boolean; prefixes?: { [prefix: string]: string }; subject?: sparqljs.Triple["subject"]; } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type">): sparqljs.ConstructQuery {
        const { ignoreRdfType, subject, ...queryParameters } = parameters ?? {}

        return { ...queryParameters, prefixes: parameters?.prefixes ?? {}, queryType: "CONSTRUCT", template: (queryParameters.template ?? []).concat(qudt_ScoreListShape.sparqlConstructTemplateTriples({ ignoreRdfType, subject })), type: "query", where: (queryParameters.where ?? []).concat(qudt_ScoreListShape.sparqlWherePatterns({ ignoreRdfType, subject })) };
    }

    export function sparqlConstructQueryString(parameters?: { ignoreRdfType?: boolean; subject?: sparqljs.Triple["subject"]; variablePrefix?: string; } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type"> & sparqljs.GeneratorOptions): string {
        return new sparqljs.Generator(parameters).stringify(qudt_ScoreListShape.sparqlConstructQuery(parameters));
    }

    export function sparqlConstructTemplateTriples(_parameters?: { ignoreRdfType?: boolean; subject?: sparqljs.Triple["subject"], variablePrefix?: string }): readonly sparqljs.Triple[] {
        return [];
    }

    export function sparqlWherePatterns(_parameters: { ignoreRdfType?: boolean; subject?: sparqljs.Triple["subject"], variablePrefix?: string }): readonly sparqljs.Pattern[] {
        return [];
    }
}
/**
 * case-sensitive UCUM code
 */
export class case$j$sensitive_UCUM$W$code {
    private _identifier: (rdfjs.BlankNode | rdfjs.NamedNode) | undefined;
    readonly type = "case$j$sensitive_UCUM$W$code";

    constructor(parameters: { readonly identifier?: (rdfjs.BlankNode | rdfjs.NamedNode) | string }) {
        if (typeof parameters.identifier === "object") { this._identifier = parameters.identifier; } else if (typeof parameters.identifier === "string") { this._identifier = dataFactory.namedNode(parameters.identifier); } else if (typeof parameters.identifier === "undefined") { } else { this._identifier =( parameters.identifier) as never;
         }
    }

    get identifier(): (rdfjs.BlankNode | rdfjs.NamedNode) {
        if (typeof this._identifier === "undefined") { this._identifier = dataFactory.blankNode(); } return this._identifier;
    }

    equals(other: case$j$sensitive_UCUM$W$code): EqualsResult {
        return (booleanEquals)(this.identifier, other.identifier).mapLeft(propertyValuesUnequal => ({ left: this, right: other, propertyName: "identifier", propertyValuesUnequal, type: "Property" as const })).chain(() => (strictEquals)(this.type, other.type).mapLeft(propertyValuesUnequal => ({ left: this, right: other, propertyName: "type", propertyValuesUnequal, type: "Property" as const })));
    }

    hash<HasherT extends { update: (message: string | number[] | ArrayBuffer | Uint8Array) => void; }>(_hasher: HasherT): HasherT {
        _hasher.update(this.identifier.value);
        _hasher.update(this.type);
        this.hashShaclProperties(_hasher);
        return _hasher;
    }

    protected hashShaclProperties<HasherT extends { update: (message: string | number[] | ArrayBuffer | Uint8Array) => void; }>(_hasher: HasherT): HasherT {
        return _hasher;
    }

    toJson(): { readonly "@id": string; readonly "type": "case$j$sensitive_UCUM$W$code" } {
        return JSON.parse(JSON.stringify({ "@id": this.identifier.termType === "BlankNode" ? `_:${this.identifier.value}` : this.identifier.value,type: this.type } satisfies ReturnType<case$j$sensitive_UCUM$W$code["toJson"]>));
    }

    toRdf({ mutateGraph, resourceSet }: { ignoreRdfType?: boolean; mutateGraph?: rdfjsResource.MutableResource.MutateGraph, resourceSet: rdfjsResource.MutableResourceSet }): rdfjsResource.MutableResource {
        const _resource = resourceSet.mutableResource(this.identifier, { mutateGraph });
        return _resource;
    }

    toString(): string {
        return JSON.stringify(this.toJson());
    }
}

export namespace case$j$sensitive_UCUM$W$code {
    export function _propertiesFromJson(_json: unknown): purify.Either<zod.ZodError, { identifier: (rdfjs.BlankNode | rdfjs.NamedNode); }> {
        const _jsonSafeParseResult = jsonZodSchema().safeParse(_json);
        if (!_jsonSafeParseResult.success) { return purify.Left(_jsonSafeParseResult.error); }

        const _jsonObject = _jsonSafeParseResult.data;
        const identifier = (_jsonObject["@id"].startsWith("_:") ? dataFactory.blankNode(_jsonObject["@id"].substring(2)) : dataFactory.namedNode(_jsonObject["@id"]));
        return purify.Either.of({ identifier })
    }

    export function fromJson(json: unknown): purify.Either<zod.ZodError, case$j$sensitive_UCUM$W$code> {
        return case$j$sensitive_UCUM$W$code._propertiesFromJson(json).map(properties => new case$j$sensitive_UCUM$W$code(properties));
    }

    export function _propertiesFromRdf({ ignoreRdfType: _ignoreRdfType, languageIn: _languageIn, resource: _resource,
        // @ts-ignore
        ..._context }: { [_index: string]: any; ignoreRdfType?: boolean; languageIn?: readonly string[]; resource: rdfjsResource.Resource; }): purify.Either<rdfjsResource.Resource.ValueError, { identifier: (rdfjs.BlankNode | rdfjs.NamedNode); }> {
        const identifier = _resource.identifier
        return purify.Either.of({ identifier })
    }

    export function fromRdf(parameters: Parameters<typeof case$j$sensitive_UCUM$W$code._propertiesFromRdf>[0]): purify.Either<rdfjsResource.Resource.ValueError, case$j$sensitive_UCUM$W$code> {
        return case$j$sensitive_UCUM$W$code._propertiesFromRdf(parameters).map(properties => new case$j$sensitive_UCUM$W$code(properties));
    }

    export function jsonSchema() {
        return zodToJsonSchema(jsonZodSchema());
    }

    export function jsonUiSchema(parameters?: { scopePrefix?: string }) {
        const scopePrefix = parameters?.scopePrefix ?? "#";
        return { "elements": [ { label: "Identifier", scope: `${scopePrefix}/properties/@id`, type: "Control" }, { rule: { condition: { schema: { const: "case$j$sensitive_UCUM$W$code" }, scope: `${scopePrefix}/properties/type` }, effect: "HIDE" }, scope: `${scopePrefix}/properties/type`, type: "Control" } ], label: "case-sensitive UCUM code", type: "Group" }
    }

    export function jsonZodSchema() {
        return zod.object({ "@id": zod.string().min(1),"type": zod.literal("case$j$sensitive_UCUM$W$code") });
    }

    export function sparqlConstructQuery(parameters?: { ignoreRdfType?: boolean; prefixes?: { [prefix: string]: string }; subject?: sparqljs.Triple["subject"]; } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type">): sparqljs.ConstructQuery {
        const { ignoreRdfType, subject, ...queryParameters } = parameters ?? {}

        return { ...queryParameters, prefixes: parameters?.prefixes ?? {}, queryType: "CONSTRUCT", template: (queryParameters.template ?? []).concat(case$j$sensitive_UCUM$W$code.sparqlConstructTemplateTriples({ ignoreRdfType, subject })), type: "query", where: (queryParameters.where ?? []).concat(case$j$sensitive_UCUM$W$code.sparqlWherePatterns({ ignoreRdfType, subject })) };
    }

    export function sparqlConstructQueryString(parameters?: { ignoreRdfType?: boolean; subject?: sparqljs.Triple["subject"]; variablePrefix?: string; } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type"> & sparqljs.GeneratorOptions): string {
        return new sparqljs.Generator(parameters).stringify(case$j$sensitive_UCUM$W$code.sparqlConstructQuery(parameters));
    }

    export function sparqlConstructTemplateTriples(_parameters?: { ignoreRdfType?: boolean; subject?: sparqljs.Triple["subject"], variablePrefix?: string }): readonly sparqljs.Triple[] {
        return [];
    }

    export function sparqlWherePatterns(_parameters: { ignoreRdfType?: boolean; subject?: sparqljs.Triple["subject"], variablePrefix?: string }): readonly sparqljs.Pattern[] {
        return [];
    }
}
export class qudt_Person {
    private _identifier: (rdfjs.BlankNode | rdfjs.NamedNode) | undefined;
    readonly type = "qudt_Person";
    readonly qudt_hasScores: readonly (qudt_ScoreListShape)[];

    constructor(parameters: { readonly identifier?: (rdfjs.BlankNode | rdfjs.NamedNode) | string, readonly qudt_hasScores?: readonly (qudt_ScoreListShape)[] }) {
        if (typeof parameters.identifier === "object") { this._identifier = parameters.identifier; } else if (typeof parameters.identifier === "string") { this._identifier = dataFactory.namedNode(parameters.identifier); } else if (typeof parameters.identifier === "undefined") { } else { this._identifier =( parameters.identifier) as never;
         }

        if (typeof parameters.qudt_hasScores === "undefined") { this.qudt_hasScores = []; } else if (Array.isArray(parameters.qudt_hasScores)) { this.qudt_hasScores = parameters.qudt_hasScores; } else { this.qudt_hasScores =( parameters.qudt_hasScores) as never;
         }
    }

    get identifier(): (rdfjs.BlankNode | rdfjs.NamedNode) {
        if (typeof this._identifier === "undefined") { this._identifier = dataFactory.blankNode(); } return this._identifier;
    }

    equals(other: qudt_Person): EqualsResult {
        return (booleanEquals)(this.identifier, other.identifier).mapLeft(propertyValuesUnequal => ({ left: this, right: other, propertyName: "identifier", propertyValuesUnequal, type: "Property" as const })).chain(() => (strictEquals)(this.type, other.type).mapLeft(propertyValuesUnequal => ({ left: this, right: other, propertyName: "type", propertyValuesUnequal, type: "Property" as const }))).chain(() => (((left, right) => arrayEquals(left, right, ((left, right) => left.equals(right)))))(this.qudt_hasScores, other.qudt_hasScores).mapLeft(propertyValuesUnequal => ({ left: this, right: other, propertyName: "qudt_hasScores", propertyValuesUnequal, type: "Property" as const })));
    }

    hash<HasherT extends { update: (message: string | number[] | ArrayBuffer | Uint8Array) => void; }>(_hasher: HasherT): HasherT {
        _hasher.update(this.identifier.value);
        _hasher.update(this.type);
        this.hashShaclProperties(_hasher);
        return _hasher;
    }

    protected hashShaclProperties<HasherT extends { update: (message: string | number[] | ArrayBuffer | Uint8Array) => void; }>(_hasher: HasherT): HasherT {
        for (const _item0 of this.qudt_hasScores) { _item0.hash(_hasher); }

        return _hasher;
    }

    toJson(): { readonly "@id": string; readonly "type": "qudt_Person"; readonly "qudt_hasScores": readonly (ReturnType<qudt_ScoreListShape["toJson"]>)[] } {
        return JSON.parse(JSON.stringify({ "@id": this.identifier.termType === "BlankNode" ? `_:${this.identifier.value}` : this.identifier.value,type: this.type,qudt_hasScores: this.qudt_hasScores.map(_item => (_item.toJson())) } satisfies ReturnType<qudt_Person["toJson"]>));
    }

    toRdf({ ignoreRdfType, mutateGraph, resourceSet }: { ignoreRdfType?: boolean; mutateGraph?: rdfjsResource.MutableResource.MutateGraph, resourceSet: rdfjsResource.MutableResourceSet }): rdfjsResource.MutableResource {
        const _resource = resourceSet.mutableResource(this.identifier, { mutateGraph });
        if (!ignoreRdfType) { _resource.add(_resource.dataFactory.namedNode("http://www.w3.org/1999/02/22-rdf-syntax-ns#type"), _resource.dataFactory.namedNode("http://qudt.org/schema/qudt/Person")); }

        _resource.add(dataFactory.namedNode("http://qudt.org/schema/qudt/hasScores"), this.qudt_hasScores.map((_item) => _item.toRdf({ mutateGraph: mutateGraph, resourceSet: resourceSet })));
        return _resource;
    }

    toString(): string {
        return JSON.stringify(this.toJson());
    }
}

export namespace qudt_Person {
    export function _propertiesFromJson(_json: unknown): purify.Either<zod.ZodError, { identifier: (rdfjs.BlankNode | rdfjs.NamedNode); qudt_hasScores: readonly (qudt_ScoreListShape)[]; }> {
        const _jsonSafeParseResult = jsonZodSchema().safeParse(_json);
        if (!_jsonSafeParseResult.success) { return purify.Left(_jsonSafeParseResult.error); }

        const _jsonObject = _jsonSafeParseResult.data;
        const identifier = (_jsonObject["@id"].startsWith("_:") ? dataFactory.blankNode(_jsonObject["@id"].substring(2)) : dataFactory.namedNode(_jsonObject["@id"]));
        const qudt_hasScores = _jsonObject["qudt_hasScores"].map(_item => (qudt_ScoreListShape.fromJson(_item).unsafeCoerce()));
        return purify.Either.of({ identifier, qudt_hasScores })
    }

    export function fromJson(json: unknown): purify.Either<zod.ZodError, qudt_Person> {
        return qudt_Person._propertiesFromJson(json).map(properties => new qudt_Person(properties));
    }

    export function _propertiesFromRdf({ ignoreRdfType: _ignoreRdfType, languageIn: _languageIn, resource: _resource,
        // @ts-ignore
        ..._context }: { [_index: string]: any; ignoreRdfType?: boolean; languageIn?: readonly string[]; resource: rdfjsResource.Resource; }): purify.Either<rdfjsResource.Resource.ValueError, { identifier: (rdfjs.BlankNode | rdfjs.NamedNode); qudt_hasScores: readonly (qudt_ScoreListShape)[]; }> {
        if (!_ignoreRdfType && !_resource.isInstanceOf(dataFactory.namedNode("http://qudt.org/schema/qudt/Person"))) { return purify.Left(new rdfjsResource.Resource.ValueError({ focusResource: _resource, message: `${rdfjsResource.Resource.Identifier.toString(_resource.identifier)} has unexpected RDF type (expected http://qudt.org/schema/qudt/Person)`, predicate: dataFactory.namedNode("http://qudt.org/schema/qudt/Person") })); }

        const identifier = _resource.identifier
        const _qudt_hasScoresEither: purify.Either<rdfjsResource.Resource.ValueError, readonly (qudt_ScoreListShape)[]> = purify.Either.of([..._resource.values(dataFactory.namedNode("http://qudt.org/schema/qudt/hasScores"), { unique: true }).flatMap(_item => _item.toValues().head().chain(value => value.toResource()).chain(_resource => qudt_ScoreListShape.fromRdf({ ..._context, ignoreRdfType: true, languageIn: _languageIn, resource: _resource })).toMaybe().toList())]);
        if (_qudt_hasScoresEither.isLeft()) { return _qudt_hasScoresEither; }

        const qudt_hasScores = _qudt_hasScoresEither.unsafeCoerce();
        return purify.Either.of({ identifier, qudt_hasScores })
    }

    export function fromRdf(parameters: Parameters<typeof qudt_Person._propertiesFromRdf>[0]): purify.Either<rdfjsResource.Resource.ValueError, qudt_Person> {
        return qudt_Person._propertiesFromRdf(parameters).map(properties => new qudt_Person(properties));
    }

    export let fromRdfType: rdfjs.NamedNode<string> = dataFactory.namedNode("http://qudt.org/schema/qudt/Person");

    export function jsonSchema() {
        return zodToJsonSchema(jsonZodSchema());
    }

    export function jsonUiSchema(parameters?: { scopePrefix?: string }) {
        const scopePrefix = parameters?.scopePrefix ?? "#";
        return { "elements": [ { label: "Identifier", scope: `${scopePrefix}/properties/@id`, type: "Control" }, { rule: { condition: { schema: { const: "qudt_Person" }, scope: `${scopePrefix}/properties/type` }, effect: "HIDE" }, scope: `${scopePrefix}/properties/type`, type: "Control" }, qudt_ScoreListShape.jsonUiSchema({ scopePrefix: `${scopePrefix}/properties/qudt_hasScores` }) ], label: "qudt_Person", type: "Group" }
    }

    export function jsonZodSchema() {
        return zod.object({ "@id": zod.string().min(1),"type": zod.literal("qudt_Person"),"qudt_hasScores": qudt_ScoreListShape.jsonZodSchema().array() });
    }

    export function sparqlConstructQuery(parameters?: { ignoreRdfType?: boolean; prefixes?: { [prefix: string]: string }; subject?: sparqljs.Triple["subject"]; } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type">): sparqljs.ConstructQuery {
        const { ignoreRdfType, subject, ...queryParameters } = parameters ?? {}

        return { ...queryParameters, prefixes: parameters?.prefixes ?? {}, queryType: "CONSTRUCT", template: (queryParameters.template ?? []).concat(qudt_Person.sparqlConstructTemplateTriples({ ignoreRdfType, subject })), type: "query", where: (queryParameters.where ?? []).concat(qudt_Person.sparqlWherePatterns({ ignoreRdfType, subject })) };
    }

    export function sparqlConstructQueryString(parameters?: { ignoreRdfType?: boolean; subject?: sparqljs.Triple["subject"]; variablePrefix?: string; } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type"> & sparqljs.GeneratorOptions): string {
        return new sparqljs.Generator(parameters).stringify(qudt_Person.sparqlConstructQuery(parameters));
    }

    export function sparqlConstructTemplateTriples(parameters?: { ignoreRdfType?: boolean; subject?: sparqljs.Triple["subject"], variablePrefix?: string }): readonly sparqljs.Triple[] {
        const subject = parameters?.subject ?? dataFactory.variable!("qudtPerson");
        const variablePrefix = parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "qudtPerson");
        return [...(parameters?.ignoreRdfType ? [] : [{ subject, predicate: dataFactory.namedNode("http://www.w3.org/1999/02/22-rdf-syntax-ns#type"), object: dataFactory.variable!(`${variablePrefix}RdfType`) }]), { object: dataFactory.variable!(`${variablePrefix}QudtHasScores`), predicate: dataFactory.namedNode("http://qudt.org/schema/qudt/hasScores"), subject }, ...qudt_ScoreListShape.sparqlConstructTemplateTriples({ ignoreRdfType: true, subject: dataFactory.variable!(`${variablePrefix}QudtHasScores`), variablePrefix: `${variablePrefix}QudtHasScores` })];
    }

    export function sparqlWherePatterns(parameters: { ignoreRdfType?: boolean; subject?: sparqljs.Triple["subject"], variablePrefix?: string }): readonly sparqljs.Pattern[] {
        const subject = parameters?.subject ?? dataFactory.variable!("qudtPerson");
        const variablePrefix = parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "qudtPerson");
        return [...(parameters?.ignoreRdfType ? [] : [{ triples: [{ subject, predicate: dataFactory.namedNode("http://www.w3.org/1999/02/22-rdf-syntax-ns#type"), object: dataFactory.namedNode("http://qudt.org/schema/qudt/Person") }], type: "bgp" as const }, { triples: [{ subject, predicate: dataFactory.namedNode("http://www.w3.org/1999/02/22-rdf-syntax-ns#type"), object: dataFactory.variable!(`${variablePrefix}RdfType`) }], type: "bgp" as const }]), { patterns: [{ triples: [{ object: dataFactory.variable!(`${variablePrefix}QudtHasScores`), predicate: dataFactory.namedNode("http://qudt.org/schema/qudt/hasScores"), subject }], type: "bgp" }, ...qudt_ScoreListShape.sparqlWherePatterns({ ignoreRdfType: true, subject: dataFactory.variable!(`${variablePrefix}QudtHasScores`), variablePrefix: `${variablePrefix}QudtHasScores` })], type: "optional" }];
    }
}
/**
 * Node shape that isn't an rdfs:Class.
 */
export class NonClassNodeShape {
    private _identifier: (rdfjs.BlankNode | rdfjs.NamedNode) | undefined;
    readonly type = "NonClassNodeShape";
    readonly stringProperty: string;

    constructor(parameters: { readonly identifier?: (rdfjs.BlankNode | rdfjs.NamedNode) | string, readonly stringProperty: string }) {
        if (typeof parameters.identifier === "object") { this._identifier = parameters.identifier; } else if (typeof parameters.identifier === "string") { this._identifier = dataFactory.namedNode(parameters.identifier); } else if (typeof parameters.identifier === "undefined") { } else { this._identifier =( parameters.identifier) as never;
         }

        this.stringProperty = parameters.stringProperty;
    }

    get identifier(): (rdfjs.BlankNode | rdfjs.NamedNode) {
        if (typeof this._identifier === "undefined") { this._identifier = dataFactory.blankNode(); } return this._identifier;
    }

    equals(other: NonClassNodeShape): EqualsResult {
        return (booleanEquals)(this.identifier, other.identifier).mapLeft(propertyValuesUnequal => ({ left: this, right: other, propertyName: "identifier", propertyValuesUnequal, type: "Property" as const })).chain(() => (strictEquals)(this.type, other.type).mapLeft(propertyValuesUnequal => ({ left: this, right: other, propertyName: "type", propertyValuesUnequal, type: "Property" as const }))).chain(() => (strictEquals)(this.stringProperty, other.stringProperty).mapLeft(propertyValuesUnequal => ({ left: this, right: other, propertyName: "stringProperty", propertyValuesUnequal, type: "Property" as const })));
    }

    hash<HasherT extends { update: (message: string | number[] | ArrayBuffer | Uint8Array) => void; }>(_hasher: HasherT): HasherT {
        _hasher.update(this.identifier.value);
        _hasher.update(this.type);
        this.hashShaclProperties(_hasher);
        return _hasher;
    }

    protected hashShaclProperties<HasherT extends { update: (message: string | number[] | ArrayBuffer | Uint8Array) => void; }>(_hasher: HasherT): HasherT {
        _hasher.update(this.stringProperty);
        return _hasher;
    }

    toJson(): { readonly "@id": string; readonly "type": "NonClassNodeShape"; readonly "stringProperty": string } {
        return JSON.parse(JSON.stringify({ "@id": this.identifier.termType === "BlankNode" ? `_:${this.identifier.value}` : this.identifier.value,type: this.type,stringProperty: this.stringProperty } satisfies ReturnType<NonClassNodeShape["toJson"]>));
    }

    toRdf({ mutateGraph, resourceSet }: { ignoreRdfType?: boolean; mutateGraph?: rdfjsResource.MutableResource.MutateGraph, resourceSet: rdfjsResource.MutableResourceSet }): rdfjsResource.MutableResource {
        const _resource = resourceSet.mutableResource(this.identifier, { mutateGraph });
        _resource.add(dataFactory.namedNode("http://qudt.org/schema/qudt/stringProperty"), this.stringProperty);
        return _resource;
    }

    toString(): string {
        return JSON.stringify(this.toJson());
    }
}

export namespace NonClassNodeShape {
    export function _propertiesFromJson(_json: unknown): purify.Either<zod.ZodError, { identifier: (rdfjs.BlankNode | rdfjs.NamedNode); stringProperty: string; }> {
        const _jsonSafeParseResult = jsonZodSchema().safeParse(_json);
        if (!_jsonSafeParseResult.success) { return purify.Left(_jsonSafeParseResult.error); }

        const _jsonObject = _jsonSafeParseResult.data;
        const identifier = (_jsonObject["@id"].startsWith("_:") ? dataFactory.blankNode(_jsonObject["@id"].substring(2)) : dataFactory.namedNode(_jsonObject["@id"]));
        const stringProperty = _jsonObject["stringProperty"];
        return purify.Either.of({ identifier, stringProperty })
    }

    export function fromJson(json: unknown): purify.Either<zod.ZodError, NonClassNodeShape> {
        return NonClassNodeShape._propertiesFromJson(json).map(properties => new NonClassNodeShape(properties));
    }

    export function _propertiesFromRdf({ ignoreRdfType: _ignoreRdfType, languageIn: _languageIn, resource: _resource,
        // @ts-ignore
        ..._context }: { [_index: string]: any; ignoreRdfType?: boolean; languageIn?: readonly string[]; resource: rdfjsResource.Resource; }): purify.Either<rdfjsResource.Resource.ValueError, { identifier: (rdfjs.BlankNode | rdfjs.NamedNode); stringProperty: string; }> {
        const identifier = _resource.identifier
        const _stringPropertyEither: purify.Either<rdfjsResource.Resource.ValueError, string> = _resource.values(dataFactory.namedNode("http://qudt.org/schema/qudt/stringProperty"), { unique: true }).head().chain(_value => _value.toString());
        if (_stringPropertyEither.isLeft()) { return _stringPropertyEither; }

        const stringProperty = _stringPropertyEither.unsafeCoerce();
        return purify.Either.of({ identifier, stringProperty })
    }

    export function fromRdf(parameters: Parameters<typeof NonClassNodeShape._propertiesFromRdf>[0]): purify.Either<rdfjsResource.Resource.ValueError, NonClassNodeShape> {
        return NonClassNodeShape._propertiesFromRdf(parameters).map(properties => new NonClassNodeShape(properties));
    }

    export function jsonSchema() {
        return zodToJsonSchema(jsonZodSchema());
    }

    export function jsonUiSchema(parameters?: { scopePrefix?: string }) {
        const scopePrefix = parameters?.scopePrefix ?? "#";
        return { "elements": [ { label: "Identifier", scope: `${scopePrefix}/properties/@id`, type: "Control" }, { rule: { condition: { schema: { const: "NonClassNodeShape" }, scope: `${scopePrefix}/properties/type` }, effect: "HIDE" }, scope: `${scopePrefix}/properties/type`, type: "Control" }, { scope: `${scopePrefix}/properties/stringProperty`, type: "Control" } ], label: "NonClassNodeShape", type: "Group" }
    }

    export function jsonZodSchema() {
        return zod.object({ "@id": zod.string().min(1),"type": zod.literal("NonClassNodeShape"),"stringProperty": zod.string() });
    }

    export function sparqlConstructQuery(parameters?: { ignoreRdfType?: boolean; prefixes?: { [prefix: string]: string }; subject?: sparqljs.Triple["subject"]; } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type">): sparqljs.ConstructQuery {
        const { ignoreRdfType, subject, ...queryParameters } = parameters ?? {}

        return { ...queryParameters, prefixes: parameters?.prefixes ?? {}, queryType: "CONSTRUCT", template: (queryParameters.template ?? []).concat(NonClassNodeShape.sparqlConstructTemplateTriples({ ignoreRdfType, subject })), type: "query", where: (queryParameters.where ?? []).concat(NonClassNodeShape.sparqlWherePatterns({ ignoreRdfType, subject })) };
    }

    export function sparqlConstructQueryString(parameters?: { ignoreRdfType?: boolean; subject?: sparqljs.Triple["subject"]; variablePrefix?: string; } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type"> & sparqljs.GeneratorOptions): string {
        return new sparqljs.Generator(parameters).stringify(NonClassNodeShape.sparqlConstructQuery(parameters));
    }

    export function sparqlConstructTemplateTriples(parameters?: { ignoreRdfType?: boolean; subject?: sparqljs.Triple["subject"], variablePrefix?: string }): readonly sparqljs.Triple[] {
        const subject = parameters?.subject ?? dataFactory.variable!("nonClassNodeShape");
        const variablePrefix = parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "nonClassNodeShape");
        return [{ object: dataFactory.variable!(`${variablePrefix}StringProperty`), predicate: dataFactory.namedNode("http://qudt.org/schema/qudt/stringProperty"), subject }];
    }

    export function sparqlWherePatterns(parameters: { ignoreRdfType?: boolean; subject?: sparqljs.Triple["subject"], variablePrefix?: string }): readonly sparqljs.Pattern[] {
        const subject = parameters?.subject ?? dataFactory.variable!("nonClassNodeShape");
        const variablePrefix = parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "nonClassNodeShape");
        return [{ triples: [{ object: dataFactory.variable!(`${variablePrefix}StringProperty`), predicate: dataFactory.namedNode("http://qudt.org/schema/qudt/stringProperty"), subject }], type: "bgp" }];
    }
}
/**
 * QUDT Concept
 */
export class QUDT_Concept {
    protected _identifier: (rdfjs.BlankNode | rdfjs.NamedNode) | undefined;
    readonly type: "Abstract_Unit" | "Angle_unit" | "Base_Dimension$W$Magnitude" | "Binary_Prefix" | "CGS_Dimension$W$vector" | "CGS_EMU$W$Dimension$W$vector" | "CGS_ESU$W$Dimension$W$vector" | "CGS_GAUSS$W$Dimension$W$vector" | "CGS_LH$W$Dimension$W$vector" | "Citation" | "Comment" | "Constant_value" | "Contextual_Unit" | "Counting_Unit" | "Currency_Unit" | "Data_Item" | "Datatype" | "Decimal_Prefix" | "Derived_Unit" | "Dimensionless_Unit" | "Discipline" | "Enumerated_Quantity" | "Enumeration" | "Factor_Unit" | "Figure" | "ISO_Dimension$W$vector" | "Imperial_dimension$W$vector" | "Interval_scale" | "Logarithmic_Unit" | "NIST_SP$22$811$W$Comment" | "Nominal_scale" | "Ordinal_scale" | "Organization" | "Physical_Constant" | "Plane_Angle$W$Unit" | "Prefix" | "QUDT_Concept" | "Quantity" | "Quantity_Kind" | "Quantity_Kind$W$$e$abstract$f$" | "Quantity_Kind$W$Dimension$W$Vector" | "Quantity_Kind$W$Dimension$W$vector$W$$e$SI$f$" | "Quantity_value" | "Ratio_scale" | "Rule" | "Scalar_Data$W$Item" | "Scalar_Datatype" | "Scale" | "Solid_Angle$W$Unit" | "Symbol" | "System_of$W$Quantity$W$Kinds" | "System_of$W$Units" | "Unit" | "User_Quantity$W$Kind" = "QUDT_Concept";
    readonly qudt_Concept$j$abbreviation: purify.Maybe<string>;
    readonly qudt_Concept$j$code: readonly ((rdfjs.BlankNode | rdfjs.NamedNode | rdfjs.Literal))[];
    readonly qudt_Concept$j$deprecated: purify.Maybe<boolean>;
    readonly qudt_Concept$j$description: readonly ((rdfjs.BlankNode | rdfjs.NamedNode | rdfjs.Literal))[];
    readonly qudt_Concept$j$exactMatch: readonly ((rdfjs.BlankNode | rdfjs.NamedNode | rdfjs.Literal))[];
    readonly qudt_Concept$j$guidance: readonly (string)[];
    readonly qudt_Concept$j$hasRule: readonly (Rule)[];
    readonly qudt_Concept$j$id: purify.Maybe<string>;
    readonly qudt_Concept$j$isReplacedBy: purify.Maybe<(rdfjs.BlankNode | rdfjs.NamedNode | rdfjs.Literal)>;
    readonly qudt_Concept$j$plainTextDescription: readonly ((rdfjs.BlankNode | rdfjs.NamedNode | rdfjs.Literal))[];

    constructor(parameters: { readonly identifier?: (rdfjs.BlankNode | rdfjs.NamedNode) | string, readonly qudt_Concept$j$abbreviation?: purify.Maybe<string> | string, readonly qudt_Concept$j$code?: readonly ((rdfjs.BlankNode | rdfjs.NamedNode | rdfjs.Literal))[], readonly qudt_Concept$j$deprecated?: boolean | purify.Maybe<boolean>, readonly qudt_Concept$j$description?: readonly ((rdfjs.BlankNode | rdfjs.NamedNode | rdfjs.Literal))[], readonly qudt_Concept$j$exactMatch?: readonly ((rdfjs.BlankNode | rdfjs.NamedNode | rdfjs.Literal))[], readonly qudt_Concept$j$guidance?: readonly (string)[], readonly qudt_Concept$j$hasRule?: readonly (Rule)[], readonly qudt_Concept$j$id?: purify.Maybe<string> | string, readonly qudt_Concept$j$isReplacedBy?: (rdfjs.BlankNode | rdfjs.NamedNode | rdfjs.Literal) | Date | boolean | number | purify.Maybe<(rdfjs.BlankNode | rdfjs.NamedNode | rdfjs.Literal)> | string, readonly qudt_Concept$j$plainTextDescription?: readonly ((rdfjs.BlankNode | rdfjs.NamedNode | rdfjs.Literal))[] }) {
        if (typeof parameters.identifier === "object") { this._identifier = parameters.identifier; } else if (typeof parameters.identifier === "string") { this._identifier = dataFactory.namedNode(parameters.identifier); } else if (typeof parameters.identifier === "undefined") { } else { this._identifier =( parameters.identifier) as never;
         }

        if (purify.Maybe.isMaybe(parameters.qudt_Concept$j$abbreviation)) { this.qudt_Concept$j$abbreviation = parameters.qudt_Concept$j$abbreviation; } else if (typeof parameters.qudt_Concept$j$abbreviation === "string") { this.qudt_Concept$j$abbreviation = purify.Maybe.of(parameters.qudt_Concept$j$abbreviation); } else if (typeof parameters.qudt_Concept$j$abbreviation === "undefined") { this.qudt_Concept$j$abbreviation = purify.Maybe.empty(); } else { this.qudt_Concept$j$abbreviation =( parameters.qudt_Concept$j$abbreviation) as never;
         }

        if (typeof parameters.qudt_Concept$j$code === "undefined") { this.qudt_Concept$j$code = []; } else if (Array.isArray(parameters.qudt_Concept$j$code)) { this.qudt_Concept$j$code = parameters.qudt_Concept$j$code; } else { this.qudt_Concept$j$code =( parameters.qudt_Concept$j$code) as never;
         }

        if (purify.Maybe.isMaybe(parameters.qudt_Concept$j$deprecated)) { this.qudt_Concept$j$deprecated = parameters.qudt_Concept$j$deprecated; } else if (typeof parameters.qudt_Concept$j$deprecated === "boolean") { this.qudt_Concept$j$deprecated = purify.Maybe.of(parameters.qudt_Concept$j$deprecated); } else if (typeof parameters.qudt_Concept$j$deprecated === "undefined") { this.qudt_Concept$j$deprecated = purify.Maybe.empty(); } else { this.qudt_Concept$j$deprecated =( parameters.qudt_Concept$j$deprecated) as never;
         }

        if (typeof parameters.qudt_Concept$j$description === "undefined") { this.qudt_Concept$j$description = []; } else if (Array.isArray(parameters.qudt_Concept$j$description)) { this.qudt_Concept$j$description = parameters.qudt_Concept$j$description; } else { this.qudt_Concept$j$description =( parameters.qudt_Concept$j$description) as never;
         }

        if (typeof parameters.qudt_Concept$j$exactMatch === "undefined") { this.qudt_Concept$j$exactMatch = []; } else if (Array.isArray(parameters.qudt_Concept$j$exactMatch)) { this.qudt_Concept$j$exactMatch = parameters.qudt_Concept$j$exactMatch; } else { this.qudt_Concept$j$exactMatch =( parameters.qudt_Concept$j$exactMatch) as never;
         }

        if (typeof parameters.qudt_Concept$j$guidance === "undefined") { this.qudt_Concept$j$guidance = []; } else if (Array.isArray(parameters.qudt_Concept$j$guidance)) { this.qudt_Concept$j$guidance = parameters.qudt_Concept$j$guidance; } else { this.qudt_Concept$j$guidance =( parameters.qudt_Concept$j$guidance) as never;
         }

        if (typeof parameters.qudt_Concept$j$hasRule === "undefined") { this.qudt_Concept$j$hasRule = []; } else if (Array.isArray(parameters.qudt_Concept$j$hasRule)) { this.qudt_Concept$j$hasRule = parameters.qudt_Concept$j$hasRule; } else { this.qudt_Concept$j$hasRule =( parameters.qudt_Concept$j$hasRule) as never;
         }

        if (purify.Maybe.isMaybe(parameters.qudt_Concept$j$id)) { this.qudt_Concept$j$id = parameters.qudt_Concept$j$id; } else if (typeof parameters.qudt_Concept$j$id === "string") { this.qudt_Concept$j$id = purify.Maybe.of(parameters.qudt_Concept$j$id); } else if (typeof parameters.qudt_Concept$j$id === "undefined") { this.qudt_Concept$j$id = purify.Maybe.empty(); } else { this.qudt_Concept$j$id =( parameters.qudt_Concept$j$id) as never;
         }

        if (purify.Maybe.isMaybe(parameters.qudt_Concept$j$isReplacedBy)) { this.qudt_Concept$j$isReplacedBy = parameters.qudt_Concept$j$isReplacedBy; } else if (typeof parameters.qudt_Concept$j$isReplacedBy === "boolean") { this.qudt_Concept$j$isReplacedBy = purify.Maybe.of(rdfLiteral.toRdf(parameters.qudt_Concept$j$isReplacedBy, { dataFactory })); } else if (typeof parameters.qudt_Concept$j$isReplacedBy === "object" && parameters.qudt_Concept$j$isReplacedBy instanceof Date) { this.qudt_Concept$j$isReplacedBy = purify.Maybe.of(rdfLiteral.toRdf(parameters.qudt_Concept$j$isReplacedBy, { dataFactory })); } else if (typeof parameters.qudt_Concept$j$isReplacedBy === "number") { this.qudt_Concept$j$isReplacedBy = purify.Maybe.of(rdfLiteral.toRdf(parameters.qudt_Concept$j$isReplacedBy, { dataFactory })); } else if (typeof parameters.qudt_Concept$j$isReplacedBy === "string") { this.qudt_Concept$j$isReplacedBy = purify.Maybe.of(dataFactory.literal(parameters.qudt_Concept$j$isReplacedBy)); } else if (typeof parameters.qudt_Concept$j$isReplacedBy === "object") { this.qudt_Concept$j$isReplacedBy = purify.Maybe.of(parameters.qudt_Concept$j$isReplacedBy); } else if (typeof parameters.qudt_Concept$j$isReplacedBy === "undefined") { this.qudt_Concept$j$isReplacedBy = purify.Maybe.empty(); } else { this.qudt_Concept$j$isReplacedBy =( parameters.qudt_Concept$j$isReplacedBy) as never;
         }

        if (typeof parameters.qudt_Concept$j$plainTextDescription === "undefined") { this.qudt_Concept$j$plainTextDescription = []; } else if (Array.isArray(parameters.qudt_Concept$j$plainTextDescription)) { this.qudt_Concept$j$plainTextDescription = parameters.qudt_Concept$j$plainTextDescription; } else { this.qudt_Concept$j$plainTextDescription =( parameters.qudt_Concept$j$plainTextDescription) as never;
         }
    }

    get identifier(): (rdfjs.BlankNode | rdfjs.NamedNode) {
        if (typeof this._identifier === "undefined") { this._identifier = dataFactory.blankNode(); } return this._identifier;
    }

    equals(other: QUDT_Concept): EqualsResult {
        return (booleanEquals)(this.identifier, other.identifier).mapLeft(propertyValuesUnequal => ({ left: this, right: other, propertyName: "identifier", propertyValuesUnequal, type: "Property" as const })).chain(() => (strictEquals)(this.type, other.type).mapLeft(propertyValuesUnequal => ({ left: this, right: other, propertyName: "type", propertyValuesUnequal, type: "Property" as const }))).chain(() => (((left, right) => maybeEquals(left, right, strictEquals)))(this.qudt_Concept$j$abbreviation, other.qudt_Concept$j$abbreviation).mapLeft(propertyValuesUnequal => ({ left: this, right: other, propertyName: "qudt_Concept$j$abbreviation", propertyValuesUnequal, type: "Property" as const }))).chain(() => (((left, right) => arrayEquals(left, right, booleanEquals)))(this.qudt_Concept$j$code, other.qudt_Concept$j$code).mapLeft(propertyValuesUnequal => ({ left: this, right: other, propertyName: "qudt_Concept$j$code", propertyValuesUnequal, type: "Property" as const }))).chain(() => (((left, right) => maybeEquals(left, right, strictEquals)))(this.qudt_Concept$j$deprecated, other.qudt_Concept$j$deprecated).mapLeft(propertyValuesUnequal => ({ left: this, right: other, propertyName: "qudt_Concept$j$deprecated", propertyValuesUnequal, type: "Property" as const }))).chain(() => (((left, right) => arrayEquals(left, right, booleanEquals)))(this.qudt_Concept$j$description, other.qudt_Concept$j$description).mapLeft(propertyValuesUnequal => ({ left: this, right: other, propertyName: "qudt_Concept$j$description", propertyValuesUnequal, type: "Property" as const }))).chain(() => (((left, right) => arrayEquals(left, right, booleanEquals)))(this.qudt_Concept$j$exactMatch, other.qudt_Concept$j$exactMatch).mapLeft(propertyValuesUnequal => ({ left: this, right: other, propertyName: "qudt_Concept$j$exactMatch", propertyValuesUnequal, type: "Property" as const }))).chain(() => (((left, right) => arrayEquals(left, right, strictEquals)))(this.qudt_Concept$j$guidance, other.qudt_Concept$j$guidance).mapLeft(propertyValuesUnequal => ({ left: this, right: other, propertyName: "qudt_Concept$j$guidance", propertyValuesUnequal, type: "Property" as const }))).chain(() => (((left, right) => arrayEquals(left, right, ((left, right) => left.equals(right)))))(this.qudt_Concept$j$hasRule, other.qudt_Concept$j$hasRule).mapLeft(propertyValuesUnequal => ({ left: this, right: other, propertyName: "qudt_Concept$j$hasRule", propertyValuesUnequal, type: "Property" as const }))).chain(() => (((left, right) => maybeEquals(left, right, strictEquals)))(this.qudt_Concept$j$id, other.qudt_Concept$j$id).mapLeft(propertyValuesUnequal => ({ left: this, right: other, propertyName: "qudt_Concept$j$id", propertyValuesUnequal, type: "Property" as const }))).chain(() => (((left, right) => maybeEquals(left, right, booleanEquals)))(this.qudt_Concept$j$isReplacedBy, other.qudt_Concept$j$isReplacedBy).mapLeft(propertyValuesUnequal => ({ left: this, right: other, propertyName: "qudt_Concept$j$isReplacedBy", propertyValuesUnequal, type: "Property" as const }))).chain(() => (((left, right) => arrayEquals(left, right, booleanEquals)))(this.qudt_Concept$j$plainTextDescription, other.qudt_Concept$j$plainTextDescription).mapLeft(propertyValuesUnequal => ({ left: this, right: other, propertyName: "qudt_Concept$j$plainTextDescription", propertyValuesUnequal, type: "Property" as const })));
    }

    hash<HasherT extends { update: (message: string | number[] | ArrayBuffer | Uint8Array) => void; }>(_hasher: HasherT): HasherT {
        _hasher.update(this.identifier.value);
        _hasher.update(this.type);
        this.hashShaclProperties(_hasher);
        return _hasher;
    }

    protected hashShaclProperties<HasherT extends { update: (message: string | number[] | ArrayBuffer | Uint8Array) => void; }>(_hasher: HasherT): HasherT {
        this.qudt_Concept$j$abbreviation.ifJust((_value0) => { _hasher.update(_value0); })
        for (const _item0 of this.qudt_Concept$j$code) { _hasher.update(_item0.termType);
        _hasher.update(_item0.value); }

        this.qudt_Concept$j$deprecated.ifJust((_value0) => { _hasher.update(_value0.toString()); })
        for (const _item0 of this.qudt_Concept$j$description) { _hasher.update(_item0.termType);
        _hasher.update(_item0.value); }

        for (const _item0 of this.qudt_Concept$j$exactMatch) { _hasher.update(_item0.termType);
        _hasher.update(_item0.value); }

        for (const _item0 of this.qudt_Concept$j$guidance) { _hasher.update(_item0); }

        for (const _item0 of this.qudt_Concept$j$hasRule) { _item0.hash(_hasher); }

        this.qudt_Concept$j$id.ifJust((_value0) => { _hasher.update(_value0); })
        this.qudt_Concept$j$isReplacedBy.ifJust((_value0) => { _hasher.update(_value0.termType);
        _hasher.update(_value0.value); })
        for (const _item0 of this.qudt_Concept$j$plainTextDescription) { _hasher.update(_item0.termType);
        _hasher.update(_item0.value); }

        return _hasher;
    }

    toJson(): { readonly "@id": string; readonly "type": "Abstract_Unit" | "Angle_unit" | "Base_Dimension$W$Magnitude" | "Binary_Prefix" | "CGS_Dimension$W$vector" | "CGS_EMU$W$Dimension$W$vector" | "CGS_ESU$W$Dimension$W$vector" | "CGS_GAUSS$W$Dimension$W$vector" | "CGS_LH$W$Dimension$W$vector" | "Citation" | "Comment" | "Constant_value" | "Contextual_Unit" | "Counting_Unit" | "Currency_Unit" | "Data_Item" | "Datatype" | "Decimal_Prefix" | "Derived_Unit" | "Dimensionless_Unit" | "Discipline" | "Enumerated_Quantity" | "Enumeration" | "Factor_Unit" | "Figure" | "ISO_Dimension$W$vector" | "Imperial_dimension$W$vector" | "Interval_scale" | "Logarithmic_Unit" | "NIST_SP$22$811$W$Comment" | "Nominal_scale" | "Ordinal_scale" | "Organization" | "Physical_Constant" | "Plane_Angle$W$Unit" | "Prefix" | "QUDT_Concept" | "Quantity" | "Quantity_Kind" | "Quantity_Kind$W$$e$abstract$f$" | "Quantity_Kind$W$Dimension$W$Vector" | "Quantity_Kind$W$Dimension$W$vector$W$$e$SI$f$" | "Quantity_value" | "Ratio_scale" | "Rule" | "Scalar_Data$W$Item" | "Scalar_Datatype" | "Scale" | "Solid_Angle$W$Unit" | "Symbol" | "System_of$W$Quantity$W$Kinds" | "System_of$W$Units" | "Unit" | "User_Quantity$W$Kind"; readonly "qudt_Concept$j$abbreviation": (string) | undefined; readonly "qudt_Concept$j$code": readonly ({ readonly "@id": string, readonly termType: "BlankNode" | "NamedNode" } | { readonly "@language": string | undefined, readonly "@type": string | undefined, readonly "@value": string, readonly termType: "Literal" })[]; readonly "qudt_Concept$j$deprecated": (boolean) | undefined; readonly "qudt_Concept$j$description": readonly ({ readonly "@id": string, readonly termType: "BlankNode" | "NamedNode" } | { readonly "@language": string | undefined, readonly "@type": string | undefined, readonly "@value": string, readonly termType: "Literal" })[]; readonly "qudt_Concept$j$exactMatch": readonly ({ readonly "@id": string, readonly termType: "BlankNode" | "NamedNode" } | { readonly "@language": string | undefined, readonly "@type": string | undefined, readonly "@value": string, readonly termType: "Literal" })[]; readonly "qudt_Concept$j$guidance": readonly (string)[]; readonly "qudt_Concept$j$hasRule": readonly (ReturnType<Rule["toJson"]>)[]; readonly "qudt_Concept$j$id": (string) | undefined; readonly "qudt_Concept$j$isReplacedBy": ({ readonly "@id": string, readonly termType: "BlankNode" | "NamedNode" } | { readonly "@language": string | undefined, readonly "@type": string | undefined, readonly "@value": string, readonly termType: "Literal" }) | undefined; readonly "qudt_Concept$j$plainTextDescription": readonly ({ readonly "@id": string, readonly termType: "BlankNode" | "NamedNode" } | { readonly "@language": string | undefined, readonly "@type": string | undefined, readonly "@value": string, readonly termType: "Literal" })[] } {
        return JSON.parse(JSON.stringify({ "@id": this.identifier.termType === "BlankNode" ? `_:${this.identifier.value}` : this.identifier.value,type: this.type,qudt_Concept$j$abbreviation: this.qudt_Concept$j$abbreviation.map(_item => (_item)).extract(),qudt_Concept$j$code: this.qudt_Concept$j$code.map(_item => ((_item.termType === "Literal") ? { "@language": _item.language.length > 0 ? _item.language : undefined, "@type": _item.datatype.value !== "http://www.w3.org/2001/XMLSchema#string" ? _item.datatype.value : undefined, "@value": _item.value, termType: "Literal" as const } : (_item.termType === "NamedNode") ? { "@id": _item.value, termType: "NamedNode" as const } : { "@id": `_:${_item.value}`, termType: "BlankNode" as const })),qudt_Concept$j$deprecated: this.qudt_Concept$j$deprecated.map(_item => (_item)).extract(),qudt_Concept$j$description: this.qudt_Concept$j$description.map(_item => ((_item.termType === "Literal") ? { "@language": _item.language.length > 0 ? _item.language : undefined, "@type": _item.datatype.value !== "http://www.w3.org/2001/XMLSchema#string" ? _item.datatype.value : undefined, "@value": _item.value, termType: "Literal" as const } : (_item.termType === "NamedNode") ? { "@id": _item.value, termType: "NamedNode" as const } : { "@id": `_:${_item.value}`, termType: "BlankNode" as const })),qudt_Concept$j$exactMatch: this.qudt_Concept$j$exactMatch.map(_item => ((_item.termType === "Literal") ? { "@language": _item.language.length > 0 ? _item.language : undefined, "@type": _item.datatype.value !== "http://www.w3.org/2001/XMLSchema#string" ? _item.datatype.value : undefined, "@value": _item.value, termType: "Literal" as const } : (_item.termType === "NamedNode") ? { "@id": _item.value, termType: "NamedNode" as const } : { "@id": `_:${_item.value}`, termType: "BlankNode" as const })),qudt_Concept$j$guidance: this.qudt_Concept$j$guidance.map(_item => (_item)),qudt_Concept$j$hasRule: this.qudt_Concept$j$hasRule.map(_item => (_item.toJson())),qudt_Concept$j$id: this.qudt_Concept$j$id.map(_item => (_item)).extract(),qudt_Concept$j$isReplacedBy: this.qudt_Concept$j$isReplacedBy.map(_item => ((_item.termType === "Literal") ? { "@language": _item.language.length > 0 ? _item.language : undefined, "@type": _item.datatype.value !== "http://www.w3.org/2001/XMLSchema#string" ? _item.datatype.value : undefined, "@value": _item.value, termType: "Literal" as const } : (_item.termType === "NamedNode") ? { "@id": _item.value, termType: "NamedNode" as const } : { "@id": `_:${_item.value}`, termType: "BlankNode" as const })).extract(),qudt_Concept$j$plainTextDescription: this.qudt_Concept$j$plainTextDescription.map(_item => ((_item.termType === "Literal") ? { "@language": _item.language.length > 0 ? _item.language : undefined, "@type": _item.datatype.value !== "http://www.w3.org/2001/XMLSchema#string" ? _item.datatype.value : undefined, "@value": _item.value, termType: "Literal" as const } : (_item.termType === "NamedNode") ? { "@id": _item.value, termType: "NamedNode" as const } : { "@id": `_:${_item.value}`, termType: "BlankNode" as const })) } satisfies ReturnType<QUDT_Concept["toJson"]>));
    }

    toRdf({ ignoreRdfType, mutateGraph, resourceSet }: { ignoreRdfType?: boolean; mutateGraph?: rdfjsResource.MutableResource.MutateGraph, resourceSet: rdfjsResource.MutableResourceSet }): rdfjsResource.MutableResource {
        const _resource = resourceSet.mutableResource(this.identifier, { mutateGraph });
        if (!ignoreRdfType) { _resource.add(_resource.dataFactory.namedNode("http://www.w3.org/1999/02/22-rdf-syntax-ns#type"), _resource.dataFactory.namedNode("http://qudt.org/schema/qudt/Concept")); }

        _resource.add(dataFactory.namedNode("http://qudt.org/schema/qudt/abbreviation"), this.qudt_Concept$j$abbreviation);
        _resource.add(dataFactory.namedNode("http://www.linkedmodel.org/schema/dtype#code"), this.qudt_Concept$j$code.map((_item) => _item));
        _resource.add(dataFactory.namedNode("http://qudt.org/schema/qudt/deprecated"), this.qudt_Concept$j$deprecated);
        _resource.add(dataFactory.namedNode("http://purl.org/dc/terms/description"), this.qudt_Concept$j$description.map((_item) => _item));
        _resource.add(dataFactory.namedNode("http://qudt.org/schema/qudt/exactMatch"), this.qudt_Concept$j$exactMatch.map((_item) => _item));
        _resource.add(dataFactory.namedNode("http://qudt.org/schema/qudt/guidance"), this.qudt_Concept$j$guidance.map((_item) => _item));
        _resource.add(dataFactory.namedNode("http://qudt.org/schema/qudt/hasRule"), this.qudt_Concept$j$hasRule.map((_item) => _item.toRdf({ mutateGraph: mutateGraph, resourceSet: resourceSet })));
        _resource.add(dataFactory.namedNode("http://qudt.org/schema/qudt/id"), this.qudt_Concept$j$id);
        _resource.add(dataFactory.namedNode("http://purl.org/dc/terms/isReplacedBy"), this.qudt_Concept$j$isReplacedBy);
        _resource.add(dataFactory.namedNode("http://qudt.org/schema/qudt/plainTextDescription"), this.qudt_Concept$j$plainTextDescription.map((_item) => _item));
        return _resource;
    }

    toString(): string {
        return JSON.stringify(this.toJson());
    }
}

export namespace QUDT_Concept {
    export function _propertiesFromJson(_json: unknown): purify.Either<zod.ZodError, { identifier: (rdfjs.BlankNode | rdfjs.NamedNode); qudt_Concept$j$abbreviation: purify.Maybe<string>; qudt_Concept$j$code: readonly ((rdfjs.BlankNode | rdfjs.NamedNode | rdfjs.Literal))[]; qudt_Concept$j$deprecated: purify.Maybe<boolean>; qudt_Concept$j$description: readonly ((rdfjs.BlankNode | rdfjs.NamedNode | rdfjs.Literal))[]; qudt_Concept$j$exactMatch: readonly ((rdfjs.BlankNode | rdfjs.NamedNode | rdfjs.Literal))[]; qudt_Concept$j$guidance: readonly (string)[]; qudt_Concept$j$hasRule: readonly (Rule)[]; qudt_Concept$j$id: purify.Maybe<string>; qudt_Concept$j$isReplacedBy: purify.Maybe<(rdfjs.BlankNode | rdfjs.NamedNode | rdfjs.Literal)>; qudt_Concept$j$plainTextDescription: readonly ((rdfjs.BlankNode | rdfjs.NamedNode | rdfjs.Literal))[]; }> {
        const _jsonSafeParseResult = qudtConceptJsonZodSchema().safeParse(_json);
        if (!_jsonSafeParseResult.success) { return purify.Left(_jsonSafeParseResult.error); }

        const _jsonObject = _jsonSafeParseResult.data;
        const identifier = (_jsonObject["@id"].startsWith("_:") ? dataFactory.blankNode(_jsonObject["@id"].substring(2)) : dataFactory.namedNode(_jsonObject["@id"]));
        const qudt_Concept$j$abbreviation = purify.Maybe.fromNullable(_jsonObject["qudt_Concept$j$abbreviation"]);
        const qudt_Concept$j$code = _jsonObject["qudt_Concept$j$code"].map(_item => (((_item.termType === "Literal") ? (dataFactory.literal(_item["@value"], typeof _item["@language"] !== "undefined" ? _item["@language"] : (typeof _item["@type"] !== "undefined" ? dataFactory.namedNode(_item["@type"]) : undefined))) : (((_item.termType === "NamedNode") ? (dataFactory.namedNode(_item["@id"])) : (dataFactory.blankNode(_item["@id"].substring(2))))))));
        const qudt_Concept$j$deprecated = purify.Maybe.fromNullable(_jsonObject["qudt_Concept$j$deprecated"]);
        const qudt_Concept$j$description = _jsonObject["qudt_Concept$j$description"].map(_item => (((_item.termType === "Literal") ? (dataFactory.literal(_item["@value"], typeof _item["@language"] !== "undefined" ? _item["@language"] : (typeof _item["@type"] !== "undefined" ? dataFactory.namedNode(_item["@type"]) : undefined))) : (((_item.termType === "NamedNode") ? (dataFactory.namedNode(_item["@id"])) : (dataFactory.blankNode(_item["@id"].substring(2))))))));
        const qudt_Concept$j$exactMatch = _jsonObject["qudt_Concept$j$exactMatch"].map(_item => (((_item.termType === "Literal") ? (dataFactory.literal(_item["@value"], typeof _item["@language"] !== "undefined" ? _item["@language"] : (typeof _item["@type"] !== "undefined" ? dataFactory.namedNode(_item["@type"]) : undefined))) : (((_item.termType === "NamedNode") ? (dataFactory.namedNode(_item["@id"])) : (dataFactory.blankNode(_item["@id"].substring(2))))))));
        const qudt_Concept$j$guidance = _jsonObject["qudt_Concept$j$guidance"];
        const qudt_Concept$j$hasRule = _jsonObject["qudt_Concept$j$hasRule"].map(_item => (Rule.fromJson(_item).unsafeCoerce()));
        const qudt_Concept$j$id = purify.Maybe.fromNullable(_jsonObject["qudt_Concept$j$id"]);
        const qudt_Concept$j$isReplacedBy = purify.Maybe.fromNullable(_jsonObject["qudt_Concept$j$isReplacedBy"]).map(_item => (((_item.termType === "Literal") ? (dataFactory.literal(_item["@value"], typeof _item["@language"] !== "undefined" ? _item["@language"] : (typeof _item["@type"] !== "undefined" ? dataFactory.namedNode(_item["@type"]) : undefined))) : (((_item.termType === "NamedNode") ? (dataFactory.namedNode(_item["@id"])) : (dataFactory.blankNode(_item["@id"].substring(2))))))));
        const qudt_Concept$j$plainTextDescription = _jsonObject["qudt_Concept$j$plainTextDescription"].map(_item => (((_item.termType === "Literal") ? (dataFactory.literal(_item["@value"], typeof _item["@language"] !== "undefined" ? _item["@language"] : (typeof _item["@type"] !== "undefined" ? dataFactory.namedNode(_item["@type"]) : undefined))) : (((_item.termType === "NamedNode") ? (dataFactory.namedNode(_item["@id"])) : (dataFactory.blankNode(_item["@id"].substring(2))))))));
        return purify.Either.of({ identifier, qudt_Concept$j$abbreviation, qudt_Concept$j$code, qudt_Concept$j$deprecated, qudt_Concept$j$description, qudt_Concept$j$exactMatch, qudt_Concept$j$guidance, qudt_Concept$j$hasRule, qudt_Concept$j$id, qudt_Concept$j$isReplacedBy, qudt_Concept$j$plainTextDescription })
    }

    export function fromJson(json: unknown): purify.Either<zod.ZodError, QUDT_Concept> {
        return (Quantity_Kind$W$$e$abstract$f$.fromJson(json) as purify.Either<zod.ZodError, QUDT_Concept>).altLazy(() => (Abstract_Unit.fromJson(json) as purify.Either<zod.ZodError, QUDT_Concept>)).altLazy(() => (Base_Dimension$W$Magnitude.fromJson(json) as purify.Either<zod.ZodError, QUDT_Concept>)).altLazy(() => (Prefix.fromJson(json) as purify.Either<zod.ZodError, QUDT_Concept>)).altLazy(() => (Citation.fromJson(json) as purify.Either<zod.ZodError, QUDT_Concept>)).altLazy(() => (Comment.fromJson(json) as purify.Either<zod.ZodError, QUDT_Concept>)).altLazy(() => (Quantity_value.fromJson(json) as purify.Either<zod.ZodError, QUDT_Concept>)).altLazy(() => (Data_Item.fromJson(json) as purify.Either<zod.ZodError, QUDT_Concept>)).altLazy(() => (Datatype.fromJson(json) as purify.Either<zod.ZodError, QUDT_Concept>)).altLazy(() => (Discipline.fromJson(json) as purify.Either<zod.ZodError, QUDT_Concept>)).altLazy(() => (Enumerated_Quantity.fromJson(json) as purify.Either<zod.ZodError, QUDT_Concept>)).altLazy(() => (Enumeration.fromJson(json) as purify.Either<zod.ZodError, QUDT_Concept>)).altLazy(() => (Factor_Unit.fromJson(json) as purify.Either<zod.ZodError, QUDT_Concept>)).altLazy(() => (Figure.fromJson(json) as purify.Either<zod.ZodError, QUDT_Concept>)).altLazy(() => (Scale.fromJson(json) as purify.Either<zod.ZodError, QUDT_Concept>)).altLazy(() => (Organization.fromJson(json) as purify.Either<zod.ZodError, QUDT_Concept>)).altLazy(() => (Quantity.fromJson(json) as purify.Either<zod.ZodError, QUDT_Concept>)).altLazy(() => (Quantity_Kind$W$Dimension$W$Vector.fromJson(json) as purify.Either<zod.ZodError, QUDT_Concept>)).altLazy(() => (Rule.fromJson(json) as purify.Either<zod.ZodError, QUDT_Concept>)).altLazy(() => (Scalar_Data$W$Item.fromJson(json) as purify.Either<zod.ZodError, QUDT_Concept>)).altLazy(() => (Symbol.fromJson(json) as purify.Either<zod.ZodError, QUDT_Concept>)).altLazy(() => (System_of$W$Quantity$W$Kinds.fromJson(json) as purify.Either<zod.ZodError, QUDT_Concept>)).altLazy(() => (System_of$W$Units.fromJson(json) as purify.Either<zod.ZodError, QUDT_Concept>)).altLazy(() => QUDT_Concept._propertiesFromJson(json).map(properties => new QUDT_Concept(properties)));
    }

    export function _propertiesFromRdf({ ignoreRdfType: _ignoreRdfType, languageIn: _languageIn, resource: _resource,
        // @ts-ignore
        ..._context }: { [_index: string]: any; ignoreRdfType?: boolean; languageIn?: readonly string[]; resource: rdfjsResource.Resource; }): purify.Either<rdfjsResource.Resource.ValueError, { identifier: (rdfjs.BlankNode | rdfjs.NamedNode); qudt_Concept$j$abbreviation: purify.Maybe<string>; qudt_Concept$j$code: readonly ((rdfjs.BlankNode | rdfjs.NamedNode | rdfjs.Literal))[]; qudt_Concept$j$deprecated: purify.Maybe<boolean>; qudt_Concept$j$description: readonly ((rdfjs.BlankNode | rdfjs.NamedNode | rdfjs.Literal))[]; qudt_Concept$j$exactMatch: readonly ((rdfjs.BlankNode | rdfjs.NamedNode | rdfjs.Literal))[]; qudt_Concept$j$guidance: readonly (string)[]; qudt_Concept$j$hasRule: readonly (Rule)[]; qudt_Concept$j$id: purify.Maybe<string>; qudt_Concept$j$isReplacedBy: purify.Maybe<(rdfjs.BlankNode | rdfjs.NamedNode | rdfjs.Literal)>; qudt_Concept$j$plainTextDescription: readonly ((rdfjs.BlankNode | rdfjs.NamedNode | rdfjs.Literal))[]; }> {
        if (!_ignoreRdfType && !_resource.isInstanceOf(dataFactory.namedNode("http://qudt.org/schema/qudt/Concept"))) { return purify.Left(new rdfjsResource.Resource.ValueError({ focusResource: _resource, message: `${rdfjsResource.Resource.Identifier.toString(_resource.identifier)} has unexpected RDF type (expected http://qudt.org/schema/qudt/Concept)`, predicate: dataFactory.namedNode("http://qudt.org/schema/qudt/Concept") })); }

        const identifier = _resource.identifier
        const _qudt_Concept$j$abbreviationEither: purify.Either<rdfjsResource.Resource.ValueError, purify.Maybe<string>> = purify.Either.of(_resource.values(dataFactory.namedNode("http://qudt.org/schema/qudt/abbreviation"), { unique: true }).head().chain(_value => _value.toString()).toMaybe());
        if (_qudt_Concept$j$abbreviationEither.isLeft()) { return _qudt_Concept$j$abbreviationEither; }

        const qudt_Concept$j$abbreviation = _qudt_Concept$j$abbreviationEither.unsafeCoerce();
        const _qudt_Concept$j$codeEither: purify.Either<rdfjsResource.Resource.ValueError, readonly ((rdfjs.BlankNode | rdfjs.NamedNode | rdfjs.Literal))[]> = purify.Either.of([..._resource.values(dataFactory.namedNode("http://www.linkedmodel.org/schema/dtype#code"), { unique: true }).flatMap(_item => _item.toValues().head().chain(_value => purify.Either.of(_value.toTerm())).toMaybe().toList())]);
        if (_qudt_Concept$j$codeEither.isLeft()) { return _qudt_Concept$j$codeEither; }

        const qudt_Concept$j$code = _qudt_Concept$j$codeEither.unsafeCoerce();
        const _qudt_Concept$j$deprecatedEither: purify.Either<rdfjsResource.Resource.ValueError, purify.Maybe<boolean>> = purify.Either.of(_resource.values(dataFactory.namedNode("http://qudt.org/schema/qudt/deprecated"), { unique: true }).head().chain(_value => _value.toBoolean()).toMaybe());
        if (_qudt_Concept$j$deprecatedEither.isLeft()) { return _qudt_Concept$j$deprecatedEither; }

        const qudt_Concept$j$deprecated = _qudt_Concept$j$deprecatedEither.unsafeCoerce();
        const _qudt_Concept$j$descriptionEither: purify.Either<rdfjsResource.Resource.ValueError, readonly ((rdfjs.BlankNode | rdfjs.NamedNode | rdfjs.Literal))[]> = purify.Either.of([..._resource.values(dataFactory.namedNode("http://purl.org/dc/terms/description"), { unique: true }).flatMap(_item => _item.toValues().head().chain(_value => purify.Either.of(_value.toTerm())).toMaybe().toList())]);
        if (_qudt_Concept$j$descriptionEither.isLeft()) { return _qudt_Concept$j$descriptionEither; }

        const qudt_Concept$j$description = _qudt_Concept$j$descriptionEither.unsafeCoerce();
        const _qudt_Concept$j$exactMatchEither: purify.Either<rdfjsResource.Resource.ValueError, readonly ((rdfjs.BlankNode | rdfjs.NamedNode | rdfjs.Literal))[]> = purify.Either.of([..._resource.values(dataFactory.namedNode("http://qudt.org/schema/qudt/exactMatch"), { unique: true }).flatMap(_item => _item.toValues().head().chain(_value => purify.Either.of(_value.toTerm())).toMaybe().toList())]);
        if (_qudt_Concept$j$exactMatchEither.isLeft()) { return _qudt_Concept$j$exactMatchEither; }

        const qudt_Concept$j$exactMatch = _qudt_Concept$j$exactMatchEither.unsafeCoerce();
        const _qudt_Concept$j$guidanceEither: purify.Either<rdfjsResource.Resource.ValueError, readonly (string)[]> = purify.Either.of([..._resource.values(dataFactory.namedNode("http://qudt.org/schema/qudt/guidance"), { unique: true }).flatMap(_item => _item.toValues().head().chain(_value => _value.toString()).toMaybe().toList())]);
        if (_qudt_Concept$j$guidanceEither.isLeft()) { return _qudt_Concept$j$guidanceEither; }

        const qudt_Concept$j$guidance = _qudt_Concept$j$guidanceEither.unsafeCoerce();
        const _qudt_Concept$j$hasRuleEither: purify.Either<rdfjsResource.Resource.ValueError, readonly (Rule)[]> = purify.Either.of([..._resource.values(dataFactory.namedNode("http://qudt.org/schema/qudt/hasRule"), { unique: true }).flatMap(_item => _item.toValues().head().chain(value => value.toResource()).chain(_resource => Rule.fromRdf({ ..._context, ignoreRdfType: true, languageIn: _languageIn, resource: _resource })).toMaybe().toList())]);
        if (_qudt_Concept$j$hasRuleEither.isLeft()) { return _qudt_Concept$j$hasRuleEither; }

        const qudt_Concept$j$hasRule = _qudt_Concept$j$hasRuleEither.unsafeCoerce();
        const _qudt_Concept$j$idEither: purify.Either<rdfjsResource.Resource.ValueError, purify.Maybe<string>> = purify.Either.of(_resource.values(dataFactory.namedNode("http://qudt.org/schema/qudt/id"), { unique: true }).head().chain(_value => _value.toString()).toMaybe());
        if (_qudt_Concept$j$idEither.isLeft()) { return _qudt_Concept$j$idEither; }

        const qudt_Concept$j$id = _qudt_Concept$j$idEither.unsafeCoerce();
        const _qudt_Concept$j$isReplacedByEither: purify.Either<rdfjsResource.Resource.ValueError, purify.Maybe<(rdfjs.BlankNode | rdfjs.NamedNode | rdfjs.Literal)>> = purify.Either.of(_resource.values(dataFactory.namedNode("http://purl.org/dc/terms/isReplacedBy"), { unique: true }).head().chain(_value => purify.Either.of(_value.toTerm())).toMaybe());
        if (_qudt_Concept$j$isReplacedByEither.isLeft()) { return _qudt_Concept$j$isReplacedByEither; }

        const qudt_Concept$j$isReplacedBy = _qudt_Concept$j$isReplacedByEither.unsafeCoerce();
        const _qudt_Concept$j$plainTextDescriptionEither: purify.Either<rdfjsResource.Resource.ValueError, readonly ((rdfjs.BlankNode | rdfjs.NamedNode | rdfjs.Literal))[]> = purify.Either.of([..._resource.values(dataFactory.namedNode("http://qudt.org/schema/qudt/plainTextDescription"), { unique: true }).flatMap(_item => _item.toValues().head().chain(_value => purify.Either.of(_value.toTerm())).toMaybe().toList())]);
        if (_qudt_Concept$j$plainTextDescriptionEither.isLeft()) { return _qudt_Concept$j$plainTextDescriptionEither; }

        const qudt_Concept$j$plainTextDescription = _qudt_Concept$j$plainTextDescriptionEither.unsafeCoerce();
        return purify.Either.of({ identifier, qudt_Concept$j$abbreviation, qudt_Concept$j$code, qudt_Concept$j$deprecated, qudt_Concept$j$description, qudt_Concept$j$exactMatch, qudt_Concept$j$guidance, qudt_Concept$j$hasRule, qudt_Concept$j$id, qudt_Concept$j$isReplacedBy, qudt_Concept$j$plainTextDescription })
    }

    export function fromRdf(parameters: Parameters<typeof QUDT_Concept._propertiesFromRdf>[0]): purify.Either<rdfjsResource.Resource.ValueError, QUDT_Concept> {
        const { ignoreRdfType: _ignoreRdfType, ...otherParameters } = parameters
        return (Quantity_Kind$W$$e$abstract$f$.fromRdf(otherParameters) as purify.Either<rdfjsResource.Resource.ValueError, QUDT_Concept>).altLazy(() => (Abstract_Unit.fromRdf(otherParameters) as purify.Either<rdfjsResource.Resource.ValueError, QUDT_Concept>)).altLazy(() => (Base_Dimension$W$Magnitude.fromRdf(otherParameters) as purify.Either<rdfjsResource.Resource.ValueError, QUDT_Concept>)).altLazy(() => (Prefix.fromRdf(otherParameters) as purify.Either<rdfjsResource.Resource.ValueError, QUDT_Concept>)).altLazy(() => (Citation.fromRdf(otherParameters) as purify.Either<rdfjsResource.Resource.ValueError, QUDT_Concept>)).altLazy(() => (Comment.fromRdf(otherParameters) as purify.Either<rdfjsResource.Resource.ValueError, QUDT_Concept>)).altLazy(() => (Quantity_value.fromRdf(otherParameters) as purify.Either<rdfjsResource.Resource.ValueError, QUDT_Concept>)).altLazy(() => (Data_Item.fromRdf(otherParameters) as purify.Either<rdfjsResource.Resource.ValueError, QUDT_Concept>)).altLazy(() => (Datatype.fromRdf(otherParameters) as purify.Either<rdfjsResource.Resource.ValueError, QUDT_Concept>)).altLazy(() => (Discipline.fromRdf(otherParameters) as purify.Either<rdfjsResource.Resource.ValueError, QUDT_Concept>)).altLazy(() => (Enumerated_Quantity.fromRdf(otherParameters) as purify.Either<rdfjsResource.Resource.ValueError, QUDT_Concept>)).altLazy(() => (Enumeration.fromRdf(otherParameters) as purify.Either<rdfjsResource.Resource.ValueError, QUDT_Concept>)).altLazy(() => (Factor_Unit.fromRdf(otherParameters) as purify.Either<rdfjsResource.Resource.ValueError, QUDT_Concept>)).altLazy(() => (Figure.fromRdf(otherParameters) as purify.Either<rdfjsResource.Resource.ValueError, QUDT_Concept>)).altLazy(() => (Scale.fromRdf(otherParameters) as purify.Either<rdfjsResource.Resource.ValueError, QUDT_Concept>)).altLazy(() => (Organization.fromRdf(otherParameters) as purify.Either<rdfjsResource.Resource.ValueError, QUDT_Concept>)).altLazy(() => (Quantity.fromRdf(otherParameters) as purify.Either<rdfjsResource.Resource.ValueError, QUDT_Concept>)).altLazy(() => (Quantity_Kind$W$Dimension$W$Vector.fromRdf(otherParameters) as purify.Either<rdfjsResource.Resource.ValueError, QUDT_Concept>)).altLazy(() => (Rule.fromRdf(otherParameters) as purify.Either<rdfjsResource.Resource.ValueError, QUDT_Concept>)).altLazy(() => (Scalar_Data$W$Item.fromRdf(otherParameters) as purify.Either<rdfjsResource.Resource.ValueError, QUDT_Concept>)).altLazy(() => (Symbol.fromRdf(otherParameters) as purify.Either<rdfjsResource.Resource.ValueError, QUDT_Concept>)).altLazy(() => (System_of$W$Quantity$W$Kinds.fromRdf(otherParameters) as purify.Either<rdfjsResource.Resource.ValueError, QUDT_Concept>)).altLazy(() => (System_of$W$Units.fromRdf(otherParameters) as purify.Either<rdfjsResource.Resource.ValueError, QUDT_Concept>)).altLazy(() => QUDT_Concept._propertiesFromRdf(parameters).map(properties => new QUDT_Concept(properties)));
    }

    export let fromRdfType: rdfjs.NamedNode<string> = dataFactory.namedNode("http://qudt.org/schema/qudt/Concept");

    export function jsonSchema() {
        return zodToJsonSchema(qudtConceptJsonZodSchema());
    }

    export function qudtConceptJsonUiSchema(parameters?: { scopePrefix?: string }) {
        const scopePrefix = parameters?.scopePrefix ?? "#";
        return { "elements": [ { label: "Identifier", scope: `${scopePrefix}/properties/@id`, type: "Control" }, { rule: { condition: { schema: { const: "QUDT_Concept" }, scope: `${scopePrefix}/properties/type` }, effect: "HIDE" }, scope: `${scopePrefix}/properties/type`, type: "Control" }, { scope: `${scopePrefix}/properties/qudt_Concept$j$abbreviation`, type: "Control" }, { scope: `${scopePrefix}/properties/qudt_Concept$j$code`, type: "Control" }, { scope: `${scopePrefix}/properties/qudt_Concept$j$deprecated`, type: "Control" }, { scope: `${scopePrefix}/properties/qudt_Concept$j$description`, type: "Control" }, { scope: `${scopePrefix}/properties/qudt_Concept$j$exactMatch`, type: "Control" }, { scope: `${scopePrefix}/properties/qudt_Concept$j$guidance`, type: "Control" }, Rule.ruleJsonUiSchema({ scopePrefix: `${scopePrefix}/properties/qudt_Concept$j$hasRule` }), { scope: `${scopePrefix}/properties/qudt_Concept$j$id`, type: "Control" }, { scope: `${scopePrefix}/properties/qudt_Concept$j$isReplacedBy`, type: "Control" }, { scope: `${scopePrefix}/properties/qudt_Concept$j$plainTextDescription`, type: "Control" } ], label: "QUDT Concept", type: "Group" }
    }

    export function qudtConceptJsonZodSchema() {
        return zod.object({ "@id": zod.string().min(1),"type": zod.enum(["Abstract_Unit","Angle_unit","Base_Dimension$W$Magnitude","Binary_Prefix","CGS_Dimension$W$vector","CGS_EMU$W$Dimension$W$vector","CGS_ESU$W$Dimension$W$vector","CGS_GAUSS$W$Dimension$W$vector","CGS_LH$W$Dimension$W$vector","Citation","Comment","Constant_value","Contextual_Unit","Counting_Unit","Currency_Unit","Data_Item","Datatype","Decimal_Prefix","Derived_Unit","Dimensionless_Unit","Discipline","Enumerated_Quantity","Enumeration","Factor_Unit","Figure","ISO_Dimension$W$vector","Imperial_dimension$W$vector","Interval_scale","Logarithmic_Unit","NIST_SP$22$811$W$Comment","Nominal_scale","Ordinal_scale","Organization","Physical_Constant","Plane_Angle$W$Unit","Prefix","QUDT_Concept","Quantity","Quantity_Kind","Quantity_Kind$W$$e$abstract$f$","Quantity_Kind$W$Dimension$W$Vector","Quantity_Kind$W$Dimension$W$vector$W$$e$SI$f$","Quantity_value","Ratio_scale","Rule","Scalar_Data$W$Item","Scalar_Datatype","Scale","Solid_Angle$W$Unit","Symbol","System_of$W$Quantity$W$Kinds","System_of$W$Units","Unit","User_Quantity$W$Kind"]),"qudt_Concept$j$abbreviation": zod.string().optional(),"qudt_Concept$j$code": zod.discriminatedUnion("termType", [zod.object({ "@id": zod.string().min(1), termType: zod.literal("BlankNode") }), zod.object({ "@id": zod.string().min(1), termType: zod.literal("NamedNode") }), zod.object({ "@language": zod.string().optional(), "@type": zod.string().optional(), "@value": zod.string(), termType: zod.literal("Literal") })]).array(),"qudt_Concept$j$deprecated": zod.boolean().optional(),"qudt_Concept$j$description": zod.discriminatedUnion("termType", [zod.object({ "@id": zod.string().min(1), termType: zod.literal("BlankNode") }), zod.object({ "@id": zod.string().min(1), termType: zod.literal("NamedNode") }), zod.object({ "@language": zod.string().optional(), "@type": zod.string().optional(), "@value": zod.string(), termType: zod.literal("Literal") })]).array(),"qudt_Concept$j$exactMatch": zod.discriminatedUnion("termType", [zod.object({ "@id": zod.string().min(1), termType: zod.literal("BlankNode") }), zod.object({ "@id": zod.string().min(1), termType: zod.literal("NamedNode") }), zod.object({ "@language": zod.string().optional(), "@type": zod.string().optional(), "@value": zod.string(), termType: zod.literal("Literal") })]).array(),"qudt_Concept$j$guidance": zod.string().array(),"qudt_Concept$j$hasRule": Rule.ruleJsonZodSchema().array(),"qudt_Concept$j$id": zod.string().optional(),"qudt_Concept$j$isReplacedBy": zod.discriminatedUnion("termType", [zod.object({ "@id": zod.string().min(1), termType: zod.literal("BlankNode") }), zod.object({ "@id": zod.string().min(1), termType: zod.literal("NamedNode") }), zod.object({ "@language": zod.string().optional(), "@type": zod.string().optional(), "@value": zod.string(), termType: zod.literal("Literal") })]).optional(),"qudt_Concept$j$plainTextDescription": zod.discriminatedUnion("termType", [zod.object({ "@id": zod.string().min(1), termType: zod.literal("BlankNode") }), zod.object({ "@id": zod.string().min(1), termType: zod.literal("NamedNode") }), zod.object({ "@language": zod.string().optional(), "@type": zod.string().optional(), "@value": zod.string(), termType: zod.literal("Literal") })]).array() });
    }

    export function sparqlConstructQuery(parameters?: { ignoreRdfType?: boolean; prefixes?: { [prefix: string]: string }; subject?: sparqljs.Triple["subject"]; } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type">): sparqljs.ConstructQuery {
        const { ignoreRdfType, subject, ...queryParameters } = parameters ?? {}

        return { ...queryParameters, prefixes: parameters?.prefixes ?? {}, queryType: "CONSTRUCT", template: (queryParameters.template ?? []).concat(QUDT_Concept.sparqlConstructTemplateTriples({ ignoreRdfType, subject })), type: "query", where: (queryParameters.where ?? []).concat(QUDT_Concept.sparqlWherePatterns({ ignoreRdfType, subject })) };
    }

    export function sparqlConstructQueryString(parameters?: { ignoreRdfType?: boolean; subject?: sparqljs.Triple["subject"]; variablePrefix?: string; } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type"> & sparqljs.GeneratorOptions): string {
        return new sparqljs.Generator(parameters).stringify(QUDT_Concept.sparqlConstructQuery(parameters));
    }

    export function sparqlConstructTemplateTriples(parameters?: { ignoreRdfType?: boolean; subject?: sparqljs.Triple["subject"], variablePrefix?: string }): readonly sparqljs.Triple[] {
        const subject = parameters?.subject ?? dataFactory.variable!("qudtConcept");
        const variablePrefix = parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "qudtConcept");
        return [...(parameters?.ignoreRdfType ? [] : [{ subject, predicate: dataFactory.namedNode("http://www.w3.org/1999/02/22-rdf-syntax-ns#type"), object: dataFactory.variable!(`${variablePrefix}RdfType`) }]), { object: dataFactory.variable!(`${variablePrefix}QudtConceptJAbbreviation`), predicate: dataFactory.namedNode("http://qudt.org/schema/qudt/abbreviation"), subject }, { object: dataFactory.variable!(`${variablePrefix}QudtConceptJCode`), predicate: dataFactory.namedNode("http://www.linkedmodel.org/schema/dtype#code"), subject }, { object: dataFactory.variable!(`${variablePrefix}QudtConceptJDeprecated`), predicate: dataFactory.namedNode("http://qudt.org/schema/qudt/deprecated"), subject }, { object: dataFactory.variable!(`${variablePrefix}QudtConceptJDescription`), predicate: dataFactory.namedNode("http://purl.org/dc/terms/description"), subject }, { object: dataFactory.variable!(`${variablePrefix}QudtConceptJExactMatch`), predicate: dataFactory.namedNode("http://qudt.org/schema/qudt/exactMatch"), subject }, { object: dataFactory.variable!(`${variablePrefix}QudtConceptJGuidance`), predicate: dataFactory.namedNode("http://qudt.org/schema/qudt/guidance"), subject }, { object: dataFactory.variable!(`${variablePrefix}QudtConceptJHasRule`), predicate: dataFactory.namedNode("http://qudt.org/schema/qudt/hasRule"), subject }, ...Rule.sparqlConstructTemplateTriples({ ignoreRdfType: true, subject: dataFactory.variable!(`${variablePrefix}QudtConceptJHasRule`), variablePrefix: `${variablePrefix}QudtConceptJHasRule` }), { object: dataFactory.variable!(`${variablePrefix}QudtConceptJId`), predicate: dataFactory.namedNode("http://qudt.org/schema/qudt/id"), subject }, { object: dataFactory.variable!(`${variablePrefix}QudtConceptJIsReplacedBy`), predicate: dataFactory.namedNode("http://purl.org/dc/terms/isReplacedBy"), subject }, { object: dataFactory.variable!(`${variablePrefix}QudtConceptJPlainTextDescription`), predicate: dataFactory.namedNode("http://qudt.org/schema/qudt/plainTextDescription"), subject }];
    }

    export function sparqlWherePatterns(parameters: { ignoreRdfType?: boolean; subject?: sparqljs.Triple["subject"], variablePrefix?: string }): readonly sparqljs.Pattern[] {
        const subject = parameters?.subject ?? dataFactory.variable!("qudtConcept");
        const variablePrefix = parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "qudtConcept");
        return [...(parameters?.ignoreRdfType ? [] : [{ triples: [{ subject, predicate: dataFactory.namedNode("http://www.w3.org/1999/02/22-rdf-syntax-ns#type"), object: dataFactory.namedNode("http://qudt.org/schema/qudt/Concept") }], type: "bgp" as const }, { triples: [{ subject, predicate: dataFactory.namedNode("http://www.w3.org/1999/02/22-rdf-syntax-ns#type"), object: dataFactory.variable!(`${variablePrefix}RdfType`) }], type: "bgp" as const }]), { patterns: [{ triples: [{ object: dataFactory.variable!(`${variablePrefix}QudtConceptJAbbreviation`), predicate: dataFactory.namedNode("http://qudt.org/schema/qudt/abbreviation"), subject }], type: "bgp" }], type: "optional" }, { patterns: [{ triples: [{ object: dataFactory.variable!(`${variablePrefix}QudtConceptJCode`), predicate: dataFactory.namedNode("http://www.linkedmodel.org/schema/dtype#code"), subject }], type: "bgp" }], type: "optional" }, { patterns: [{ triples: [{ object: dataFactory.variable!(`${variablePrefix}QudtConceptJDeprecated`), predicate: dataFactory.namedNode("http://qudt.org/schema/qudt/deprecated"), subject }], type: "bgp" }], type: "optional" }, { patterns: [{ triples: [{ object: dataFactory.variable!(`${variablePrefix}QudtConceptJDescription`), predicate: dataFactory.namedNode("http://purl.org/dc/terms/description"), subject }], type: "bgp" }], type: "optional" }, { patterns: [{ triples: [{ object: dataFactory.variable!(`${variablePrefix}QudtConceptJExactMatch`), predicate: dataFactory.namedNode("http://qudt.org/schema/qudt/exactMatch"), subject }], type: "bgp" }], type: "optional" }, { patterns: [{ triples: [{ object: dataFactory.variable!(`${variablePrefix}QudtConceptJGuidance`), predicate: dataFactory.namedNode("http://qudt.org/schema/qudt/guidance"), subject }], type: "bgp" }], type: "optional" }, { patterns: [{ triples: [{ object: dataFactory.variable!(`${variablePrefix}QudtConceptJHasRule`), predicate: dataFactory.namedNode("http://qudt.org/schema/qudt/hasRule"), subject }], type: "bgp" }, ...Rule.sparqlWherePatterns({ ignoreRdfType: true, subject: dataFactory.variable!(`${variablePrefix}QudtConceptJHasRule`), variablePrefix: `${variablePrefix}QudtConceptJHasRule` })], type: "optional" }, { patterns: [{ triples: [{ object: dataFactory.variable!(`${variablePrefix}QudtConceptJId`), predicate: dataFactory.namedNode("http://qudt.org/schema/qudt/id"), subject }], type: "bgp" }], type: "optional" }, { patterns: [{ triples: [{ object: dataFactory.variable!(`${variablePrefix}QudtConceptJIsReplacedBy`), predicate: dataFactory.namedNode("http://purl.org/dc/terms/isReplacedBy"), subject }], type: "bgp" }], type: "optional" }, { patterns: [{ triples: [{ object: dataFactory.variable!(`${variablePrefix}QudtConceptJPlainTextDescription`), predicate: dataFactory.namedNode("http://qudt.org/schema/qudt/plainTextDescription"), subject }], type: "bgp" }], type: "optional" }];
    }
}
/**
 * Quantity Kind (abstract)
 */
export class Quantity_Kind$W$$e$abstract$f$ extends QUDT_Concept {
    override readonly type: "Quantity_Kind" | "Quantity_Kind$W$$e$abstract$f$" | "User_Quantity$W$Kind" = "Quantity_Kind$W$$e$abstract$f$";
    readonly qudt_AbstractQuantityKind$j$altSymbol: readonly ((rdfjs.BlankNode | rdfjs.NamedNode | rdfjs.Literal))[];
    readonly qudt_AbstractQuantityKind$j$broader: readonly (Quantity_Kind)[];
    readonly qudt_AbstractQuantityKind$j$latexSymbol: readonly (string)[];
    readonly qudt_AbstractQuantityKind$j$symbol: purify.Maybe<(rdfjs.BlankNode | rdfjs.NamedNode | rdfjs.Literal)>;

    constructor(parameters: { readonly identifier?: (rdfjs.BlankNode | rdfjs.NamedNode) | string, readonly qudt_AbstractQuantityKind$j$altSymbol?: readonly ((rdfjs.BlankNode | rdfjs.NamedNode | rdfjs.Literal))[], readonly qudt_AbstractQuantityKind$j$broader?: readonly (Quantity_Kind)[], readonly qudt_AbstractQuantityKind$j$latexSymbol?: readonly (string)[], readonly qudt_AbstractQuantityKind$j$symbol?: (rdfjs.BlankNode | rdfjs.NamedNode | rdfjs.Literal) | Date | boolean | number | purify.Maybe<(rdfjs.BlankNode | rdfjs.NamedNode | rdfjs.Literal)> | string } & ConstructorParameters<typeof QUDT_Concept>[0]) {
        super(parameters);
        if (typeof parameters.qudt_AbstractQuantityKind$j$altSymbol === "undefined") { this.qudt_AbstractQuantityKind$j$altSymbol = []; } else if (Array.isArray(parameters.qudt_AbstractQuantityKind$j$altSymbol)) { this.qudt_AbstractQuantityKind$j$altSymbol = parameters.qudt_AbstractQuantityKind$j$altSymbol; } else { this.qudt_AbstractQuantityKind$j$altSymbol =( parameters.qudt_AbstractQuantityKind$j$altSymbol) as never;
         }

        if (typeof parameters.qudt_AbstractQuantityKind$j$broader === "undefined") { this.qudt_AbstractQuantityKind$j$broader = []; } else if (Array.isArray(parameters.qudt_AbstractQuantityKind$j$broader)) { this.qudt_AbstractQuantityKind$j$broader = parameters.qudt_AbstractQuantityKind$j$broader; } else { this.qudt_AbstractQuantityKind$j$broader =( parameters.qudt_AbstractQuantityKind$j$broader) as never;
         }

        if (typeof parameters.qudt_AbstractQuantityKind$j$latexSymbol === "undefined") { this.qudt_AbstractQuantityKind$j$latexSymbol = []; } else if (Array.isArray(parameters.qudt_AbstractQuantityKind$j$latexSymbol)) { this.qudt_AbstractQuantityKind$j$latexSymbol = parameters.qudt_AbstractQuantityKind$j$latexSymbol; } else { this.qudt_AbstractQuantityKind$j$latexSymbol =( parameters.qudt_AbstractQuantityKind$j$latexSymbol) as never;
         }

        if (purify.Maybe.isMaybe(parameters.qudt_AbstractQuantityKind$j$symbol)) { this.qudt_AbstractQuantityKind$j$symbol = parameters.qudt_AbstractQuantityKind$j$symbol; } else if (typeof parameters.qudt_AbstractQuantityKind$j$symbol === "boolean") { this.qudt_AbstractQuantityKind$j$symbol = purify.Maybe.of(rdfLiteral.toRdf(parameters.qudt_AbstractQuantityKind$j$symbol, { dataFactory })); } else if (typeof parameters.qudt_AbstractQuantityKind$j$symbol === "object" && parameters.qudt_AbstractQuantityKind$j$symbol instanceof Date) { this.qudt_AbstractQuantityKind$j$symbol = purify.Maybe.of(rdfLiteral.toRdf(parameters.qudt_AbstractQuantityKind$j$symbol, { dataFactory })); } else if (typeof parameters.qudt_AbstractQuantityKind$j$symbol === "number") { this.qudt_AbstractQuantityKind$j$symbol = purify.Maybe.of(rdfLiteral.toRdf(parameters.qudt_AbstractQuantityKind$j$symbol, { dataFactory })); } else if (typeof parameters.qudt_AbstractQuantityKind$j$symbol === "string") { this.qudt_AbstractQuantityKind$j$symbol = purify.Maybe.of(dataFactory.literal(parameters.qudt_AbstractQuantityKind$j$symbol)); } else if (typeof parameters.qudt_AbstractQuantityKind$j$symbol === "object") { this.qudt_AbstractQuantityKind$j$symbol = purify.Maybe.of(parameters.qudt_AbstractQuantityKind$j$symbol); } else if (typeof parameters.qudt_AbstractQuantityKind$j$symbol === "undefined") { this.qudt_AbstractQuantityKind$j$symbol = purify.Maybe.empty(); } else { this.qudt_AbstractQuantityKind$j$symbol =( parameters.qudt_AbstractQuantityKind$j$symbol) as never;
         }
    }

    override get identifier(): (rdfjs.BlankNode | rdfjs.NamedNode) {
        if (typeof this._identifier === "undefined") { this._identifier = dataFactory.blankNode(); } return this._identifier;
    }

    override equals(other: Quantity_Kind$W$$e$abstract$f$): EqualsResult {
        return super.equals(other).chain(() => (((left, right) => arrayEquals(left, right, booleanEquals)))(this.qudt_AbstractQuantityKind$j$altSymbol, other.qudt_AbstractQuantityKind$j$altSymbol).mapLeft(propertyValuesUnequal => ({ left: this, right: other, propertyName: "qudt_AbstractQuantityKind$j$altSymbol", propertyValuesUnequal, type: "Property" as const }))).chain(() => (((left, right) => arrayEquals(left, right, ((left, right) => left.equals(right)))))(this.qudt_AbstractQuantityKind$j$broader, other.qudt_AbstractQuantityKind$j$broader).mapLeft(propertyValuesUnequal => ({ left: this, right: other, propertyName: "qudt_AbstractQuantityKind$j$broader", propertyValuesUnequal, type: "Property" as const }))).chain(() => (((left, right) => arrayEquals(left, right, strictEquals)))(this.qudt_AbstractQuantityKind$j$latexSymbol, other.qudt_AbstractQuantityKind$j$latexSymbol).mapLeft(propertyValuesUnequal => ({ left: this, right: other, propertyName: "qudt_AbstractQuantityKind$j$latexSymbol", propertyValuesUnequal, type: "Property" as const }))).chain(() => (((left, right) => maybeEquals(left, right, booleanEquals)))(this.qudt_AbstractQuantityKind$j$symbol, other.qudt_AbstractQuantityKind$j$symbol).mapLeft(propertyValuesUnequal => ({ left: this, right: other, propertyName: "qudt_AbstractQuantityKind$j$symbol", propertyValuesUnequal, type: "Property" as const })));
    }

    override hash<HasherT extends { update: (message: string | number[] | ArrayBuffer | Uint8Array) => void; }>(_hasher: HasherT): HasherT {
        this.hashShaclProperties(_hasher);
        return _hasher;
    }

    protected override hashShaclProperties<HasherT extends { update: (message: string | number[] | ArrayBuffer | Uint8Array) => void; }>(_hasher: HasherT): HasherT {
        super.hashShaclProperties(_hasher);
        for (const _item0 of this.qudt_AbstractQuantityKind$j$altSymbol) { _hasher.update(_item0.termType);
        _hasher.update(_item0.value); }

        for (const _item0 of this.qudt_AbstractQuantityKind$j$broader) { _item0.hash(_hasher); }

        for (const _item0 of this.qudt_AbstractQuantityKind$j$latexSymbol) { _hasher.update(_item0); }

        this.qudt_AbstractQuantityKind$j$symbol.ifJust((_value0) => { _hasher.update(_value0.termType);
        _hasher.update(_value0.value); })
        return _hasher;
    }

    override toJson(): { readonly "qudt_AbstractQuantityKind$j$altSymbol": readonly ({ readonly "@id": string, readonly termType: "BlankNode" | "NamedNode" } | { readonly "@language": string | undefined, readonly "@type": string | undefined, readonly "@value": string, readonly termType: "Literal" })[]; readonly "qudt_AbstractQuantityKind$j$broader": readonly (ReturnType<Quantity_Kind["toJson"]>)[]; readonly "qudt_AbstractQuantityKind$j$latexSymbol": readonly (string)[]; readonly "qudt_AbstractQuantityKind$j$symbol": ({ readonly "@id": string, readonly termType: "BlankNode" | "NamedNode" } | { readonly "@language": string | undefined, readonly "@type": string | undefined, readonly "@value": string, readonly termType: "Literal" }) | undefined } & ReturnType<QUDT_Concept["toJson"]> {
        return JSON.parse(JSON.stringify({ ...super.toJson(),qudt_AbstractQuantityKind$j$altSymbol: this.qudt_AbstractQuantityKind$j$altSymbol.map(_item => ((_item.termType === "Literal") ? { "@language": _item.language.length > 0 ? _item.language : undefined, "@type": _item.datatype.value !== "http://www.w3.org/2001/XMLSchema#string" ? _item.datatype.value : undefined, "@value": _item.value, termType: "Literal" as const } : (_item.termType === "NamedNode") ? { "@id": _item.value, termType: "NamedNode" as const } : { "@id": `_:${_item.value}`, termType: "BlankNode" as const })),qudt_AbstractQuantityKind$j$broader: this.qudt_AbstractQuantityKind$j$broader.map(_item => (_item.toJson())),qudt_AbstractQuantityKind$j$latexSymbol: this.qudt_AbstractQuantityKind$j$latexSymbol.map(_item => (_item)),qudt_AbstractQuantityKind$j$symbol: this.qudt_AbstractQuantityKind$j$symbol.map(_item => ((_item.termType === "Literal") ? { "@language": _item.language.length > 0 ? _item.language : undefined, "@type": _item.datatype.value !== "http://www.w3.org/2001/XMLSchema#string" ? _item.datatype.value : undefined, "@value": _item.value, termType: "Literal" as const } : (_item.termType === "NamedNode") ? { "@id": _item.value, termType: "NamedNode" as const } : { "@id": `_:${_item.value}`, termType: "BlankNode" as const })).extract() } satisfies ReturnType<Quantity_Kind$W$$e$abstract$f$["toJson"]>));
    }

    override toRdf({ ignoreRdfType, mutateGraph, resourceSet }: { ignoreRdfType?: boolean; mutateGraph?: rdfjsResource.MutableResource.MutateGraph, resourceSet: rdfjsResource.MutableResourceSet }): rdfjsResource.MutableResource {
        const _resource = super.toRdf({ ignoreRdfType: true, mutateGraph, resourceSet });
        if (!ignoreRdfType) { _resource.add(_resource.dataFactory.namedNode("http://www.w3.org/1999/02/22-rdf-syntax-ns#type"), _resource.dataFactory.namedNode("http://qudt.org/schema/qudt/AbstractQuantityKind")); }

        _resource.add(dataFactory.namedNode("http://qudt.org/schema/qudt/altSymbol"), this.qudt_AbstractQuantityKind$j$altSymbol.map((_item) => _item));
        _resource.add(dataFactory.namedNode("http://www.w3.org/2004/02/skos/core#broader"), this.qudt_AbstractQuantityKind$j$broader.map((_item) => _item.toRdf({ mutateGraph: mutateGraph, resourceSet: resourceSet })));
        _resource.add(dataFactory.namedNode("http://qudt.org/schema/qudt/latexSymbol"), this.qudt_AbstractQuantityKind$j$latexSymbol.map((_item) => _item));
        _resource.add(dataFactory.namedNode("http://qudt.org/schema/qudt/symbol"), this.qudt_AbstractQuantityKind$j$symbol);
        return _resource;
    }

    override toString(): string {
        return JSON.stringify(this.toJson());
    }
}

export namespace Quantity_Kind$W$$e$abstract$f$ {
    export function _propertiesFromJson(_json: unknown): purify.Either<zod.ZodError, { identifier: (rdfjs.BlankNode | rdfjs.NamedNode); qudt_AbstractQuantityKind$j$altSymbol: readonly ((rdfjs.BlankNode | rdfjs.NamedNode | rdfjs.Literal))[]; qudt_AbstractQuantityKind$j$broader: readonly (Quantity_Kind)[]; qudt_AbstractQuantityKind$j$latexSymbol: readonly (string)[]; qudt_AbstractQuantityKind$j$symbol: purify.Maybe<(rdfjs.BlankNode | rdfjs.NamedNode | rdfjs.Literal)>; } & UnwrapR<ReturnType<typeof QUDT_Concept._propertiesFromJson>>> {
        const _jsonSafeParseResult = quantityKindWEAbstractFJsonZodSchema().safeParse(_json);
        if (!_jsonSafeParseResult.success) { return purify.Left(_jsonSafeParseResult.error); }

        const _jsonObject = _jsonSafeParseResult.data;
        const _super0Either = QUDT_Concept._propertiesFromJson(_jsonObject);
        if (_super0Either.isLeft()) { return _super0Either; }

        const _super0 = _super0Either.unsafeCoerce()
        const identifier = (_jsonObject["@id"].startsWith("_:") ? dataFactory.blankNode(_jsonObject["@id"].substring(2)) : dataFactory.namedNode(_jsonObject["@id"]));
        const qudt_AbstractQuantityKind$j$altSymbol = _jsonObject["qudt_AbstractQuantityKind$j$altSymbol"].map(_item => (((_item.termType === "Literal") ? (dataFactory.literal(_item["@value"], typeof _item["@language"] !== "undefined" ? _item["@language"] : (typeof _item["@type"] !== "undefined" ? dataFactory.namedNode(_item["@type"]) : undefined))) : (((_item.termType === "NamedNode") ? (dataFactory.namedNode(_item["@id"])) : (dataFactory.blankNode(_item["@id"].substring(2))))))));
        const qudt_AbstractQuantityKind$j$broader = _jsonObject["qudt_AbstractQuantityKind$j$broader"].map(_item => (Quantity_Kind.fromJson(_item).unsafeCoerce()));
        const qudt_AbstractQuantityKind$j$latexSymbol = _jsonObject["qudt_AbstractQuantityKind$j$latexSymbol"];
        const qudt_AbstractQuantityKind$j$symbol = purify.Maybe.fromNullable(_jsonObject["qudt_AbstractQuantityKind$j$symbol"]).map(_item => (((_item.termType === "Literal") ? (dataFactory.literal(_item["@value"], typeof _item["@language"] !== "undefined" ? _item["@language"] : (typeof _item["@type"] !== "undefined" ? dataFactory.namedNode(_item["@type"]) : undefined))) : (((_item.termType === "NamedNode") ? (dataFactory.namedNode(_item["@id"])) : (dataFactory.blankNode(_item["@id"].substring(2))))))));
        return purify.Either.of({ ..._super0, identifier, qudt_AbstractQuantityKind$j$altSymbol, qudt_AbstractQuantityKind$j$broader, qudt_AbstractQuantityKind$j$latexSymbol, qudt_AbstractQuantityKind$j$symbol })
    }

    export function fromJson(json: unknown): purify.Either<zod.ZodError, Quantity_Kind$W$$e$abstract$f$> {
        return (Quantity_Kind.fromJson(json) as purify.Either<zod.ZodError, Quantity_Kind$W$$e$abstract$f$>).altLazy(() => (User_Quantity$W$Kind.fromJson(json) as purify.Either<zod.ZodError, Quantity_Kind$W$$e$abstract$f$>)).altLazy(() => Quantity_Kind$W$$e$abstract$f$._propertiesFromJson(json).map(properties => new Quantity_Kind$W$$e$abstract$f$(properties)));
    }

    export function _propertiesFromRdf({ ignoreRdfType: _ignoreRdfType, languageIn: _languageIn, resource: _resource,
        // @ts-ignore
        ..._context }: { [_index: string]: any; ignoreRdfType?: boolean; languageIn?: readonly string[]; resource: rdfjsResource.Resource; }): purify.Either<rdfjsResource.Resource.ValueError, { identifier: (rdfjs.BlankNode | rdfjs.NamedNode); qudt_AbstractQuantityKind$j$altSymbol: readonly ((rdfjs.BlankNode | rdfjs.NamedNode | rdfjs.Literal))[]; qudt_AbstractQuantityKind$j$broader: readonly (Quantity_Kind)[]; qudt_AbstractQuantityKind$j$latexSymbol: readonly (string)[]; qudt_AbstractQuantityKind$j$symbol: purify.Maybe<(rdfjs.BlankNode | rdfjs.NamedNode | rdfjs.Literal)>; } & UnwrapR<ReturnType<typeof QUDT_Concept._propertiesFromRdf>>> {
        const _super0Either = QUDT_Concept._propertiesFromRdf({ ..._context, ignoreRdfType: true, languageIn: _languageIn, resource: _resource });
        if (_super0Either.isLeft()) { return _super0Either; }

        const _super0 = _super0Either.unsafeCoerce()
        if (!_ignoreRdfType && !_resource.isInstanceOf(dataFactory.namedNode("http://qudt.org/schema/qudt/AbstractQuantityKind"))) { return purify.Left(new rdfjsResource.Resource.ValueError({ focusResource: _resource, message: `${rdfjsResource.Resource.Identifier.toString(_resource.identifier)} has unexpected RDF type (expected http://qudt.org/schema/qudt/AbstractQuantityKind)`, predicate: dataFactory.namedNode("http://qudt.org/schema/qudt/AbstractQuantityKind") })); }

        const identifier = _resource.identifier
        const _qudt_AbstractQuantityKind$j$altSymbolEither: purify.Either<rdfjsResource.Resource.ValueError, readonly ((rdfjs.BlankNode | rdfjs.NamedNode | rdfjs.Literal))[]> = purify.Either.of([..._resource.values(dataFactory.namedNode("http://qudt.org/schema/qudt/altSymbol"), { unique: true }).flatMap(_item => _item.toValues().head().chain(_value => purify.Either.of(_value.toTerm())).toMaybe().toList())]);
        if (_qudt_AbstractQuantityKind$j$altSymbolEither.isLeft()) { return _qudt_AbstractQuantityKind$j$altSymbolEither; }

        const qudt_AbstractQuantityKind$j$altSymbol = _qudt_AbstractQuantityKind$j$altSymbolEither.unsafeCoerce();
        const _qudt_AbstractQuantityKind$j$broaderEither: purify.Either<rdfjsResource.Resource.ValueError, readonly (Quantity_Kind)[]> = purify.Either.of([..._resource.values(dataFactory.namedNode("http://www.w3.org/2004/02/skos/core#broader"), { unique: true }).flatMap(_item => _item.toValues().head().chain(value => value.toResource()).chain(_resource => Quantity_Kind.fromRdf({ ..._context, ignoreRdfType: true, languageIn: _languageIn, resource: _resource })).toMaybe().toList())]);
        if (_qudt_AbstractQuantityKind$j$broaderEither.isLeft()) { return _qudt_AbstractQuantityKind$j$broaderEither; }

        const qudt_AbstractQuantityKind$j$broader = _qudt_AbstractQuantityKind$j$broaderEither.unsafeCoerce();
        const _qudt_AbstractQuantityKind$j$latexSymbolEither: purify.Either<rdfjsResource.Resource.ValueError, readonly (string)[]> = purify.Either.of([..._resource.values(dataFactory.namedNode("http://qudt.org/schema/qudt/latexSymbol"), { unique: true }).flatMap(_item => _item.toValues().head().chain(_value => _value.toString()).toMaybe().toList())]);
        if (_qudt_AbstractQuantityKind$j$latexSymbolEither.isLeft()) { return _qudt_AbstractQuantityKind$j$latexSymbolEither; }

        const qudt_AbstractQuantityKind$j$latexSymbol = _qudt_AbstractQuantityKind$j$latexSymbolEither.unsafeCoerce();
        const _qudt_AbstractQuantityKind$j$symbolEither: purify.Either<rdfjsResource.Resource.ValueError, purify.Maybe<(rdfjs.BlankNode | rdfjs.NamedNode | rdfjs.Literal)>> = purify.Either.of(_resource.values(dataFactory.namedNode("http://qudt.org/schema/qudt/symbol"), { unique: true }).head().chain(_value => purify.Either.of(_value.toTerm())).toMaybe());
        if (_qudt_AbstractQuantityKind$j$symbolEither.isLeft()) { return _qudt_AbstractQuantityKind$j$symbolEither; }

        const qudt_AbstractQuantityKind$j$symbol = _qudt_AbstractQuantityKind$j$symbolEither.unsafeCoerce();
        return purify.Either.of({ ..._super0, identifier, qudt_AbstractQuantityKind$j$altSymbol, qudt_AbstractQuantityKind$j$broader, qudt_AbstractQuantityKind$j$latexSymbol, qudt_AbstractQuantityKind$j$symbol })
    }

    export function fromRdf(parameters: Parameters<typeof Quantity_Kind$W$$e$abstract$f$._propertiesFromRdf>[0]): purify.Either<rdfjsResource.Resource.ValueError, Quantity_Kind$W$$e$abstract$f$> {
        const { ignoreRdfType: _ignoreRdfType, ...otherParameters } = parameters
        return (Quantity_Kind.fromRdf(otherParameters) as purify.Either<rdfjsResource.Resource.ValueError, Quantity_Kind$W$$e$abstract$f$>).altLazy(() => (User_Quantity$W$Kind.fromRdf(otherParameters) as purify.Either<rdfjsResource.Resource.ValueError, Quantity_Kind$W$$e$abstract$f$>)).altLazy(() => Quantity_Kind$W$$e$abstract$f$._propertiesFromRdf(parameters).map(properties => new Quantity_Kind$W$$e$abstract$f$(properties)));
    }

    export let fromRdfType: rdfjs.NamedNode<string> = dataFactory.namedNode("http://qudt.org/schema/qudt/AbstractQuantityKind");

    export function jsonSchema() {
        return zodToJsonSchema(quantityKindWEAbstractFJsonZodSchema());
    }

    export function quantityKindWEAbstractFJsonUiSchema(parameters?: { scopePrefix?: string }) {
        const scopePrefix = parameters?.scopePrefix ?? "#";
        return { "elements": [ QUDT_Concept.qudtConceptJsonUiSchema({ scopePrefix }), { scope: `${scopePrefix}/properties/qudt_AbstractQuantityKind$j$altSymbol`, type: "Control" }, Quantity_Kind.quantityKindJsonUiSchema({ scopePrefix: `${scopePrefix}/properties/qudt_AbstractQuantityKind$j$broader` }), { scope: `${scopePrefix}/properties/qudt_AbstractQuantityKind$j$latexSymbol`, type: "Control" }, { scope: `${scopePrefix}/properties/qudt_AbstractQuantityKind$j$symbol`, type: "Control" } ], label: "Quantity Kind (abstract)", type: "Group" }
    }

    export function quantityKindWEAbstractFJsonZodSchema() {
        return QUDT_Concept.qudtConceptJsonZodSchema().merge(zod.object({ "@id": zod.string().min(1),"type": zod.enum(["Quantity_Kind","Quantity_Kind$W$$e$abstract$f$","User_Quantity$W$Kind"]),"qudt_AbstractQuantityKind$j$altSymbol": zod.discriminatedUnion("termType", [zod.object({ "@id": zod.string().min(1), termType: zod.literal("BlankNode") }), zod.object({ "@id": zod.string().min(1), termType: zod.literal("NamedNode") }), zod.object({ "@language": zod.string().optional(), "@type": zod.string().optional(), "@value": zod.string(), termType: zod.literal("Literal") })]).array(),"qudt_AbstractQuantityKind$j$broader": Quantity_Kind.quantityKindJsonZodSchema().array(),"qudt_AbstractQuantityKind$j$latexSymbol": zod.string().array(),"qudt_AbstractQuantityKind$j$symbol": zod.discriminatedUnion("termType", [zod.object({ "@id": zod.string().min(1), termType: zod.literal("BlankNode") }), zod.object({ "@id": zod.string().min(1), termType: zod.literal("NamedNode") }), zod.object({ "@language": zod.string().optional(), "@type": zod.string().optional(), "@value": zod.string(), termType: zod.literal("Literal") })]).optional() }));
    }

    export function sparqlConstructQuery(parameters?: { ignoreRdfType?: boolean; prefixes?: { [prefix: string]: string }; subject?: sparqljs.Triple["subject"]; } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type">): sparqljs.ConstructQuery {
        const { ignoreRdfType, subject, ...queryParameters } = parameters ?? {}

        return { ...queryParameters, prefixes: parameters?.prefixes ?? {}, queryType: "CONSTRUCT", template: (queryParameters.template ?? []).concat(Quantity_Kind$W$$e$abstract$f$.sparqlConstructTemplateTriples({ ignoreRdfType, subject })), type: "query", where: (queryParameters.where ?? []).concat(Quantity_Kind$W$$e$abstract$f$.sparqlWherePatterns({ ignoreRdfType, subject })) };
    }

    export function sparqlConstructQueryString(parameters?: { ignoreRdfType?: boolean; subject?: sparqljs.Triple["subject"]; variablePrefix?: string; } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type"> & sparqljs.GeneratorOptions): string {
        return new sparqljs.Generator(parameters).stringify(Quantity_Kind$W$$e$abstract$f$.sparqlConstructQuery(parameters));
    }

    export function sparqlConstructTemplateTriples(parameters?: { ignoreRdfType?: boolean; subject?: sparqljs.Triple["subject"], variablePrefix?: string }): readonly sparqljs.Triple[] {
        const subject = parameters?.subject ?? dataFactory.variable!("quantityKindWEAbstractF");
        const variablePrefix = parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "quantityKindWEAbstractF");
        return [...QUDT_Concept.sparqlConstructTemplateTriples({ ignoreRdfType: true, subject, variablePrefix }), ...(parameters?.ignoreRdfType ? [] : [{ subject, predicate: dataFactory.namedNode("http://www.w3.org/1999/02/22-rdf-syntax-ns#type"), object: dataFactory.variable!(`${variablePrefix}RdfType`) }]), { object: dataFactory.variable!(`${variablePrefix}QudtAbstractQuantityKindJAltSymbol`), predicate: dataFactory.namedNode("http://qudt.org/schema/qudt/altSymbol"), subject }, { object: dataFactory.variable!(`${variablePrefix}QudtAbstractQuantityKindJBroader`), predicate: dataFactory.namedNode("http://www.w3.org/2004/02/skos/core#broader"), subject }, ...Quantity_Kind.sparqlConstructTemplateTriples({ ignoreRdfType: true, subject: dataFactory.variable!(`${variablePrefix}QudtAbstractQuantityKindJBroader`), variablePrefix: `${variablePrefix}QudtAbstractQuantityKindJBroader` }), { object: dataFactory.variable!(`${variablePrefix}QudtAbstractQuantityKindJLatexSymbol`), predicate: dataFactory.namedNode("http://qudt.org/schema/qudt/latexSymbol"), subject }, { object: dataFactory.variable!(`${variablePrefix}QudtAbstractQuantityKindJSymbol`), predicate: dataFactory.namedNode("http://qudt.org/schema/qudt/symbol"), subject }];
    }

    export function sparqlWherePatterns(parameters: { ignoreRdfType?: boolean; subject?: sparqljs.Triple["subject"], variablePrefix?: string }): readonly sparqljs.Pattern[] {
        const subject = parameters?.subject ?? dataFactory.variable!("quantityKindWEAbstractF");
        const variablePrefix = parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "quantityKindWEAbstractF");
        return [...QUDT_Concept.sparqlWherePatterns({ ignoreRdfType: true, subject, variablePrefix }), ...(parameters?.ignoreRdfType ? [] : [{ triples: [{ subject, predicate: dataFactory.namedNode("http://www.w3.org/1999/02/22-rdf-syntax-ns#type"), object: dataFactory.namedNode("http://qudt.org/schema/qudt/AbstractQuantityKind") }], type: "bgp" as const }, { triples: [{ subject, predicate: dataFactory.namedNode("http://www.w3.org/1999/02/22-rdf-syntax-ns#type"), object: dataFactory.variable!(`${variablePrefix}RdfType`) }], type: "bgp" as const }]), { patterns: [{ triples: [{ object: dataFactory.variable!(`${variablePrefix}QudtAbstractQuantityKindJAltSymbol`), predicate: dataFactory.namedNode("http://qudt.org/schema/qudt/altSymbol"), subject }], type: "bgp" }], type: "optional" }, { patterns: [{ triples: [{ object: dataFactory.variable!(`${variablePrefix}QudtAbstractQuantityKindJBroader`), predicate: dataFactory.namedNode("http://www.w3.org/2004/02/skos/core#broader"), subject }], type: "bgp" }, ...Quantity_Kind.sparqlWherePatterns({ ignoreRdfType: true, subject: dataFactory.variable!(`${variablePrefix}QudtAbstractQuantityKindJBroader`), variablePrefix: `${variablePrefix}QudtAbstractQuantityKindJBroader` })], type: "optional" }, { patterns: [{ triples: [{ object: dataFactory.variable!(`${variablePrefix}QudtAbstractQuantityKindJLatexSymbol`), predicate: dataFactory.namedNode("http://qudt.org/schema/qudt/latexSymbol"), subject }], type: "bgp" }], type: "optional" }, { patterns: [{ triples: [{ object: dataFactory.variable!(`${variablePrefix}QudtAbstractQuantityKindJSymbol`), predicate: dataFactory.namedNode("http://qudt.org/schema/qudt/symbol"), subject }], type: "bgp" }], type: "optional" }];
    }
}
/**
 * User Quantity Kind
 */
export class User_Quantity$W$Kind extends Quantity_Kind$W$$e$abstract$f$ {
    override readonly type = "User_Quantity$W$Kind";
    readonly qudt_UserQuantityKind$j$hasQuantityKind: Quantity_Kind;

    constructor(parameters: { readonly identifier?: (rdfjs.BlankNode | rdfjs.NamedNode) | string, readonly qudt_UserQuantityKind$j$hasQuantityKind: Quantity_Kind } & ConstructorParameters<typeof Quantity_Kind$W$$e$abstract$f$>[0]) {
        super(parameters);
        this.qudt_UserQuantityKind$j$hasQuantityKind = parameters.qudt_UserQuantityKind$j$hasQuantityKind;
    }

    override get identifier(): (rdfjs.BlankNode | rdfjs.NamedNode) {
        if (typeof this._identifier === "undefined") { this._identifier = dataFactory.blankNode(); } return this._identifier;
    }

    override equals(other: User_Quantity$W$Kind): EqualsResult {
        return super.equals(other).chain(() => (((left, right) => left.equals(right)))(this.qudt_UserQuantityKind$j$hasQuantityKind, other.qudt_UserQuantityKind$j$hasQuantityKind).mapLeft(propertyValuesUnequal => ({ left: this, right: other, propertyName: "qudt_UserQuantityKind$j$hasQuantityKind", propertyValuesUnequal, type: "Property" as const })));
    }

    override hash<HasherT extends { update: (message: string | number[] | ArrayBuffer | Uint8Array) => void; }>(_hasher: HasherT): HasherT {
        this.hashShaclProperties(_hasher);
        return _hasher;
    }

    protected override hashShaclProperties<HasherT extends { update: (message: string | number[] | ArrayBuffer | Uint8Array) => void; }>(_hasher: HasherT): HasherT {
        super.hashShaclProperties(_hasher);
        this.qudt_UserQuantityKind$j$hasQuantityKind.hash(_hasher);
        return _hasher;
    }

    override toJson(): { readonly "qudt_UserQuantityKind$j$hasQuantityKind": ReturnType<Quantity_Kind["toJson"]> } & ReturnType<Quantity_Kind$W$$e$abstract$f$["toJson"]> {
        return JSON.parse(JSON.stringify({ ...super.toJson(),qudt_UserQuantityKind$j$hasQuantityKind: this.qudt_UserQuantityKind$j$hasQuantityKind.toJson() } satisfies ReturnType<User_Quantity$W$Kind["toJson"]>));
    }

    override toRdf({ ignoreRdfType, mutateGraph, resourceSet }: { ignoreRdfType?: boolean; mutateGraph?: rdfjsResource.MutableResource.MutateGraph, resourceSet: rdfjsResource.MutableResourceSet }): rdfjsResource.MutableResource {
        const _resource = super.toRdf({ ignoreRdfType: true, mutateGraph, resourceSet });
        if (!ignoreRdfType) { _resource.add(_resource.dataFactory.namedNode("http://www.w3.org/1999/02/22-rdf-syntax-ns#type"), _resource.dataFactory.namedNode("http://qudt.org/schema/qudt/UserQuantityKind")); }

        _resource.add(dataFactory.namedNode("http://qudt.org/schema/qudt/hasQuantityKind"), this.qudt_UserQuantityKind$j$hasQuantityKind.toRdf({ mutateGraph: mutateGraph, resourceSet: resourceSet }));
        return _resource;
    }

    override toString(): string {
        return JSON.stringify(this.toJson());
    }
}

export namespace User_Quantity$W$Kind {
    export function _propertiesFromJson(_json: unknown): purify.Either<zod.ZodError, { identifier: (rdfjs.BlankNode | rdfjs.NamedNode); qudt_UserQuantityKind$j$hasQuantityKind: Quantity_Kind; } & UnwrapR<ReturnType<typeof Quantity_Kind$W$$e$abstract$f$._propertiesFromJson>>> {
        const _jsonSafeParseResult = userQuantityWKindJsonZodSchema().safeParse(_json);
        if (!_jsonSafeParseResult.success) { return purify.Left(_jsonSafeParseResult.error); }

        const _jsonObject = _jsonSafeParseResult.data;
        const _super0Either = Quantity_Kind$W$$e$abstract$f$._propertiesFromJson(_jsonObject);
        if (_super0Either.isLeft()) { return _super0Either; }

        const _super0 = _super0Either.unsafeCoerce()
        const identifier = (_jsonObject["@id"].startsWith("_:") ? dataFactory.blankNode(_jsonObject["@id"].substring(2)) : dataFactory.namedNode(_jsonObject["@id"]));
        const qudt_UserQuantityKind$j$hasQuantityKind = Quantity_Kind.fromJson(_jsonObject["qudt_UserQuantityKind$j$hasQuantityKind"]).unsafeCoerce();
        return purify.Either.of({ ..._super0, identifier, qudt_UserQuantityKind$j$hasQuantityKind })
    }

    export function fromJson(json: unknown): purify.Either<zod.ZodError, User_Quantity$W$Kind> {
        return User_Quantity$W$Kind._propertiesFromJson(json).map(properties => new User_Quantity$W$Kind(properties));
    }

    export function _propertiesFromRdf({ ignoreRdfType: _ignoreRdfType, languageIn: _languageIn, resource: _resource,
        // @ts-ignore
        ..._context }: { [_index: string]: any; ignoreRdfType?: boolean; languageIn?: readonly string[]; resource: rdfjsResource.Resource; }): purify.Either<rdfjsResource.Resource.ValueError, { identifier: (rdfjs.BlankNode | rdfjs.NamedNode); qudt_UserQuantityKind$j$hasQuantityKind: Quantity_Kind; } & UnwrapR<ReturnType<typeof Quantity_Kind$W$$e$abstract$f$._propertiesFromRdf>>> {
        const _super0Either = Quantity_Kind$W$$e$abstract$f$._propertiesFromRdf({ ..._context, ignoreRdfType: true, languageIn: _languageIn, resource: _resource });
        if (_super0Either.isLeft()) { return _super0Either; }

        const _super0 = _super0Either.unsafeCoerce()
        if (!_ignoreRdfType && !_resource.isInstanceOf(dataFactory.namedNode("http://qudt.org/schema/qudt/UserQuantityKind"))) { return purify.Left(new rdfjsResource.Resource.ValueError({ focusResource: _resource, message: `${rdfjsResource.Resource.Identifier.toString(_resource.identifier)} has unexpected RDF type (expected http://qudt.org/schema/qudt/UserQuantityKind)`, predicate: dataFactory.namedNode("http://qudt.org/schema/qudt/UserQuantityKind") })); }

        const identifier = _resource.identifier
        const _qudt_UserQuantityKind$j$hasQuantityKindEither: purify.Either<rdfjsResource.Resource.ValueError, Quantity_Kind> = _resource.values(dataFactory.namedNode("http://qudt.org/schema/qudt/hasQuantityKind"), { unique: true }).head().chain(value => value.toResource()).chain(_resource => Quantity_Kind.fromRdf({ ..._context, ignoreRdfType: true, languageIn: _languageIn, resource: _resource }));
        if (_qudt_UserQuantityKind$j$hasQuantityKindEither.isLeft()) { return _qudt_UserQuantityKind$j$hasQuantityKindEither; }

        const qudt_UserQuantityKind$j$hasQuantityKind = _qudt_UserQuantityKind$j$hasQuantityKindEither.unsafeCoerce();
        return purify.Either.of({ ..._super0, identifier, qudt_UserQuantityKind$j$hasQuantityKind })
    }

    export function fromRdf(parameters: Parameters<typeof User_Quantity$W$Kind._propertiesFromRdf>[0]): purify.Either<rdfjsResource.Resource.ValueError, User_Quantity$W$Kind> {
        return User_Quantity$W$Kind._propertiesFromRdf(parameters).map(properties => new User_Quantity$W$Kind(properties));
    }

    export let fromRdfType: rdfjs.NamedNode<string> = dataFactory.namedNode("http://qudt.org/schema/qudt/UserQuantityKind");

    export function jsonSchema() {
        return zodToJsonSchema(userQuantityWKindJsonZodSchema());
    }

    export function userQuantityWKindJsonUiSchema(parameters?: { scopePrefix?: string }) {
        const scopePrefix = parameters?.scopePrefix ?? "#";
        return { "elements": [ Quantity_Kind$W$$e$abstract$f$.quantityKindWEAbstractFJsonUiSchema({ scopePrefix }), Quantity_Kind.quantityKindJsonUiSchema({ scopePrefix: `${scopePrefix}/properties/qudt_UserQuantityKind$j$hasQuantityKind` }) ], label: "User Quantity Kind", type: "Group" }
    }

    export function userQuantityWKindJsonZodSchema() {
        return Quantity_Kind$W$$e$abstract$f$.quantityKindWEAbstractFJsonZodSchema().merge(zod.object({ "@id": zod.string().min(1),"type": zod.literal("User_Quantity$W$Kind"),"qudt_UserQuantityKind$j$hasQuantityKind": Quantity_Kind.quantityKindJsonZodSchema() }));
    }

    export function sparqlConstructQuery(parameters?: { ignoreRdfType?: boolean; prefixes?: { [prefix: string]: string }; subject?: sparqljs.Triple["subject"]; } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type">): sparqljs.ConstructQuery {
        const { ignoreRdfType, subject, ...queryParameters } = parameters ?? {}

        return { ...queryParameters, prefixes: parameters?.prefixes ?? {}, queryType: "CONSTRUCT", template: (queryParameters.template ?? []).concat(User_Quantity$W$Kind.sparqlConstructTemplateTriples({ ignoreRdfType, subject })), type: "query", where: (queryParameters.where ?? []).concat(User_Quantity$W$Kind.sparqlWherePatterns({ ignoreRdfType, subject })) };
    }

    export function sparqlConstructQueryString(parameters?: { ignoreRdfType?: boolean; subject?: sparqljs.Triple["subject"]; variablePrefix?: string; } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type"> & sparqljs.GeneratorOptions): string {
        return new sparqljs.Generator(parameters).stringify(User_Quantity$W$Kind.sparqlConstructQuery(parameters));
    }

    export function sparqlConstructTemplateTriples(parameters?: { ignoreRdfType?: boolean; subject?: sparqljs.Triple["subject"], variablePrefix?: string }): readonly sparqljs.Triple[] {
        const subject = parameters?.subject ?? dataFactory.variable!("userQuantityWKind");
        const variablePrefix = parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "userQuantityWKind");
        return [...Quantity_Kind$W$$e$abstract$f$.sparqlConstructTemplateTriples({ ignoreRdfType: true, subject, variablePrefix }), ...(parameters?.ignoreRdfType ? [] : [{ subject, predicate: dataFactory.namedNode("http://www.w3.org/1999/02/22-rdf-syntax-ns#type"), object: dataFactory.variable!(`${variablePrefix}RdfType`) }]), { object: dataFactory.variable!(`${variablePrefix}QudtUserQuantityKindJHasQuantityKind`), predicate: dataFactory.namedNode("http://qudt.org/schema/qudt/hasQuantityKind"), subject }, ...Quantity_Kind.sparqlConstructTemplateTriples({ ignoreRdfType: true, subject: dataFactory.variable!(`${variablePrefix}QudtUserQuantityKindJHasQuantityKind`), variablePrefix: `${variablePrefix}QudtUserQuantityKindJHasQuantityKind` })];
    }

    export function sparqlWherePatterns(parameters: { ignoreRdfType?: boolean; subject?: sparqljs.Triple["subject"], variablePrefix?: string }): readonly sparqljs.Pattern[] {
        const subject = parameters?.subject ?? dataFactory.variable!("userQuantityWKind");
        const variablePrefix = parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "userQuantityWKind");
        return [...Quantity_Kind$W$$e$abstract$f$.sparqlWherePatterns({ ignoreRdfType: true, subject, variablePrefix }), ...(parameters?.ignoreRdfType ? [] : [{ triples: [{ subject, predicate: dataFactory.namedNode("http://www.w3.org/1999/02/22-rdf-syntax-ns#type"), object: dataFactory.namedNode("http://qudt.org/schema/qudt/UserQuantityKind") }], type: "bgp" as const }, { triples: [{ subject, predicate: dataFactory.namedNode("http://www.w3.org/1999/02/22-rdf-syntax-ns#type"), object: dataFactory.variable!(`${variablePrefix}RdfType`) }], type: "bgp" as const }]), { triples: [{ object: dataFactory.variable!(`${variablePrefix}QudtUserQuantityKindJHasQuantityKind`), predicate: dataFactory.namedNode("http://qudt.org/schema/qudt/hasQuantityKind"), subject }], type: "bgp" }, ...Quantity_Kind.sparqlWherePatterns({ ignoreRdfType: true, subject: dataFactory.variable!(`${variablePrefix}QudtUserQuantityKindJHasQuantityKind`), variablePrefix: `${variablePrefix}QudtUserQuantityKindJHasQuantityKind` })];
    }
}
/**
 * QUDT Aspect
 */
export class QUDT_Aspect {
    protected _identifier: (rdfjs.BlankNode | rdfjs.NamedNode) | undefined;
    readonly type: "Enumerated_Value" | "QUDT_Aspect" | "Quantifiable" | "Quantity_type" | "Rule_Type" | "Scale_type" | "Transform_type" | "Verifiable" = "QUDT_Aspect";

    constructor(parameters: { readonly identifier?: (rdfjs.BlankNode | rdfjs.NamedNode) | string }) {
        if (typeof parameters.identifier === "object") { this._identifier = parameters.identifier; } else if (typeof parameters.identifier === "string") { this._identifier = dataFactory.namedNode(parameters.identifier); } else if (typeof parameters.identifier === "undefined") { } else { this._identifier =( parameters.identifier) as never;
         }
    }

    get identifier(): (rdfjs.BlankNode | rdfjs.NamedNode) {
        if (typeof this._identifier === "undefined") { this._identifier = dataFactory.blankNode(); } return this._identifier;
    }

    equals(other: QUDT_Aspect): EqualsResult {
        return (booleanEquals)(this.identifier, other.identifier).mapLeft(propertyValuesUnequal => ({ left: this, right: other, propertyName: "identifier", propertyValuesUnequal, type: "Property" as const })).chain(() => (strictEquals)(this.type, other.type).mapLeft(propertyValuesUnequal => ({ left: this, right: other, propertyName: "type", propertyValuesUnequal, type: "Property" as const })));
    }

    hash<HasherT extends { update: (message: string | number[] | ArrayBuffer | Uint8Array) => void; }>(_hasher: HasherT): HasherT {
        _hasher.update(this.identifier.value);
        _hasher.update(this.type);
        this.hashShaclProperties(_hasher);
        return _hasher;
    }

    protected hashShaclProperties<HasherT extends { update: (message: string | number[] | ArrayBuffer | Uint8Array) => void; }>(_hasher: HasherT): HasherT {
        return _hasher;
    }

    toJson(): { readonly "@id": string; readonly "type": "Enumerated_Value" | "QUDT_Aspect" | "Quantifiable" | "Quantity_type" | "Rule_Type" | "Scale_type" | "Transform_type" | "Verifiable" } {
        return JSON.parse(JSON.stringify({ "@id": this.identifier.termType === "BlankNode" ? `_:${this.identifier.value}` : this.identifier.value,type: this.type } satisfies ReturnType<QUDT_Aspect["toJson"]>));
    }

    toRdf({ ignoreRdfType, mutateGraph, resourceSet }: { ignoreRdfType?: boolean; mutateGraph?: rdfjsResource.MutableResource.MutateGraph, resourceSet: rdfjsResource.MutableResourceSet }): rdfjsResource.MutableResource {
        const _resource = resourceSet.mutableResource(this.identifier, { mutateGraph });
        if (!ignoreRdfType) { _resource.add(_resource.dataFactory.namedNode("http://www.w3.org/1999/02/22-rdf-syntax-ns#type"), _resource.dataFactory.namedNode("http://qudt.org/schema/qudt/Aspect")); }

        return _resource;
    }

    toString(): string {
        return JSON.stringify(this.toJson());
    }
}

export namespace QUDT_Aspect {
    export function _propertiesFromJson(_json: unknown): purify.Either<zod.ZodError, { identifier: (rdfjs.BlankNode | rdfjs.NamedNode); }> {
        const _jsonSafeParseResult = qudtAspectJsonZodSchema().safeParse(_json);
        if (!_jsonSafeParseResult.success) { return purify.Left(_jsonSafeParseResult.error); }

        const _jsonObject = _jsonSafeParseResult.data;
        const identifier = (_jsonObject["@id"].startsWith("_:") ? dataFactory.blankNode(_jsonObject["@id"].substring(2)) : dataFactory.namedNode(_jsonObject["@id"]));
        return purify.Either.of({ identifier })
    }

    export function fromJson(json: unknown): purify.Either<zod.ZodError, QUDT_Aspect> {
        return (Verifiable.fromJson(json) as purify.Either<zod.ZodError, QUDT_Aspect>).altLazy(() => (Quantifiable.fromJson(json) as purify.Either<zod.ZodError, QUDT_Aspect>)).altLazy(() => QUDT_Aspect._propertiesFromJson(json).map(properties => new QUDT_Aspect(properties)));
    }

    export function _propertiesFromRdf({ ignoreRdfType: _ignoreRdfType, languageIn: _languageIn, resource: _resource,
        // @ts-ignore
        ..._context }: { [_index: string]: any; ignoreRdfType?: boolean; languageIn?: readonly string[]; resource: rdfjsResource.Resource; }): purify.Either<rdfjsResource.Resource.ValueError, { identifier: (rdfjs.BlankNode | rdfjs.NamedNode); }> {
        if (!_ignoreRdfType && !_resource.isInstanceOf(dataFactory.namedNode("http://qudt.org/schema/qudt/Aspect"))) { return purify.Left(new rdfjsResource.Resource.ValueError({ focusResource: _resource, message: `${rdfjsResource.Resource.Identifier.toString(_resource.identifier)} has unexpected RDF type (expected http://qudt.org/schema/qudt/Aspect)`, predicate: dataFactory.namedNode("http://qudt.org/schema/qudt/Aspect") })); }

        const identifier = _resource.identifier
        return purify.Either.of({ identifier })
    }

    export function fromRdf(parameters: Parameters<typeof QUDT_Aspect._propertiesFromRdf>[0]): purify.Either<rdfjsResource.Resource.ValueError, QUDT_Aspect> {
        const { ignoreRdfType: _ignoreRdfType, ...otherParameters } = parameters
        return (Verifiable.fromRdf(otherParameters) as purify.Either<rdfjsResource.Resource.ValueError, QUDT_Aspect>).altLazy(() => (Quantifiable.fromRdf(otherParameters) as purify.Either<rdfjsResource.Resource.ValueError, QUDT_Aspect>)).altLazy(() => QUDT_Aspect._propertiesFromRdf(parameters).map(properties => new QUDT_Aspect(properties)));
    }

    export let fromRdfType: rdfjs.NamedNode<string> = dataFactory.namedNode("http://qudt.org/schema/qudt/Aspect");

    export function jsonSchema() {
        return zodToJsonSchema(qudtAspectJsonZodSchema());
    }

    export function qudtAspectJsonUiSchema(parameters?: { scopePrefix?: string }) {
        const scopePrefix = parameters?.scopePrefix ?? "#";
        return { "elements": [ { label: "Identifier", scope: `${scopePrefix}/properties/@id`, type: "Control" }, { rule: { condition: { schema: { const: "QUDT_Aspect" }, scope: `${scopePrefix}/properties/type` }, effect: "HIDE" }, scope: `${scopePrefix}/properties/type`, type: "Control" } ], label: "QUDT Aspect", type: "Group" }
    }

    export function qudtAspectJsonZodSchema() {
        return zod.object({ "@id": zod.string().min(1),"type": zod.enum(["Enumerated_Value","QUDT_Aspect","Quantifiable","Quantity_type","Rule_Type","Scale_type","Transform_type","Verifiable"]) });
    }

    export function sparqlConstructQuery(parameters?: { ignoreRdfType?: boolean; prefixes?: { [prefix: string]: string }; subject?: sparqljs.Triple["subject"]; } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type">): sparqljs.ConstructQuery {
        const { ignoreRdfType, subject, ...queryParameters } = parameters ?? {}

        return { ...queryParameters, prefixes: parameters?.prefixes ?? {}, queryType: "CONSTRUCT", template: (queryParameters.template ?? []).concat(QUDT_Aspect.sparqlConstructTemplateTriples({ ignoreRdfType, subject })), type: "query", where: (queryParameters.where ?? []).concat(QUDT_Aspect.sparqlWherePatterns({ ignoreRdfType, subject })) };
    }

    export function sparqlConstructQueryString(parameters?: { ignoreRdfType?: boolean; subject?: sparqljs.Triple["subject"]; variablePrefix?: string; } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type"> & sparqljs.GeneratorOptions): string {
        return new sparqljs.Generator(parameters).stringify(QUDT_Aspect.sparqlConstructQuery(parameters));
    }

    export function sparqlConstructTemplateTriples(parameters?: { ignoreRdfType?: boolean; subject?: sparqljs.Triple["subject"], variablePrefix?: string }): readonly sparqljs.Triple[] {
        const subject = parameters?.subject ?? dataFactory.variable!("qudtAspect");
        const variablePrefix = parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "qudtAspect");
        return [...(parameters?.ignoreRdfType ? [] : [{ subject, predicate: dataFactory.namedNode("http://www.w3.org/1999/02/22-rdf-syntax-ns#type"), object: dataFactory.variable!(`${variablePrefix}RdfType`) }])];
    }

    export function sparqlWherePatterns(parameters: { ignoreRdfType?: boolean; subject?: sparqljs.Triple["subject"], variablePrefix?: string }): readonly sparqljs.Pattern[] {
        const subject = parameters?.subject ?? dataFactory.variable!("qudtAspect");
        const variablePrefix = parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "qudtAspect");
        return [...(parameters?.ignoreRdfType ? [] : [{ triples: [{ subject, predicate: dataFactory.namedNode("http://www.w3.org/1999/02/22-rdf-syntax-ns#type"), object: dataFactory.namedNode("http://qudt.org/schema/qudt/Aspect") }], type: "bgp" as const }, { triples: [{ subject, predicate: dataFactory.namedNode("http://www.w3.org/1999/02/22-rdf-syntax-ns#type"), object: dataFactory.variable!(`${variablePrefix}RdfType`) }], type: "bgp" as const }])];
    }
}
/**
 * Verifiable
 */
export class Verifiable extends QUDT_Aspect {
    override readonly type: "Enumerated_Value" | "Quantity_type" | "Rule_Type" | "Scale_type" | "Transform_type" | "Verifiable" = "Verifiable";
    readonly qudt_InformativeReferencePropertyShape: readonly ((rdfjs.BlankNode | rdfjs.NamedNode | rdfjs.Literal))[];
    readonly qudt_Verifiable$j$dbpediaMatch: readonly (string)[];
    readonly qudt_Verifiable$j$isoNormativeReference: readonly (string)[];
    readonly qudt_Verifiable$j$normativeReference: readonly (string)[];

    constructor(parameters: { readonly identifier?: (rdfjs.BlankNode | rdfjs.NamedNode) | string, readonly qudt_InformativeReferencePropertyShape?: readonly ((rdfjs.BlankNode | rdfjs.NamedNode | rdfjs.Literal))[], readonly qudt_Verifiable$j$dbpediaMatch?: readonly (string)[], readonly qudt_Verifiable$j$isoNormativeReference?: readonly (string)[], readonly qudt_Verifiable$j$normativeReference?: readonly (string)[] } & ConstructorParameters<typeof QUDT_Aspect>[0]) {
        super(parameters);
        if (typeof parameters.qudt_InformativeReferencePropertyShape === "undefined") { this.qudt_InformativeReferencePropertyShape = []; } else if (Array.isArray(parameters.qudt_InformativeReferencePropertyShape)) { this.qudt_InformativeReferencePropertyShape = parameters.qudt_InformativeReferencePropertyShape; } else { this.qudt_InformativeReferencePropertyShape =( parameters.qudt_InformativeReferencePropertyShape) as never;
         }

        if (typeof parameters.qudt_Verifiable$j$dbpediaMatch === "undefined") { this.qudt_Verifiable$j$dbpediaMatch = []; } else if (Array.isArray(parameters.qudt_Verifiable$j$dbpediaMatch)) { this.qudt_Verifiable$j$dbpediaMatch = parameters.qudt_Verifiable$j$dbpediaMatch; } else { this.qudt_Verifiable$j$dbpediaMatch =( parameters.qudt_Verifiable$j$dbpediaMatch) as never;
         }

        if (typeof parameters.qudt_Verifiable$j$isoNormativeReference === "undefined") { this.qudt_Verifiable$j$isoNormativeReference = []; } else if (Array.isArray(parameters.qudt_Verifiable$j$isoNormativeReference)) { this.qudt_Verifiable$j$isoNormativeReference = parameters.qudt_Verifiable$j$isoNormativeReference; } else { this.qudt_Verifiable$j$isoNormativeReference =( parameters.qudt_Verifiable$j$isoNormativeReference) as never;
         }

        if (typeof parameters.qudt_Verifiable$j$normativeReference === "undefined") { this.qudt_Verifiable$j$normativeReference = []; } else if (Array.isArray(parameters.qudt_Verifiable$j$normativeReference)) { this.qudt_Verifiable$j$normativeReference = parameters.qudt_Verifiable$j$normativeReference; } else { this.qudt_Verifiable$j$normativeReference =( parameters.qudt_Verifiable$j$normativeReference) as never;
         }
    }

    override get identifier(): (rdfjs.BlankNode | rdfjs.NamedNode) {
        if (typeof this._identifier === "undefined") { this._identifier = dataFactory.blankNode(); } return this._identifier;
    }

    override equals(other: Verifiable): EqualsResult {
        return super.equals(other).chain(() => (((left, right) => arrayEquals(left, right, booleanEquals)))(this.qudt_InformativeReferencePropertyShape, other.qudt_InformativeReferencePropertyShape).mapLeft(propertyValuesUnequal => ({ left: this, right: other, propertyName: "qudt_InformativeReferencePropertyShape", propertyValuesUnequal, type: "Property" as const }))).chain(() => (((left, right) => arrayEquals(left, right, strictEquals)))(this.qudt_Verifiable$j$dbpediaMatch, other.qudt_Verifiable$j$dbpediaMatch).mapLeft(propertyValuesUnequal => ({ left: this, right: other, propertyName: "qudt_Verifiable$j$dbpediaMatch", propertyValuesUnequal, type: "Property" as const }))).chain(() => (((left, right) => arrayEquals(left, right, strictEquals)))(this.qudt_Verifiable$j$isoNormativeReference, other.qudt_Verifiable$j$isoNormativeReference).mapLeft(propertyValuesUnequal => ({ left: this, right: other, propertyName: "qudt_Verifiable$j$isoNormativeReference", propertyValuesUnequal, type: "Property" as const }))).chain(() => (((left, right) => arrayEquals(left, right, strictEquals)))(this.qudt_Verifiable$j$normativeReference, other.qudt_Verifiable$j$normativeReference).mapLeft(propertyValuesUnequal => ({ left: this, right: other, propertyName: "qudt_Verifiable$j$normativeReference", propertyValuesUnequal, type: "Property" as const })));
    }

    override hash<HasherT extends { update: (message: string | number[] | ArrayBuffer | Uint8Array) => void; }>(_hasher: HasherT): HasherT {
        this.hashShaclProperties(_hasher);
        return _hasher;
    }

    protected override hashShaclProperties<HasherT extends { update: (message: string | number[] | ArrayBuffer | Uint8Array) => void; }>(_hasher: HasherT): HasherT {
        super.hashShaclProperties(_hasher);
        for (const _item0 of this.qudt_InformativeReferencePropertyShape) { _hasher.update(_item0.termType);
        _hasher.update(_item0.value); }

        for (const _item0 of this.qudt_Verifiable$j$dbpediaMatch) { _hasher.update(_item0); }

        for (const _item0 of this.qudt_Verifiable$j$isoNormativeReference) { _hasher.update(_item0); }

        for (const _item0 of this.qudt_Verifiable$j$normativeReference) { _hasher.update(_item0); }

        return _hasher;
    }

    override toJson(): { readonly "qudt_InformativeReferencePropertyShape": readonly ({ readonly "@id": string, readonly termType: "BlankNode" | "NamedNode" } | { readonly "@language": string | undefined, readonly "@type": string | undefined, readonly "@value": string, readonly termType: "Literal" })[]; readonly "qudt_Verifiable$j$dbpediaMatch": readonly (string)[]; readonly "qudt_Verifiable$j$isoNormativeReference": readonly (string)[]; readonly "qudt_Verifiable$j$normativeReference": readonly (string)[] } & ReturnType<QUDT_Aspect["toJson"]> {
        return JSON.parse(JSON.stringify({ ...super.toJson(),qudt_InformativeReferencePropertyShape: this.qudt_InformativeReferencePropertyShape.map(_item => ((_item.termType === "Literal") ? { "@language": _item.language.length > 0 ? _item.language : undefined, "@type": _item.datatype.value !== "http://www.w3.org/2001/XMLSchema#string" ? _item.datatype.value : undefined, "@value": _item.value, termType: "Literal" as const } : (_item.termType === "NamedNode") ? { "@id": _item.value, termType: "NamedNode" as const } : { "@id": `_:${_item.value}`, termType: "BlankNode" as const })),qudt_Verifiable$j$dbpediaMatch: this.qudt_Verifiable$j$dbpediaMatch.map(_item => (_item)),qudt_Verifiable$j$isoNormativeReference: this.qudt_Verifiable$j$isoNormativeReference.map(_item => (_item)),qudt_Verifiable$j$normativeReference: this.qudt_Verifiable$j$normativeReference.map(_item => (_item)) } satisfies ReturnType<Verifiable["toJson"]>));
    }

    override toRdf({ ignoreRdfType, mutateGraph, resourceSet }: { ignoreRdfType?: boolean; mutateGraph?: rdfjsResource.MutableResource.MutateGraph, resourceSet: rdfjsResource.MutableResourceSet }): rdfjsResource.MutableResource {
        const _resource = super.toRdf({ ignoreRdfType: true, mutateGraph, resourceSet });
        if (!ignoreRdfType) { _resource.add(_resource.dataFactory.namedNode("http://www.w3.org/1999/02/22-rdf-syntax-ns#type"), _resource.dataFactory.namedNode("http://qudt.org/schema/qudt/Verifiable")); }

        _resource.add(dataFactory.namedNode("http://qudt.org/schema/qudt/informativeReference"), this.qudt_InformativeReferencePropertyShape.map((_item) => _item));
        _resource.add(dataFactory.namedNode("http://qudt.org/schema/qudt/dbpediaMatch"), this.qudt_Verifiable$j$dbpediaMatch.map((_item) => _item));
        _resource.add(dataFactory.namedNode("http://qudt.org/schema/qudt/isoNormativeReference"), this.qudt_Verifiable$j$isoNormativeReference.map((_item) => _item));
        _resource.add(dataFactory.namedNode("http://qudt.org/schema/qudt/normativeReference"), this.qudt_Verifiable$j$normativeReference.map((_item) => _item));
        return _resource;
    }

    override toString(): string {
        return JSON.stringify(this.toJson());
    }
}

export namespace Verifiable {
    export function _propertiesFromJson(_json: unknown): purify.Either<zod.ZodError, { identifier: (rdfjs.BlankNode | rdfjs.NamedNode); qudt_InformativeReferencePropertyShape: readonly ((rdfjs.BlankNode | rdfjs.NamedNode | rdfjs.Literal))[]; qudt_Verifiable$j$dbpediaMatch: readonly (string)[]; qudt_Verifiable$j$isoNormativeReference: readonly (string)[]; qudt_Verifiable$j$normativeReference: readonly (string)[]; } & UnwrapR<ReturnType<typeof QUDT_Aspect._propertiesFromJson>>> {
        const _jsonSafeParseResult = verifiableJsonZodSchema().safeParse(_json);
        if (!_jsonSafeParseResult.success) { return purify.Left(_jsonSafeParseResult.error); }

        const _jsonObject = _jsonSafeParseResult.data;
        const _super0Either = QUDT_Aspect._propertiesFromJson(_jsonObject);
        if (_super0Either.isLeft()) { return _super0Either; }

        const _super0 = _super0Either.unsafeCoerce()
        const identifier = (_jsonObject["@id"].startsWith("_:") ? dataFactory.blankNode(_jsonObject["@id"].substring(2)) : dataFactory.namedNode(_jsonObject["@id"]));
        const qudt_InformativeReferencePropertyShape = _jsonObject["qudt_InformativeReferencePropertyShape"].map(_item => (((_item.termType === "Literal") ? (dataFactory.literal(_item["@value"], typeof _item["@language"] !== "undefined" ? _item["@language"] : (typeof _item["@type"] !== "undefined" ? dataFactory.namedNode(_item["@type"]) : undefined))) : (((_item.termType === "NamedNode") ? (dataFactory.namedNode(_item["@id"])) : (dataFactory.blankNode(_item["@id"].substring(2))))))));
        const qudt_Verifiable$j$dbpediaMatch = _jsonObject["qudt_Verifiable$j$dbpediaMatch"];
        const qudt_Verifiable$j$isoNormativeReference = _jsonObject["qudt_Verifiable$j$isoNormativeReference"];
        const qudt_Verifiable$j$normativeReference = _jsonObject["qudt_Verifiable$j$normativeReference"];
        return purify.Either.of({ ..._super0, identifier, qudt_InformativeReferencePropertyShape, qudt_Verifiable$j$dbpediaMatch, qudt_Verifiable$j$isoNormativeReference, qudt_Verifiable$j$normativeReference })
    }

    export function fromJson(json: unknown): purify.Either<zod.ZodError, Verifiable> {
        return (Enumerated_Value.fromJson(json) as purify.Either<zod.ZodError, Verifiable>).altLazy(() => Verifiable._propertiesFromJson(json).map(properties => new Verifiable(properties)));
    }

    export function _propertiesFromRdf({ ignoreRdfType: _ignoreRdfType, languageIn: _languageIn, resource: _resource,
        // @ts-ignore
        ..._context }: { [_index: string]: any; ignoreRdfType?: boolean; languageIn?: readonly string[]; resource: rdfjsResource.Resource; }): purify.Either<rdfjsResource.Resource.ValueError, { identifier: (rdfjs.BlankNode | rdfjs.NamedNode); qudt_InformativeReferencePropertyShape: readonly ((rdfjs.BlankNode | rdfjs.NamedNode | rdfjs.Literal))[]; qudt_Verifiable$j$dbpediaMatch: readonly (string)[]; qudt_Verifiable$j$isoNormativeReference: readonly (string)[]; qudt_Verifiable$j$normativeReference: readonly (string)[]; } & UnwrapR<ReturnType<typeof QUDT_Aspect._propertiesFromRdf>>> {
        const _super0Either = QUDT_Aspect._propertiesFromRdf({ ..._context, ignoreRdfType: true, languageIn: _languageIn, resource: _resource });
        if (_super0Either.isLeft()) { return _super0Either; }

        const _super0 = _super0Either.unsafeCoerce()
        if (!_ignoreRdfType && !_resource.isInstanceOf(dataFactory.namedNode("http://qudt.org/schema/qudt/Verifiable"))) { return purify.Left(new rdfjsResource.Resource.ValueError({ focusResource: _resource, message: `${rdfjsResource.Resource.Identifier.toString(_resource.identifier)} has unexpected RDF type (expected http://qudt.org/schema/qudt/Verifiable)`, predicate: dataFactory.namedNode("http://qudt.org/schema/qudt/Verifiable") })); }

        const identifier = _resource.identifier
        const _qudt_InformativeReferencePropertyShapeEither: purify.Either<rdfjsResource.Resource.ValueError, readonly ((rdfjs.BlankNode | rdfjs.NamedNode | rdfjs.Literal))[]> = purify.Either.of([..._resource.values(dataFactory.namedNode("http://qudt.org/schema/qudt/informativeReference"), { unique: true }).flatMap(_item => _item.toValues().head().chain(_value => purify.Either.of(_value.toTerm())).toMaybe().toList())]);
        if (_qudt_InformativeReferencePropertyShapeEither.isLeft()) { return _qudt_InformativeReferencePropertyShapeEither; }

        const qudt_InformativeReferencePropertyShape = _qudt_InformativeReferencePropertyShapeEither.unsafeCoerce();
        const _qudt_Verifiable$j$dbpediaMatchEither: purify.Either<rdfjsResource.Resource.ValueError, readonly (string)[]> = purify.Either.of([..._resource.values(dataFactory.namedNode("http://qudt.org/schema/qudt/dbpediaMatch"), { unique: true }).flatMap(_item => _item.toValues().head().chain(_value => _value.toString()).toMaybe().toList())]);
        if (_qudt_Verifiable$j$dbpediaMatchEither.isLeft()) { return _qudt_Verifiable$j$dbpediaMatchEither; }

        const qudt_Verifiable$j$dbpediaMatch = _qudt_Verifiable$j$dbpediaMatchEither.unsafeCoerce();
        const _qudt_Verifiable$j$isoNormativeReferenceEither: purify.Either<rdfjsResource.Resource.ValueError, readonly (string)[]> = purify.Either.of([..._resource.values(dataFactory.namedNode("http://qudt.org/schema/qudt/isoNormativeReference"), { unique: true }).flatMap(_item => _item.toValues().head().chain(_value => _value.toString()).toMaybe().toList())]);
        if (_qudt_Verifiable$j$isoNormativeReferenceEither.isLeft()) { return _qudt_Verifiable$j$isoNormativeReferenceEither; }

        const qudt_Verifiable$j$isoNormativeReference = _qudt_Verifiable$j$isoNormativeReferenceEither.unsafeCoerce();
        const _qudt_Verifiable$j$normativeReferenceEither: purify.Either<rdfjsResource.Resource.ValueError, readonly (string)[]> = purify.Either.of([..._resource.values(dataFactory.namedNode("http://qudt.org/schema/qudt/normativeReference"), { unique: true }).flatMap(_item => _item.toValues().head().chain(_value => _value.toString()).toMaybe().toList())]);
        if (_qudt_Verifiable$j$normativeReferenceEither.isLeft()) { return _qudt_Verifiable$j$normativeReferenceEither; }

        const qudt_Verifiable$j$normativeReference = _qudt_Verifiable$j$normativeReferenceEither.unsafeCoerce();
        return purify.Either.of({ ..._super0, identifier, qudt_InformativeReferencePropertyShape, qudt_Verifiable$j$dbpediaMatch, qudt_Verifiable$j$isoNormativeReference, qudt_Verifiable$j$normativeReference })
    }

    export function fromRdf(parameters: Parameters<typeof Verifiable._propertiesFromRdf>[0]): purify.Either<rdfjsResource.Resource.ValueError, Verifiable> {
        const { ignoreRdfType: _ignoreRdfType, ...otherParameters } = parameters
        return (Enumerated_Value.fromRdf(otherParameters) as purify.Either<rdfjsResource.Resource.ValueError, Verifiable>).altLazy(() => Verifiable._propertiesFromRdf(parameters).map(properties => new Verifiable(properties)));
    }

    export let fromRdfType: rdfjs.NamedNode<string> = dataFactory.namedNode("http://qudt.org/schema/qudt/Verifiable");

    export function jsonSchema() {
        return zodToJsonSchema(verifiableJsonZodSchema());
    }

    export function verifiableJsonUiSchema(parameters?: { scopePrefix?: string }) {
        const scopePrefix = parameters?.scopePrefix ?? "#";
        return { "elements": [ QUDT_Aspect.qudtAspectJsonUiSchema({ scopePrefix }), { scope: `${scopePrefix}/properties/qudt_InformativeReferencePropertyShape`, type: "Control" }, { scope: `${scopePrefix}/properties/qudt_Verifiable$j$dbpediaMatch`, type: "Control" }, { scope: `${scopePrefix}/properties/qudt_Verifiable$j$isoNormativeReference`, type: "Control" }, { scope: `${scopePrefix}/properties/qudt_Verifiable$j$normativeReference`, type: "Control" } ], label: "Verifiable", type: "Group" }
    }

    export function verifiableJsonZodSchema() {
        return QUDT_Aspect.qudtAspectJsonZodSchema().merge(zod.object({ "@id": zod.string().min(1),"type": zod.enum(["Enumerated_Value","Quantity_type","Rule_Type","Scale_type","Transform_type","Verifiable"]),"qudt_InformativeReferencePropertyShape": zod.discriminatedUnion("termType", [zod.object({ "@id": zod.string().min(1), termType: zod.literal("BlankNode") }), zod.object({ "@id": zod.string().min(1), termType: zod.literal("NamedNode") }), zod.object({ "@language": zod.string().optional(), "@type": zod.string().optional(), "@value": zod.string(), termType: zod.literal("Literal") })]).array(),"qudt_Verifiable$j$dbpediaMatch": zod.string().array(),"qudt_Verifiable$j$isoNormativeReference": zod.string().array(),"qudt_Verifiable$j$normativeReference": zod.string().array() }));
    }

    export function sparqlConstructQuery(parameters?: { ignoreRdfType?: boolean; prefixes?: { [prefix: string]: string }; subject?: sparqljs.Triple["subject"]; } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type">): sparqljs.ConstructQuery {
        const { ignoreRdfType, subject, ...queryParameters } = parameters ?? {}

        return { ...queryParameters, prefixes: parameters?.prefixes ?? {}, queryType: "CONSTRUCT", template: (queryParameters.template ?? []).concat(Verifiable.sparqlConstructTemplateTriples({ ignoreRdfType, subject })), type: "query", where: (queryParameters.where ?? []).concat(Verifiable.sparqlWherePatterns({ ignoreRdfType, subject })) };
    }

    export function sparqlConstructQueryString(parameters?: { ignoreRdfType?: boolean; subject?: sparqljs.Triple["subject"]; variablePrefix?: string; } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type"> & sparqljs.GeneratorOptions): string {
        return new sparqljs.Generator(parameters).stringify(Verifiable.sparqlConstructQuery(parameters));
    }

    export function sparqlConstructTemplateTriples(parameters?: { ignoreRdfType?: boolean; subject?: sparqljs.Triple["subject"], variablePrefix?: string }): readonly sparqljs.Triple[] {
        const subject = parameters?.subject ?? dataFactory.variable!("verifiable");
        const variablePrefix = parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "verifiable");
        return [...QUDT_Aspect.sparqlConstructTemplateTriples({ ignoreRdfType: true, subject, variablePrefix }), ...(parameters?.ignoreRdfType ? [] : [{ subject, predicate: dataFactory.namedNode("http://www.w3.org/1999/02/22-rdf-syntax-ns#type"), object: dataFactory.variable!(`${variablePrefix}RdfType`) }]), { object: dataFactory.variable!(`${variablePrefix}QudtInformativeReferencePropertyShape`), predicate: dataFactory.namedNode("http://qudt.org/schema/qudt/informativeReference"), subject }, { object: dataFactory.variable!(`${variablePrefix}QudtVerifiableJDbpediaMatch`), predicate: dataFactory.namedNode("http://qudt.org/schema/qudt/dbpediaMatch"), subject }, { object: dataFactory.variable!(`${variablePrefix}QudtVerifiableJIsoNormativeReference`), predicate: dataFactory.namedNode("http://qudt.org/schema/qudt/isoNormativeReference"), subject }, { object: dataFactory.variable!(`${variablePrefix}QudtVerifiableJNormativeReference`), predicate: dataFactory.namedNode("http://qudt.org/schema/qudt/normativeReference"), subject }];
    }

    export function sparqlWherePatterns(parameters: { ignoreRdfType?: boolean; subject?: sparqljs.Triple["subject"], variablePrefix?: string }): readonly sparqljs.Pattern[] {
        const subject = parameters?.subject ?? dataFactory.variable!("verifiable");
        const variablePrefix = parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "verifiable");
        return [...QUDT_Aspect.sparqlWherePatterns({ ignoreRdfType: true, subject, variablePrefix }), ...(parameters?.ignoreRdfType ? [] : [{ triples: [{ subject, predicate: dataFactory.namedNode("http://www.w3.org/1999/02/22-rdf-syntax-ns#type"), object: dataFactory.namedNode("http://qudt.org/schema/qudt/Verifiable") }], type: "bgp" as const }, { triples: [{ subject, predicate: dataFactory.namedNode("http://www.w3.org/1999/02/22-rdf-syntax-ns#type"), object: dataFactory.variable!(`${variablePrefix}RdfType`) }], type: "bgp" as const }]), { patterns: [{ triples: [{ object: dataFactory.variable!(`${variablePrefix}QudtInformativeReferencePropertyShape`), predicate: dataFactory.namedNode("http://qudt.org/schema/qudt/informativeReference"), subject }], type: "bgp" }], type: "optional" }, { patterns: [{ triples: [{ object: dataFactory.variable!(`${variablePrefix}QudtVerifiableJDbpediaMatch`), predicate: dataFactory.namedNode("http://qudt.org/schema/qudt/dbpediaMatch"), subject }], type: "bgp" }], type: "optional" }, { patterns: [{ triples: [{ object: dataFactory.variable!(`${variablePrefix}QudtVerifiableJIsoNormativeReference`), predicate: dataFactory.namedNode("http://qudt.org/schema/qudt/isoNormativeReference"), subject }], type: "bgp" }], type: "optional" }, { patterns: [{ triples: [{ object: dataFactory.variable!(`${variablePrefix}QudtVerifiableJNormativeReference`), predicate: dataFactory.namedNode("http://qudt.org/schema/qudt/normativeReference"), subject }], type: "bgp" }], type: "optional" }];
    }
}
/**
 * Enumerated Value
 */
export class Enumerated_Value extends Verifiable {
    override readonly type: "Enumerated_Value" | "Quantity_type" | "Rule_Type" | "Scale_type" | "Transform_type" = "Enumerated_Value";
    readonly qudt_EnumeratedValue$j$abbreviation: purify.Maybe<string>;
    readonly qudt_EnumeratedValue$j$altSymbol: readonly ((rdfjs.BlankNode | rdfjs.NamedNode | rdfjs.Literal))[];
    readonly qudt_EnumeratedValue$j$description: purify.Maybe<(rdfjs.BlankNode | rdfjs.NamedNode | rdfjs.Literal)>;
    readonly qudt_EnumeratedValue$j$symbol: purify.Maybe<(rdfjs.BlankNode | rdfjs.NamedNode | rdfjs.Literal)>;

    constructor(parameters: { readonly identifier?: (rdfjs.BlankNode | rdfjs.NamedNode) | string, readonly qudt_EnumeratedValue$j$abbreviation?: purify.Maybe<string> | string, readonly qudt_EnumeratedValue$j$altSymbol?: readonly ((rdfjs.BlankNode | rdfjs.NamedNode | rdfjs.Literal))[], readonly qudt_EnumeratedValue$j$description?: (rdfjs.BlankNode | rdfjs.NamedNode | rdfjs.Literal) | Date | boolean | number | purify.Maybe<(rdfjs.BlankNode | rdfjs.NamedNode | rdfjs.Literal)> | string, readonly qudt_EnumeratedValue$j$symbol?: (rdfjs.BlankNode | rdfjs.NamedNode | rdfjs.Literal) | Date | boolean | number | purify.Maybe<(rdfjs.BlankNode | rdfjs.NamedNode | rdfjs.Literal)> | string } & ConstructorParameters<typeof Verifiable>[0]) {
        super(parameters);
        if (purify.Maybe.isMaybe(parameters.qudt_EnumeratedValue$j$abbreviation)) { this.qudt_EnumeratedValue$j$abbreviation = parameters.qudt_EnumeratedValue$j$abbreviation; } else if (typeof parameters.qudt_EnumeratedValue$j$abbreviation === "string") { this.qudt_EnumeratedValue$j$abbreviation = purify.Maybe.of(parameters.qudt_EnumeratedValue$j$abbreviation); } else if (typeof parameters.qudt_EnumeratedValue$j$abbreviation === "undefined") { this.qudt_EnumeratedValue$j$abbreviation = purify.Maybe.empty(); } else { this.qudt_EnumeratedValue$j$abbreviation =( parameters.qudt_EnumeratedValue$j$abbreviation) as never;
         }

        if (typeof parameters.qudt_EnumeratedValue$j$altSymbol === "undefined") { this.qudt_EnumeratedValue$j$altSymbol = []; } else if (Array.isArray(parameters.qudt_EnumeratedValue$j$altSymbol)) { this.qudt_EnumeratedValue$j$altSymbol = parameters.qudt_EnumeratedValue$j$altSymbol; } else { this.qudt_EnumeratedValue$j$altSymbol =( parameters.qudt_EnumeratedValue$j$altSymbol) as never;
         }

        if (purify.Maybe.isMaybe(parameters.qudt_EnumeratedValue$j$description)) { this.qudt_EnumeratedValue$j$description = parameters.qudt_EnumeratedValue$j$description; } else if (typeof parameters.qudt_EnumeratedValue$j$description === "boolean") { this.qudt_EnumeratedValue$j$description = purify.Maybe.of(rdfLiteral.toRdf(parameters.qudt_EnumeratedValue$j$description, { dataFactory })); } else if (typeof parameters.qudt_EnumeratedValue$j$description === "object" && parameters.qudt_EnumeratedValue$j$description instanceof Date) { this.qudt_EnumeratedValue$j$description = purify.Maybe.of(rdfLiteral.toRdf(parameters.qudt_EnumeratedValue$j$description, { dataFactory })); } else if (typeof parameters.qudt_EnumeratedValue$j$description === "number") { this.qudt_EnumeratedValue$j$description = purify.Maybe.of(rdfLiteral.toRdf(parameters.qudt_EnumeratedValue$j$description, { dataFactory })); } else if (typeof parameters.qudt_EnumeratedValue$j$description === "string") { this.qudt_EnumeratedValue$j$description = purify.Maybe.of(dataFactory.literal(parameters.qudt_EnumeratedValue$j$description)); } else if (typeof parameters.qudt_EnumeratedValue$j$description === "object") { this.qudt_EnumeratedValue$j$description = purify.Maybe.of(parameters.qudt_EnumeratedValue$j$description); } else if (typeof parameters.qudt_EnumeratedValue$j$description === "undefined") { this.qudt_EnumeratedValue$j$description = purify.Maybe.empty(); } else { this.qudt_EnumeratedValue$j$description =( parameters.qudt_EnumeratedValue$j$description) as never;
         }

        if (purify.Maybe.isMaybe(parameters.qudt_EnumeratedValue$j$symbol)) { this.qudt_EnumeratedValue$j$symbol = parameters.qudt_EnumeratedValue$j$symbol; } else if (typeof parameters.qudt_EnumeratedValue$j$symbol === "boolean") { this.qudt_EnumeratedValue$j$symbol = purify.Maybe.of(rdfLiteral.toRdf(parameters.qudt_EnumeratedValue$j$symbol, { dataFactory })); } else if (typeof parameters.qudt_EnumeratedValue$j$symbol === "object" && parameters.qudt_EnumeratedValue$j$symbol instanceof Date) { this.qudt_EnumeratedValue$j$symbol = purify.Maybe.of(rdfLiteral.toRdf(parameters.qudt_EnumeratedValue$j$symbol, { dataFactory })); } else if (typeof parameters.qudt_EnumeratedValue$j$symbol === "number") { this.qudt_EnumeratedValue$j$symbol = purify.Maybe.of(rdfLiteral.toRdf(parameters.qudt_EnumeratedValue$j$symbol, { dataFactory })); } else if (typeof parameters.qudt_EnumeratedValue$j$symbol === "string") { this.qudt_EnumeratedValue$j$symbol = purify.Maybe.of(dataFactory.literal(parameters.qudt_EnumeratedValue$j$symbol)); } else if (typeof parameters.qudt_EnumeratedValue$j$symbol === "object") { this.qudt_EnumeratedValue$j$symbol = purify.Maybe.of(parameters.qudt_EnumeratedValue$j$symbol); } else if (typeof parameters.qudt_EnumeratedValue$j$symbol === "undefined") { this.qudt_EnumeratedValue$j$symbol = purify.Maybe.empty(); } else { this.qudt_EnumeratedValue$j$symbol =( parameters.qudt_EnumeratedValue$j$symbol) as never;
         }
    }

    override get identifier(): (rdfjs.BlankNode | rdfjs.NamedNode) {
        if (typeof this._identifier === "undefined") { this._identifier = dataFactory.blankNode(); } return this._identifier;
    }

    override equals(other: Enumerated_Value): EqualsResult {
        return super.equals(other).chain(() => (((left, right) => maybeEquals(left, right, strictEquals)))(this.qudt_EnumeratedValue$j$abbreviation, other.qudt_EnumeratedValue$j$abbreviation).mapLeft(propertyValuesUnequal => ({ left: this, right: other, propertyName: "qudt_EnumeratedValue$j$abbreviation", propertyValuesUnequal, type: "Property" as const }))).chain(() => (((left, right) => arrayEquals(left, right, booleanEquals)))(this.qudt_EnumeratedValue$j$altSymbol, other.qudt_EnumeratedValue$j$altSymbol).mapLeft(propertyValuesUnequal => ({ left: this, right: other, propertyName: "qudt_EnumeratedValue$j$altSymbol", propertyValuesUnequal, type: "Property" as const }))).chain(() => (((left, right) => maybeEquals(left, right, booleanEquals)))(this.qudt_EnumeratedValue$j$description, other.qudt_EnumeratedValue$j$description).mapLeft(propertyValuesUnequal => ({ left: this, right: other, propertyName: "qudt_EnumeratedValue$j$description", propertyValuesUnequal, type: "Property" as const }))).chain(() => (((left, right) => maybeEquals(left, right, booleanEquals)))(this.qudt_EnumeratedValue$j$symbol, other.qudt_EnumeratedValue$j$symbol).mapLeft(propertyValuesUnequal => ({ left: this, right: other, propertyName: "qudt_EnumeratedValue$j$symbol", propertyValuesUnequal, type: "Property" as const })));
    }

    override hash<HasherT extends { update: (message: string | number[] | ArrayBuffer | Uint8Array) => void; }>(_hasher: HasherT): HasherT {
        this.hashShaclProperties(_hasher);
        return _hasher;
    }

    protected override hashShaclProperties<HasherT extends { update: (message: string | number[] | ArrayBuffer | Uint8Array) => void; }>(_hasher: HasherT): HasherT {
        super.hashShaclProperties(_hasher);
        this.qudt_EnumeratedValue$j$abbreviation.ifJust((_value0) => { _hasher.update(_value0); })
        for (const _item0 of this.qudt_EnumeratedValue$j$altSymbol) { _hasher.update(_item0.termType);
        _hasher.update(_item0.value); }

        this.qudt_EnumeratedValue$j$description.ifJust((_value0) => { _hasher.update(_value0.termType);
        _hasher.update(_value0.value); })
        this.qudt_EnumeratedValue$j$symbol.ifJust((_value0) => { _hasher.update(_value0.termType);
        _hasher.update(_value0.value); })
        return _hasher;
    }

    override toJson(): { readonly "qudt_EnumeratedValue$j$abbreviation": (string) | undefined; readonly "qudt_EnumeratedValue$j$altSymbol": readonly ({ readonly "@id": string, readonly termType: "BlankNode" | "NamedNode" } | { readonly "@language": string | undefined, readonly "@type": string | undefined, readonly "@value": string, readonly termType: "Literal" })[]; readonly "qudt_EnumeratedValue$j$description": ({ readonly "@id": string, readonly termType: "BlankNode" | "NamedNode" } | { readonly "@language": string | undefined, readonly "@type": string | undefined, readonly "@value": string, readonly termType: "Literal" }) | undefined; readonly "qudt_EnumeratedValue$j$symbol": ({ readonly "@id": string, readonly termType: "BlankNode" | "NamedNode" } | { readonly "@language": string | undefined, readonly "@type": string | undefined, readonly "@value": string, readonly termType: "Literal" }) | undefined } & ReturnType<Verifiable["toJson"]> {
        return JSON.parse(JSON.stringify({ ...super.toJson(),qudt_EnumeratedValue$j$abbreviation: this.qudt_EnumeratedValue$j$abbreviation.map(_item => (_item)).extract(),qudt_EnumeratedValue$j$altSymbol: this.qudt_EnumeratedValue$j$altSymbol.map(_item => ((_item.termType === "Literal") ? { "@language": _item.language.length > 0 ? _item.language : undefined, "@type": _item.datatype.value !== "http://www.w3.org/2001/XMLSchema#string" ? _item.datatype.value : undefined, "@value": _item.value, termType: "Literal" as const } : (_item.termType === "NamedNode") ? { "@id": _item.value, termType: "NamedNode" as const } : { "@id": `_:${_item.value}`, termType: "BlankNode" as const })),qudt_EnumeratedValue$j$description: this.qudt_EnumeratedValue$j$description.map(_item => ((_item.termType === "Literal") ? { "@language": _item.language.length > 0 ? _item.language : undefined, "@type": _item.datatype.value !== "http://www.w3.org/2001/XMLSchema#string" ? _item.datatype.value : undefined, "@value": _item.value, termType: "Literal" as const } : (_item.termType === "NamedNode") ? { "@id": _item.value, termType: "NamedNode" as const } : { "@id": `_:${_item.value}`, termType: "BlankNode" as const })).extract(),qudt_EnumeratedValue$j$symbol: this.qudt_EnumeratedValue$j$symbol.map(_item => ((_item.termType === "Literal") ? { "@language": _item.language.length > 0 ? _item.language : undefined, "@type": _item.datatype.value !== "http://www.w3.org/2001/XMLSchema#string" ? _item.datatype.value : undefined, "@value": _item.value, termType: "Literal" as const } : (_item.termType === "NamedNode") ? { "@id": _item.value, termType: "NamedNode" as const } : { "@id": `_:${_item.value}`, termType: "BlankNode" as const })).extract() } satisfies ReturnType<Enumerated_Value["toJson"]>));
    }

    override toRdf({ ignoreRdfType, mutateGraph, resourceSet }: { ignoreRdfType?: boolean; mutateGraph?: rdfjsResource.MutableResource.MutateGraph, resourceSet: rdfjsResource.MutableResourceSet }): rdfjsResource.MutableResource {
        const _resource = super.toRdf({ ignoreRdfType: true, mutateGraph, resourceSet });
        if (!ignoreRdfType) { _resource.add(_resource.dataFactory.namedNode("http://www.w3.org/1999/02/22-rdf-syntax-ns#type"), _resource.dataFactory.namedNode("http://qudt.org/schema/qudt/EnumeratedValue")); }

        _resource.add(dataFactory.namedNode("http://qudt.org/schema/qudt/abbreviation"), this.qudt_EnumeratedValue$j$abbreviation);
        _resource.add(dataFactory.namedNode("http://qudt.org/schema/qudt/altSymbol"), this.qudt_EnumeratedValue$j$altSymbol.map((_item) => _item));
        _resource.add(dataFactory.namedNode("http://purl.org/dc/terms/description"), this.qudt_EnumeratedValue$j$description);
        _resource.add(dataFactory.namedNode("http://qudt.org/schema/qudt/symbol"), this.qudt_EnumeratedValue$j$symbol);
        return _resource;
    }

    override toString(): string {
        return JSON.stringify(this.toJson());
    }
}

export namespace Enumerated_Value {
    export function _propertiesFromJson(_json: unknown): purify.Either<zod.ZodError, { identifier: (rdfjs.BlankNode | rdfjs.NamedNode); qudt_EnumeratedValue$j$abbreviation: purify.Maybe<string>; qudt_EnumeratedValue$j$altSymbol: readonly ((rdfjs.BlankNode | rdfjs.NamedNode | rdfjs.Literal))[]; qudt_EnumeratedValue$j$description: purify.Maybe<(rdfjs.BlankNode | rdfjs.NamedNode | rdfjs.Literal)>; qudt_EnumeratedValue$j$symbol: purify.Maybe<(rdfjs.BlankNode | rdfjs.NamedNode | rdfjs.Literal)>; } & UnwrapR<ReturnType<typeof Verifiable._propertiesFromJson>>> {
        const _jsonSafeParseResult = enumeratedValueJsonZodSchema().safeParse(_json);
        if (!_jsonSafeParseResult.success) { return purify.Left(_jsonSafeParseResult.error); }

        const _jsonObject = _jsonSafeParseResult.data;
        const _super0Either = Verifiable._propertiesFromJson(_jsonObject);
        if (_super0Either.isLeft()) { return _super0Either; }

        const _super0 = _super0Either.unsafeCoerce()
        const identifier = (_jsonObject["@id"].startsWith("_:") ? dataFactory.blankNode(_jsonObject["@id"].substring(2)) : dataFactory.namedNode(_jsonObject["@id"]));
        const qudt_EnumeratedValue$j$abbreviation = purify.Maybe.fromNullable(_jsonObject["qudt_EnumeratedValue$j$abbreviation"]);
        const qudt_EnumeratedValue$j$altSymbol = _jsonObject["qudt_EnumeratedValue$j$altSymbol"].map(_item => (((_item.termType === "Literal") ? (dataFactory.literal(_item["@value"], typeof _item["@language"] !== "undefined" ? _item["@language"] : (typeof _item["@type"] !== "undefined" ? dataFactory.namedNode(_item["@type"]) : undefined))) : (((_item.termType === "NamedNode") ? (dataFactory.namedNode(_item["@id"])) : (dataFactory.blankNode(_item["@id"].substring(2))))))));
        const qudt_EnumeratedValue$j$description = purify.Maybe.fromNullable(_jsonObject["qudt_EnumeratedValue$j$description"]).map(_item => (((_item.termType === "Literal") ? (dataFactory.literal(_item["@value"], typeof _item["@language"] !== "undefined" ? _item["@language"] : (typeof _item["@type"] !== "undefined" ? dataFactory.namedNode(_item["@type"]) : undefined))) : (((_item.termType === "NamedNode") ? (dataFactory.namedNode(_item["@id"])) : (dataFactory.blankNode(_item["@id"].substring(2))))))));
        const qudt_EnumeratedValue$j$symbol = purify.Maybe.fromNullable(_jsonObject["qudt_EnumeratedValue$j$symbol"]).map(_item => (((_item.termType === "Literal") ? (dataFactory.literal(_item["@value"], typeof _item["@language"] !== "undefined" ? _item["@language"] : (typeof _item["@type"] !== "undefined" ? dataFactory.namedNode(_item["@type"]) : undefined))) : (((_item.termType === "NamedNode") ? (dataFactory.namedNode(_item["@id"])) : (dataFactory.blankNode(_item["@id"].substring(2))))))));
        return purify.Either.of({ ..._super0, identifier, qudt_EnumeratedValue$j$abbreviation, qudt_EnumeratedValue$j$altSymbol, qudt_EnumeratedValue$j$description, qudt_EnumeratedValue$j$symbol })
    }

    export function fromJson(json: unknown): purify.Either<zod.ZodError, Enumerated_Value> {
        return (Quantity_type.fromJson(json) as purify.Either<zod.ZodError, Enumerated_Value>).altLazy(() => (Rule_Type.fromJson(json) as purify.Either<zod.ZodError, Enumerated_Value>)).altLazy(() => (Scale_type.fromJson(json) as purify.Either<zod.ZodError, Enumerated_Value>)).altLazy(() => (Transform_type.fromJson(json) as purify.Either<zod.ZodError, Enumerated_Value>)).altLazy(() => Enumerated_Value._propertiesFromJson(json).map(properties => new Enumerated_Value(properties)));
    }

    export function _propertiesFromRdf({ ignoreRdfType: _ignoreRdfType, languageIn: _languageIn, resource: _resource,
        // @ts-ignore
        ..._context }: { [_index: string]: any; ignoreRdfType?: boolean; languageIn?: readonly string[]; resource: rdfjsResource.Resource; }): purify.Either<rdfjsResource.Resource.ValueError, { identifier: (rdfjs.BlankNode | rdfjs.NamedNode); qudt_EnumeratedValue$j$abbreviation: purify.Maybe<string>; qudt_EnumeratedValue$j$altSymbol: readonly ((rdfjs.BlankNode | rdfjs.NamedNode | rdfjs.Literal))[]; qudt_EnumeratedValue$j$description: purify.Maybe<(rdfjs.BlankNode | rdfjs.NamedNode | rdfjs.Literal)>; qudt_EnumeratedValue$j$symbol: purify.Maybe<(rdfjs.BlankNode | rdfjs.NamedNode | rdfjs.Literal)>; } & UnwrapR<ReturnType<typeof Verifiable._propertiesFromRdf>>> {
        const _super0Either = Verifiable._propertiesFromRdf({ ..._context, ignoreRdfType: true, languageIn: _languageIn, resource: _resource });
        if (_super0Either.isLeft()) { return _super0Either; }

        const _super0 = _super0Either.unsafeCoerce()
        if (!_ignoreRdfType && !_resource.isInstanceOf(dataFactory.namedNode("http://qudt.org/schema/qudt/EnumeratedValue"))) { return purify.Left(new rdfjsResource.Resource.ValueError({ focusResource: _resource, message: `${rdfjsResource.Resource.Identifier.toString(_resource.identifier)} has unexpected RDF type (expected http://qudt.org/schema/qudt/EnumeratedValue)`, predicate: dataFactory.namedNode("http://qudt.org/schema/qudt/EnumeratedValue") })); }

        const identifier = _resource.identifier
        const _qudt_EnumeratedValue$j$abbreviationEither: purify.Either<rdfjsResource.Resource.ValueError, purify.Maybe<string>> = purify.Either.of(_resource.values(dataFactory.namedNode("http://qudt.org/schema/qudt/abbreviation"), { unique: true }).head().chain(_value => _value.toString()).toMaybe());
        if (_qudt_EnumeratedValue$j$abbreviationEither.isLeft()) { return _qudt_EnumeratedValue$j$abbreviationEither; }

        const qudt_EnumeratedValue$j$abbreviation = _qudt_EnumeratedValue$j$abbreviationEither.unsafeCoerce();
        const _qudt_EnumeratedValue$j$altSymbolEither: purify.Either<rdfjsResource.Resource.ValueError, readonly ((rdfjs.BlankNode | rdfjs.NamedNode | rdfjs.Literal))[]> = purify.Either.of([..._resource.values(dataFactory.namedNode("http://qudt.org/schema/qudt/altSymbol"), { unique: true }).flatMap(_item => _item.toValues().head().chain(_value => purify.Either.of(_value.toTerm())).toMaybe().toList())]);
        if (_qudt_EnumeratedValue$j$altSymbolEither.isLeft()) { return _qudt_EnumeratedValue$j$altSymbolEither; }

        const qudt_EnumeratedValue$j$altSymbol = _qudt_EnumeratedValue$j$altSymbolEither.unsafeCoerce();
        const _qudt_EnumeratedValue$j$descriptionEither: purify.Either<rdfjsResource.Resource.ValueError, purify.Maybe<(rdfjs.BlankNode | rdfjs.NamedNode | rdfjs.Literal)>> = purify.Either.of(_resource.values(dataFactory.namedNode("http://purl.org/dc/terms/description"), { unique: true }).head().chain(_value => purify.Either.of(_value.toTerm())).toMaybe());
        if (_qudt_EnumeratedValue$j$descriptionEither.isLeft()) { return _qudt_EnumeratedValue$j$descriptionEither; }

        const qudt_EnumeratedValue$j$description = _qudt_EnumeratedValue$j$descriptionEither.unsafeCoerce();
        const _qudt_EnumeratedValue$j$symbolEither: purify.Either<rdfjsResource.Resource.ValueError, purify.Maybe<(rdfjs.BlankNode | rdfjs.NamedNode | rdfjs.Literal)>> = purify.Either.of(_resource.values(dataFactory.namedNode("http://qudt.org/schema/qudt/symbol"), { unique: true }).head().chain(_value => purify.Either.of(_value.toTerm())).toMaybe());
        if (_qudt_EnumeratedValue$j$symbolEither.isLeft()) { return _qudt_EnumeratedValue$j$symbolEither; }

        const qudt_EnumeratedValue$j$symbol = _qudt_EnumeratedValue$j$symbolEither.unsafeCoerce();
        return purify.Either.of({ ..._super0, identifier, qudt_EnumeratedValue$j$abbreviation, qudt_EnumeratedValue$j$altSymbol, qudt_EnumeratedValue$j$description, qudt_EnumeratedValue$j$symbol })
    }

    export function fromRdf(parameters: Parameters<typeof Enumerated_Value._propertiesFromRdf>[0]): purify.Either<rdfjsResource.Resource.ValueError, Enumerated_Value> {
        const { ignoreRdfType: _ignoreRdfType, ...otherParameters } = parameters
        return (Quantity_type.fromRdf(otherParameters) as purify.Either<rdfjsResource.Resource.ValueError, Enumerated_Value>).altLazy(() => (Rule_Type.fromRdf(otherParameters) as purify.Either<rdfjsResource.Resource.ValueError, Enumerated_Value>)).altLazy(() => (Scale_type.fromRdf(otherParameters) as purify.Either<rdfjsResource.Resource.ValueError, Enumerated_Value>)).altLazy(() => (Transform_type.fromRdf(otherParameters) as purify.Either<rdfjsResource.Resource.ValueError, Enumerated_Value>)).altLazy(() => Enumerated_Value._propertiesFromRdf(parameters).map(properties => new Enumerated_Value(properties)));
    }

    export let fromRdfType: rdfjs.NamedNode<string> = dataFactory.namedNode("http://qudt.org/schema/qudt/EnumeratedValue");

    export function jsonSchema() {
        return zodToJsonSchema(enumeratedValueJsonZodSchema());
    }

    export function enumeratedValueJsonUiSchema(parameters?: { scopePrefix?: string }) {
        const scopePrefix = parameters?.scopePrefix ?? "#";
        return { "elements": [ Verifiable.verifiableJsonUiSchema({ scopePrefix }), { scope: `${scopePrefix}/properties/qudt_EnumeratedValue$j$abbreviation`, type: "Control" }, { scope: `${scopePrefix}/properties/qudt_EnumeratedValue$j$altSymbol`, type: "Control" }, { scope: `${scopePrefix}/properties/qudt_EnumeratedValue$j$description`, type: "Control" }, { scope: `${scopePrefix}/properties/qudt_EnumeratedValue$j$symbol`, type: "Control" } ], label: "Enumerated Value", type: "Group" }
    }

    export function enumeratedValueJsonZodSchema() {
        return Verifiable.verifiableJsonZodSchema().merge(zod.object({ "@id": zod.string().min(1),"type": zod.enum(["Enumerated_Value","Quantity_type","Rule_Type","Scale_type","Transform_type"]),"qudt_EnumeratedValue$j$abbreviation": zod.string().optional(),"qudt_EnumeratedValue$j$altSymbol": zod.discriminatedUnion("termType", [zod.object({ "@id": zod.string().min(1), termType: zod.literal("BlankNode") }), zod.object({ "@id": zod.string().min(1), termType: zod.literal("NamedNode") }), zod.object({ "@language": zod.string().optional(), "@type": zod.string().optional(), "@value": zod.string(), termType: zod.literal("Literal") })]).array(),"qudt_EnumeratedValue$j$description": zod.discriminatedUnion("termType", [zod.object({ "@id": zod.string().min(1), termType: zod.literal("BlankNode") }), zod.object({ "@id": zod.string().min(1), termType: zod.literal("NamedNode") }), zod.object({ "@language": zod.string().optional(), "@type": zod.string().optional(), "@value": zod.string(), termType: zod.literal("Literal") })]).optional(),"qudt_EnumeratedValue$j$symbol": zod.discriminatedUnion("termType", [zod.object({ "@id": zod.string().min(1), termType: zod.literal("BlankNode") }), zod.object({ "@id": zod.string().min(1), termType: zod.literal("NamedNode") }), zod.object({ "@language": zod.string().optional(), "@type": zod.string().optional(), "@value": zod.string(), termType: zod.literal("Literal") })]).optional() }));
    }

    export function sparqlConstructQuery(parameters?: { ignoreRdfType?: boolean; prefixes?: { [prefix: string]: string }; subject?: sparqljs.Triple["subject"]; } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type">): sparqljs.ConstructQuery {
        const { ignoreRdfType, subject, ...queryParameters } = parameters ?? {}

        return { ...queryParameters, prefixes: parameters?.prefixes ?? {}, queryType: "CONSTRUCT", template: (queryParameters.template ?? []).concat(Enumerated_Value.sparqlConstructTemplateTriples({ ignoreRdfType, subject })), type: "query", where: (queryParameters.where ?? []).concat(Enumerated_Value.sparqlWherePatterns({ ignoreRdfType, subject })) };
    }

    export function sparqlConstructQueryString(parameters?: { ignoreRdfType?: boolean; subject?: sparqljs.Triple["subject"]; variablePrefix?: string; } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type"> & sparqljs.GeneratorOptions): string {
        return new sparqljs.Generator(parameters).stringify(Enumerated_Value.sparqlConstructQuery(parameters));
    }

    export function sparqlConstructTemplateTriples(parameters?: { ignoreRdfType?: boolean; subject?: sparqljs.Triple["subject"], variablePrefix?: string }): readonly sparqljs.Triple[] {
        const subject = parameters?.subject ?? dataFactory.variable!("enumeratedValue");
        const variablePrefix = parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "enumeratedValue");
        return [...Verifiable.sparqlConstructTemplateTriples({ ignoreRdfType: true, subject, variablePrefix }), ...(parameters?.ignoreRdfType ? [] : [{ subject, predicate: dataFactory.namedNode("http://www.w3.org/1999/02/22-rdf-syntax-ns#type"), object: dataFactory.variable!(`${variablePrefix}RdfType`) }]), { object: dataFactory.variable!(`${variablePrefix}QudtEnumeratedValueJAbbreviation`), predicate: dataFactory.namedNode("http://qudt.org/schema/qudt/abbreviation"), subject }, { object: dataFactory.variable!(`${variablePrefix}QudtEnumeratedValueJAltSymbol`), predicate: dataFactory.namedNode("http://qudt.org/schema/qudt/altSymbol"), subject }, { object: dataFactory.variable!(`${variablePrefix}QudtEnumeratedValueJDescription`), predicate: dataFactory.namedNode("http://purl.org/dc/terms/description"), subject }, { object: dataFactory.variable!(`${variablePrefix}QudtEnumeratedValueJSymbol`), predicate: dataFactory.namedNode("http://qudt.org/schema/qudt/symbol"), subject }];
    }

    export function sparqlWherePatterns(parameters: { ignoreRdfType?: boolean; subject?: sparqljs.Triple["subject"], variablePrefix?: string }): readonly sparqljs.Pattern[] {
        const subject = parameters?.subject ?? dataFactory.variable!("enumeratedValue");
        const variablePrefix = parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "enumeratedValue");
        return [...Verifiable.sparqlWherePatterns({ ignoreRdfType: true, subject, variablePrefix }), ...(parameters?.ignoreRdfType ? [] : [{ triples: [{ subject, predicate: dataFactory.namedNode("http://www.w3.org/1999/02/22-rdf-syntax-ns#type"), object: dataFactory.namedNode("http://qudt.org/schema/qudt/EnumeratedValue") }], type: "bgp" as const }, { triples: [{ subject, predicate: dataFactory.namedNode("http://www.w3.org/1999/02/22-rdf-syntax-ns#type"), object: dataFactory.variable!(`${variablePrefix}RdfType`) }], type: "bgp" as const }]), { patterns: [{ triples: [{ object: dataFactory.variable!(`${variablePrefix}QudtEnumeratedValueJAbbreviation`), predicate: dataFactory.namedNode("http://qudt.org/schema/qudt/abbreviation"), subject }], type: "bgp" }], type: "optional" }, { patterns: [{ triples: [{ object: dataFactory.variable!(`${variablePrefix}QudtEnumeratedValueJAltSymbol`), predicate: dataFactory.namedNode("http://qudt.org/schema/qudt/altSymbol"), subject }], type: "bgp" }], type: "optional" }, { patterns: [{ triples: [{ object: dataFactory.variable!(`${variablePrefix}QudtEnumeratedValueJDescription`), predicate: dataFactory.namedNode("http://purl.org/dc/terms/description"), subject }], type: "bgp" }], type: "optional" }, { patterns: [{ triples: [{ object: dataFactory.variable!(`${variablePrefix}QudtEnumeratedValueJSymbol`), predicate: dataFactory.namedNode("http://qudt.org/schema/qudt/symbol"), subject }], type: "bgp" }], type: "optional" }];
    }
}
/**
 * Transform type
 */
export class Transform_type extends Enumerated_Value {
    override readonly type = "Transform_type";

    // biome-ignore lint/complexity/noUselessConstructor: Always have a constructor
    constructor(parameters: { readonly identifier?: (rdfjs.BlankNode | rdfjs.NamedNode) | string } & ConstructorParameters<typeof Enumerated_Value>[0]) {
        super(parameters);
    }

    override get identifier(): (rdfjs.BlankNode | rdfjs.NamedNode) {
        if (typeof this._identifier === "undefined") { this._identifier = dataFactory.blankNode(); } return this._identifier;
    }

    override toRdf({ ignoreRdfType, mutateGraph, resourceSet }: { ignoreRdfType?: boolean; mutateGraph?: rdfjsResource.MutableResource.MutateGraph, resourceSet: rdfjsResource.MutableResourceSet }): rdfjsResource.MutableResource {
        const _resource = super.toRdf({ ignoreRdfType: true, mutateGraph, resourceSet });
        if (!ignoreRdfType) { _resource.add(_resource.dataFactory.namedNode("http://www.w3.org/1999/02/22-rdf-syntax-ns#type"), _resource.dataFactory.namedNode("http://qudt.org/schema/qudt/TransformType")); }

        return _resource;
    }

    override toString(): string {
        return JSON.stringify(this.toJson());
    }
}

export namespace Transform_type {
    export function _propertiesFromJson(_json: unknown): purify.Either<zod.ZodError, { identifier: (rdfjs.BlankNode | rdfjs.NamedNode); } & UnwrapR<ReturnType<typeof Enumerated_Value._propertiesFromJson>>> {
        const _jsonSafeParseResult = transformTypeJsonZodSchema().safeParse(_json);
        if (!_jsonSafeParseResult.success) { return purify.Left(_jsonSafeParseResult.error); }

        const _jsonObject = _jsonSafeParseResult.data;
        const _super0Either = Enumerated_Value._propertiesFromJson(_jsonObject);
        if (_super0Either.isLeft()) { return _super0Either; }

        const _super0 = _super0Either.unsafeCoerce()
        const identifier = (_jsonObject["@id"].startsWith("_:") ? dataFactory.blankNode(_jsonObject["@id"].substring(2)) : dataFactory.namedNode(_jsonObject["@id"]));
        return purify.Either.of({ ..._super0, identifier })
    }

    export function fromJson(json: unknown): purify.Either<zod.ZodError, Transform_type> {
        return Transform_type._propertiesFromJson(json).map(properties => new Transform_type(properties));
    }

    export function _propertiesFromRdf({ ignoreRdfType: _ignoreRdfType, languageIn: _languageIn, resource: _resource,
        // @ts-ignore
        ..._context }: { [_index: string]: any; ignoreRdfType?: boolean; languageIn?: readonly string[]; resource: rdfjsResource.Resource; }): purify.Either<rdfjsResource.Resource.ValueError, { identifier: (rdfjs.BlankNode | rdfjs.NamedNode); } & UnwrapR<ReturnType<typeof Enumerated_Value._propertiesFromRdf>>> {
        const _super0Either = Enumerated_Value._propertiesFromRdf({ ..._context, ignoreRdfType: true, languageIn: _languageIn, resource: _resource });
        if (_super0Either.isLeft()) { return _super0Either; }

        const _super0 = _super0Either.unsafeCoerce()
        if (!_ignoreRdfType && !_resource.isInstanceOf(dataFactory.namedNode("http://qudt.org/schema/qudt/TransformType"))) { return purify.Left(new rdfjsResource.Resource.ValueError({ focusResource: _resource, message: `${rdfjsResource.Resource.Identifier.toString(_resource.identifier)} has unexpected RDF type (expected http://qudt.org/schema/qudt/TransformType)`, predicate: dataFactory.namedNode("http://qudt.org/schema/qudt/TransformType") })); }

        const identifier = _resource.identifier
        return purify.Either.of({ ..._super0, identifier })
    }

    export function fromRdf(parameters: Parameters<typeof Transform_type._propertiesFromRdf>[0]): purify.Either<rdfjsResource.Resource.ValueError, Transform_type> {
        return Transform_type._propertiesFromRdf(parameters).map(properties => new Transform_type(properties));
    }

    export let fromRdfType: rdfjs.NamedNode<string> = dataFactory.namedNode("http://qudt.org/schema/qudt/TransformType");

    export function jsonSchema() {
        return zodToJsonSchema(transformTypeJsonZodSchema());
    }

    export function transformTypeJsonUiSchema(parameters?: { scopePrefix?: string }) {
        const scopePrefix = parameters?.scopePrefix ?? "#";
        return { "elements": [ Enumerated_Value.enumeratedValueJsonUiSchema({ scopePrefix }) ], label: "Transform type", type: "Group" }
    }

    export function transformTypeJsonZodSchema() {
        return Enumerated_Value.enumeratedValueJsonZodSchema().merge(zod.object({ "@id": zod.string().min(1),"type": zod.literal("Transform_type") }));
    }

    export function sparqlConstructQuery(parameters?: { ignoreRdfType?: boolean; prefixes?: { [prefix: string]: string }; subject?: sparqljs.Triple["subject"]; } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type">): sparqljs.ConstructQuery {
        const { ignoreRdfType, subject, ...queryParameters } = parameters ?? {}

        return { ...queryParameters, prefixes: parameters?.prefixes ?? {}, queryType: "CONSTRUCT", template: (queryParameters.template ?? []).concat(Transform_type.sparqlConstructTemplateTriples({ ignoreRdfType, subject })), type: "query", where: (queryParameters.where ?? []).concat(Transform_type.sparqlWherePatterns({ ignoreRdfType, subject })) };
    }

    export function sparqlConstructQueryString(parameters?: { ignoreRdfType?: boolean; subject?: sparqljs.Triple["subject"]; variablePrefix?: string; } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type"> & sparqljs.GeneratorOptions): string {
        return new sparqljs.Generator(parameters).stringify(Transform_type.sparqlConstructQuery(parameters));
    }

    export function sparqlConstructTemplateTriples(parameters?: { ignoreRdfType?: boolean; subject?: sparqljs.Triple["subject"], variablePrefix?: string }): readonly sparqljs.Triple[] {
        const subject = parameters?.subject ?? dataFactory.variable!("transformType");
        const variablePrefix = parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "transformType");
        return [...Enumerated_Value.sparqlConstructTemplateTriples({ ignoreRdfType: true, subject, variablePrefix }), ...(parameters?.ignoreRdfType ? [] : [{ subject, predicate: dataFactory.namedNode("http://www.w3.org/1999/02/22-rdf-syntax-ns#type"), object: dataFactory.variable!(`${variablePrefix}RdfType`) }])];
    }

    export function sparqlWherePatterns(parameters: { ignoreRdfType?: boolean; subject?: sparqljs.Triple["subject"], variablePrefix?: string }): readonly sparqljs.Pattern[] {
        const subject = parameters?.subject ?? dataFactory.variable!("transformType");
        const variablePrefix = parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "transformType");
        return [...Enumerated_Value.sparqlWherePatterns({ ignoreRdfType: true, subject, variablePrefix }), ...(parameters?.ignoreRdfType ? [] : [{ triples: [{ subject, predicate: dataFactory.namedNode("http://www.w3.org/1999/02/22-rdf-syntax-ns#type"), object: dataFactory.namedNode("http://qudt.org/schema/qudt/TransformType") }], type: "bgp" as const }, { triples: [{ subject, predicate: dataFactory.namedNode("http://www.w3.org/1999/02/22-rdf-syntax-ns#type"), object: dataFactory.variable!(`${variablePrefix}RdfType`) }], type: "bgp" as const }])];
    }
}
/**
 * System of Units
 */
export class System_of$W$Units extends QUDT_Concept {
    override readonly type = "System_of$W$Units";
    readonly qudt_SystemOfUnits$j$applicablePhysicalConstant: readonly ((rdfjs.BlankNode | rdfjs.NamedNode | rdfjs.Literal))[];
    readonly qudt_SystemOfUnits$j$hasAllowedUnit: readonly (Abstract_Unit)[];
    readonly qudt_SystemOfUnits$j$hasBaseUnit: readonly (Abstract_Unit)[];
    readonly qudt_SystemOfUnits$j$hasCoherentUnit: readonly (Abstract_Unit)[];
    readonly qudt_SystemOfUnits$j$hasDefinedUnit: readonly (Abstract_Unit)[];
    readonly qudt_SystemOfUnits$j$hasDerivedCoherentUnit: readonly (Abstract_Unit)[];
    readonly qudt_SystemOfUnits$j$hasDerivedUnit: readonly (Abstract_Unit)[];
    readonly qudt_SystemOfUnits$j$hasUnit: readonly (Abstract_Unit)[];
    readonly qudt_SystemOfUnits$j$prefix: readonly (Prefix)[];

    constructor(parameters: { readonly identifier?: (rdfjs.BlankNode | rdfjs.NamedNode) | string, readonly qudt_SystemOfUnits$j$applicablePhysicalConstant?: readonly ((rdfjs.BlankNode | rdfjs.NamedNode | rdfjs.Literal))[], readonly qudt_SystemOfUnits$j$hasAllowedUnit?: readonly (Abstract_Unit)[], readonly qudt_SystemOfUnits$j$hasBaseUnit?: readonly (Abstract_Unit)[], readonly qudt_SystemOfUnits$j$hasCoherentUnit?: readonly (Abstract_Unit)[], readonly qudt_SystemOfUnits$j$hasDefinedUnit?: readonly (Abstract_Unit)[], readonly qudt_SystemOfUnits$j$hasDerivedCoherentUnit?: readonly (Abstract_Unit)[], readonly qudt_SystemOfUnits$j$hasDerivedUnit?: readonly (Abstract_Unit)[], readonly qudt_SystemOfUnits$j$hasUnit?: readonly (Abstract_Unit)[], readonly qudt_SystemOfUnits$j$prefix?: readonly (Prefix)[] } & ConstructorParameters<typeof QUDT_Concept>[0]) {
        super(parameters);
        if (typeof parameters.qudt_SystemOfUnits$j$applicablePhysicalConstant === "undefined") { this.qudt_SystemOfUnits$j$applicablePhysicalConstant = []; } else if (Array.isArray(parameters.qudt_SystemOfUnits$j$applicablePhysicalConstant)) { this.qudt_SystemOfUnits$j$applicablePhysicalConstant = parameters.qudt_SystemOfUnits$j$applicablePhysicalConstant; } else { this.qudt_SystemOfUnits$j$applicablePhysicalConstant =( parameters.qudt_SystemOfUnits$j$applicablePhysicalConstant) as never;
         }

        if (typeof parameters.qudt_SystemOfUnits$j$hasAllowedUnit === "undefined") { this.qudt_SystemOfUnits$j$hasAllowedUnit = []; } else if (Array.isArray(parameters.qudt_SystemOfUnits$j$hasAllowedUnit)) { this.qudt_SystemOfUnits$j$hasAllowedUnit = parameters.qudt_SystemOfUnits$j$hasAllowedUnit; } else { this.qudt_SystemOfUnits$j$hasAllowedUnit =( parameters.qudt_SystemOfUnits$j$hasAllowedUnit) as never;
         }

        if (typeof parameters.qudt_SystemOfUnits$j$hasBaseUnit === "undefined") { this.qudt_SystemOfUnits$j$hasBaseUnit = []; } else if (Array.isArray(parameters.qudt_SystemOfUnits$j$hasBaseUnit)) { this.qudt_SystemOfUnits$j$hasBaseUnit = parameters.qudt_SystemOfUnits$j$hasBaseUnit; } else { this.qudt_SystemOfUnits$j$hasBaseUnit =( parameters.qudt_SystemOfUnits$j$hasBaseUnit) as never;
         }

        if (typeof parameters.qudt_SystemOfUnits$j$hasCoherentUnit === "undefined") { this.qudt_SystemOfUnits$j$hasCoherentUnit = []; } else if (Array.isArray(parameters.qudt_SystemOfUnits$j$hasCoherentUnit)) { this.qudt_SystemOfUnits$j$hasCoherentUnit = parameters.qudt_SystemOfUnits$j$hasCoherentUnit; } else { this.qudt_SystemOfUnits$j$hasCoherentUnit =( parameters.qudt_SystemOfUnits$j$hasCoherentUnit) as never;
         }

        if (typeof parameters.qudt_SystemOfUnits$j$hasDefinedUnit === "undefined") { this.qudt_SystemOfUnits$j$hasDefinedUnit = []; } else if (Array.isArray(parameters.qudt_SystemOfUnits$j$hasDefinedUnit)) { this.qudt_SystemOfUnits$j$hasDefinedUnit = parameters.qudt_SystemOfUnits$j$hasDefinedUnit; } else { this.qudt_SystemOfUnits$j$hasDefinedUnit =( parameters.qudt_SystemOfUnits$j$hasDefinedUnit) as never;
         }

        if (typeof parameters.qudt_SystemOfUnits$j$hasDerivedCoherentUnit === "undefined") { this.qudt_SystemOfUnits$j$hasDerivedCoherentUnit = []; } else if (Array.isArray(parameters.qudt_SystemOfUnits$j$hasDerivedCoherentUnit)) { this.qudt_SystemOfUnits$j$hasDerivedCoherentUnit = parameters.qudt_SystemOfUnits$j$hasDerivedCoherentUnit; } else { this.qudt_SystemOfUnits$j$hasDerivedCoherentUnit =( parameters.qudt_SystemOfUnits$j$hasDerivedCoherentUnit) as never;
         }

        if (typeof parameters.qudt_SystemOfUnits$j$hasDerivedUnit === "undefined") { this.qudt_SystemOfUnits$j$hasDerivedUnit = []; } else if (Array.isArray(parameters.qudt_SystemOfUnits$j$hasDerivedUnit)) { this.qudt_SystemOfUnits$j$hasDerivedUnit = parameters.qudt_SystemOfUnits$j$hasDerivedUnit; } else { this.qudt_SystemOfUnits$j$hasDerivedUnit =( parameters.qudt_SystemOfUnits$j$hasDerivedUnit) as never;
         }

        if (typeof parameters.qudt_SystemOfUnits$j$hasUnit === "undefined") { this.qudt_SystemOfUnits$j$hasUnit = []; } else if (Array.isArray(parameters.qudt_SystemOfUnits$j$hasUnit)) { this.qudt_SystemOfUnits$j$hasUnit = parameters.qudt_SystemOfUnits$j$hasUnit; } else { this.qudt_SystemOfUnits$j$hasUnit =( parameters.qudt_SystemOfUnits$j$hasUnit) as never;
         }

        if (typeof parameters.qudt_SystemOfUnits$j$prefix === "undefined") { this.qudt_SystemOfUnits$j$prefix = []; } else if (Array.isArray(parameters.qudt_SystemOfUnits$j$prefix)) { this.qudt_SystemOfUnits$j$prefix = parameters.qudt_SystemOfUnits$j$prefix; } else { this.qudt_SystemOfUnits$j$prefix =( parameters.qudt_SystemOfUnits$j$prefix) as never;
         }
    }

    override get identifier(): (rdfjs.BlankNode | rdfjs.NamedNode) {
        if (typeof this._identifier === "undefined") { this._identifier = dataFactory.blankNode(); } return this._identifier;
    }

    override equals(other: System_of$W$Units): EqualsResult {
        return super.equals(other).chain(() => (((left, right) => arrayEquals(left, right, booleanEquals)))(this.qudt_SystemOfUnits$j$applicablePhysicalConstant, other.qudt_SystemOfUnits$j$applicablePhysicalConstant).mapLeft(propertyValuesUnequal => ({ left: this, right: other, propertyName: "qudt_SystemOfUnits$j$applicablePhysicalConstant", propertyValuesUnequal, type: "Property" as const }))).chain(() => (((left, right) => arrayEquals(left, right, ((left, right) => left.equals(right)))))(this.qudt_SystemOfUnits$j$hasAllowedUnit, other.qudt_SystemOfUnits$j$hasAllowedUnit).mapLeft(propertyValuesUnequal => ({ left: this, right: other, propertyName: "qudt_SystemOfUnits$j$hasAllowedUnit", propertyValuesUnequal, type: "Property" as const }))).chain(() => (((left, right) => arrayEquals(left, right, ((left, right) => left.equals(right)))))(this.qudt_SystemOfUnits$j$hasBaseUnit, other.qudt_SystemOfUnits$j$hasBaseUnit).mapLeft(propertyValuesUnequal => ({ left: this, right: other, propertyName: "qudt_SystemOfUnits$j$hasBaseUnit", propertyValuesUnequal, type: "Property" as const }))).chain(() => (((left, right) => arrayEquals(left, right, ((left, right) => left.equals(right)))))(this.qudt_SystemOfUnits$j$hasCoherentUnit, other.qudt_SystemOfUnits$j$hasCoherentUnit).mapLeft(propertyValuesUnequal => ({ left: this, right: other, propertyName: "qudt_SystemOfUnits$j$hasCoherentUnit", propertyValuesUnequal, type: "Property" as const }))).chain(() => (((left, right) => arrayEquals(left, right, ((left, right) => left.equals(right)))))(this.qudt_SystemOfUnits$j$hasDefinedUnit, other.qudt_SystemOfUnits$j$hasDefinedUnit).mapLeft(propertyValuesUnequal => ({ left: this, right: other, propertyName: "qudt_SystemOfUnits$j$hasDefinedUnit", propertyValuesUnequal, type: "Property" as const }))).chain(() => (((left, right) => arrayEquals(left, right, ((left, right) => left.equals(right)))))(this.qudt_SystemOfUnits$j$hasDerivedCoherentUnit, other.qudt_SystemOfUnits$j$hasDerivedCoherentUnit).mapLeft(propertyValuesUnequal => ({ left: this, right: other, propertyName: "qudt_SystemOfUnits$j$hasDerivedCoherentUnit", propertyValuesUnequal, type: "Property" as const }))).chain(() => (((left, right) => arrayEquals(left, right, ((left, right) => left.equals(right)))))(this.qudt_SystemOfUnits$j$hasDerivedUnit, other.qudt_SystemOfUnits$j$hasDerivedUnit).mapLeft(propertyValuesUnequal => ({ left: this, right: other, propertyName: "qudt_SystemOfUnits$j$hasDerivedUnit", propertyValuesUnequal, type: "Property" as const }))).chain(() => (((left, right) => arrayEquals(left, right, ((left, right) => left.equals(right)))))(this.qudt_SystemOfUnits$j$hasUnit, other.qudt_SystemOfUnits$j$hasUnit).mapLeft(propertyValuesUnequal => ({ left: this, right: other, propertyName: "qudt_SystemOfUnits$j$hasUnit", propertyValuesUnequal, type: "Property" as const }))).chain(() => (((left, right) => arrayEquals(left, right, ((left, right) => left.equals(right)))))(this.qudt_SystemOfUnits$j$prefix, other.qudt_SystemOfUnits$j$prefix).mapLeft(propertyValuesUnequal => ({ left: this, right: other, propertyName: "qudt_SystemOfUnits$j$prefix", propertyValuesUnequal, type: "Property" as const })));
    }

    override hash<HasherT extends { update: (message: string | number[] | ArrayBuffer | Uint8Array) => void; }>(_hasher: HasherT): HasherT {
        this.hashShaclProperties(_hasher);
        return _hasher;
    }

    protected override hashShaclProperties<HasherT extends { update: (message: string | number[] | ArrayBuffer | Uint8Array) => void; }>(_hasher: HasherT): HasherT {
        super.hashShaclProperties(_hasher);
        for (const _item0 of this.qudt_SystemOfUnits$j$applicablePhysicalConstant) { _hasher.update(_item0.termType);
        _hasher.update(_item0.value); }

        for (const _item0 of this.qudt_SystemOfUnits$j$hasAllowedUnit) { _item0.hash(_hasher); }

        for (const _item0 of this.qudt_SystemOfUnits$j$hasBaseUnit) { _item0.hash(_hasher); }

        for (const _item0 of this.qudt_SystemOfUnits$j$hasCoherentUnit) { _item0.hash(_hasher); }

        for (const _item0 of this.qudt_SystemOfUnits$j$hasDefinedUnit) { _item0.hash(_hasher); }

        for (const _item0 of this.qudt_SystemOfUnits$j$hasDerivedCoherentUnit) { _item0.hash(_hasher); }

        for (const _item0 of this.qudt_SystemOfUnits$j$hasDerivedUnit) { _item0.hash(_hasher); }

        for (const _item0 of this.qudt_SystemOfUnits$j$hasUnit) { _item0.hash(_hasher); }

        for (const _item0 of this.qudt_SystemOfUnits$j$prefix) { _item0.hash(_hasher); }

        return _hasher;
    }

    override toJson(): { readonly "qudt_SystemOfUnits$j$applicablePhysicalConstant": readonly ({ readonly "@id": string, readonly termType: "BlankNode" | "NamedNode" } | { readonly "@language": string | undefined, readonly "@type": string | undefined, readonly "@value": string, readonly termType: "Literal" })[]; readonly "qudt_SystemOfUnits$j$hasAllowedUnit": readonly (ReturnType<Abstract_Unit["toJson"]>)[]; readonly "qudt_SystemOfUnits$j$hasBaseUnit": readonly (ReturnType<Abstract_Unit["toJson"]>)[]; readonly "qudt_SystemOfUnits$j$hasCoherentUnit": readonly (ReturnType<Abstract_Unit["toJson"]>)[]; readonly "qudt_SystemOfUnits$j$hasDefinedUnit": readonly (ReturnType<Abstract_Unit["toJson"]>)[]; readonly "qudt_SystemOfUnits$j$hasDerivedCoherentUnit": readonly (ReturnType<Abstract_Unit["toJson"]>)[]; readonly "qudt_SystemOfUnits$j$hasDerivedUnit": readonly (ReturnType<Abstract_Unit["toJson"]>)[]; readonly "qudt_SystemOfUnits$j$hasUnit": readonly (ReturnType<Abstract_Unit["toJson"]>)[]; readonly "qudt_SystemOfUnits$j$prefix": readonly (ReturnType<Prefix["toJson"]>)[] } & ReturnType<QUDT_Concept["toJson"]> {
        return JSON.parse(JSON.stringify({ ...super.toJson(),qudt_SystemOfUnits$j$applicablePhysicalConstant: this.qudt_SystemOfUnits$j$applicablePhysicalConstant.map(_item => ((_item.termType === "Literal") ? { "@language": _item.language.length > 0 ? _item.language : undefined, "@type": _item.datatype.value !== "http://www.w3.org/2001/XMLSchema#string" ? _item.datatype.value : undefined, "@value": _item.value, termType: "Literal" as const } : (_item.termType === "NamedNode") ? { "@id": _item.value, termType: "NamedNode" as const } : { "@id": `_:${_item.value}`, termType: "BlankNode" as const })),qudt_SystemOfUnits$j$hasAllowedUnit: this.qudt_SystemOfUnits$j$hasAllowedUnit.map(_item => (_item.toJson())),qudt_SystemOfUnits$j$hasBaseUnit: this.qudt_SystemOfUnits$j$hasBaseUnit.map(_item => (_item.toJson())),qudt_SystemOfUnits$j$hasCoherentUnit: this.qudt_SystemOfUnits$j$hasCoherentUnit.map(_item => (_item.toJson())),qudt_SystemOfUnits$j$hasDefinedUnit: this.qudt_SystemOfUnits$j$hasDefinedUnit.map(_item => (_item.toJson())),qudt_SystemOfUnits$j$hasDerivedCoherentUnit: this.qudt_SystemOfUnits$j$hasDerivedCoherentUnit.map(_item => (_item.toJson())),qudt_SystemOfUnits$j$hasDerivedUnit: this.qudt_SystemOfUnits$j$hasDerivedUnit.map(_item => (_item.toJson())),qudt_SystemOfUnits$j$hasUnit: this.qudt_SystemOfUnits$j$hasUnit.map(_item => (_item.toJson())),qudt_SystemOfUnits$j$prefix: this.qudt_SystemOfUnits$j$prefix.map(_item => (_item.toJson())) } satisfies ReturnType<System_of$W$Units["toJson"]>));
    }

    override toRdf({ ignoreRdfType, mutateGraph, resourceSet }: { ignoreRdfType?: boolean; mutateGraph?: rdfjsResource.MutableResource.MutateGraph, resourceSet: rdfjsResource.MutableResourceSet }): rdfjsResource.MutableResource {
        const _resource = super.toRdf({ ignoreRdfType: true, mutateGraph, resourceSet });
        if (!ignoreRdfType) { _resource.add(_resource.dataFactory.namedNode("http://www.w3.org/1999/02/22-rdf-syntax-ns#type"), _resource.dataFactory.namedNode("http://qudt.org/schema/qudt/SystemOfUnits")); }

        _resource.add(dataFactory.namedNode("http://qudt.org/schema/qudt/applicablePhysicalConstant"), this.qudt_SystemOfUnits$j$applicablePhysicalConstant.map((_item) => _item));
        _resource.add(dataFactory.namedNode("http://qudt.org/schema/qudt/hasAllowedUnit"), this.qudt_SystemOfUnits$j$hasAllowedUnit.map((_item) => _item.toRdf({ mutateGraph: mutateGraph, resourceSet: resourceSet })));
        _resource.add(dataFactory.namedNode("http://qudt.org/schema/qudt/hasBaseUnit"), this.qudt_SystemOfUnits$j$hasBaseUnit.map((_item) => _item.toRdf({ mutateGraph: mutateGraph, resourceSet: resourceSet })));
        _resource.add(dataFactory.namedNode("http://qudt.org/schema/qudt/hasCoherentUnit"), this.qudt_SystemOfUnits$j$hasCoherentUnit.map((_item) => _item.toRdf({ mutateGraph: mutateGraph, resourceSet: resourceSet })));
        _resource.add(dataFactory.namedNode("http://qudt.org/schema/qudt/hasDefinedUnit"), this.qudt_SystemOfUnits$j$hasDefinedUnit.map((_item) => _item.toRdf({ mutateGraph: mutateGraph, resourceSet: resourceSet })));
        _resource.add(dataFactory.namedNode("http://qudt.org/schema/qudt/hasDerivedCoherentUnit"), this.qudt_SystemOfUnits$j$hasDerivedCoherentUnit.map((_item) => _item.toRdf({ mutateGraph: mutateGraph, resourceSet: resourceSet })));
        _resource.add(dataFactory.namedNode("http://qudt.org/schema/qudt/hasDerivedUnit"), this.qudt_SystemOfUnits$j$hasDerivedUnit.map((_item) => _item.toRdf({ mutateGraph: mutateGraph, resourceSet: resourceSet })));
        _resource.add(dataFactory.namedNode("http://qudt.org/schema/qudt/hasUnit"), this.qudt_SystemOfUnits$j$hasUnit.map((_item) => _item.toRdf({ mutateGraph: mutateGraph, resourceSet: resourceSet })));
        _resource.add(dataFactory.namedNode("http://qudt.org/schema/qudt/prefix"), this.qudt_SystemOfUnits$j$prefix.map((_item) => _item.toRdf({ mutateGraph: mutateGraph, resourceSet: resourceSet })));
        return _resource;
    }

    override toString(): string {
        return JSON.stringify(this.toJson());
    }
}

export namespace System_of$W$Units {
    export function _propertiesFromJson(_json: unknown): purify.Either<zod.ZodError, { identifier: (rdfjs.BlankNode | rdfjs.NamedNode); qudt_SystemOfUnits$j$applicablePhysicalConstant: readonly ((rdfjs.BlankNode | rdfjs.NamedNode | rdfjs.Literal))[]; qudt_SystemOfUnits$j$hasAllowedUnit: readonly (Abstract_Unit)[]; qudt_SystemOfUnits$j$hasBaseUnit: readonly (Abstract_Unit)[]; qudt_SystemOfUnits$j$hasCoherentUnit: readonly (Abstract_Unit)[]; qudt_SystemOfUnits$j$hasDefinedUnit: readonly (Abstract_Unit)[]; qudt_SystemOfUnits$j$hasDerivedCoherentUnit: readonly (Abstract_Unit)[]; qudt_SystemOfUnits$j$hasDerivedUnit: readonly (Abstract_Unit)[]; qudt_SystemOfUnits$j$hasUnit: readonly (Abstract_Unit)[]; qudt_SystemOfUnits$j$prefix: readonly (Prefix)[]; } & UnwrapR<ReturnType<typeof QUDT_Concept._propertiesFromJson>>> {
        const _jsonSafeParseResult = systemOfWUnitsJsonZodSchema().safeParse(_json);
        if (!_jsonSafeParseResult.success) { return purify.Left(_jsonSafeParseResult.error); }

        const _jsonObject = _jsonSafeParseResult.data;
        const _super0Either = QUDT_Concept._propertiesFromJson(_jsonObject);
        if (_super0Either.isLeft()) { return _super0Either; }

        const _super0 = _super0Either.unsafeCoerce()
        const identifier = (_jsonObject["@id"].startsWith("_:") ? dataFactory.blankNode(_jsonObject["@id"].substring(2)) : dataFactory.namedNode(_jsonObject["@id"]));
        const qudt_SystemOfUnits$j$applicablePhysicalConstant = _jsonObject["qudt_SystemOfUnits$j$applicablePhysicalConstant"].map(_item => (((_item.termType === "Literal") ? (dataFactory.literal(_item["@value"], typeof _item["@language"] !== "undefined" ? _item["@language"] : (typeof _item["@type"] !== "undefined" ? dataFactory.namedNode(_item["@type"]) : undefined))) : (((_item.termType === "NamedNode") ? (dataFactory.namedNode(_item["@id"])) : (dataFactory.blankNode(_item["@id"].substring(2))))))));
        const qudt_SystemOfUnits$j$hasAllowedUnit = _jsonObject["qudt_SystemOfUnits$j$hasAllowedUnit"].map(_item => (Abstract_Unit.fromJson(_item).unsafeCoerce()));
        const qudt_SystemOfUnits$j$hasBaseUnit = _jsonObject["qudt_SystemOfUnits$j$hasBaseUnit"].map(_item => (Abstract_Unit.fromJson(_item).unsafeCoerce()));
        const qudt_SystemOfUnits$j$hasCoherentUnit = _jsonObject["qudt_SystemOfUnits$j$hasCoherentUnit"].map(_item => (Abstract_Unit.fromJson(_item).unsafeCoerce()));
        const qudt_SystemOfUnits$j$hasDefinedUnit = _jsonObject["qudt_SystemOfUnits$j$hasDefinedUnit"].map(_item => (Abstract_Unit.fromJson(_item).unsafeCoerce()));
        const qudt_SystemOfUnits$j$hasDerivedCoherentUnit = _jsonObject["qudt_SystemOfUnits$j$hasDerivedCoherentUnit"].map(_item => (Abstract_Unit.fromJson(_item).unsafeCoerce()));
        const qudt_SystemOfUnits$j$hasDerivedUnit = _jsonObject["qudt_SystemOfUnits$j$hasDerivedUnit"].map(_item => (Abstract_Unit.fromJson(_item).unsafeCoerce()));
        const qudt_SystemOfUnits$j$hasUnit = _jsonObject["qudt_SystemOfUnits$j$hasUnit"].map(_item => (Abstract_Unit.fromJson(_item).unsafeCoerce()));
        const qudt_SystemOfUnits$j$prefix = _jsonObject["qudt_SystemOfUnits$j$prefix"].map(_item => (Prefix.fromJson(_item).unsafeCoerce()));
        return purify.Either.of({ ..._super0, identifier, qudt_SystemOfUnits$j$applicablePhysicalConstant, qudt_SystemOfUnits$j$hasAllowedUnit, qudt_SystemOfUnits$j$hasBaseUnit, qudt_SystemOfUnits$j$hasCoherentUnit, qudt_SystemOfUnits$j$hasDefinedUnit, qudt_SystemOfUnits$j$hasDerivedCoherentUnit, qudt_SystemOfUnits$j$hasDerivedUnit, qudt_SystemOfUnits$j$hasUnit, qudt_SystemOfUnits$j$prefix })
    }

    export function fromJson(json: unknown): purify.Either<zod.ZodError, System_of$W$Units> {
        return System_of$W$Units._propertiesFromJson(json).map(properties => new System_of$W$Units(properties));
    }

    export function _propertiesFromRdf({ ignoreRdfType: _ignoreRdfType, languageIn: _languageIn, resource: _resource,
        // @ts-ignore
        ..._context }: { [_index: string]: any; ignoreRdfType?: boolean; languageIn?: readonly string[]; resource: rdfjsResource.Resource; }): purify.Either<rdfjsResource.Resource.ValueError, { identifier: (rdfjs.BlankNode | rdfjs.NamedNode); qudt_SystemOfUnits$j$applicablePhysicalConstant: readonly ((rdfjs.BlankNode | rdfjs.NamedNode | rdfjs.Literal))[]; qudt_SystemOfUnits$j$hasAllowedUnit: readonly (Abstract_Unit)[]; qudt_SystemOfUnits$j$hasBaseUnit: readonly (Abstract_Unit)[]; qudt_SystemOfUnits$j$hasCoherentUnit: readonly (Abstract_Unit)[]; qudt_SystemOfUnits$j$hasDefinedUnit: readonly (Abstract_Unit)[]; qudt_SystemOfUnits$j$hasDerivedCoherentUnit: readonly (Abstract_Unit)[]; qudt_SystemOfUnits$j$hasDerivedUnit: readonly (Abstract_Unit)[]; qudt_SystemOfUnits$j$hasUnit: readonly (Abstract_Unit)[]; qudt_SystemOfUnits$j$prefix: readonly (Prefix)[]; } & UnwrapR<ReturnType<typeof QUDT_Concept._propertiesFromRdf>>> {
        const _super0Either = QUDT_Concept._propertiesFromRdf({ ..._context, ignoreRdfType: true, languageIn: _languageIn, resource: _resource });
        if (_super0Either.isLeft()) { return _super0Either; }

        const _super0 = _super0Either.unsafeCoerce()
        if (!_ignoreRdfType && !_resource.isInstanceOf(dataFactory.namedNode("http://qudt.org/schema/qudt/SystemOfUnits"))) { return purify.Left(new rdfjsResource.Resource.ValueError({ focusResource: _resource, message: `${rdfjsResource.Resource.Identifier.toString(_resource.identifier)} has unexpected RDF type (expected http://qudt.org/schema/qudt/SystemOfUnits)`, predicate: dataFactory.namedNode("http://qudt.org/schema/qudt/SystemOfUnits") })); }

        const identifier = _resource.identifier
        const _qudt_SystemOfUnits$j$applicablePhysicalConstantEither: purify.Either<rdfjsResource.Resource.ValueError, readonly ((rdfjs.BlankNode | rdfjs.NamedNode | rdfjs.Literal))[]> = purify.Either.of([..._resource.values(dataFactory.namedNode("http://qudt.org/schema/qudt/applicablePhysicalConstant"), { unique: true }).flatMap(_item => _item.toValues().head().chain(_value => purify.Either.of(_value.toTerm())).toMaybe().toList())]);
        if (_qudt_SystemOfUnits$j$applicablePhysicalConstantEither.isLeft()) { return _qudt_SystemOfUnits$j$applicablePhysicalConstantEither; }

        const qudt_SystemOfUnits$j$applicablePhysicalConstant = _qudt_SystemOfUnits$j$applicablePhysicalConstantEither.unsafeCoerce();
        const _qudt_SystemOfUnits$j$hasAllowedUnitEither: purify.Either<rdfjsResource.Resource.ValueError, readonly (Abstract_Unit)[]> = purify.Either.of([..._resource.values(dataFactory.namedNode("http://qudt.org/schema/qudt/hasAllowedUnit"), { unique: true }).flatMap(_item => _item.toValues().head().chain(value => value.toResource()).chain(_resource => Abstract_Unit.fromRdf({ ..._context, ignoreRdfType: true, languageIn: _languageIn, resource: _resource })).toMaybe().toList())]);
        if (_qudt_SystemOfUnits$j$hasAllowedUnitEither.isLeft()) { return _qudt_SystemOfUnits$j$hasAllowedUnitEither; }

        const qudt_SystemOfUnits$j$hasAllowedUnit = _qudt_SystemOfUnits$j$hasAllowedUnitEither.unsafeCoerce();
        const _qudt_SystemOfUnits$j$hasBaseUnitEither: purify.Either<rdfjsResource.Resource.ValueError, readonly (Abstract_Unit)[]> = purify.Either.of([..._resource.values(dataFactory.namedNode("http://qudt.org/schema/qudt/hasBaseUnit"), { unique: true }).flatMap(_item => _item.toValues().head().chain(value => value.toResource()).chain(_resource => Abstract_Unit.fromRdf({ ..._context, ignoreRdfType: true, languageIn: _languageIn, resource: _resource })).toMaybe().toList())]);
        if (_qudt_SystemOfUnits$j$hasBaseUnitEither.isLeft()) { return _qudt_SystemOfUnits$j$hasBaseUnitEither; }

        const qudt_SystemOfUnits$j$hasBaseUnit = _qudt_SystemOfUnits$j$hasBaseUnitEither.unsafeCoerce();
        const _qudt_SystemOfUnits$j$hasCoherentUnitEither: purify.Either<rdfjsResource.Resource.ValueError, readonly (Abstract_Unit)[]> = purify.Either.of([..._resource.values(dataFactory.namedNode("http://qudt.org/schema/qudt/hasCoherentUnit"), { unique: true }).flatMap(_item => _item.toValues().head().chain(value => value.toResource()).chain(_resource => Abstract_Unit.fromRdf({ ..._context, ignoreRdfType: true, languageIn: _languageIn, resource: _resource })).toMaybe().toList())]);
        if (_qudt_SystemOfUnits$j$hasCoherentUnitEither.isLeft()) { return _qudt_SystemOfUnits$j$hasCoherentUnitEither; }

        const qudt_SystemOfUnits$j$hasCoherentUnit = _qudt_SystemOfUnits$j$hasCoherentUnitEither.unsafeCoerce();
        const _qudt_SystemOfUnits$j$hasDefinedUnitEither: purify.Either<rdfjsResource.Resource.ValueError, readonly (Abstract_Unit)[]> = purify.Either.of([..._resource.values(dataFactory.namedNode("http://qudt.org/schema/qudt/hasDefinedUnit"), { unique: true }).flatMap(_item => _item.toValues().head().chain(value => value.toResource()).chain(_resource => Abstract_Unit.fromRdf({ ..._context, ignoreRdfType: true, languageIn: _languageIn, resource: _resource })).toMaybe().toList())]);
        if (_qudt_SystemOfUnits$j$hasDefinedUnitEither.isLeft()) { return _qudt_SystemOfUnits$j$hasDefinedUnitEither; }

        const qudt_SystemOfUnits$j$hasDefinedUnit = _qudt_SystemOfUnits$j$hasDefinedUnitEither.unsafeCoerce();
        const _qudt_SystemOfUnits$j$hasDerivedCoherentUnitEither: purify.Either<rdfjsResource.Resource.ValueError, readonly (Abstract_Unit)[]> = purify.Either.of([..._resource.values(dataFactory.namedNode("http://qudt.org/schema/qudt/hasDerivedCoherentUnit"), { unique: true }).flatMap(_item => _item.toValues().head().chain(value => value.toResource()).chain(_resource => Abstract_Unit.fromRdf({ ..._context, ignoreRdfType: true, languageIn: _languageIn, resource: _resource })).toMaybe().toList())]);
        if (_qudt_SystemOfUnits$j$hasDerivedCoherentUnitEither.isLeft()) { return _qudt_SystemOfUnits$j$hasDerivedCoherentUnitEither; }

        const qudt_SystemOfUnits$j$hasDerivedCoherentUnit = _qudt_SystemOfUnits$j$hasDerivedCoherentUnitEither.unsafeCoerce();
        const _qudt_SystemOfUnits$j$hasDerivedUnitEither: purify.Either<rdfjsResource.Resource.ValueError, readonly (Abstract_Unit)[]> = purify.Either.of([..._resource.values(dataFactory.namedNode("http://qudt.org/schema/qudt/hasDerivedUnit"), { unique: true }).flatMap(_item => _item.toValues().head().chain(value => value.toResource()).chain(_resource => Abstract_Unit.fromRdf({ ..._context, ignoreRdfType: true, languageIn: _languageIn, resource: _resource })).toMaybe().toList())]);
        if (_qudt_SystemOfUnits$j$hasDerivedUnitEither.isLeft()) { return _qudt_SystemOfUnits$j$hasDerivedUnitEither; }

        const qudt_SystemOfUnits$j$hasDerivedUnit = _qudt_SystemOfUnits$j$hasDerivedUnitEither.unsafeCoerce();
        const _qudt_SystemOfUnits$j$hasUnitEither: purify.Either<rdfjsResource.Resource.ValueError, readonly (Abstract_Unit)[]> = purify.Either.of([..._resource.values(dataFactory.namedNode("http://qudt.org/schema/qudt/hasUnit"), { unique: true }).flatMap(_item => _item.toValues().head().chain(value => value.toResource()).chain(_resource => Abstract_Unit.fromRdf({ ..._context, ignoreRdfType: true, languageIn: _languageIn, resource: _resource })).toMaybe().toList())]);
        if (_qudt_SystemOfUnits$j$hasUnitEither.isLeft()) { return _qudt_SystemOfUnits$j$hasUnitEither; }

        const qudt_SystemOfUnits$j$hasUnit = _qudt_SystemOfUnits$j$hasUnitEither.unsafeCoerce();
        const _qudt_SystemOfUnits$j$prefixEither: purify.Either<rdfjsResource.Resource.ValueError, readonly (Prefix)[]> = purify.Either.of([..._resource.values(dataFactory.namedNode("http://qudt.org/schema/qudt/prefix"), { unique: true }).flatMap(_item => _item.toValues().head().chain(value => value.toResource()).chain(_resource => Prefix.fromRdf({ ..._context, ignoreRdfType: true, languageIn: _languageIn, resource: _resource })).toMaybe().toList())]);
        if (_qudt_SystemOfUnits$j$prefixEither.isLeft()) { return _qudt_SystemOfUnits$j$prefixEither; }

        const qudt_SystemOfUnits$j$prefix = _qudt_SystemOfUnits$j$prefixEither.unsafeCoerce();
        return purify.Either.of({ ..._super0, identifier, qudt_SystemOfUnits$j$applicablePhysicalConstant, qudt_SystemOfUnits$j$hasAllowedUnit, qudt_SystemOfUnits$j$hasBaseUnit, qudt_SystemOfUnits$j$hasCoherentUnit, qudt_SystemOfUnits$j$hasDefinedUnit, qudt_SystemOfUnits$j$hasDerivedCoherentUnit, qudt_SystemOfUnits$j$hasDerivedUnit, qudt_SystemOfUnits$j$hasUnit, qudt_SystemOfUnits$j$prefix })
    }

    export function fromRdf(parameters: Parameters<typeof System_of$W$Units._propertiesFromRdf>[0]): purify.Either<rdfjsResource.Resource.ValueError, System_of$W$Units> {
        return System_of$W$Units._propertiesFromRdf(parameters).map(properties => new System_of$W$Units(properties));
    }

    export let fromRdfType: rdfjs.NamedNode<string> = dataFactory.namedNode("http://qudt.org/schema/qudt/SystemOfUnits");

    export function jsonSchema() {
        return zodToJsonSchema(systemOfWUnitsJsonZodSchema());
    }

    export function systemOfWUnitsJsonUiSchema(parameters?: { scopePrefix?: string }) {
        const scopePrefix = parameters?.scopePrefix ?? "#";
        return { "elements": [ QUDT_Concept.qudtConceptJsonUiSchema({ scopePrefix }), { scope: `${scopePrefix}/properties/qudt_SystemOfUnits$j$applicablePhysicalConstant`, type: "Control" }, Abstract_Unit.abstractUnitJsonUiSchema({ scopePrefix: `${scopePrefix}/properties/qudt_SystemOfUnits$j$hasAllowedUnit` }), Abstract_Unit.abstractUnitJsonUiSchema({ scopePrefix: `${scopePrefix}/properties/qudt_SystemOfUnits$j$hasBaseUnit` }), Abstract_Unit.abstractUnitJsonUiSchema({ scopePrefix: `${scopePrefix}/properties/qudt_SystemOfUnits$j$hasCoherentUnit` }), Abstract_Unit.abstractUnitJsonUiSchema({ scopePrefix: `${scopePrefix}/properties/qudt_SystemOfUnits$j$hasDefinedUnit` }), Abstract_Unit.abstractUnitJsonUiSchema({ scopePrefix: `${scopePrefix}/properties/qudt_SystemOfUnits$j$hasDerivedCoherentUnit` }), Abstract_Unit.abstractUnitJsonUiSchema({ scopePrefix: `${scopePrefix}/properties/qudt_SystemOfUnits$j$hasDerivedUnit` }), Abstract_Unit.abstractUnitJsonUiSchema({ scopePrefix: `${scopePrefix}/properties/qudt_SystemOfUnits$j$hasUnit` }), Prefix.prefixJsonUiSchema({ scopePrefix: `${scopePrefix}/properties/qudt_SystemOfUnits$j$prefix` }) ], label: "System of Units", type: "Group" }
    }

    export function systemOfWUnitsJsonZodSchema() {
        return QUDT_Concept.qudtConceptJsonZodSchema().merge(zod.object({ "@id": zod.string().min(1),"type": zod.literal("System_of$W$Units"),"qudt_SystemOfUnits$j$applicablePhysicalConstant": zod.discriminatedUnion("termType", [zod.object({ "@id": zod.string().min(1), termType: zod.literal("BlankNode") }), zod.object({ "@id": zod.string().min(1), termType: zod.literal("NamedNode") }), zod.object({ "@language": zod.string().optional(), "@type": zod.string().optional(), "@value": zod.string(), termType: zod.literal("Literal") })]).array(),"qudt_SystemOfUnits$j$hasAllowedUnit": Abstract_Unit.abstractUnitJsonZodSchema().array(),"qudt_SystemOfUnits$j$hasBaseUnit": Abstract_Unit.abstractUnitJsonZodSchema().array(),"qudt_SystemOfUnits$j$hasCoherentUnit": Abstract_Unit.abstractUnitJsonZodSchema().array(),"qudt_SystemOfUnits$j$hasDefinedUnit": Abstract_Unit.abstractUnitJsonZodSchema().array(),"qudt_SystemOfUnits$j$hasDerivedCoherentUnit": Abstract_Unit.abstractUnitJsonZodSchema().array(),"qudt_SystemOfUnits$j$hasDerivedUnit": Abstract_Unit.abstractUnitJsonZodSchema().array(),"qudt_SystemOfUnits$j$hasUnit": Abstract_Unit.abstractUnitJsonZodSchema().array(),"qudt_SystemOfUnits$j$prefix": Prefix.prefixJsonZodSchema().array() }));
    }

    export function sparqlConstructQuery(parameters?: { ignoreRdfType?: boolean; prefixes?: { [prefix: string]: string }; subject?: sparqljs.Triple["subject"]; } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type">): sparqljs.ConstructQuery {
        const { ignoreRdfType, subject, ...queryParameters } = parameters ?? {}

        return { ...queryParameters, prefixes: parameters?.prefixes ?? {}, queryType: "CONSTRUCT", template: (queryParameters.template ?? []).concat(System_of$W$Units.sparqlConstructTemplateTriples({ ignoreRdfType, subject })), type: "query", where: (queryParameters.where ?? []).concat(System_of$W$Units.sparqlWherePatterns({ ignoreRdfType, subject })) };
    }

    export function sparqlConstructQueryString(parameters?: { ignoreRdfType?: boolean; subject?: sparqljs.Triple["subject"]; variablePrefix?: string; } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type"> & sparqljs.GeneratorOptions): string {
        return new sparqljs.Generator(parameters).stringify(System_of$W$Units.sparqlConstructQuery(parameters));
    }

    export function sparqlConstructTemplateTriples(parameters?: { ignoreRdfType?: boolean; subject?: sparqljs.Triple["subject"], variablePrefix?: string }): readonly sparqljs.Triple[] {
        const subject = parameters?.subject ?? dataFactory.variable!("systemOfWUnits");
        const variablePrefix = parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "systemOfWUnits");
        return [...QUDT_Concept.sparqlConstructTemplateTriples({ ignoreRdfType: true, subject, variablePrefix }), ...(parameters?.ignoreRdfType ? [] : [{ subject, predicate: dataFactory.namedNode("http://www.w3.org/1999/02/22-rdf-syntax-ns#type"), object: dataFactory.variable!(`${variablePrefix}RdfType`) }]), { object: dataFactory.variable!(`${variablePrefix}QudtSystemOfUnitsJApplicablePhysicalConstant`), predicate: dataFactory.namedNode("http://qudt.org/schema/qudt/applicablePhysicalConstant"), subject }, { object: dataFactory.variable!(`${variablePrefix}QudtSystemOfUnitsJHasAllowedUnit`), predicate: dataFactory.namedNode("http://qudt.org/schema/qudt/hasAllowedUnit"), subject }, ...Abstract_Unit.sparqlConstructTemplateTriples({ ignoreRdfType: true, subject: dataFactory.variable!(`${variablePrefix}QudtSystemOfUnitsJHasAllowedUnit`), variablePrefix: `${variablePrefix}QudtSystemOfUnitsJHasAllowedUnit` }), { object: dataFactory.variable!(`${variablePrefix}QudtSystemOfUnitsJHasBaseUnit`), predicate: dataFactory.namedNode("http://qudt.org/schema/qudt/hasBaseUnit"), subject }, ...Abstract_Unit.sparqlConstructTemplateTriples({ ignoreRdfType: true, subject: dataFactory.variable!(`${variablePrefix}QudtSystemOfUnitsJHasBaseUnit`), variablePrefix: `${variablePrefix}QudtSystemOfUnitsJHasBaseUnit` }), { object: dataFactory.variable!(`${variablePrefix}QudtSystemOfUnitsJHasCoherentUnit`), predicate: dataFactory.namedNode("http://qudt.org/schema/qudt/hasCoherentUnit"), subject }, ...Abstract_Unit.sparqlConstructTemplateTriples({ ignoreRdfType: true, subject: dataFactory.variable!(`${variablePrefix}QudtSystemOfUnitsJHasCoherentUnit`), variablePrefix: `${variablePrefix}QudtSystemOfUnitsJHasCoherentUnit` }), { object: dataFactory.variable!(`${variablePrefix}QudtSystemOfUnitsJHasDefinedUnit`), predicate: dataFactory.namedNode("http://qudt.org/schema/qudt/hasDefinedUnit"), subject }, ...Abstract_Unit.sparqlConstructTemplateTriples({ ignoreRdfType: true, subject: dataFactory.variable!(`${variablePrefix}QudtSystemOfUnitsJHasDefinedUnit`), variablePrefix: `${variablePrefix}QudtSystemOfUnitsJHasDefinedUnit` }), { object: dataFactory.variable!(`${variablePrefix}QudtSystemOfUnitsJHasDerivedCoherentUnit`), predicate: dataFactory.namedNode("http://qudt.org/schema/qudt/hasDerivedCoherentUnit"), subject }, ...Abstract_Unit.sparqlConstructTemplateTriples({ ignoreRdfType: true, subject: dataFactory.variable!(`${variablePrefix}QudtSystemOfUnitsJHasDerivedCoherentUnit`), variablePrefix: `${variablePrefix}QudtSystemOfUnitsJHasDerivedCoherentUnit` }), { object: dataFactory.variable!(`${variablePrefix}QudtSystemOfUnitsJHasDerivedUnit`), predicate: dataFactory.namedNode("http://qudt.org/schema/qudt/hasDerivedUnit"), subject }, ...Abstract_Unit.sparqlConstructTemplateTriples({ ignoreRdfType: true, subject: dataFactory.variable!(`${variablePrefix}QudtSystemOfUnitsJHasDerivedUnit`), variablePrefix: `${variablePrefix}QudtSystemOfUnitsJHasDerivedUnit` }), { object: dataFactory.variable!(`${variablePrefix}QudtSystemOfUnitsJHasUnit`), predicate: dataFactory.namedNode("http://qudt.org/schema/qudt/hasUnit"), subject }, ...Abstract_Unit.sparqlConstructTemplateTriples({ ignoreRdfType: true, subject: dataFactory.variable!(`${variablePrefix}QudtSystemOfUnitsJHasUnit`), variablePrefix: `${variablePrefix}QudtSystemOfUnitsJHasUnit` }), { object: dataFactory.variable!(`${variablePrefix}QudtSystemOfUnitsJPrefix`), predicate: dataFactory.namedNode("http://qudt.org/schema/qudt/prefix"), subject }, ...Prefix.sparqlConstructTemplateTriples({ ignoreRdfType: true, subject: dataFactory.variable!(`${variablePrefix}QudtSystemOfUnitsJPrefix`), variablePrefix: `${variablePrefix}QudtSystemOfUnitsJPrefix` })];
    }

    export function sparqlWherePatterns(parameters: { ignoreRdfType?: boolean; subject?: sparqljs.Triple["subject"], variablePrefix?: string }): readonly sparqljs.Pattern[] {
        const subject = parameters?.subject ?? dataFactory.variable!("systemOfWUnits");
        const variablePrefix = parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "systemOfWUnits");
        return [...QUDT_Concept.sparqlWherePatterns({ ignoreRdfType: true, subject, variablePrefix }), ...(parameters?.ignoreRdfType ? [] : [{ triples: [{ subject, predicate: dataFactory.namedNode("http://www.w3.org/1999/02/22-rdf-syntax-ns#type"), object: dataFactory.namedNode("http://qudt.org/schema/qudt/SystemOfUnits") }], type: "bgp" as const }, { triples: [{ subject, predicate: dataFactory.namedNode("http://www.w3.org/1999/02/22-rdf-syntax-ns#type"), object: dataFactory.variable!(`${variablePrefix}RdfType`) }], type: "bgp" as const }]), { patterns: [{ triples: [{ object: dataFactory.variable!(`${variablePrefix}QudtSystemOfUnitsJApplicablePhysicalConstant`), predicate: dataFactory.namedNode("http://qudt.org/schema/qudt/applicablePhysicalConstant"), subject }], type: "bgp" }], type: "optional" }, { patterns: [{ triples: [{ object: dataFactory.variable!(`${variablePrefix}QudtSystemOfUnitsJHasAllowedUnit`), predicate: dataFactory.namedNode("http://qudt.org/schema/qudt/hasAllowedUnit"), subject }], type: "bgp" }, ...Abstract_Unit.sparqlWherePatterns({ ignoreRdfType: true, subject: dataFactory.variable!(`${variablePrefix}QudtSystemOfUnitsJHasAllowedUnit`), variablePrefix: `${variablePrefix}QudtSystemOfUnitsJHasAllowedUnit` })], type: "optional" }, { patterns: [{ triples: [{ object: dataFactory.variable!(`${variablePrefix}QudtSystemOfUnitsJHasBaseUnit`), predicate: dataFactory.namedNode("http://qudt.org/schema/qudt/hasBaseUnit"), subject }], type: "bgp" }, ...Abstract_Unit.sparqlWherePatterns({ ignoreRdfType: true, subject: dataFactory.variable!(`${variablePrefix}QudtSystemOfUnitsJHasBaseUnit`), variablePrefix: `${variablePrefix}QudtSystemOfUnitsJHasBaseUnit` })], type: "optional" }, { patterns: [{ triples: [{ object: dataFactory.variable!(`${variablePrefix}QudtSystemOfUnitsJHasCoherentUnit`), predicate: dataFactory.namedNode("http://qudt.org/schema/qudt/hasCoherentUnit"), subject }], type: "bgp" }, ...Abstract_Unit.sparqlWherePatterns({ ignoreRdfType: true, subject: dataFactory.variable!(`${variablePrefix}QudtSystemOfUnitsJHasCoherentUnit`), variablePrefix: `${variablePrefix}QudtSystemOfUnitsJHasCoherentUnit` })], type: "optional" }, { patterns: [{ triples: [{ object: dataFactory.variable!(`${variablePrefix}QudtSystemOfUnitsJHasDefinedUnit`), predicate: dataFactory.namedNode("http://qudt.org/schema/qudt/hasDefinedUnit"), subject }], type: "bgp" }, ...Abstract_Unit.sparqlWherePatterns({ ignoreRdfType: true, subject: dataFactory.variable!(`${variablePrefix}QudtSystemOfUnitsJHasDefinedUnit`), variablePrefix: `${variablePrefix}QudtSystemOfUnitsJHasDefinedUnit` })], type: "optional" }, { patterns: [{ triples: [{ object: dataFactory.variable!(`${variablePrefix}QudtSystemOfUnitsJHasDerivedCoherentUnit`), predicate: dataFactory.namedNode("http://qudt.org/schema/qudt/hasDerivedCoherentUnit"), subject }], type: "bgp" }, ...Abstract_Unit.sparqlWherePatterns({ ignoreRdfType: true, subject: dataFactory.variable!(`${variablePrefix}QudtSystemOfUnitsJHasDerivedCoherentUnit`), variablePrefix: `${variablePrefix}QudtSystemOfUnitsJHasDerivedCoherentUnit` })], type: "optional" }, { patterns: [{ triples: [{ object: dataFactory.variable!(`${variablePrefix}QudtSystemOfUnitsJHasDerivedUnit`), predicate: dataFactory.namedNode("http://qudt.org/schema/qudt/hasDerivedUnit"), subject }], type: "bgp" }, ...Abstract_Unit.sparqlWherePatterns({ ignoreRdfType: true, subject: dataFactory.variable!(`${variablePrefix}QudtSystemOfUnitsJHasDerivedUnit`), variablePrefix: `${variablePrefix}QudtSystemOfUnitsJHasDerivedUnit` })], type: "optional" }, { patterns: [{ triples: [{ object: dataFactory.variable!(`${variablePrefix}QudtSystemOfUnitsJHasUnit`), predicate: dataFactory.namedNode("http://qudt.org/schema/qudt/hasUnit"), subject }], type: "bgp" }, ...Abstract_Unit.sparqlWherePatterns({ ignoreRdfType: true, subject: dataFactory.variable!(`${variablePrefix}QudtSystemOfUnitsJHasUnit`), variablePrefix: `${variablePrefix}QudtSystemOfUnitsJHasUnit` })], type: "optional" }, { patterns: [{ triples: [{ object: dataFactory.variable!(`${variablePrefix}QudtSystemOfUnitsJPrefix`), predicate: dataFactory.namedNode("http://qudt.org/schema/qudt/prefix"), subject }], type: "bgp" }, ...Prefix.sparqlWherePatterns({ ignoreRdfType: true, subject: dataFactory.variable!(`${variablePrefix}QudtSystemOfUnitsJPrefix`), variablePrefix: `${variablePrefix}QudtSystemOfUnitsJPrefix` })], type: "optional" }];
    }
}
/**
 * System of Quantity Kinds
 */
export class System_of$W$Quantity$W$Kinds extends QUDT_Concept {
    override readonly type = "System_of$W$Quantity$W$Kinds";
    readonly qudt_SystemOfQuantityKinds$j$baseDimensionEnumeration: purify.Maybe<Enumeration>;
    readonly qudt_SystemOfQuantityKinds$j$hasBaseQuantityKind: readonly ((rdfjs.BlankNode | rdfjs.NamedNode | rdfjs.Literal))[];
    readonly qudt_SystemOfQuantityKinds$j$hasQuantityKind: readonly ((rdfjs.BlankNode | rdfjs.NamedNode | rdfjs.Literal))[];
    readonly qudt_SystemOfQuantityKinds$j$hasUnitSystem: purify.Maybe<System_of$W$Units>;
    readonly qudt_SystemOfQuantityKinds$j$systemDerivedQuantityKind: readonly ((rdfjs.BlankNode | rdfjs.NamedNode | rdfjs.Literal))[];

    constructor(parameters: { readonly identifier?: (rdfjs.BlankNode | rdfjs.NamedNode) | string, readonly qudt_SystemOfQuantityKinds$j$baseDimensionEnumeration?: Enumeration | purify.Maybe<Enumeration>, readonly qudt_SystemOfQuantityKinds$j$hasBaseQuantityKind?: readonly ((rdfjs.BlankNode | rdfjs.NamedNode | rdfjs.Literal))[], readonly qudt_SystemOfQuantityKinds$j$hasQuantityKind?: readonly ((rdfjs.BlankNode | rdfjs.NamedNode | rdfjs.Literal))[], readonly qudt_SystemOfQuantityKinds$j$hasUnitSystem?: System_of$W$Units | purify.Maybe<System_of$W$Units>, readonly qudt_SystemOfQuantityKinds$j$systemDerivedQuantityKind?: readonly ((rdfjs.BlankNode | rdfjs.NamedNode | rdfjs.Literal))[] } & ConstructorParameters<typeof QUDT_Concept>[0]) {
        super(parameters);
        if (purify.Maybe.isMaybe(parameters.qudt_SystemOfQuantityKinds$j$baseDimensionEnumeration)) { this.qudt_SystemOfQuantityKinds$j$baseDimensionEnumeration = parameters.qudt_SystemOfQuantityKinds$j$baseDimensionEnumeration; } else if (typeof parameters.qudt_SystemOfQuantityKinds$j$baseDimensionEnumeration === "object" && parameters.qudt_SystemOfQuantityKinds$j$baseDimensionEnumeration instanceof Enumeration) { this.qudt_SystemOfQuantityKinds$j$baseDimensionEnumeration = purify.Maybe.of(parameters.qudt_SystemOfQuantityKinds$j$baseDimensionEnumeration); } else if (typeof parameters.qudt_SystemOfQuantityKinds$j$baseDimensionEnumeration === "undefined") { this.qudt_SystemOfQuantityKinds$j$baseDimensionEnumeration = purify.Maybe.empty(); } else { this.qudt_SystemOfQuantityKinds$j$baseDimensionEnumeration =( parameters.qudt_SystemOfQuantityKinds$j$baseDimensionEnumeration) as never;
         }

        if (typeof parameters.qudt_SystemOfQuantityKinds$j$hasBaseQuantityKind === "undefined") { this.qudt_SystemOfQuantityKinds$j$hasBaseQuantityKind = []; } else if (Array.isArray(parameters.qudt_SystemOfQuantityKinds$j$hasBaseQuantityKind)) { this.qudt_SystemOfQuantityKinds$j$hasBaseQuantityKind = parameters.qudt_SystemOfQuantityKinds$j$hasBaseQuantityKind; } else { this.qudt_SystemOfQuantityKinds$j$hasBaseQuantityKind =( parameters.qudt_SystemOfQuantityKinds$j$hasBaseQuantityKind) as never;
         }

        if (typeof parameters.qudt_SystemOfQuantityKinds$j$hasQuantityKind === "undefined") { this.qudt_SystemOfQuantityKinds$j$hasQuantityKind = []; } else if (Array.isArray(parameters.qudt_SystemOfQuantityKinds$j$hasQuantityKind)) { this.qudt_SystemOfQuantityKinds$j$hasQuantityKind = parameters.qudt_SystemOfQuantityKinds$j$hasQuantityKind; } else { this.qudt_SystemOfQuantityKinds$j$hasQuantityKind =( parameters.qudt_SystemOfQuantityKinds$j$hasQuantityKind) as never;
         }

        if (purify.Maybe.isMaybe(parameters.qudt_SystemOfQuantityKinds$j$hasUnitSystem)) { this.qudt_SystemOfQuantityKinds$j$hasUnitSystem = parameters.qudt_SystemOfQuantityKinds$j$hasUnitSystem; } else if (typeof parameters.qudt_SystemOfQuantityKinds$j$hasUnitSystem === "object" && parameters.qudt_SystemOfQuantityKinds$j$hasUnitSystem instanceof System_of$W$Units) { this.qudt_SystemOfQuantityKinds$j$hasUnitSystem = purify.Maybe.of(parameters.qudt_SystemOfQuantityKinds$j$hasUnitSystem); } else if (typeof parameters.qudt_SystemOfQuantityKinds$j$hasUnitSystem === "undefined") { this.qudt_SystemOfQuantityKinds$j$hasUnitSystem = purify.Maybe.empty(); } else { this.qudt_SystemOfQuantityKinds$j$hasUnitSystem =( parameters.qudt_SystemOfQuantityKinds$j$hasUnitSystem) as never;
         }

        if (typeof parameters.qudt_SystemOfQuantityKinds$j$systemDerivedQuantityKind === "undefined") { this.qudt_SystemOfQuantityKinds$j$systemDerivedQuantityKind = []; } else if (Array.isArray(parameters.qudt_SystemOfQuantityKinds$j$systemDerivedQuantityKind)) { this.qudt_SystemOfQuantityKinds$j$systemDerivedQuantityKind = parameters.qudt_SystemOfQuantityKinds$j$systemDerivedQuantityKind; } else { this.qudt_SystemOfQuantityKinds$j$systemDerivedQuantityKind =( parameters.qudt_SystemOfQuantityKinds$j$systemDerivedQuantityKind) as never;
         }
    }

    override get identifier(): (rdfjs.BlankNode | rdfjs.NamedNode) {
        if (typeof this._identifier === "undefined") { this._identifier = dataFactory.blankNode(); } return this._identifier;
    }

    override equals(other: System_of$W$Quantity$W$Kinds): EqualsResult {
        return super.equals(other).chain(() => (((left, right) => maybeEquals(left, right, ((left, right) => left.equals(right)))))(this.qudt_SystemOfQuantityKinds$j$baseDimensionEnumeration, other.qudt_SystemOfQuantityKinds$j$baseDimensionEnumeration).mapLeft(propertyValuesUnequal => ({ left: this, right: other, propertyName: "qudt_SystemOfQuantityKinds$j$baseDimensionEnumeration", propertyValuesUnequal, type: "Property" as const }))).chain(() => (((left, right) => arrayEquals(left, right, booleanEquals)))(this.qudt_SystemOfQuantityKinds$j$hasBaseQuantityKind, other.qudt_SystemOfQuantityKinds$j$hasBaseQuantityKind).mapLeft(propertyValuesUnequal => ({ left: this, right: other, propertyName: "qudt_SystemOfQuantityKinds$j$hasBaseQuantityKind", propertyValuesUnequal, type: "Property" as const }))).chain(() => (((left, right) => arrayEquals(left, right, booleanEquals)))(this.qudt_SystemOfQuantityKinds$j$hasQuantityKind, other.qudt_SystemOfQuantityKinds$j$hasQuantityKind).mapLeft(propertyValuesUnequal => ({ left: this, right: other, propertyName: "qudt_SystemOfQuantityKinds$j$hasQuantityKind", propertyValuesUnequal, type: "Property" as const }))).chain(() => (((left, right) => maybeEquals(left, right, ((left, right) => left.equals(right)))))(this.qudt_SystemOfQuantityKinds$j$hasUnitSystem, other.qudt_SystemOfQuantityKinds$j$hasUnitSystem).mapLeft(propertyValuesUnequal => ({ left: this, right: other, propertyName: "qudt_SystemOfQuantityKinds$j$hasUnitSystem", propertyValuesUnequal, type: "Property" as const }))).chain(() => (((left, right) => arrayEquals(left, right, booleanEquals)))(this.qudt_SystemOfQuantityKinds$j$systemDerivedQuantityKind, other.qudt_SystemOfQuantityKinds$j$systemDerivedQuantityKind).mapLeft(propertyValuesUnequal => ({ left: this, right: other, propertyName: "qudt_SystemOfQuantityKinds$j$systemDerivedQuantityKind", propertyValuesUnequal, type: "Property" as const })));
    }

    override hash<HasherT extends { update: (message: string | number[] | ArrayBuffer | Uint8Array) => void; }>(_hasher: HasherT): HasherT {
        this.hashShaclProperties(_hasher);
        return _hasher;
    }

    protected override hashShaclProperties<HasherT extends { update: (message: string | number[] | ArrayBuffer | Uint8Array) => void; }>(_hasher: HasherT): HasherT {
        super.hashShaclProperties(_hasher);
        this.qudt_SystemOfQuantityKinds$j$baseDimensionEnumeration.ifJust((_value0) => { _value0.hash(_hasher); })
        for (const _item0 of this.qudt_SystemOfQuantityKinds$j$hasBaseQuantityKind) { _hasher.update(_item0.termType);
        _hasher.update(_item0.value); }

        for (const _item0 of this.qudt_SystemOfQuantityKinds$j$hasQuantityKind) { _hasher.update(_item0.termType);
        _hasher.update(_item0.value); }

        this.qudt_SystemOfQuantityKinds$j$hasUnitSystem.ifJust((_value0) => { _value0.hash(_hasher); })
        for (const _item0 of this.qudt_SystemOfQuantityKinds$j$systemDerivedQuantityKind) { _hasher.update(_item0.termType);
        _hasher.update(_item0.value); }

        return _hasher;
    }

    override toJson(): { readonly "qudt_SystemOfQuantityKinds$j$baseDimensionEnumeration": (ReturnType<Enumeration["toJson"]>) | undefined; readonly "qudt_SystemOfQuantityKinds$j$hasBaseQuantityKind": readonly ({ readonly "@id": string, readonly termType: "BlankNode" | "NamedNode" } | { readonly "@language": string | undefined, readonly "@type": string | undefined, readonly "@value": string, readonly termType: "Literal" })[]; readonly "qudt_SystemOfQuantityKinds$j$hasQuantityKind": readonly ({ readonly "@id": string, readonly termType: "BlankNode" | "NamedNode" } | { readonly "@language": string | undefined, readonly "@type": string | undefined, readonly "@value": string, readonly termType: "Literal" })[]; readonly "qudt_SystemOfQuantityKinds$j$hasUnitSystem": (ReturnType<System_of$W$Units["toJson"]>) | undefined; readonly "qudt_SystemOfQuantityKinds$j$systemDerivedQuantityKind": readonly ({ readonly "@id": string, readonly termType: "BlankNode" | "NamedNode" } | { readonly "@language": string | undefined, readonly "@type": string | undefined, readonly "@value": string, readonly termType: "Literal" })[] } & ReturnType<QUDT_Concept["toJson"]> {
        return JSON.parse(JSON.stringify({ ...super.toJson(),qudt_SystemOfQuantityKinds$j$baseDimensionEnumeration: this.qudt_SystemOfQuantityKinds$j$baseDimensionEnumeration.map(_item => (_item.toJson())).extract(),qudt_SystemOfQuantityKinds$j$hasBaseQuantityKind: this.qudt_SystemOfQuantityKinds$j$hasBaseQuantityKind.map(_item => ((_item.termType === "Literal") ? { "@language": _item.language.length > 0 ? _item.language : undefined, "@type": _item.datatype.value !== "http://www.w3.org/2001/XMLSchema#string" ? _item.datatype.value : undefined, "@value": _item.value, termType: "Literal" as const } : (_item.termType === "NamedNode") ? { "@id": _item.value, termType: "NamedNode" as const } : { "@id": `_:${_item.value}`, termType: "BlankNode" as const })),qudt_SystemOfQuantityKinds$j$hasQuantityKind: this.qudt_SystemOfQuantityKinds$j$hasQuantityKind.map(_item => ((_item.termType === "Literal") ? { "@language": _item.language.length > 0 ? _item.language : undefined, "@type": _item.datatype.value !== "http://www.w3.org/2001/XMLSchema#string" ? _item.datatype.value : undefined, "@value": _item.value, termType: "Literal" as const } : (_item.termType === "NamedNode") ? { "@id": _item.value, termType: "NamedNode" as const } : { "@id": `_:${_item.value}`, termType: "BlankNode" as const })),qudt_SystemOfQuantityKinds$j$hasUnitSystem: this.qudt_SystemOfQuantityKinds$j$hasUnitSystem.map(_item => (_item.toJson())).extract(),qudt_SystemOfQuantityKinds$j$systemDerivedQuantityKind: this.qudt_SystemOfQuantityKinds$j$systemDerivedQuantityKind.map(_item => ((_item.termType === "Literal") ? { "@language": _item.language.length > 0 ? _item.language : undefined, "@type": _item.datatype.value !== "http://www.w3.org/2001/XMLSchema#string" ? _item.datatype.value : undefined, "@value": _item.value, termType: "Literal" as const } : (_item.termType === "NamedNode") ? { "@id": _item.value, termType: "NamedNode" as const } : { "@id": `_:${_item.value}`, termType: "BlankNode" as const })) } satisfies ReturnType<System_of$W$Quantity$W$Kinds["toJson"]>));
    }

    override toRdf({ ignoreRdfType, mutateGraph, resourceSet }: { ignoreRdfType?: boolean; mutateGraph?: rdfjsResource.MutableResource.MutateGraph, resourceSet: rdfjsResource.MutableResourceSet }): rdfjsResource.MutableResource {
        const _resource = super.toRdf({ ignoreRdfType: true, mutateGraph, resourceSet });
        if (!ignoreRdfType) { _resource.add(_resource.dataFactory.namedNode("http://www.w3.org/1999/02/22-rdf-syntax-ns#type"), _resource.dataFactory.namedNode("http://qudt.org/schema/qudt/SystemOfQuantityKinds")); }

        _resource.add(dataFactory.namedNode("http://qudt.org/schema/qudt/baseDimensionEnumeration"), this.qudt_SystemOfQuantityKinds$j$baseDimensionEnumeration.map((_value) => _value.toRdf({ mutateGraph: mutateGraph, resourceSet: resourceSet })));
        _resource.add(dataFactory.namedNode("http://qudt.org/schema/qudt/hasBaseQuantityKind"), this.qudt_SystemOfQuantityKinds$j$hasBaseQuantityKind.map((_item) => _item));
        _resource.add(dataFactory.namedNode("http://qudt.org/schema/qudt/hasQuantityKind"), this.qudt_SystemOfQuantityKinds$j$hasQuantityKind.map((_item) => _item));
        _resource.add(dataFactory.namedNode("http://qudt.org/schema/qudt/hasUnitSystem"), this.qudt_SystemOfQuantityKinds$j$hasUnitSystem.map((_value) => _value.toRdf({ mutateGraph: mutateGraph, resourceSet: resourceSet })));
        _resource.add(dataFactory.namedNode("http://qudt.org/schema/qudt/systemDerivedQuantityKind"), this.qudt_SystemOfQuantityKinds$j$systemDerivedQuantityKind.map((_item) => _item));
        return _resource;
    }

    override toString(): string {
        return JSON.stringify(this.toJson());
    }
}

export namespace System_of$W$Quantity$W$Kinds {
    export function _propertiesFromJson(_json: unknown): purify.Either<zod.ZodError, { identifier: (rdfjs.BlankNode | rdfjs.NamedNode); qudt_SystemOfQuantityKinds$j$baseDimensionEnumeration: purify.Maybe<Enumeration>; qudt_SystemOfQuantityKinds$j$hasBaseQuantityKind: readonly ((rdfjs.BlankNode | rdfjs.NamedNode | rdfjs.Literal))[]; qudt_SystemOfQuantityKinds$j$hasQuantityKind: readonly ((rdfjs.BlankNode | rdfjs.NamedNode | rdfjs.Literal))[]; qudt_SystemOfQuantityKinds$j$hasUnitSystem: purify.Maybe<System_of$W$Units>; qudt_SystemOfQuantityKinds$j$systemDerivedQuantityKind: readonly ((rdfjs.BlankNode | rdfjs.NamedNode | rdfjs.Literal))[]; } & UnwrapR<ReturnType<typeof QUDT_Concept._propertiesFromJson>>> {
        const _jsonSafeParseResult = systemOfWQuantityWKindsJsonZodSchema().safeParse(_json);
        if (!_jsonSafeParseResult.success) { return purify.Left(_jsonSafeParseResult.error); }

        const _jsonObject = _jsonSafeParseResult.data;
        const _super0Either = QUDT_Concept._propertiesFromJson(_jsonObject);
        if (_super0Either.isLeft()) { return _super0Either; }

        const _super0 = _super0Either.unsafeCoerce()
        const identifier = (_jsonObject["@id"].startsWith("_:") ? dataFactory.blankNode(_jsonObject["@id"].substring(2)) : dataFactory.namedNode(_jsonObject["@id"]));
        const qudt_SystemOfQuantityKinds$j$baseDimensionEnumeration = purify.Maybe.fromNullable(_jsonObject["qudt_SystemOfQuantityKinds$j$baseDimensionEnumeration"]).map(_item => (Enumeration.fromJson(_item).unsafeCoerce()));
        const qudt_SystemOfQuantityKinds$j$hasBaseQuantityKind = _jsonObject["qudt_SystemOfQuantityKinds$j$hasBaseQuantityKind"].map(_item => (((_item.termType === "Literal") ? (dataFactory.literal(_item["@value"], typeof _item["@language"] !== "undefined" ? _item["@language"] : (typeof _item["@type"] !== "undefined" ? dataFactory.namedNode(_item["@type"]) : undefined))) : (((_item.termType === "NamedNode") ? (dataFactory.namedNode(_item["@id"])) : (dataFactory.blankNode(_item["@id"].substring(2))))))));
        const qudt_SystemOfQuantityKinds$j$hasQuantityKind = _jsonObject["qudt_SystemOfQuantityKinds$j$hasQuantityKind"].map(_item => (((_item.termType === "Literal") ? (dataFactory.literal(_item["@value"], typeof _item["@language"] !== "undefined" ? _item["@language"] : (typeof _item["@type"] !== "undefined" ? dataFactory.namedNode(_item["@type"]) : undefined))) : (((_item.termType === "NamedNode") ? (dataFactory.namedNode(_item["@id"])) : (dataFactory.blankNode(_item["@id"].substring(2))))))));
        const qudt_SystemOfQuantityKinds$j$hasUnitSystem = purify.Maybe.fromNullable(_jsonObject["qudt_SystemOfQuantityKinds$j$hasUnitSystem"]).map(_item => (System_of$W$Units.fromJson(_item).unsafeCoerce()));
        const qudt_SystemOfQuantityKinds$j$systemDerivedQuantityKind = _jsonObject["qudt_SystemOfQuantityKinds$j$systemDerivedQuantityKind"].map(_item => (((_item.termType === "Literal") ? (dataFactory.literal(_item["@value"], typeof _item["@language"] !== "undefined" ? _item["@language"] : (typeof _item["@type"] !== "undefined" ? dataFactory.namedNode(_item["@type"]) : undefined))) : (((_item.termType === "NamedNode") ? (dataFactory.namedNode(_item["@id"])) : (dataFactory.blankNode(_item["@id"].substring(2))))))));
        return purify.Either.of({ ..._super0, identifier, qudt_SystemOfQuantityKinds$j$baseDimensionEnumeration, qudt_SystemOfQuantityKinds$j$hasBaseQuantityKind, qudt_SystemOfQuantityKinds$j$hasQuantityKind, qudt_SystemOfQuantityKinds$j$hasUnitSystem, qudt_SystemOfQuantityKinds$j$systemDerivedQuantityKind })
    }

    export function fromJson(json: unknown): purify.Either<zod.ZodError, System_of$W$Quantity$W$Kinds> {
        return System_of$W$Quantity$W$Kinds._propertiesFromJson(json).map(properties => new System_of$W$Quantity$W$Kinds(properties));
    }

    export function _propertiesFromRdf({ ignoreRdfType: _ignoreRdfType, languageIn: _languageIn, resource: _resource,
        // @ts-ignore
        ..._context }: { [_index: string]: any; ignoreRdfType?: boolean; languageIn?: readonly string[]; resource: rdfjsResource.Resource; }): purify.Either<rdfjsResource.Resource.ValueError, { identifier: (rdfjs.BlankNode | rdfjs.NamedNode); qudt_SystemOfQuantityKinds$j$baseDimensionEnumeration: purify.Maybe<Enumeration>; qudt_SystemOfQuantityKinds$j$hasBaseQuantityKind: readonly ((rdfjs.BlankNode | rdfjs.NamedNode | rdfjs.Literal))[]; qudt_SystemOfQuantityKinds$j$hasQuantityKind: readonly ((rdfjs.BlankNode | rdfjs.NamedNode | rdfjs.Literal))[]; qudt_SystemOfQuantityKinds$j$hasUnitSystem: purify.Maybe<System_of$W$Units>; qudt_SystemOfQuantityKinds$j$systemDerivedQuantityKind: readonly ((rdfjs.BlankNode | rdfjs.NamedNode | rdfjs.Literal))[]; } & UnwrapR<ReturnType<typeof QUDT_Concept._propertiesFromRdf>>> {
        const _super0Either = QUDT_Concept._propertiesFromRdf({ ..._context, ignoreRdfType: true, languageIn: _languageIn, resource: _resource });
        if (_super0Either.isLeft()) { return _super0Either; }

        const _super0 = _super0Either.unsafeCoerce()
        if (!_ignoreRdfType && !_resource.isInstanceOf(dataFactory.namedNode("http://qudt.org/schema/qudt/SystemOfQuantityKinds"))) { return purify.Left(new rdfjsResource.Resource.ValueError({ focusResource: _resource, message: `${rdfjsResource.Resource.Identifier.toString(_resource.identifier)} has unexpected RDF type (expected http://qudt.org/schema/qudt/SystemOfQuantityKinds)`, predicate: dataFactory.namedNode("http://qudt.org/schema/qudt/SystemOfQuantityKinds") })); }

        const identifier = _resource.identifier
        const _qudt_SystemOfQuantityKinds$j$baseDimensionEnumerationEither: purify.Either<rdfjsResource.Resource.ValueError, purify.Maybe<Enumeration>> = purify.Either.of(_resource.values(dataFactory.namedNode("http://qudt.org/schema/qudt/baseDimensionEnumeration"), { unique: true }).head().chain(value => value.toResource()).chain(_resource => Enumeration.fromRdf({ ..._context, ignoreRdfType: true, languageIn: _languageIn, resource: _resource })).toMaybe());
        if (_qudt_SystemOfQuantityKinds$j$baseDimensionEnumerationEither.isLeft()) { return _qudt_SystemOfQuantityKinds$j$baseDimensionEnumerationEither; }

        const qudt_SystemOfQuantityKinds$j$baseDimensionEnumeration = _qudt_SystemOfQuantityKinds$j$baseDimensionEnumerationEither.unsafeCoerce();
        const _qudt_SystemOfQuantityKinds$j$hasBaseQuantityKindEither: purify.Either<rdfjsResource.Resource.ValueError, readonly ((rdfjs.BlankNode | rdfjs.NamedNode | rdfjs.Literal))[]> = purify.Either.of([..._resource.values(dataFactory.namedNode("http://qudt.org/schema/qudt/hasBaseQuantityKind"), { unique: true }).flatMap(_item => _item.toValues().head().chain(_value => purify.Either.of(_value.toTerm())).toMaybe().toList())]);
        if (_qudt_SystemOfQuantityKinds$j$hasBaseQuantityKindEither.isLeft()) { return _qudt_SystemOfQuantityKinds$j$hasBaseQuantityKindEither; }

        const qudt_SystemOfQuantityKinds$j$hasBaseQuantityKind = _qudt_SystemOfQuantityKinds$j$hasBaseQuantityKindEither.unsafeCoerce();
        const _qudt_SystemOfQuantityKinds$j$hasQuantityKindEither: purify.Either<rdfjsResource.Resource.ValueError, readonly ((rdfjs.BlankNode | rdfjs.NamedNode | rdfjs.Literal))[]> = purify.Either.of([..._resource.values(dataFactory.namedNode("http://qudt.org/schema/qudt/hasQuantityKind"), { unique: true }).flatMap(_item => _item.toValues().head().chain(_value => purify.Either.of(_value.toTerm())).toMaybe().toList())]);
        if (_qudt_SystemOfQuantityKinds$j$hasQuantityKindEither.isLeft()) { return _qudt_SystemOfQuantityKinds$j$hasQuantityKindEither; }

        const qudt_SystemOfQuantityKinds$j$hasQuantityKind = _qudt_SystemOfQuantityKinds$j$hasQuantityKindEither.unsafeCoerce();
        const _qudt_SystemOfQuantityKinds$j$hasUnitSystemEither: purify.Either<rdfjsResource.Resource.ValueError, purify.Maybe<System_of$W$Units>> = purify.Either.of(_resource.values(dataFactory.namedNode("http://qudt.org/schema/qudt/hasUnitSystem"), { unique: true }).head().chain(value => value.toResource()).chain(_resource => System_of$W$Units.fromRdf({ ..._context, ignoreRdfType: true, languageIn: _languageIn, resource: _resource })).toMaybe());
        if (_qudt_SystemOfQuantityKinds$j$hasUnitSystemEither.isLeft()) { return _qudt_SystemOfQuantityKinds$j$hasUnitSystemEither; }

        const qudt_SystemOfQuantityKinds$j$hasUnitSystem = _qudt_SystemOfQuantityKinds$j$hasUnitSystemEither.unsafeCoerce();
        const _qudt_SystemOfQuantityKinds$j$systemDerivedQuantityKindEither: purify.Either<rdfjsResource.Resource.ValueError, readonly ((rdfjs.BlankNode | rdfjs.NamedNode | rdfjs.Literal))[]> = purify.Either.of([..._resource.values(dataFactory.namedNode("http://qudt.org/schema/qudt/systemDerivedQuantityKind"), { unique: true }).flatMap(_item => _item.toValues().head().chain(_value => purify.Either.of(_value.toTerm())).toMaybe().toList())]);
        if (_qudt_SystemOfQuantityKinds$j$systemDerivedQuantityKindEither.isLeft()) { return _qudt_SystemOfQuantityKinds$j$systemDerivedQuantityKindEither; }

        const qudt_SystemOfQuantityKinds$j$systemDerivedQuantityKind = _qudt_SystemOfQuantityKinds$j$systemDerivedQuantityKindEither.unsafeCoerce();
        return purify.Either.of({ ..._super0, identifier, qudt_SystemOfQuantityKinds$j$baseDimensionEnumeration, qudt_SystemOfQuantityKinds$j$hasBaseQuantityKind, qudt_SystemOfQuantityKinds$j$hasQuantityKind, qudt_SystemOfQuantityKinds$j$hasUnitSystem, qudt_SystemOfQuantityKinds$j$systemDerivedQuantityKind })
    }

    export function fromRdf(parameters: Parameters<typeof System_of$W$Quantity$W$Kinds._propertiesFromRdf>[0]): purify.Either<rdfjsResource.Resource.ValueError, System_of$W$Quantity$W$Kinds> {
        return System_of$W$Quantity$W$Kinds._propertiesFromRdf(parameters).map(properties => new System_of$W$Quantity$W$Kinds(properties));
    }

    export let fromRdfType: rdfjs.NamedNode<string> = dataFactory.namedNode("http://qudt.org/schema/qudt/SystemOfQuantityKinds");

    export function jsonSchema() {
        return zodToJsonSchema(systemOfWQuantityWKindsJsonZodSchema());
    }

    export function systemOfWQuantityWKindsJsonUiSchema(parameters?: { scopePrefix?: string }) {
        const scopePrefix = parameters?.scopePrefix ?? "#";
        return { "elements": [ QUDT_Concept.qudtConceptJsonUiSchema({ scopePrefix }), Enumeration.enumerationJsonUiSchema({ scopePrefix: `${scopePrefix}/properties/qudt_SystemOfQuantityKinds$j$baseDimensionEnumeration` }), { scope: `${scopePrefix}/properties/qudt_SystemOfQuantityKinds$j$hasBaseQuantityKind`, type: "Control" }, { scope: `${scopePrefix}/properties/qudt_SystemOfQuantityKinds$j$hasQuantityKind`, type: "Control" }, System_of$W$Units.systemOfWUnitsJsonUiSchema({ scopePrefix: `${scopePrefix}/properties/qudt_SystemOfQuantityKinds$j$hasUnitSystem` }), { scope: `${scopePrefix}/properties/qudt_SystemOfQuantityKinds$j$systemDerivedQuantityKind`, type: "Control" } ], label: "System of Quantity Kinds", type: "Group" }
    }

    export function systemOfWQuantityWKindsJsonZodSchema() {
        return QUDT_Concept.qudtConceptJsonZodSchema().merge(zod.object({ "@id": zod.string().min(1),"type": zod.literal("System_of$W$Quantity$W$Kinds"),"qudt_SystemOfQuantityKinds$j$baseDimensionEnumeration": Enumeration.enumerationJsonZodSchema().optional(),"qudt_SystemOfQuantityKinds$j$hasBaseQuantityKind": zod.discriminatedUnion("termType", [zod.object({ "@id": zod.string().min(1), termType: zod.literal("BlankNode") }), zod.object({ "@id": zod.string().min(1), termType: zod.literal("NamedNode") }), zod.object({ "@language": zod.string().optional(), "@type": zod.string().optional(), "@value": zod.string(), termType: zod.literal("Literal") })]).array(),"qudt_SystemOfQuantityKinds$j$hasQuantityKind": zod.discriminatedUnion("termType", [zod.object({ "@id": zod.string().min(1), termType: zod.literal("BlankNode") }), zod.object({ "@id": zod.string().min(1), termType: zod.literal("NamedNode") }), zod.object({ "@language": zod.string().optional(), "@type": zod.string().optional(), "@value": zod.string(), termType: zod.literal("Literal") })]).array(),"qudt_SystemOfQuantityKinds$j$hasUnitSystem": System_of$W$Units.systemOfWUnitsJsonZodSchema().optional(),"qudt_SystemOfQuantityKinds$j$systemDerivedQuantityKind": zod.discriminatedUnion("termType", [zod.object({ "@id": zod.string().min(1), termType: zod.literal("BlankNode") }), zod.object({ "@id": zod.string().min(1), termType: zod.literal("NamedNode") }), zod.object({ "@language": zod.string().optional(), "@type": zod.string().optional(), "@value": zod.string(), termType: zod.literal("Literal") })]).array() }));
    }

    export function sparqlConstructQuery(parameters?: { ignoreRdfType?: boolean; prefixes?: { [prefix: string]: string }; subject?: sparqljs.Triple["subject"]; } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type">): sparqljs.ConstructQuery {
        const { ignoreRdfType, subject, ...queryParameters } = parameters ?? {}

        return { ...queryParameters, prefixes: parameters?.prefixes ?? {}, queryType: "CONSTRUCT", template: (queryParameters.template ?? []).concat(System_of$W$Quantity$W$Kinds.sparqlConstructTemplateTriples({ ignoreRdfType, subject })), type: "query", where: (queryParameters.where ?? []).concat(System_of$W$Quantity$W$Kinds.sparqlWherePatterns({ ignoreRdfType, subject })) };
    }

    export function sparqlConstructQueryString(parameters?: { ignoreRdfType?: boolean; subject?: sparqljs.Triple["subject"]; variablePrefix?: string; } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type"> & sparqljs.GeneratorOptions): string {
        return new sparqljs.Generator(parameters).stringify(System_of$W$Quantity$W$Kinds.sparqlConstructQuery(parameters));
    }

    export function sparqlConstructTemplateTriples(parameters?: { ignoreRdfType?: boolean; subject?: sparqljs.Triple["subject"], variablePrefix?: string }): readonly sparqljs.Triple[] {
        const subject = parameters?.subject ?? dataFactory.variable!("systemOfWQuantityWKinds");
        const variablePrefix = parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "systemOfWQuantityWKinds");
        return [...QUDT_Concept.sparqlConstructTemplateTriples({ ignoreRdfType: true, subject, variablePrefix }), ...(parameters?.ignoreRdfType ? [] : [{ subject, predicate: dataFactory.namedNode("http://www.w3.org/1999/02/22-rdf-syntax-ns#type"), object: dataFactory.variable!(`${variablePrefix}RdfType`) }]), { object: dataFactory.variable!(`${variablePrefix}QudtSystemOfQuantityKindsJBaseDimensionEnumeration`), predicate: dataFactory.namedNode("http://qudt.org/schema/qudt/baseDimensionEnumeration"), subject }, ...Enumeration.sparqlConstructTemplateTriples({ ignoreRdfType: true, subject: dataFactory.variable!(`${variablePrefix}QudtSystemOfQuantityKindsJBaseDimensionEnumeration`), variablePrefix: `${variablePrefix}QudtSystemOfQuantityKindsJBaseDimensionEnumeration` }), { object: dataFactory.variable!(`${variablePrefix}QudtSystemOfQuantityKindsJHasBaseQuantityKind`), predicate: dataFactory.namedNode("http://qudt.org/schema/qudt/hasBaseQuantityKind"), subject }, { object: dataFactory.variable!(`${variablePrefix}QudtSystemOfQuantityKindsJHasQuantityKind`), predicate: dataFactory.namedNode("http://qudt.org/schema/qudt/hasQuantityKind"), subject }, { object: dataFactory.variable!(`${variablePrefix}QudtSystemOfQuantityKindsJHasUnitSystem`), predicate: dataFactory.namedNode("http://qudt.org/schema/qudt/hasUnitSystem"), subject }, ...System_of$W$Units.sparqlConstructTemplateTriples({ ignoreRdfType: true, subject: dataFactory.variable!(`${variablePrefix}QudtSystemOfQuantityKindsJHasUnitSystem`), variablePrefix: `${variablePrefix}QudtSystemOfQuantityKindsJHasUnitSystem` }), { object: dataFactory.variable!(`${variablePrefix}QudtSystemOfQuantityKindsJSystemDerivedQuantityKind`), predicate: dataFactory.namedNode("http://qudt.org/schema/qudt/systemDerivedQuantityKind"), subject }];
    }

    export function sparqlWherePatterns(parameters: { ignoreRdfType?: boolean; subject?: sparqljs.Triple["subject"], variablePrefix?: string }): readonly sparqljs.Pattern[] {
        const subject = parameters?.subject ?? dataFactory.variable!("systemOfWQuantityWKinds");
        const variablePrefix = parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "systemOfWQuantityWKinds");
        return [...QUDT_Concept.sparqlWherePatterns({ ignoreRdfType: true, subject, variablePrefix }), ...(parameters?.ignoreRdfType ? [] : [{ triples: [{ subject, predicate: dataFactory.namedNode("http://www.w3.org/1999/02/22-rdf-syntax-ns#type"), object: dataFactory.namedNode("http://qudt.org/schema/qudt/SystemOfQuantityKinds") }], type: "bgp" as const }, { triples: [{ subject, predicate: dataFactory.namedNode("http://www.w3.org/1999/02/22-rdf-syntax-ns#type"), object: dataFactory.variable!(`${variablePrefix}RdfType`) }], type: "bgp" as const }]), { patterns: [{ triples: [{ object: dataFactory.variable!(`${variablePrefix}QudtSystemOfQuantityKindsJBaseDimensionEnumeration`), predicate: dataFactory.namedNode("http://qudt.org/schema/qudt/baseDimensionEnumeration"), subject }], type: "bgp" }, ...Enumeration.sparqlWherePatterns({ ignoreRdfType: true, subject: dataFactory.variable!(`${variablePrefix}QudtSystemOfQuantityKindsJBaseDimensionEnumeration`), variablePrefix: `${variablePrefix}QudtSystemOfQuantityKindsJBaseDimensionEnumeration` })], type: "optional" }, { patterns: [{ triples: [{ object: dataFactory.variable!(`${variablePrefix}QudtSystemOfQuantityKindsJHasBaseQuantityKind`), predicate: dataFactory.namedNode("http://qudt.org/schema/qudt/hasBaseQuantityKind"), subject }], type: "bgp" }], type: "optional" }, { patterns: [{ triples: [{ object: dataFactory.variable!(`${variablePrefix}QudtSystemOfQuantityKindsJHasQuantityKind`), predicate: dataFactory.namedNode("http://qudt.org/schema/qudt/hasQuantityKind"), subject }], type: "bgp" }], type: "optional" }, { patterns: [{ triples: [{ object: dataFactory.variable!(`${variablePrefix}QudtSystemOfQuantityKindsJHasUnitSystem`), predicate: dataFactory.namedNode("http://qudt.org/schema/qudt/hasUnitSystem"), subject }], type: "bgp" }, ...System_of$W$Units.sparqlWherePatterns({ ignoreRdfType: true, subject: dataFactory.variable!(`${variablePrefix}QudtSystemOfQuantityKindsJHasUnitSystem`), variablePrefix: `${variablePrefix}QudtSystemOfQuantityKindsJHasUnitSystem` })], type: "optional" }, { patterns: [{ triples: [{ object: dataFactory.variable!(`${variablePrefix}QudtSystemOfQuantityKindsJSystemDerivedQuantityKind`), predicate: dataFactory.namedNode("http://qudt.org/schema/qudt/systemDerivedQuantityKind"), subject }], type: "bgp" }], type: "optional" }];
    }
}
/**
 * A `SymmetricRelation` is modeling construct used to define symmetric behavior for appropriate relations.
 */
export class Symmetric_relation {
    private _identifier: (rdfjs.BlankNode | rdfjs.NamedNode) | undefined;
    readonly type = "Symmetric_relation";

    constructor(parameters: { readonly identifier?: (rdfjs.BlankNode | rdfjs.NamedNode) | string }) {
        if (typeof parameters.identifier === "object") { this._identifier = parameters.identifier; } else if (typeof parameters.identifier === "string") { this._identifier = dataFactory.namedNode(parameters.identifier); } else if (typeof parameters.identifier === "undefined") { } else { this._identifier =( parameters.identifier) as never;
         }
    }

    get identifier(): (rdfjs.BlankNode | rdfjs.NamedNode) {
        if (typeof this._identifier === "undefined") { this._identifier = dataFactory.blankNode(); } return this._identifier;
    }

    equals(other: Symmetric_relation): EqualsResult {
        return (booleanEquals)(this.identifier, other.identifier).mapLeft(propertyValuesUnequal => ({ left: this, right: other, propertyName: "identifier", propertyValuesUnequal, type: "Property" as const })).chain(() => (strictEquals)(this.type, other.type).mapLeft(propertyValuesUnequal => ({ left: this, right: other, propertyName: "type", propertyValuesUnequal, type: "Property" as const })));
    }

    hash<HasherT extends { update: (message: string | number[] | ArrayBuffer | Uint8Array) => void; }>(_hasher: HasherT): HasherT {
        _hasher.update(this.identifier.value);
        _hasher.update(this.type);
        this.hashShaclProperties(_hasher);
        return _hasher;
    }

    protected hashShaclProperties<HasherT extends { update: (message: string | number[] | ArrayBuffer | Uint8Array) => void; }>(_hasher: HasherT): HasherT {
        return _hasher;
    }

    toJson(): { readonly "@id": string; readonly "type": "Symmetric_relation" } {
        return JSON.parse(JSON.stringify({ "@id": this.identifier.termType === "BlankNode" ? `_:${this.identifier.value}` : this.identifier.value,type: this.type } satisfies ReturnType<Symmetric_relation["toJson"]>));
    }

    toRdf({ ignoreRdfType, mutateGraph, resourceSet }: { ignoreRdfType?: boolean; mutateGraph?: rdfjsResource.MutableResource.MutateGraph, resourceSet: rdfjsResource.MutableResourceSet }): rdfjsResource.MutableResource {
        const _resource = resourceSet.mutableResource(this.identifier, { mutateGraph });
        if (!ignoreRdfType) { _resource.add(_resource.dataFactory.namedNode("http://www.w3.org/1999/02/22-rdf-syntax-ns#type"), _resource.dataFactory.namedNode("http://qudt.org/schema/qudt/SymmetricRelation")); }

        return _resource;
    }

    toString(): string {
        return JSON.stringify(this.toJson());
    }
}

export namespace Symmetric_relation {
    export function _propertiesFromJson(_json: unknown): purify.Either<zod.ZodError, { identifier: (rdfjs.BlankNode | rdfjs.NamedNode); }> {
        const _jsonSafeParseResult = jsonZodSchema().safeParse(_json);
        if (!_jsonSafeParseResult.success) { return purify.Left(_jsonSafeParseResult.error); }

        const _jsonObject = _jsonSafeParseResult.data;
        const identifier = (_jsonObject["@id"].startsWith("_:") ? dataFactory.blankNode(_jsonObject["@id"].substring(2)) : dataFactory.namedNode(_jsonObject["@id"]));
        return purify.Either.of({ identifier })
    }

    export function fromJson(json: unknown): purify.Either<zod.ZodError, Symmetric_relation> {
        return Symmetric_relation._propertiesFromJson(json).map(properties => new Symmetric_relation(properties));
    }

    export function _propertiesFromRdf({ ignoreRdfType: _ignoreRdfType, languageIn: _languageIn, resource: _resource,
        // @ts-ignore
        ..._context }: { [_index: string]: any; ignoreRdfType?: boolean; languageIn?: readonly string[]; resource: rdfjsResource.Resource; }): purify.Either<rdfjsResource.Resource.ValueError, { identifier: (rdfjs.BlankNode | rdfjs.NamedNode); }> {
        if (!_ignoreRdfType && !_resource.isInstanceOf(dataFactory.namedNode("http://qudt.org/schema/qudt/SymmetricRelation"))) { return purify.Left(new rdfjsResource.Resource.ValueError({ focusResource: _resource, message: `${rdfjsResource.Resource.Identifier.toString(_resource.identifier)} has unexpected RDF type (expected http://qudt.org/schema/qudt/SymmetricRelation)`, predicate: dataFactory.namedNode("http://qudt.org/schema/qudt/SymmetricRelation") })); }

        const identifier = _resource.identifier
        return purify.Either.of({ identifier })
    }

    export function fromRdf(parameters: Parameters<typeof Symmetric_relation._propertiesFromRdf>[0]): purify.Either<rdfjsResource.Resource.ValueError, Symmetric_relation> {
        return Symmetric_relation._propertiesFromRdf(parameters).map(properties => new Symmetric_relation(properties));
    }

    export let fromRdfType: rdfjs.NamedNode<string> = dataFactory.namedNode("http://qudt.org/schema/qudt/SymmetricRelation");

    export function jsonSchema() {
        return zodToJsonSchema(jsonZodSchema());
    }

    export function jsonUiSchema(parameters?: { scopePrefix?: string }) {
        const scopePrefix = parameters?.scopePrefix ?? "#";
        return { "elements": [ { label: "Identifier", scope: `${scopePrefix}/properties/@id`, type: "Control" }, { rule: { condition: { schema: { const: "Symmetric_relation" }, scope: `${scopePrefix}/properties/type` }, effect: "HIDE" }, scope: `${scopePrefix}/properties/type`, type: "Control" } ], label: "Symmetric relation", type: "Group" }
    }

    export function jsonZodSchema() {
        return zod.object({ "@id": zod.string().min(1),"type": zod.literal("Symmetric_relation") });
    }

    export function sparqlConstructQuery(parameters?: { ignoreRdfType?: boolean; prefixes?: { [prefix: string]: string }; subject?: sparqljs.Triple["subject"]; } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type">): sparqljs.ConstructQuery {
        const { ignoreRdfType, subject, ...queryParameters } = parameters ?? {}

        return { ...queryParameters, prefixes: parameters?.prefixes ?? {}, queryType: "CONSTRUCT", template: (queryParameters.template ?? []).concat(Symmetric_relation.sparqlConstructTemplateTriples({ ignoreRdfType, subject })), type: "query", where: (queryParameters.where ?? []).concat(Symmetric_relation.sparqlWherePatterns({ ignoreRdfType, subject })) };
    }

    export function sparqlConstructQueryString(parameters?: { ignoreRdfType?: boolean; subject?: sparqljs.Triple["subject"]; variablePrefix?: string; } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type"> & sparqljs.GeneratorOptions): string {
        return new sparqljs.Generator(parameters).stringify(Symmetric_relation.sparqlConstructQuery(parameters));
    }

    export function sparqlConstructTemplateTriples(parameters?: { ignoreRdfType?: boolean; subject?: sparqljs.Triple["subject"], variablePrefix?: string }): readonly sparqljs.Triple[] {
        const subject = parameters?.subject ?? dataFactory.variable!("symmetricRelation");
        const variablePrefix = parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "symmetricRelation");
        return [...(parameters?.ignoreRdfType ? [] : [{ subject, predicate: dataFactory.namedNode("http://www.w3.org/1999/02/22-rdf-syntax-ns#type"), object: dataFactory.variable!(`${variablePrefix}RdfType`) }])];
    }

    export function sparqlWherePatterns(parameters: { ignoreRdfType?: boolean; subject?: sparqljs.Triple["subject"], variablePrefix?: string }): readonly sparqljs.Pattern[] {
        const subject = parameters?.subject ?? dataFactory.variable!("symmetricRelation");
        const variablePrefix = parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "symmetricRelation");
        return [...(parameters?.ignoreRdfType ? [] : [{ triples: [{ subject, predicate: dataFactory.namedNode("http://www.w3.org/1999/02/22-rdf-syntax-ns#type"), object: dataFactory.namedNode("http://qudt.org/schema/qudt/SymmetricRelation") }], type: "bgp" as const }, { triples: [{ subject, predicate: dataFactory.namedNode("http://www.w3.org/1999/02/22-rdf-syntax-ns#type"), object: dataFactory.variable!(`${variablePrefix}RdfType`) }], type: "bgp" as const }])];
    }
}
/**
 * Symbol
 */
export class Symbol extends QUDT_Concept {
    override readonly type = "Symbol";

    // biome-ignore lint/complexity/noUselessConstructor: Always have a constructor
    constructor(parameters: { readonly identifier?: (rdfjs.BlankNode | rdfjs.NamedNode) | string } & ConstructorParameters<typeof QUDT_Concept>[0]) {
        super(parameters);
    }

    override get identifier(): (rdfjs.BlankNode | rdfjs.NamedNode) {
        if (typeof this._identifier === "undefined") { this._identifier = dataFactory.blankNode(); } return this._identifier;
    }

    override toRdf({ ignoreRdfType, mutateGraph, resourceSet }: { ignoreRdfType?: boolean; mutateGraph?: rdfjsResource.MutableResource.MutateGraph, resourceSet: rdfjsResource.MutableResourceSet }): rdfjsResource.MutableResource {
        const _resource = super.toRdf({ ignoreRdfType: true, mutateGraph, resourceSet });
        if (!ignoreRdfType) { _resource.add(_resource.dataFactory.namedNode("http://www.w3.org/1999/02/22-rdf-syntax-ns#type"), _resource.dataFactory.namedNode("http://qudt.org/schema/qudt/Symbol")); }

        return _resource;
    }

    override toString(): string {
        return JSON.stringify(this.toJson());
    }
}

export namespace Symbol {
    export function _propertiesFromJson(_json: unknown): purify.Either<zod.ZodError, { identifier: (rdfjs.BlankNode | rdfjs.NamedNode); } & UnwrapR<ReturnType<typeof QUDT_Concept._propertiesFromJson>>> {
        const _jsonSafeParseResult = symbolJsonZodSchema().safeParse(_json);
        if (!_jsonSafeParseResult.success) { return purify.Left(_jsonSafeParseResult.error); }

        const _jsonObject = _jsonSafeParseResult.data;
        const _super0Either = QUDT_Concept._propertiesFromJson(_jsonObject);
        if (_super0Either.isLeft()) { return _super0Either; }

        const _super0 = _super0Either.unsafeCoerce()
        const identifier = (_jsonObject["@id"].startsWith("_:") ? dataFactory.blankNode(_jsonObject["@id"].substring(2)) : dataFactory.namedNode(_jsonObject["@id"]));
        return purify.Either.of({ ..._super0, identifier })
    }

    export function fromJson(json: unknown): purify.Either<zod.ZodError, Symbol> {
        return Symbol._propertiesFromJson(json).map(properties => new Symbol(properties));
    }

    export function _propertiesFromRdf({ ignoreRdfType: _ignoreRdfType, languageIn: _languageIn, resource: _resource,
        // @ts-ignore
        ..._context }: { [_index: string]: any; ignoreRdfType?: boolean; languageIn?: readonly string[]; resource: rdfjsResource.Resource; }): purify.Either<rdfjsResource.Resource.ValueError, { identifier: (rdfjs.BlankNode | rdfjs.NamedNode); } & UnwrapR<ReturnType<typeof QUDT_Concept._propertiesFromRdf>>> {
        const _super0Either = QUDT_Concept._propertiesFromRdf({ ..._context, ignoreRdfType: true, languageIn: _languageIn, resource: _resource });
        if (_super0Either.isLeft()) { return _super0Either; }

        const _super0 = _super0Either.unsafeCoerce()
        if (!_ignoreRdfType && !_resource.isInstanceOf(dataFactory.namedNode("http://qudt.org/schema/qudt/Symbol"))) { return purify.Left(new rdfjsResource.Resource.ValueError({ focusResource: _resource, message: `${rdfjsResource.Resource.Identifier.toString(_resource.identifier)} has unexpected RDF type (expected http://qudt.org/schema/qudt/Symbol)`, predicate: dataFactory.namedNode("http://qudt.org/schema/qudt/Symbol") })); }

        const identifier = _resource.identifier
        return purify.Either.of({ ..._super0, identifier })
    }

    export function fromRdf(parameters: Parameters<typeof Symbol._propertiesFromRdf>[0]): purify.Either<rdfjsResource.Resource.ValueError, Symbol> {
        return Symbol._propertiesFromRdf(parameters).map(properties => new Symbol(properties));
    }

    export let fromRdfType: rdfjs.NamedNode<string> = dataFactory.namedNode("http://qudt.org/schema/qudt/Symbol");

    export function jsonSchema() {
        return zodToJsonSchema(symbolJsonZodSchema());
    }

    export function symbolJsonUiSchema(parameters?: { scopePrefix?: string }) {
        const scopePrefix = parameters?.scopePrefix ?? "#";
        return { "elements": [ QUDT_Concept.qudtConceptJsonUiSchema({ scopePrefix }) ], label: "Symbol", type: "Group" }
    }

    export function symbolJsonZodSchema() {
        return QUDT_Concept.qudtConceptJsonZodSchema().merge(zod.object({ "@id": zod.string().min(1),"type": zod.literal("Symbol") }));
    }

    export function sparqlConstructQuery(parameters?: { ignoreRdfType?: boolean; prefixes?: { [prefix: string]: string }; subject?: sparqljs.Triple["subject"]; } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type">): sparqljs.ConstructQuery {
        const { ignoreRdfType, subject, ...queryParameters } = parameters ?? {}

        return { ...queryParameters, prefixes: parameters?.prefixes ?? {}, queryType: "CONSTRUCT", template: (queryParameters.template ?? []).concat(Symbol.sparqlConstructTemplateTriples({ ignoreRdfType, subject })), type: "query", where: (queryParameters.where ?? []).concat(Symbol.sparqlWherePatterns({ ignoreRdfType, subject })) };
    }

    export function sparqlConstructQueryString(parameters?: { ignoreRdfType?: boolean; subject?: sparqljs.Triple["subject"]; variablePrefix?: string; } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type"> & sparqljs.GeneratorOptions): string {
        return new sparqljs.Generator(parameters).stringify(Symbol.sparqlConstructQuery(parameters));
    }

    export function sparqlConstructTemplateTriples(parameters?: { ignoreRdfType?: boolean; subject?: sparqljs.Triple["subject"], variablePrefix?: string }): readonly sparqljs.Triple[] {
        const subject = parameters?.subject ?? dataFactory.variable!("symbol");
        const variablePrefix = parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "symbol");
        return [...QUDT_Concept.sparqlConstructTemplateTriples({ ignoreRdfType: true, subject, variablePrefix }), ...(parameters?.ignoreRdfType ? [] : [{ subject, predicate: dataFactory.namedNode("http://www.w3.org/1999/02/22-rdf-syntax-ns#type"), object: dataFactory.variable!(`${variablePrefix}RdfType`) }])];
    }

    export function sparqlWherePatterns(parameters: { ignoreRdfType?: boolean; subject?: sparqljs.Triple["subject"], variablePrefix?: string }): readonly sparqljs.Pattern[] {
        const subject = parameters?.subject ?? dataFactory.variable!("symbol");
        const variablePrefix = parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "symbol");
        return [...QUDT_Concept.sparqlWherePatterns({ ignoreRdfType: true, subject, variablePrefix }), ...(parameters?.ignoreRdfType ? [] : [{ triples: [{ subject, predicate: dataFactory.namedNode("http://www.w3.org/1999/02/22-rdf-syntax-ns#type"), object: dataFactory.namedNode("http://qudt.org/schema/qudt/Symbol") }], type: "bgp" as const }, { triples: [{ subject, predicate: dataFactory.namedNode("http://www.w3.org/1999/02/22-rdf-syntax-ns#type"), object: dataFactory.variable!(`${variablePrefix}RdfType`) }], type: "bgp" as const }])];
    }
}
/**
 * Statement
 */
export class Statement {
    private _identifier: (rdfjs.BlankNode | rdfjs.NamedNode) | undefined;
    readonly type = "Statement";

    constructor(parameters: { readonly identifier?: (rdfjs.BlankNode | rdfjs.NamedNode) | string }) {
        if (typeof parameters.identifier === "object") { this._identifier = parameters.identifier; } else if (typeof parameters.identifier === "string") { this._identifier = dataFactory.namedNode(parameters.identifier); } else if (typeof parameters.identifier === "undefined") { } else { this._identifier =( parameters.identifier) as never;
         }
    }

    get identifier(): (rdfjs.BlankNode | rdfjs.NamedNode) {
        if (typeof this._identifier === "undefined") { this._identifier = dataFactory.blankNode(); } return this._identifier;
    }

    equals(other: Statement): EqualsResult {
        return (booleanEquals)(this.identifier, other.identifier).mapLeft(propertyValuesUnequal => ({ left: this, right: other, propertyName: "identifier", propertyValuesUnequal, type: "Property" as const })).chain(() => (strictEquals)(this.type, other.type).mapLeft(propertyValuesUnequal => ({ left: this, right: other, propertyName: "type", propertyValuesUnequal, type: "Property" as const })));
    }

    hash<HasherT extends { update: (message: string | number[] | ArrayBuffer | Uint8Array) => void; }>(_hasher: HasherT): HasherT {
        _hasher.update(this.identifier.value);
        _hasher.update(this.type);
        this.hashShaclProperties(_hasher);
        return _hasher;
    }

    protected hashShaclProperties<HasherT extends { update: (message: string | number[] | ArrayBuffer | Uint8Array) => void; }>(_hasher: HasherT): HasherT {
        return _hasher;
    }

    toJson(): { readonly "@id": string; readonly "type": "Statement" } {
        return JSON.parse(JSON.stringify({ "@id": this.identifier.termType === "BlankNode" ? `_:${this.identifier.value}` : this.identifier.value,type: this.type } satisfies ReturnType<Statement["toJson"]>));
    }

    toRdf({ ignoreRdfType, mutateGraph, resourceSet }: { ignoreRdfType?: boolean; mutateGraph?: rdfjsResource.MutableResource.MutateGraph, resourceSet: rdfjsResource.MutableResourceSet }): rdfjsResource.MutableResource {
        const _resource = resourceSet.mutableResource(this.identifier, { mutateGraph });
        if (!ignoreRdfType) { _resource.add(_resource.dataFactory.namedNode("http://www.w3.org/1999/02/22-rdf-syntax-ns#type"), _resource.dataFactory.namedNode("http://qudt.org/schema/qudt/Statement")); }

        return _resource;
    }

    toString(): string {
        return JSON.stringify(this.toJson());
    }
}

export namespace Statement {
    export function _propertiesFromJson(_json: unknown): purify.Either<zod.ZodError, { identifier: (rdfjs.BlankNode | rdfjs.NamedNode); }> {
        const _jsonSafeParseResult = jsonZodSchema().safeParse(_json);
        if (!_jsonSafeParseResult.success) { return purify.Left(_jsonSafeParseResult.error); }

        const _jsonObject = _jsonSafeParseResult.data;
        const identifier = (_jsonObject["@id"].startsWith("_:") ? dataFactory.blankNode(_jsonObject["@id"].substring(2)) : dataFactory.namedNode(_jsonObject["@id"]));
        return purify.Either.of({ identifier })
    }

    export function fromJson(json: unknown): purify.Either<zod.ZodError, Statement> {
        return Statement._propertiesFromJson(json).map(properties => new Statement(properties));
    }

    export function _propertiesFromRdf({ ignoreRdfType: _ignoreRdfType, languageIn: _languageIn, resource: _resource,
        // @ts-ignore
        ..._context }: { [_index: string]: any; ignoreRdfType?: boolean; languageIn?: readonly string[]; resource: rdfjsResource.Resource; }): purify.Either<rdfjsResource.Resource.ValueError, { identifier: (rdfjs.BlankNode | rdfjs.NamedNode); }> {
        if (!_ignoreRdfType && !_resource.isInstanceOf(dataFactory.namedNode("http://qudt.org/schema/qudt/Statement"))) { return purify.Left(new rdfjsResource.Resource.ValueError({ focusResource: _resource, message: `${rdfjsResource.Resource.Identifier.toString(_resource.identifier)} has unexpected RDF type (expected http://qudt.org/schema/qudt/Statement)`, predicate: dataFactory.namedNode("http://qudt.org/schema/qudt/Statement") })); }

        const identifier = _resource.identifier
        return purify.Either.of({ identifier })
    }

    export function fromRdf(parameters: Parameters<typeof Statement._propertiesFromRdf>[0]): purify.Either<rdfjsResource.Resource.ValueError, Statement> {
        return Statement._propertiesFromRdf(parameters).map(properties => new Statement(properties));
    }

    export let fromRdfType: rdfjs.NamedNode<string> = dataFactory.namedNode("http://qudt.org/schema/qudt/Statement");

    export function jsonSchema() {
        return zodToJsonSchema(jsonZodSchema());
    }

    export function jsonUiSchema(parameters?: { scopePrefix?: string }) {
        const scopePrefix = parameters?.scopePrefix ?? "#";
        return { "elements": [ { label: "Identifier", scope: `${scopePrefix}/properties/@id`, type: "Control" }, { rule: { condition: { schema: { const: "Statement" }, scope: `${scopePrefix}/properties/type` }, effect: "HIDE" }, scope: `${scopePrefix}/properties/type`, type: "Control" } ], label: "Statement", type: "Group" }
    }

    export function jsonZodSchema() {
        return zod.object({ "@id": zod.string().min(1),"type": zod.literal("Statement") });
    }

    export function sparqlConstructQuery(parameters?: { ignoreRdfType?: boolean; prefixes?: { [prefix: string]: string }; subject?: sparqljs.Triple["subject"]; } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type">): sparqljs.ConstructQuery {
        const { ignoreRdfType, subject, ...queryParameters } = parameters ?? {}

        return { ...queryParameters, prefixes: parameters?.prefixes ?? {}, queryType: "CONSTRUCT", template: (queryParameters.template ?? []).concat(Statement.sparqlConstructTemplateTriples({ ignoreRdfType, subject })), type: "query", where: (queryParameters.where ?? []).concat(Statement.sparqlWherePatterns({ ignoreRdfType, subject })) };
    }

    export function sparqlConstructQueryString(parameters?: { ignoreRdfType?: boolean; subject?: sparqljs.Triple["subject"]; variablePrefix?: string; } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type"> & sparqljs.GeneratorOptions): string {
        return new sparqljs.Generator(parameters).stringify(Statement.sparqlConstructQuery(parameters));
    }

    export function sparqlConstructTemplateTriples(parameters?: { ignoreRdfType?: boolean; subject?: sparqljs.Triple["subject"], variablePrefix?: string }): readonly sparqljs.Triple[] {
        const subject = parameters?.subject ?? dataFactory.variable!("statement");
        const variablePrefix = parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "statement");
        return [...(parameters?.ignoreRdfType ? [] : [{ subject, predicate: dataFactory.namedNode("http://www.w3.org/1999/02/22-rdf-syntax-ns#type"), object: dataFactory.variable!(`${variablePrefix}RdfType`) }])];
    }

    export function sparqlWherePatterns(parameters: { ignoreRdfType?: boolean; subject?: sparqljs.Triple["subject"], variablePrefix?: string }): readonly sparqljs.Pattern[] {
        const subject = parameters?.subject ?? dataFactory.variable!("statement");
        const variablePrefix = parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "statement");
        return [...(parameters?.ignoreRdfType ? [] : [{ triples: [{ subject, predicate: dataFactory.namedNode("http://www.w3.org/1999/02/22-rdf-syntax-ns#type"), object: dataFactory.namedNode("http://qudt.org/schema/qudt/Statement") }], type: "bgp" as const }, { triples: [{ subject, predicate: dataFactory.namedNode("http://www.w3.org/1999/02/22-rdf-syntax-ns#type"), object: dataFactory.variable!(`${variablePrefix}RdfType`) }], type: "bgp" as const }])];
    }
}
/**
 * Abstract Unit
 */
export class Abstract_Unit extends QUDT_Concept {
    override readonly type: "Abstract_Unit" | "Angle_unit" | "Contextual_Unit" | "Counting_Unit" | "Currency_Unit" | "Derived_Unit" | "Dimensionless_Unit" | "Logarithmic_Unit" | "Plane_Angle$W$Unit" | "Solid_Angle$W$Unit" | "Unit" = "Abstract_Unit";

    // biome-ignore lint/complexity/noUselessConstructor: Always have a constructor
    constructor(parameters: { readonly identifier?: (rdfjs.BlankNode | rdfjs.NamedNode) | string } & ConstructorParameters<typeof QUDT_Concept>[0]) {
        super(parameters);
    }

    override get identifier(): (rdfjs.BlankNode | rdfjs.NamedNode) {
        if (typeof this._identifier === "undefined") { this._identifier = dataFactory.blankNode(); } return this._identifier;
    }

    override toRdf({ ignoreRdfType, mutateGraph, resourceSet }: { ignoreRdfType?: boolean; mutateGraph?: rdfjsResource.MutableResource.MutateGraph, resourceSet: rdfjsResource.MutableResourceSet }): rdfjsResource.MutableResource {
        const _resource = super.toRdf({ ignoreRdfType: true, mutateGraph, resourceSet });
        if (!ignoreRdfType) { _resource.add(_resource.dataFactory.namedNode("http://www.w3.org/1999/02/22-rdf-syntax-ns#type"), _resource.dataFactory.namedNode("http://qudt.org/schema/qudt/AbstractUnit")); }

        return _resource;
    }

    override toString(): string {
        return JSON.stringify(this.toJson());
    }
}

export namespace Abstract_Unit {
    export function _propertiesFromJson(_json: unknown): purify.Either<zod.ZodError, { identifier: (rdfjs.BlankNode | rdfjs.NamedNode); } & UnwrapR<ReturnType<typeof QUDT_Concept._propertiesFromJson>>> {
        const _jsonSafeParseResult = abstractUnitJsonZodSchema().safeParse(_json);
        if (!_jsonSafeParseResult.success) { return purify.Left(_jsonSafeParseResult.error); }

        const _jsonObject = _jsonSafeParseResult.data;
        const _super0Either = QUDT_Concept._propertiesFromJson(_jsonObject);
        if (_super0Either.isLeft()) { return _super0Either; }

        const _super0 = _super0Either.unsafeCoerce()
        const identifier = (_jsonObject["@id"].startsWith("_:") ? dataFactory.blankNode(_jsonObject["@id"].substring(2)) : dataFactory.namedNode(_jsonObject["@id"]));
        return purify.Either.of({ ..._super0, identifier })
    }

    export function fromJson(json: unknown): purify.Either<zod.ZodError, Abstract_Unit> {
        return (Unit.fromJson(json) as purify.Either<zod.ZodError, Abstract_Unit>).altLazy(() => Abstract_Unit._propertiesFromJson(json).map(properties => new Abstract_Unit(properties)));
    }

    export function _propertiesFromRdf({ ignoreRdfType: _ignoreRdfType, languageIn: _languageIn, resource: _resource,
        // @ts-ignore
        ..._context }: { [_index: string]: any; ignoreRdfType?: boolean; languageIn?: readonly string[]; resource: rdfjsResource.Resource; }): purify.Either<rdfjsResource.Resource.ValueError, { identifier: (rdfjs.BlankNode | rdfjs.NamedNode); } & UnwrapR<ReturnType<typeof QUDT_Concept._propertiesFromRdf>>> {
        const _super0Either = QUDT_Concept._propertiesFromRdf({ ..._context, ignoreRdfType: true, languageIn: _languageIn, resource: _resource });
        if (_super0Either.isLeft()) { return _super0Either; }

        const _super0 = _super0Either.unsafeCoerce()
        if (!_ignoreRdfType && !_resource.isInstanceOf(dataFactory.namedNode("http://qudt.org/schema/qudt/AbstractUnit"))) { return purify.Left(new rdfjsResource.Resource.ValueError({ focusResource: _resource, message: `${rdfjsResource.Resource.Identifier.toString(_resource.identifier)} has unexpected RDF type (expected http://qudt.org/schema/qudt/AbstractUnit)`, predicate: dataFactory.namedNode("http://qudt.org/schema/qudt/AbstractUnit") })); }

        const identifier = _resource.identifier
        return purify.Either.of({ ..._super0, identifier })
    }

    export function fromRdf(parameters: Parameters<typeof Abstract_Unit._propertiesFromRdf>[0]): purify.Either<rdfjsResource.Resource.ValueError, Abstract_Unit> {
        const { ignoreRdfType: _ignoreRdfType, ...otherParameters } = parameters
        return (Unit.fromRdf(otherParameters) as purify.Either<rdfjsResource.Resource.ValueError, Abstract_Unit>).altLazy(() => Abstract_Unit._propertiesFromRdf(parameters).map(properties => new Abstract_Unit(properties)));
    }

    export let fromRdfType: rdfjs.NamedNode<string> = dataFactory.namedNode("http://qudt.org/schema/qudt/AbstractUnit");

    export function jsonSchema() {
        return zodToJsonSchema(abstractUnitJsonZodSchema());
    }

    export function abstractUnitJsonUiSchema(parameters?: { scopePrefix?: string }) {
        const scopePrefix = parameters?.scopePrefix ?? "#";
        return { "elements": [ QUDT_Concept.qudtConceptJsonUiSchema({ scopePrefix }) ], label: "Abstract Unit", type: "Group" }
    }

    export function abstractUnitJsonZodSchema() {
        return QUDT_Concept.qudtConceptJsonZodSchema().merge(zod.object({ "@id": zod.string().min(1),"type": zod.enum(["Abstract_Unit","Angle_unit","Contextual_Unit","Counting_Unit","Currency_Unit","Derived_Unit","Dimensionless_Unit","Logarithmic_Unit","Plane_Angle$W$Unit","Solid_Angle$W$Unit","Unit"]) }));
    }

    export function sparqlConstructQuery(parameters?: { ignoreRdfType?: boolean; prefixes?: { [prefix: string]: string }; subject?: sparqljs.Triple["subject"]; } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type">): sparqljs.ConstructQuery {
        const { ignoreRdfType, subject, ...queryParameters } = parameters ?? {}

        return { ...queryParameters, prefixes: parameters?.prefixes ?? {}, queryType: "CONSTRUCT", template: (queryParameters.template ?? []).concat(Abstract_Unit.sparqlConstructTemplateTriples({ ignoreRdfType, subject })), type: "query", where: (queryParameters.where ?? []).concat(Abstract_Unit.sparqlWherePatterns({ ignoreRdfType, subject })) };
    }

    export function sparqlConstructQueryString(parameters?: { ignoreRdfType?: boolean; subject?: sparqljs.Triple["subject"]; variablePrefix?: string; } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type"> & sparqljs.GeneratorOptions): string {
        return new sparqljs.Generator(parameters).stringify(Abstract_Unit.sparqlConstructQuery(parameters));
    }

    export function sparqlConstructTemplateTriples(parameters?: { ignoreRdfType?: boolean; subject?: sparqljs.Triple["subject"], variablePrefix?: string }): readonly sparqljs.Triple[] {
        const subject = parameters?.subject ?? dataFactory.variable!("abstractUnit");
        const variablePrefix = parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "abstractUnit");
        return [...QUDT_Concept.sparqlConstructTemplateTriples({ ignoreRdfType: true, subject, variablePrefix }), ...(parameters?.ignoreRdfType ? [] : [{ subject, predicate: dataFactory.namedNode("http://www.w3.org/1999/02/22-rdf-syntax-ns#type"), object: dataFactory.variable!(`${variablePrefix}RdfType`) }])];
    }

    export function sparqlWherePatterns(parameters: { ignoreRdfType?: boolean; subject?: sparqljs.Triple["subject"], variablePrefix?: string }): readonly sparqljs.Pattern[] {
        const subject = parameters?.subject ?? dataFactory.variable!("abstractUnit");
        const variablePrefix = parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "abstractUnit");
        return [...QUDT_Concept.sparqlWherePatterns({ ignoreRdfType: true, subject, variablePrefix }), ...(parameters?.ignoreRdfType ? [] : [{ triples: [{ subject, predicate: dataFactory.namedNode("http://www.w3.org/1999/02/22-rdf-syntax-ns#type"), object: dataFactory.namedNode("http://qudt.org/schema/qudt/AbstractUnit") }], type: "bgp" as const }, { triples: [{ subject, predicate: dataFactory.namedNode("http://www.w3.org/1999/02/22-rdf-syntax-ns#type"), object: dataFactory.variable!(`${variablePrefix}RdfType`) }], type: "bgp" as const }])];
    }
}
/**
 * Unit
 */
export class Unit extends Abstract_Unit {
    override readonly type: "Angle_unit" | "Contextual_Unit" | "Counting_Unit" | "Currency_Unit" | "Derived_Unit" | "Dimensionless_Unit" | "Logarithmic_Unit" | "Plane_Angle$W$Unit" | "Solid_Angle$W$Unit" | "Unit" = "Unit";
    readonly qudt_Unit$j$altSymbol: readonly ((rdfjs.BlankNode | rdfjs.NamedNode | rdfjs.Literal))[];
    readonly qudt_Unit$j$applicableSystem: readonly (System_of$W$Units)[];
    readonly qudt_Unit$j$conversionMultiplier: purify.Maybe<number>;
    readonly qudt_Unit$j$conversionMultiplierSN: purify.Maybe<number>;
    readonly qudt_Unit$j$conversionOffset: purify.Maybe<number>;
    readonly qudt_Unit$j$conversionOffsetSN: purify.Maybe<number>;
    readonly qudt_Unit$j$definedUnitOfSystem: readonly (System_of$W$Units)[];
    readonly qudt_Unit$j$derivedCoherentUnitOfSystem: readonly (System_of$W$Units)[];
    readonly qudt_Unit$j$derivedUnitOfSystem: readonly (System_of$W$Units)[];
    readonly qudt_Unit$j$expression: readonly ((rdfjs.BlankNode | rdfjs.NamedNode | rdfjs.Literal))[];
    readonly qudt_Unit$j$factorUnitScalar: purify.Maybe<number>;
    readonly qudt_Unit$j$hasDimensionVector: Quantity_Kind$W$Dimension$W$Vector;
    readonly qudt_Unit$j$hasFactorUnit: readonly ((rdfjs.BlankNode | rdfjs.NamedNode))[];
    readonly qudt_Unit$j$hasQuantityKind: purify.NonEmptyList<Quantity_Kind>;
    readonly qudt_Unit$j$iec61360Code: readonly (string)[];
    readonly qudt_Unit$j$latexDefinition: readonly (string)[];
    readonly qudt_Unit$j$latexSymbol: readonly (string)[];
    readonly qudt_Unit$j$mathMLdefinition: purify.Maybe<string>;
    readonly qudt_Unit$j$omUnit: readonly ((rdfjs.BlankNode | rdfjs.NamedNode | rdfjs.Literal))[];
    readonly qudt_Unit$j$prefix: purify.Maybe<Prefix>;
    readonly qudt_Unit$j$qkdvDenominator: purify.Maybe<Quantity_Kind$W$Dimension$W$Vector>;
    readonly qudt_Unit$j$qkdvNumerator: purify.Maybe<Quantity_Kind$W$Dimension$W$Vector>;
    readonly qudt_Unit$j$scalingOf: purify.Maybe<Abstract_Unit>;
    readonly qudt_Unit$j$siExactMatch: purify.Maybe<(rdfjs.BlankNode | rdfjs.NamedNode | rdfjs.Literal)>;
    readonly qudt_Unit$j$siUnitsExpression: readonly (string)[];
    readonly qudt_Unit$j$symbol: purify.Maybe<(rdfjs.BlankNode | rdfjs.NamedNode | rdfjs.Literal)>;
    readonly qudt_Unit$j$ucumCode: readonly (string)[];
    readonly qudt_Unit$j$udunitsCode: readonly (string)[];
    readonly qudt_Unit$j$uneceCommonCode: readonly (string)[];
    readonly qudt_Unit$j$unitOfSystem: readonly (System_of$W$Units)[];

    constructor(parameters: { readonly identifier?: (rdfjs.BlankNode | rdfjs.NamedNode) | string, readonly qudt_Unit$j$altSymbol?: readonly ((rdfjs.BlankNode | rdfjs.NamedNode | rdfjs.Literal))[], readonly qudt_Unit$j$applicableSystem?: readonly (System_of$W$Units)[], readonly qudt_Unit$j$conversionMultiplier?: number | purify.Maybe<number>, readonly qudt_Unit$j$conversionMultiplierSN?: number | purify.Maybe<number>, readonly qudt_Unit$j$conversionOffset?: number | purify.Maybe<number>, readonly qudt_Unit$j$conversionOffsetSN?: number | purify.Maybe<number>, readonly qudt_Unit$j$definedUnitOfSystem?: readonly (System_of$W$Units)[], readonly qudt_Unit$j$derivedCoherentUnitOfSystem?: readonly (System_of$W$Units)[], readonly qudt_Unit$j$derivedUnitOfSystem?: readonly (System_of$W$Units)[], readonly qudt_Unit$j$expression?: readonly ((rdfjs.BlankNode | rdfjs.NamedNode | rdfjs.Literal))[], readonly qudt_Unit$j$factorUnitScalar?: number | purify.Maybe<number>, readonly qudt_Unit$j$hasDimensionVector: Quantity_Kind$W$Dimension$W$Vector, readonly qudt_Unit$j$hasFactorUnit?: readonly ((rdfjs.BlankNode | rdfjs.NamedNode))[], readonly qudt_Unit$j$hasQuantityKind: purify.NonEmptyList<Quantity_Kind>, readonly qudt_Unit$j$iec61360Code?: readonly (string)[], readonly qudt_Unit$j$latexDefinition?: readonly (string)[], readonly qudt_Unit$j$latexSymbol?: readonly (string)[], readonly qudt_Unit$j$mathMLdefinition?: purify.Maybe<string> | string, readonly qudt_Unit$j$omUnit?: readonly ((rdfjs.BlankNode | rdfjs.NamedNode | rdfjs.Literal))[], readonly qudt_Unit$j$prefix?: Prefix | purify.Maybe<Prefix>, readonly qudt_Unit$j$qkdvDenominator?: Quantity_Kind$W$Dimension$W$Vector | purify.Maybe<Quantity_Kind$W$Dimension$W$Vector>, readonly qudt_Unit$j$qkdvNumerator?: Quantity_Kind$W$Dimension$W$Vector | purify.Maybe<Quantity_Kind$W$Dimension$W$Vector>, readonly qudt_Unit$j$scalingOf?: Abstract_Unit | purify.Maybe<Abstract_Unit>, readonly qudt_Unit$j$siExactMatch?: (rdfjs.BlankNode | rdfjs.NamedNode | rdfjs.Literal) | Date | boolean | number | purify.Maybe<(rdfjs.BlankNode | rdfjs.NamedNode | rdfjs.Literal)> | string, readonly qudt_Unit$j$siUnitsExpression?: readonly (string)[], readonly qudt_Unit$j$symbol?: (rdfjs.BlankNode | rdfjs.NamedNode | rdfjs.Literal) | Date | boolean | number | purify.Maybe<(rdfjs.BlankNode | rdfjs.NamedNode | rdfjs.Literal)> | string, readonly qudt_Unit$j$ucumCode?: readonly (string)[], readonly qudt_Unit$j$udunitsCode?: readonly (string)[], readonly qudt_Unit$j$uneceCommonCode?: readonly (string)[], readonly qudt_Unit$j$unitOfSystem?: readonly (System_of$W$Units)[] } & ConstructorParameters<typeof Abstract_Unit>[0]) {
        super(parameters);
        if (typeof parameters.qudt_Unit$j$altSymbol === "undefined") { this.qudt_Unit$j$altSymbol = []; } else if (Array.isArray(parameters.qudt_Unit$j$altSymbol)) { this.qudt_Unit$j$altSymbol = parameters.qudt_Unit$j$altSymbol; } else { this.qudt_Unit$j$altSymbol =( parameters.qudt_Unit$j$altSymbol) as never;
         }

        if (typeof parameters.qudt_Unit$j$applicableSystem === "undefined") { this.qudt_Unit$j$applicableSystem = []; } else if (Array.isArray(parameters.qudt_Unit$j$applicableSystem)) { this.qudt_Unit$j$applicableSystem = parameters.qudt_Unit$j$applicableSystem; } else { this.qudt_Unit$j$applicableSystem =( parameters.qudt_Unit$j$applicableSystem) as never;
         }

        if (purify.Maybe.isMaybe(parameters.qudt_Unit$j$conversionMultiplier)) { this.qudt_Unit$j$conversionMultiplier = parameters.qudt_Unit$j$conversionMultiplier; } else if (typeof parameters.qudt_Unit$j$conversionMultiplier === "number") { this.qudt_Unit$j$conversionMultiplier = purify.Maybe.of(parameters.qudt_Unit$j$conversionMultiplier); } else if (typeof parameters.qudt_Unit$j$conversionMultiplier === "undefined") { this.qudt_Unit$j$conversionMultiplier = purify.Maybe.empty(); } else { this.qudt_Unit$j$conversionMultiplier =( parameters.qudt_Unit$j$conversionMultiplier) as never;
         }

        if (purify.Maybe.isMaybe(parameters.qudt_Unit$j$conversionMultiplierSN)) { this.qudt_Unit$j$conversionMultiplierSN = parameters.qudt_Unit$j$conversionMultiplierSN; } else if (typeof parameters.qudt_Unit$j$conversionMultiplierSN === "number") { this.qudt_Unit$j$conversionMultiplierSN = purify.Maybe.of(parameters.qudt_Unit$j$conversionMultiplierSN); } else if (typeof parameters.qudt_Unit$j$conversionMultiplierSN === "undefined") { this.qudt_Unit$j$conversionMultiplierSN = purify.Maybe.empty(); } else { this.qudt_Unit$j$conversionMultiplierSN =( parameters.qudt_Unit$j$conversionMultiplierSN) as never;
         }

        if (purify.Maybe.isMaybe(parameters.qudt_Unit$j$conversionOffset)) { this.qudt_Unit$j$conversionOffset = parameters.qudt_Unit$j$conversionOffset; } else if (typeof parameters.qudt_Unit$j$conversionOffset === "number") { this.qudt_Unit$j$conversionOffset = purify.Maybe.of(parameters.qudt_Unit$j$conversionOffset); } else if (typeof parameters.qudt_Unit$j$conversionOffset === "undefined") { this.qudt_Unit$j$conversionOffset = purify.Maybe.empty(); } else { this.qudt_Unit$j$conversionOffset =( parameters.qudt_Unit$j$conversionOffset) as never;
         }

        if (purify.Maybe.isMaybe(parameters.qudt_Unit$j$conversionOffsetSN)) { this.qudt_Unit$j$conversionOffsetSN = parameters.qudt_Unit$j$conversionOffsetSN; } else if (typeof parameters.qudt_Unit$j$conversionOffsetSN === "number") { this.qudt_Unit$j$conversionOffsetSN = purify.Maybe.of(parameters.qudt_Unit$j$conversionOffsetSN); } else if (typeof parameters.qudt_Unit$j$conversionOffsetSN === "undefined") { this.qudt_Unit$j$conversionOffsetSN = purify.Maybe.empty(); } else { this.qudt_Unit$j$conversionOffsetSN =( parameters.qudt_Unit$j$conversionOffsetSN) as never;
         }

        if (typeof parameters.qudt_Unit$j$definedUnitOfSystem === "undefined") { this.qudt_Unit$j$definedUnitOfSystem = []; } else if (Array.isArray(parameters.qudt_Unit$j$definedUnitOfSystem)) { this.qudt_Unit$j$definedUnitOfSystem = parameters.qudt_Unit$j$definedUnitOfSystem; } else { this.qudt_Unit$j$definedUnitOfSystem =( parameters.qudt_Unit$j$definedUnitOfSystem) as never;
         }

        if (typeof parameters.qudt_Unit$j$derivedCoherentUnitOfSystem === "undefined") { this.qudt_Unit$j$derivedCoherentUnitOfSystem = []; } else if (Array.isArray(parameters.qudt_Unit$j$derivedCoherentUnitOfSystem)) { this.qudt_Unit$j$derivedCoherentUnitOfSystem = parameters.qudt_Unit$j$derivedCoherentUnitOfSystem; } else { this.qudt_Unit$j$derivedCoherentUnitOfSystem =( parameters.qudt_Unit$j$derivedCoherentUnitOfSystem) as never;
         }

        if (typeof parameters.qudt_Unit$j$derivedUnitOfSystem === "undefined") { this.qudt_Unit$j$derivedUnitOfSystem = []; } else if (Array.isArray(parameters.qudt_Unit$j$derivedUnitOfSystem)) { this.qudt_Unit$j$derivedUnitOfSystem = parameters.qudt_Unit$j$derivedUnitOfSystem; } else { this.qudt_Unit$j$derivedUnitOfSystem =( parameters.qudt_Unit$j$derivedUnitOfSystem) as never;
         }

        if (typeof parameters.qudt_Unit$j$expression === "undefined") { this.qudt_Unit$j$expression = []; } else if (Array.isArray(parameters.qudt_Unit$j$expression)) { this.qudt_Unit$j$expression = parameters.qudt_Unit$j$expression; } else { this.qudt_Unit$j$expression =( parameters.qudt_Unit$j$expression) as never;
         }

        if (purify.Maybe.isMaybe(parameters.qudt_Unit$j$factorUnitScalar)) { this.qudt_Unit$j$factorUnitScalar = parameters.qudt_Unit$j$factorUnitScalar; } else if (typeof parameters.qudt_Unit$j$factorUnitScalar === "number") { this.qudt_Unit$j$factorUnitScalar = purify.Maybe.of(parameters.qudt_Unit$j$factorUnitScalar); } else if (typeof parameters.qudt_Unit$j$factorUnitScalar === "undefined") { this.qudt_Unit$j$factorUnitScalar = purify.Maybe.empty(); } else { this.qudt_Unit$j$factorUnitScalar =( parameters.qudt_Unit$j$factorUnitScalar) as never;
         }

        this.qudt_Unit$j$hasDimensionVector = parameters.qudt_Unit$j$hasDimensionVector;
        if (typeof parameters.qudt_Unit$j$hasFactorUnit === "undefined") { this.qudt_Unit$j$hasFactorUnit = []; } else if (Array.isArray(parameters.qudt_Unit$j$hasFactorUnit)) { this.qudt_Unit$j$hasFactorUnit = parameters.qudt_Unit$j$hasFactorUnit; } else { this.qudt_Unit$j$hasFactorUnit =( parameters.qudt_Unit$j$hasFactorUnit) as never;
         }

        this.qudt_Unit$j$hasQuantityKind = parameters.qudt_Unit$j$hasQuantityKind;
        if (typeof parameters.qudt_Unit$j$iec61360Code === "undefined") { this.qudt_Unit$j$iec61360Code = []; } else if (Array.isArray(parameters.qudt_Unit$j$iec61360Code)) { this.qudt_Unit$j$iec61360Code = parameters.qudt_Unit$j$iec61360Code; } else { this.qudt_Unit$j$iec61360Code =( parameters.qudt_Unit$j$iec61360Code) as never;
         }

        if (typeof parameters.qudt_Unit$j$latexDefinition === "undefined") { this.qudt_Unit$j$latexDefinition = []; } else if (Array.isArray(parameters.qudt_Unit$j$latexDefinition)) { this.qudt_Unit$j$latexDefinition = parameters.qudt_Unit$j$latexDefinition; } else { this.qudt_Unit$j$latexDefinition =( parameters.qudt_Unit$j$latexDefinition) as never;
         }

        if (typeof parameters.qudt_Unit$j$latexSymbol === "undefined") { this.qudt_Unit$j$latexSymbol = []; } else if (Array.isArray(parameters.qudt_Unit$j$latexSymbol)) { this.qudt_Unit$j$latexSymbol = parameters.qudt_Unit$j$latexSymbol; } else { this.qudt_Unit$j$latexSymbol =( parameters.qudt_Unit$j$latexSymbol) as never;
         }

        if (purify.Maybe.isMaybe(parameters.qudt_Unit$j$mathMLdefinition)) { this.qudt_Unit$j$mathMLdefinition = parameters.qudt_Unit$j$mathMLdefinition; } else if (typeof parameters.qudt_Unit$j$mathMLdefinition === "string") { this.qudt_Unit$j$mathMLdefinition = purify.Maybe.of(parameters.qudt_Unit$j$mathMLdefinition); } else if (typeof parameters.qudt_Unit$j$mathMLdefinition === "undefined") { this.qudt_Unit$j$mathMLdefinition = purify.Maybe.empty(); } else { this.qudt_Unit$j$mathMLdefinition =( parameters.qudt_Unit$j$mathMLdefinition) as never;
         }

        if (typeof parameters.qudt_Unit$j$omUnit === "undefined") { this.qudt_Unit$j$omUnit = []; } else if (Array.isArray(parameters.qudt_Unit$j$omUnit)) { this.qudt_Unit$j$omUnit = parameters.qudt_Unit$j$omUnit; } else { this.qudt_Unit$j$omUnit =( parameters.qudt_Unit$j$omUnit) as never;
         }

        if (purify.Maybe.isMaybe(parameters.qudt_Unit$j$prefix)) { this.qudt_Unit$j$prefix = parameters.qudt_Unit$j$prefix; } else if (typeof parameters.qudt_Unit$j$prefix === "object" && parameters.qudt_Unit$j$prefix instanceof Prefix) { this.qudt_Unit$j$prefix = purify.Maybe.of(parameters.qudt_Unit$j$prefix); } else if (typeof parameters.qudt_Unit$j$prefix === "undefined") { this.qudt_Unit$j$prefix = purify.Maybe.empty(); } else { this.qudt_Unit$j$prefix =( parameters.qudt_Unit$j$prefix) as never;
         }

        if (purify.Maybe.isMaybe(parameters.qudt_Unit$j$qkdvDenominator)) { this.qudt_Unit$j$qkdvDenominator = parameters.qudt_Unit$j$qkdvDenominator; } else if (typeof parameters.qudt_Unit$j$qkdvDenominator === "object" && parameters.qudt_Unit$j$qkdvDenominator instanceof Quantity_Kind$W$Dimension$W$Vector) { this.qudt_Unit$j$qkdvDenominator = purify.Maybe.of(parameters.qudt_Unit$j$qkdvDenominator); } else if (typeof parameters.qudt_Unit$j$qkdvDenominator === "undefined") { this.qudt_Unit$j$qkdvDenominator = purify.Maybe.empty(); } else { this.qudt_Unit$j$qkdvDenominator =( parameters.qudt_Unit$j$qkdvDenominator) as never;
         }

        if (purify.Maybe.isMaybe(parameters.qudt_Unit$j$qkdvNumerator)) { this.qudt_Unit$j$qkdvNumerator = parameters.qudt_Unit$j$qkdvNumerator; } else if (typeof parameters.qudt_Unit$j$qkdvNumerator === "object" && parameters.qudt_Unit$j$qkdvNumerator instanceof Quantity_Kind$W$Dimension$W$Vector) { this.qudt_Unit$j$qkdvNumerator = purify.Maybe.of(parameters.qudt_Unit$j$qkdvNumerator); } else if (typeof parameters.qudt_Unit$j$qkdvNumerator === "undefined") { this.qudt_Unit$j$qkdvNumerator = purify.Maybe.empty(); } else { this.qudt_Unit$j$qkdvNumerator =( parameters.qudt_Unit$j$qkdvNumerator) as never;
         }

        if (purify.Maybe.isMaybe(parameters.qudt_Unit$j$scalingOf)) { this.qudt_Unit$j$scalingOf = parameters.qudt_Unit$j$scalingOf; } else if (typeof parameters.qudt_Unit$j$scalingOf === "object" && parameters.qudt_Unit$j$scalingOf instanceof Abstract_Unit) { this.qudt_Unit$j$scalingOf = purify.Maybe.of(parameters.qudt_Unit$j$scalingOf); } else if (typeof parameters.qudt_Unit$j$scalingOf === "undefined") { this.qudt_Unit$j$scalingOf = purify.Maybe.empty(); } else { this.qudt_Unit$j$scalingOf =( parameters.qudt_Unit$j$scalingOf) as never;
         }

        if (purify.Maybe.isMaybe(parameters.qudt_Unit$j$siExactMatch)) { this.qudt_Unit$j$siExactMatch = parameters.qudt_Unit$j$siExactMatch; } else if (typeof parameters.qudt_Unit$j$siExactMatch === "boolean") { this.qudt_Unit$j$siExactMatch = purify.Maybe.of(rdfLiteral.toRdf(parameters.qudt_Unit$j$siExactMatch, { dataFactory })); } else if (typeof parameters.qudt_Unit$j$siExactMatch === "object" && parameters.qudt_Unit$j$siExactMatch instanceof Date) { this.qudt_Unit$j$siExactMatch = purify.Maybe.of(rdfLiteral.toRdf(parameters.qudt_Unit$j$siExactMatch, { dataFactory })); } else if (typeof parameters.qudt_Unit$j$siExactMatch === "number") { this.qudt_Unit$j$siExactMatch = purify.Maybe.of(rdfLiteral.toRdf(parameters.qudt_Unit$j$siExactMatch, { dataFactory })); } else if (typeof parameters.qudt_Unit$j$siExactMatch === "string") { this.qudt_Unit$j$siExactMatch = purify.Maybe.of(dataFactory.literal(parameters.qudt_Unit$j$siExactMatch)); } else if (typeof parameters.qudt_Unit$j$siExactMatch === "object") { this.qudt_Unit$j$siExactMatch = purify.Maybe.of(parameters.qudt_Unit$j$siExactMatch); } else if (typeof parameters.qudt_Unit$j$siExactMatch === "undefined") { this.qudt_Unit$j$siExactMatch = purify.Maybe.empty(); } else { this.qudt_Unit$j$siExactMatch =( parameters.qudt_Unit$j$siExactMatch) as never;
         }

        if (typeof parameters.qudt_Unit$j$siUnitsExpression === "undefined") { this.qudt_Unit$j$siUnitsExpression = []; } else if (Array.isArray(parameters.qudt_Unit$j$siUnitsExpression)) { this.qudt_Unit$j$siUnitsExpression = parameters.qudt_Unit$j$siUnitsExpression; } else { this.qudt_Unit$j$siUnitsExpression =( parameters.qudt_Unit$j$siUnitsExpression) as never;
         }

        if (purify.Maybe.isMaybe(parameters.qudt_Unit$j$symbol)) { this.qudt_Unit$j$symbol = parameters.qudt_Unit$j$symbol; } else if (typeof parameters.qudt_Unit$j$symbol === "boolean") { this.qudt_Unit$j$symbol = purify.Maybe.of(rdfLiteral.toRdf(parameters.qudt_Unit$j$symbol, { dataFactory })); } else if (typeof parameters.qudt_Unit$j$symbol === "object" && parameters.qudt_Unit$j$symbol instanceof Date) { this.qudt_Unit$j$symbol = purify.Maybe.of(rdfLiteral.toRdf(parameters.qudt_Unit$j$symbol, { dataFactory })); } else if (typeof parameters.qudt_Unit$j$symbol === "number") { this.qudt_Unit$j$symbol = purify.Maybe.of(rdfLiteral.toRdf(parameters.qudt_Unit$j$symbol, { dataFactory })); } else if (typeof parameters.qudt_Unit$j$symbol === "string") { this.qudt_Unit$j$symbol = purify.Maybe.of(dataFactory.literal(parameters.qudt_Unit$j$symbol)); } else if (typeof parameters.qudt_Unit$j$symbol === "object") { this.qudt_Unit$j$symbol = purify.Maybe.of(parameters.qudt_Unit$j$symbol); } else if (typeof parameters.qudt_Unit$j$symbol === "undefined") { this.qudt_Unit$j$symbol = purify.Maybe.empty(); } else { this.qudt_Unit$j$symbol =( parameters.qudt_Unit$j$symbol) as never;
         }

        if (typeof parameters.qudt_Unit$j$ucumCode === "undefined") { this.qudt_Unit$j$ucumCode = []; } else if (Array.isArray(parameters.qudt_Unit$j$ucumCode)) { this.qudt_Unit$j$ucumCode = parameters.qudt_Unit$j$ucumCode; } else { this.qudt_Unit$j$ucumCode =( parameters.qudt_Unit$j$ucumCode) as never;
         }

        if (typeof parameters.qudt_Unit$j$udunitsCode === "undefined") { this.qudt_Unit$j$udunitsCode = []; } else if (Array.isArray(parameters.qudt_Unit$j$udunitsCode)) { this.qudt_Unit$j$udunitsCode = parameters.qudt_Unit$j$udunitsCode; } else { this.qudt_Unit$j$udunitsCode =( parameters.qudt_Unit$j$udunitsCode) as never;
         }

        if (typeof parameters.qudt_Unit$j$uneceCommonCode === "undefined") { this.qudt_Unit$j$uneceCommonCode = []; } else if (Array.isArray(parameters.qudt_Unit$j$uneceCommonCode)) { this.qudt_Unit$j$uneceCommonCode = parameters.qudt_Unit$j$uneceCommonCode; } else { this.qudt_Unit$j$uneceCommonCode =( parameters.qudt_Unit$j$uneceCommonCode) as never;
         }

        if (typeof parameters.qudt_Unit$j$unitOfSystem === "undefined") { this.qudt_Unit$j$unitOfSystem = []; } else if (Array.isArray(parameters.qudt_Unit$j$unitOfSystem)) { this.qudt_Unit$j$unitOfSystem = parameters.qudt_Unit$j$unitOfSystem; } else { this.qudt_Unit$j$unitOfSystem =( parameters.qudt_Unit$j$unitOfSystem) as never;
         }
    }

    override get identifier(): (rdfjs.BlankNode | rdfjs.NamedNode) {
        if (typeof this._identifier === "undefined") { this._identifier = dataFactory.blankNode(); } return this._identifier;
    }

    override equals(other: Unit): EqualsResult {
        return super.equals(other).chain(() => (((left, right) => arrayEquals(left, right, booleanEquals)))(this.qudt_Unit$j$altSymbol, other.qudt_Unit$j$altSymbol).mapLeft(propertyValuesUnequal => ({ left: this, right: other, propertyName: "qudt_Unit$j$altSymbol", propertyValuesUnequal, type: "Property" as const }))).chain(() => (((left, right) => arrayEquals(left, right, ((left, right) => left.equals(right)))))(this.qudt_Unit$j$applicableSystem, other.qudt_Unit$j$applicableSystem).mapLeft(propertyValuesUnequal => ({ left: this, right: other, propertyName: "qudt_Unit$j$applicableSystem", propertyValuesUnequal, type: "Property" as const }))).chain(() => (((left, right) => maybeEquals(left, right, strictEquals)))(this.qudt_Unit$j$conversionMultiplier, other.qudt_Unit$j$conversionMultiplier).mapLeft(propertyValuesUnequal => ({ left: this, right: other, propertyName: "qudt_Unit$j$conversionMultiplier", propertyValuesUnequal, type: "Property" as const }))).chain(() => (((left, right) => maybeEquals(left, right, strictEquals)))(this.qudt_Unit$j$conversionMultiplierSN, other.qudt_Unit$j$conversionMultiplierSN).mapLeft(propertyValuesUnequal => ({ left: this, right: other, propertyName: "qudt_Unit$j$conversionMultiplierSN", propertyValuesUnequal, type: "Property" as const }))).chain(() => (((left, right) => maybeEquals(left, right, strictEquals)))(this.qudt_Unit$j$conversionOffset, other.qudt_Unit$j$conversionOffset).mapLeft(propertyValuesUnequal => ({ left: this, right: other, propertyName: "qudt_Unit$j$conversionOffset", propertyValuesUnequal, type: "Property" as const }))).chain(() => (((left, right) => maybeEquals(left, right, strictEquals)))(this.qudt_Unit$j$conversionOffsetSN, other.qudt_Unit$j$conversionOffsetSN).mapLeft(propertyValuesUnequal => ({ left: this, right: other, propertyName: "qudt_Unit$j$conversionOffsetSN", propertyValuesUnequal, type: "Property" as const }))).chain(() => (((left, right) => arrayEquals(left, right, ((left, right) => left.equals(right)))))(this.qudt_Unit$j$definedUnitOfSystem, other.qudt_Unit$j$definedUnitOfSystem).mapLeft(propertyValuesUnequal => ({ left: this, right: other, propertyName: "qudt_Unit$j$definedUnitOfSystem", propertyValuesUnequal, type: "Property" as const }))).chain(() => (((left, right) => arrayEquals(left, right, ((left, right) => left.equals(right)))))(this.qudt_Unit$j$derivedCoherentUnitOfSystem, other.qudt_Unit$j$derivedCoherentUnitOfSystem).mapLeft(propertyValuesUnequal => ({ left: this, right: other, propertyName: "qudt_Unit$j$derivedCoherentUnitOfSystem", propertyValuesUnequal, type: "Property" as const }))).chain(() => (((left, right) => arrayEquals(left, right, ((left, right) => left.equals(right)))))(this.qudt_Unit$j$derivedUnitOfSystem, other.qudt_Unit$j$derivedUnitOfSystem).mapLeft(propertyValuesUnequal => ({ left: this, right: other, propertyName: "qudt_Unit$j$derivedUnitOfSystem", propertyValuesUnequal, type: "Property" as const }))).chain(() => (((left, right) => arrayEquals(left, right, booleanEquals)))(this.qudt_Unit$j$expression, other.qudt_Unit$j$expression).mapLeft(propertyValuesUnequal => ({ left: this, right: other, propertyName: "qudt_Unit$j$expression", propertyValuesUnequal, type: "Property" as const }))).chain(() => (((left, right) => maybeEquals(left, right, strictEquals)))(this.qudt_Unit$j$factorUnitScalar, other.qudt_Unit$j$factorUnitScalar).mapLeft(propertyValuesUnequal => ({ left: this, right: other, propertyName: "qudt_Unit$j$factorUnitScalar", propertyValuesUnequal, type: "Property" as const }))).chain(() => (((left, right) => left.equals(right)))(this.qudt_Unit$j$hasDimensionVector, other.qudt_Unit$j$hasDimensionVector).mapLeft(propertyValuesUnequal => ({ left: this, right: other, propertyName: "qudt_Unit$j$hasDimensionVector", propertyValuesUnequal, type: "Property" as const }))).chain(() => (((left, right) => arrayEquals(left, right, booleanEquals)))(this.qudt_Unit$j$hasFactorUnit, other.qudt_Unit$j$hasFactorUnit).mapLeft(propertyValuesUnequal => ({ left: this, right: other, propertyName: "qudt_Unit$j$hasFactorUnit", propertyValuesUnequal, type: "Property" as const }))).chain(() => (((left, right) => arrayEquals(left, right, ((left, right) => left.equals(right)))))(this.qudt_Unit$j$hasQuantityKind, other.qudt_Unit$j$hasQuantityKind).mapLeft(propertyValuesUnequal => ({ left: this, right: other, propertyName: "qudt_Unit$j$hasQuantityKind", propertyValuesUnequal, type: "Property" as const }))).chain(() => (((left, right) => arrayEquals(left, right, strictEquals)))(this.qudt_Unit$j$iec61360Code, other.qudt_Unit$j$iec61360Code).mapLeft(propertyValuesUnequal => ({ left: this, right: other, propertyName: "qudt_Unit$j$iec61360Code", propertyValuesUnequal, type: "Property" as const }))).chain(() => (((left, right) => arrayEquals(left, right, strictEquals)))(this.qudt_Unit$j$latexDefinition, other.qudt_Unit$j$latexDefinition).mapLeft(propertyValuesUnequal => ({ left: this, right: other, propertyName: "qudt_Unit$j$latexDefinition", propertyValuesUnequal, type: "Property" as const }))).chain(() => (((left, right) => arrayEquals(left, right, strictEquals)))(this.qudt_Unit$j$latexSymbol, other.qudt_Unit$j$latexSymbol).mapLeft(propertyValuesUnequal => ({ left: this, right: other, propertyName: "qudt_Unit$j$latexSymbol", propertyValuesUnequal, type: "Property" as const }))).chain(() => (((left, right) => maybeEquals(left, right, strictEquals)))(this.qudt_Unit$j$mathMLdefinition, other.qudt_Unit$j$mathMLdefinition).mapLeft(propertyValuesUnequal => ({ left: this, right: other, propertyName: "qudt_Unit$j$mathMLdefinition", propertyValuesUnequal, type: "Property" as const }))).chain(() => (((left, right) => arrayEquals(left, right, booleanEquals)))(this.qudt_Unit$j$omUnit, other.qudt_Unit$j$omUnit).mapLeft(propertyValuesUnequal => ({ left: this, right: other, propertyName: "qudt_Unit$j$omUnit", propertyValuesUnequal, type: "Property" as const }))).chain(() => (((left, right) => maybeEquals(left, right, ((left, right) => left.equals(right)))))(this.qudt_Unit$j$prefix, other.qudt_Unit$j$prefix).mapLeft(propertyValuesUnequal => ({ left: this, right: other, propertyName: "qudt_Unit$j$prefix", propertyValuesUnequal, type: "Property" as const }))).chain(() => (((left, right) => maybeEquals(left, right, ((left, right) => left.equals(right)))))(this.qudt_Unit$j$qkdvDenominator, other.qudt_Unit$j$qkdvDenominator).mapLeft(propertyValuesUnequal => ({ left: this, right: other, propertyName: "qudt_Unit$j$qkdvDenominator", propertyValuesUnequal, type: "Property" as const }))).chain(() => (((left, right) => maybeEquals(left, right, ((left, right) => left.equals(right)))))(this.qudt_Unit$j$qkdvNumerator, other.qudt_Unit$j$qkdvNumerator).mapLeft(propertyValuesUnequal => ({ left: this, right: other, propertyName: "qudt_Unit$j$qkdvNumerator", propertyValuesUnequal, type: "Property" as const }))).chain(() => (((left, right) => maybeEquals(left, right, ((left, right) => left.equals(right)))))(this.qudt_Unit$j$scalingOf, other.qudt_Unit$j$scalingOf).mapLeft(propertyValuesUnequal => ({ left: this, right: other, propertyName: "qudt_Unit$j$scalingOf", propertyValuesUnequal, type: "Property" as const }))).chain(() => (((left, right) => maybeEquals(left, right, booleanEquals)))(this.qudt_Unit$j$siExactMatch, other.qudt_Unit$j$siExactMatch).mapLeft(propertyValuesUnequal => ({ left: this, right: other, propertyName: "qudt_Unit$j$siExactMatch", propertyValuesUnequal, type: "Property" as const }))).chain(() => (((left, right) => arrayEquals(left, right, strictEquals)))(this.qudt_Unit$j$siUnitsExpression, other.qudt_Unit$j$siUnitsExpression).mapLeft(propertyValuesUnequal => ({ left: this, right: other, propertyName: "qudt_Unit$j$siUnitsExpression", propertyValuesUnequal, type: "Property" as const }))).chain(() => (((left, right) => maybeEquals(left, right, booleanEquals)))(this.qudt_Unit$j$symbol, other.qudt_Unit$j$symbol).mapLeft(propertyValuesUnequal => ({ left: this, right: other, propertyName: "qudt_Unit$j$symbol", propertyValuesUnequal, type: "Property" as const }))).chain(() => (((left, right) => arrayEquals(left, right, strictEquals)))(this.qudt_Unit$j$ucumCode, other.qudt_Unit$j$ucumCode).mapLeft(propertyValuesUnequal => ({ left: this, right: other, propertyName: "qudt_Unit$j$ucumCode", propertyValuesUnequal, type: "Property" as const }))).chain(() => (((left, right) => arrayEquals(left, right, strictEquals)))(this.qudt_Unit$j$udunitsCode, other.qudt_Unit$j$udunitsCode).mapLeft(propertyValuesUnequal => ({ left: this, right: other, propertyName: "qudt_Unit$j$udunitsCode", propertyValuesUnequal, type: "Property" as const }))).chain(() => (((left, right) => arrayEquals(left, right, strictEquals)))(this.qudt_Unit$j$uneceCommonCode, other.qudt_Unit$j$uneceCommonCode).mapLeft(propertyValuesUnequal => ({ left: this, right: other, propertyName: "qudt_Unit$j$uneceCommonCode", propertyValuesUnequal, type: "Property" as const }))).chain(() => (((left, right) => arrayEquals(left, right, ((left, right) => left.equals(right)))))(this.qudt_Unit$j$unitOfSystem, other.qudt_Unit$j$unitOfSystem).mapLeft(propertyValuesUnequal => ({ left: this, right: other, propertyName: "qudt_Unit$j$unitOfSystem", propertyValuesUnequal, type: "Property" as const })));
    }

    override hash<HasherT extends { update: (message: string | number[] | ArrayBuffer | Uint8Array) => void; }>(_hasher: HasherT): HasherT {
        this.hashShaclProperties(_hasher);
        return _hasher;
    }

    protected override hashShaclProperties<HasherT extends { update: (message: string | number[] | ArrayBuffer | Uint8Array) => void; }>(_hasher: HasherT): HasherT {
        super.hashShaclProperties(_hasher);
        for (const _item0 of this.qudt_Unit$j$altSymbol) { _hasher.update(_item0.termType);
        _hasher.update(_item0.value); }

        for (const _item0 of this.qudt_Unit$j$applicableSystem) { _item0.hash(_hasher); }

        this.qudt_Unit$j$conversionMultiplier.ifJust((_value0) => { _hasher.update(_value0.toString()); })
        this.qudt_Unit$j$conversionMultiplierSN.ifJust((_value0) => { _hasher.update(_value0.toString()); })
        this.qudt_Unit$j$conversionOffset.ifJust((_value0) => { _hasher.update(_value0.toString()); })
        this.qudt_Unit$j$conversionOffsetSN.ifJust((_value0) => { _hasher.update(_value0.toString()); })
        for (const _item0 of this.qudt_Unit$j$definedUnitOfSystem) { _item0.hash(_hasher); }

        for (const _item0 of this.qudt_Unit$j$derivedCoherentUnitOfSystem) { _item0.hash(_hasher); }

        for (const _item0 of this.qudt_Unit$j$derivedUnitOfSystem) { _item0.hash(_hasher); }

        for (const _item0 of this.qudt_Unit$j$expression) { _hasher.update(_item0.termType);
        _hasher.update(_item0.value); }

        this.qudt_Unit$j$factorUnitScalar.ifJust((_value0) => { _hasher.update(_value0.toString()); })
        this.qudt_Unit$j$hasDimensionVector.hash(_hasher);
        for (const _item0 of this.qudt_Unit$j$hasFactorUnit) { _hasher.update(_item0.termType);
        _hasher.update(_item0.value); }

        for (const _item0 of this.qudt_Unit$j$hasQuantityKind) { _item0.hash(_hasher); }

        for (const _item0 of this.qudt_Unit$j$iec61360Code) { _hasher.update(_item0); }

        for (const _item0 of this.qudt_Unit$j$latexDefinition) { _hasher.update(_item0); }

        for (const _item0 of this.qudt_Unit$j$latexSymbol) { _hasher.update(_item0); }

        this.qudt_Unit$j$mathMLdefinition.ifJust((_value0) => { _hasher.update(_value0); })
        for (const _item0 of this.qudt_Unit$j$omUnit) { _hasher.update(_item0.termType);
        _hasher.update(_item0.value); }

        this.qudt_Unit$j$prefix.ifJust((_value0) => { _value0.hash(_hasher); })
        this.qudt_Unit$j$qkdvDenominator.ifJust((_value0) => { _value0.hash(_hasher); })
        this.qudt_Unit$j$qkdvNumerator.ifJust((_value0) => { _value0.hash(_hasher); })
        this.qudt_Unit$j$scalingOf.ifJust((_value0) => { _value0.hash(_hasher); })
        this.qudt_Unit$j$siExactMatch.ifJust((_value0) => { _hasher.update(_value0.termType);
        _hasher.update(_value0.value); })
        for (const _item0 of this.qudt_Unit$j$siUnitsExpression) { _hasher.update(_item0); }

        this.qudt_Unit$j$symbol.ifJust((_value0) => { _hasher.update(_value0.termType);
        _hasher.update(_value0.value); })
        for (const _item0 of this.qudt_Unit$j$ucumCode) { _hasher.update(_item0); }

        for (const _item0 of this.qudt_Unit$j$udunitsCode) { _hasher.update(_item0); }

        for (const _item0 of this.qudt_Unit$j$uneceCommonCode) { _hasher.update(_item0); }

        for (const _item0 of this.qudt_Unit$j$unitOfSystem) { _item0.hash(_hasher); }

        return _hasher;
    }

    override toJson(): { readonly "qudt_Unit$j$altSymbol": readonly ({ readonly "@id": string, readonly termType: "BlankNode" | "NamedNode" } | { readonly "@language": string | undefined, readonly "@type": string | undefined, readonly "@value": string, readonly termType: "Literal" })[]; readonly "qudt_Unit$j$applicableSystem": readonly (ReturnType<System_of$W$Units["toJson"]>)[]; readonly "qudt_Unit$j$conversionMultiplier": (number) | undefined; readonly "qudt_Unit$j$conversionMultiplierSN": (number) | undefined; readonly "qudt_Unit$j$conversionOffset": (number) | undefined; readonly "qudt_Unit$j$conversionOffsetSN": (number) | undefined; readonly "qudt_Unit$j$definedUnitOfSystem": readonly (ReturnType<System_of$W$Units["toJson"]>)[]; readonly "qudt_Unit$j$derivedCoherentUnitOfSystem": readonly (ReturnType<System_of$W$Units["toJson"]>)[]; readonly "qudt_Unit$j$derivedUnitOfSystem": readonly (ReturnType<System_of$W$Units["toJson"]>)[]; readonly "qudt_Unit$j$expression": readonly ({ readonly "@id": string, readonly termType: "BlankNode" | "NamedNode" } | { readonly "@language": string | undefined, readonly "@type": string | undefined, readonly "@value": string, readonly termType: "Literal" })[]; readonly "qudt_Unit$j$factorUnitScalar": (number) | undefined; readonly "qudt_Unit$j$hasDimensionVector": ReturnType<Quantity_Kind$W$Dimension$W$Vector["toJson"]>; readonly "qudt_Unit$j$hasFactorUnit": readonly ({ readonly "@id": string })[]; readonly "qudt_Unit$j$hasQuantityKind": readonly (ReturnType<Quantity_Kind["toJson"]>)[]; readonly "qudt_Unit$j$iec61360Code": readonly (string)[]; readonly "qudt_Unit$j$latexDefinition": readonly (string)[]; readonly "qudt_Unit$j$latexSymbol": readonly (string)[]; readonly "qudt_Unit$j$mathMLdefinition": (string) | undefined; readonly "qudt_Unit$j$omUnit": readonly ({ readonly "@id": string, readonly termType: "BlankNode" | "NamedNode" } | { readonly "@language": string | undefined, readonly "@type": string | undefined, readonly "@value": string, readonly termType: "Literal" })[]; readonly "qudt_Unit$j$prefix": (ReturnType<Prefix["toJson"]>) | undefined; readonly "qudt_Unit$j$qkdvDenominator": (ReturnType<Quantity_Kind$W$Dimension$W$Vector["toJson"]>) | undefined; readonly "qudt_Unit$j$qkdvNumerator": (ReturnType<Quantity_Kind$W$Dimension$W$Vector["toJson"]>) | undefined; readonly "qudt_Unit$j$scalingOf": (ReturnType<Abstract_Unit["toJson"]>) | undefined; readonly "qudt_Unit$j$siExactMatch": ({ readonly "@id": string, readonly termType: "BlankNode" | "NamedNode" } | { readonly "@language": string | undefined, readonly "@type": string | undefined, readonly "@value": string, readonly termType: "Literal" }) | undefined; readonly "qudt_Unit$j$siUnitsExpression": readonly (string)[]; readonly "qudt_Unit$j$symbol": ({ readonly "@id": string, readonly termType: "BlankNode" | "NamedNode" } | { readonly "@language": string | undefined, readonly "@type": string | undefined, readonly "@value": string, readonly termType: "Literal" }) | undefined; readonly "qudt_Unit$j$ucumCode": readonly (string)[]; readonly "qudt_Unit$j$udunitsCode": readonly (string)[]; readonly "qudt_Unit$j$uneceCommonCode": readonly (string)[]; readonly "qudt_Unit$j$unitOfSystem": readonly (ReturnType<System_of$W$Units["toJson"]>)[] } & ReturnType<Abstract_Unit["toJson"]> {
        return JSON.parse(JSON.stringify({ ...super.toJson(),qudt_Unit$j$altSymbol: this.qudt_Unit$j$altSymbol.map(_item => ((_item.termType === "Literal") ? { "@language": _item.language.length > 0 ? _item.language : undefined, "@type": _item.datatype.value !== "http://www.w3.org/2001/XMLSchema#string" ? _item.datatype.value : undefined, "@value": _item.value, termType: "Literal" as const } : (_item.termType === "NamedNode") ? { "@id": _item.value, termType: "NamedNode" as const } : { "@id": `_:${_item.value}`, termType: "BlankNode" as const })),qudt_Unit$j$applicableSystem: this.qudt_Unit$j$applicableSystem.map(_item => (_item.toJson())),qudt_Unit$j$conversionMultiplier: this.qudt_Unit$j$conversionMultiplier.map(_item => (_item)).extract(),qudt_Unit$j$conversionMultiplierSN: this.qudt_Unit$j$conversionMultiplierSN.map(_item => (_item)).extract(),qudt_Unit$j$conversionOffset: this.qudt_Unit$j$conversionOffset.map(_item => (_item)).extract(),qudt_Unit$j$conversionOffsetSN: this.qudt_Unit$j$conversionOffsetSN.map(_item => (_item)).extract(),qudt_Unit$j$definedUnitOfSystem: this.qudt_Unit$j$definedUnitOfSystem.map(_item => (_item.toJson())),qudt_Unit$j$derivedCoherentUnitOfSystem: this.qudt_Unit$j$derivedCoherentUnitOfSystem.map(_item => (_item.toJson())),qudt_Unit$j$derivedUnitOfSystem: this.qudt_Unit$j$derivedUnitOfSystem.map(_item => (_item.toJson())),qudt_Unit$j$expression: this.qudt_Unit$j$expression.map(_item => ((_item.termType === "Literal") ? { "@language": _item.language.length > 0 ? _item.language : undefined, "@type": _item.datatype.value !== "http://www.w3.org/2001/XMLSchema#string" ? _item.datatype.value : undefined, "@value": _item.value, termType: "Literal" as const } : (_item.termType === "NamedNode") ? { "@id": _item.value, termType: "NamedNode" as const } : { "@id": `_:${_item.value}`, termType: "BlankNode" as const })),qudt_Unit$j$factorUnitScalar: this.qudt_Unit$j$factorUnitScalar.map(_item => (_item)).extract(),qudt_Unit$j$hasDimensionVector: this.qudt_Unit$j$hasDimensionVector.toJson(),qudt_Unit$j$hasFactorUnit: this.qudt_Unit$j$hasFactorUnit.map(_item => ((_item.termType === "BlankNode" ? { "@id": `_:${_item.value}` } : { "@id": _item.value }))),qudt_Unit$j$hasQuantityKind: this.qudt_Unit$j$hasQuantityKind.map(_item => (_item.toJson())),qudt_Unit$j$iec61360Code: this.qudt_Unit$j$iec61360Code.map(_item => (_item)),qudt_Unit$j$latexDefinition: this.qudt_Unit$j$latexDefinition.map(_item => (_item)),qudt_Unit$j$latexSymbol: this.qudt_Unit$j$latexSymbol.map(_item => (_item)),qudt_Unit$j$mathMLdefinition: this.qudt_Unit$j$mathMLdefinition.map(_item => (_item)).extract(),qudt_Unit$j$omUnit: this.qudt_Unit$j$omUnit.map(_item => ((_item.termType === "Literal") ? { "@language": _item.language.length > 0 ? _item.language : undefined, "@type": _item.datatype.value !== "http://www.w3.org/2001/XMLSchema#string" ? _item.datatype.value : undefined, "@value": _item.value, termType: "Literal" as const } : (_item.termType === "NamedNode") ? { "@id": _item.value, termType: "NamedNode" as const } : { "@id": `_:${_item.value}`, termType: "BlankNode" as const })),qudt_Unit$j$prefix: this.qudt_Unit$j$prefix.map(_item => (_item.toJson())).extract(),qudt_Unit$j$qkdvDenominator: this.qudt_Unit$j$qkdvDenominator.map(_item => (_item.toJson())).extract(),qudt_Unit$j$qkdvNumerator: this.qudt_Unit$j$qkdvNumerator.map(_item => (_item.toJson())).extract(),qudt_Unit$j$scalingOf: this.qudt_Unit$j$scalingOf.map(_item => (_item.toJson())).extract(),qudt_Unit$j$siExactMatch: this.qudt_Unit$j$siExactMatch.map(_item => ((_item.termType === "Literal") ? { "@language": _item.language.length > 0 ? _item.language : undefined, "@type": _item.datatype.value !== "http://www.w3.org/2001/XMLSchema#string" ? _item.datatype.value : undefined, "@value": _item.value, termType: "Literal" as const } : (_item.termType === "NamedNode") ? { "@id": _item.value, termType: "NamedNode" as const } : { "@id": `_:${_item.value}`, termType: "BlankNode" as const })).extract(),qudt_Unit$j$siUnitsExpression: this.qudt_Unit$j$siUnitsExpression.map(_item => (_item)),qudt_Unit$j$symbol: this.qudt_Unit$j$symbol.map(_item => ((_item.termType === "Literal") ? { "@language": _item.language.length > 0 ? _item.language : undefined, "@type": _item.datatype.value !== "http://www.w3.org/2001/XMLSchema#string" ? _item.datatype.value : undefined, "@value": _item.value, termType: "Literal" as const } : (_item.termType === "NamedNode") ? { "@id": _item.value, termType: "NamedNode" as const } : { "@id": `_:${_item.value}`, termType: "BlankNode" as const })).extract(),qudt_Unit$j$ucumCode: this.qudt_Unit$j$ucumCode.map(_item => (_item)),qudt_Unit$j$udunitsCode: this.qudt_Unit$j$udunitsCode.map(_item => (_item)),qudt_Unit$j$uneceCommonCode: this.qudt_Unit$j$uneceCommonCode.map(_item => (_item)),qudt_Unit$j$unitOfSystem: this.qudt_Unit$j$unitOfSystem.map(_item => (_item.toJson())) } satisfies ReturnType<Unit["toJson"]>));
    }

    override toRdf({ ignoreRdfType, mutateGraph, resourceSet }: { ignoreRdfType?: boolean; mutateGraph?: rdfjsResource.MutableResource.MutateGraph, resourceSet: rdfjsResource.MutableResourceSet }): rdfjsResource.MutableResource {
        const _resource = super.toRdf({ ignoreRdfType: true, mutateGraph, resourceSet });
        if (!ignoreRdfType) { _resource.add(_resource.dataFactory.namedNode("http://www.w3.org/1999/02/22-rdf-syntax-ns#type"), _resource.dataFactory.namedNode("http://qudt.org/schema/qudt/Unit")); }

        _resource.add(dataFactory.namedNode("http://qudt.org/schema/qudt/altSymbol"), this.qudt_Unit$j$altSymbol.map((_item) => _item));
        _resource.add(dataFactory.namedNode("http://qudt.org/schema/qudt/applicableSystem"), this.qudt_Unit$j$applicableSystem.map((_item) => _item.toRdf({ mutateGraph: mutateGraph, resourceSet: resourceSet })));
        _resource.add(dataFactory.namedNode("http://qudt.org/schema/qudt/conversionMultiplier"), this.qudt_Unit$j$conversionMultiplier);
        _resource.add(dataFactory.namedNode("http://qudt.org/schema/qudt/conversionMultiplierSN"), this.qudt_Unit$j$conversionMultiplierSN);
        _resource.add(dataFactory.namedNode("http://qudt.org/schema/qudt/conversionOffset"), this.qudt_Unit$j$conversionOffset);
        _resource.add(dataFactory.namedNode("http://qudt.org/schema/qudt/conversionOffsetSN"), this.qudt_Unit$j$conversionOffsetSN);
        _resource.add(dataFactory.namedNode("http://qudt.org/schema/qudt/definedUnitOfSystem"), this.qudt_Unit$j$definedUnitOfSystem.map((_item) => _item.toRdf({ mutateGraph: mutateGraph, resourceSet: resourceSet })));
        _resource.add(dataFactory.namedNode("http://qudt.org/schema/qudt/derivedCoherentUnitOfSystem"), this.qudt_Unit$j$derivedCoherentUnitOfSystem.map((_item) => _item.toRdf({ mutateGraph: mutateGraph, resourceSet: resourceSet })));
        _resource.add(dataFactory.namedNode("http://qudt.org/schema/qudt/derivedUnitOfSystem"), this.qudt_Unit$j$derivedUnitOfSystem.map((_item) => _item.toRdf({ mutateGraph: mutateGraph, resourceSet: resourceSet })));
        _resource.add(dataFactory.namedNode("http://qudt.org/schema/qudt/expression"), this.qudt_Unit$j$expression.map((_item) => _item));
        _resource.add(dataFactory.namedNode("http://qudt.org/schema/qudt/factorUnitScalar"), this.qudt_Unit$j$factorUnitScalar);
        _resource.add(dataFactory.namedNode("http://qudt.org/schema/qudt/hasDimensionVector"), this.qudt_Unit$j$hasDimensionVector.toRdf({ mutateGraph: mutateGraph, resourceSet: resourceSet }));
        _resource.add(dataFactory.namedNode("http://qudt.org/schema/qudt/hasFactorUnit"), this.qudt_Unit$j$hasFactorUnit.map((_item) => _item));
        _resource.add(dataFactory.namedNode("http://qudt.org/schema/qudt/hasQuantityKind"), this.qudt_Unit$j$hasQuantityKind.map((_item) => _item.toRdf({ mutateGraph: mutateGraph, resourceSet: resourceSet })));
        _resource.add(dataFactory.namedNode("http://qudt.org/schema/qudt/iec61360Code"), this.qudt_Unit$j$iec61360Code.map((_item) => _item));
        _resource.add(dataFactory.namedNode("http://qudt.org/schema/qudt/latexDefinition"), this.qudt_Unit$j$latexDefinition.map((_item) => _item));
        _resource.add(dataFactory.namedNode("http://qudt.org/schema/qudt/latexSymbol"), this.qudt_Unit$j$latexSymbol.map((_item) => _item));
        _resource.add(dataFactory.namedNode("http://qudt.org/schema/qudt/mathMLdefinition"), this.qudt_Unit$j$mathMLdefinition);
        _resource.add(dataFactory.namedNode("http://qudt.org/schema/qudt/omUnit"), this.qudt_Unit$j$omUnit.map((_item) => _item));
        _resource.add(dataFactory.namedNode("http://qudt.org/schema/qudt/prefix"), this.qudt_Unit$j$prefix.map((_value) => _value.toRdf({ mutateGraph: mutateGraph, resourceSet: resourceSet })));
        _resource.add(dataFactory.namedNode("http://qudt.org/schema/qudt/qkdvDenominator"), this.qudt_Unit$j$qkdvDenominator.map((_value) => _value.toRdf({ mutateGraph: mutateGraph, resourceSet: resourceSet })));
        _resource.add(dataFactory.namedNode("http://qudt.org/schema/qudt/qkdvNumerator"), this.qudt_Unit$j$qkdvNumerator.map((_value) => _value.toRdf({ mutateGraph: mutateGraph, resourceSet: resourceSet })));
        _resource.add(dataFactory.namedNode("http://qudt.org/schema/qudt/scalingOf"), this.qudt_Unit$j$scalingOf.map((_value) => _value.toRdf({ mutateGraph: mutateGraph, resourceSet: resourceSet })));
        _resource.add(dataFactory.namedNode("http://qudt.org/schema/qudt/siExactMatch"), this.qudt_Unit$j$siExactMatch);
        _resource.add(dataFactory.namedNode("http://qudt.org/schema/qudt/siUnitsExpression"), this.qudt_Unit$j$siUnitsExpression.map((_item) => _item));
        _resource.add(dataFactory.namedNode("http://qudt.org/schema/qudt/symbol"), this.qudt_Unit$j$symbol);
        _resource.add(dataFactory.namedNode("http://qudt.org/schema/qudt/ucumCode"), this.qudt_Unit$j$ucumCode.map((_item) => _item));
        _resource.add(dataFactory.namedNode("http://qudt.org/schema/qudt/udunitsCode"), this.qudt_Unit$j$udunitsCode.map((_item) => _item));
        _resource.add(dataFactory.namedNode("http://qudt.org/schema/qudt/uneceCommonCode"), this.qudt_Unit$j$uneceCommonCode.map((_item) => _item));
        _resource.add(dataFactory.namedNode("http://qudt.org/schema/qudt/isUnitOfSystem"), this.qudt_Unit$j$unitOfSystem.map((_item) => _item.toRdf({ mutateGraph: mutateGraph, resourceSet: resourceSet })));
        return _resource;
    }

    override toString(): string {
        return JSON.stringify(this.toJson());
    }
}

export namespace Unit {
    export function _propertiesFromJson(_json: unknown): purify.Either<zod.ZodError, { identifier: (rdfjs.BlankNode | rdfjs.NamedNode); qudt_Unit$j$altSymbol: readonly ((rdfjs.BlankNode | rdfjs.NamedNode | rdfjs.Literal))[]; qudt_Unit$j$applicableSystem: readonly (System_of$W$Units)[]; qudt_Unit$j$conversionMultiplier: purify.Maybe<number>; qudt_Unit$j$conversionMultiplierSN: purify.Maybe<number>; qudt_Unit$j$conversionOffset: purify.Maybe<number>; qudt_Unit$j$conversionOffsetSN: purify.Maybe<number>; qudt_Unit$j$definedUnitOfSystem: readonly (System_of$W$Units)[]; qudt_Unit$j$derivedCoherentUnitOfSystem: readonly (System_of$W$Units)[]; qudt_Unit$j$derivedUnitOfSystem: readonly (System_of$W$Units)[]; qudt_Unit$j$expression: readonly ((rdfjs.BlankNode | rdfjs.NamedNode | rdfjs.Literal))[]; qudt_Unit$j$factorUnitScalar: purify.Maybe<number>; qudt_Unit$j$hasDimensionVector: Quantity_Kind$W$Dimension$W$Vector; qudt_Unit$j$hasFactorUnit: readonly ((rdfjs.BlankNode | rdfjs.NamedNode))[]; qudt_Unit$j$hasQuantityKind: purify.NonEmptyList<Quantity_Kind>; qudt_Unit$j$iec61360Code: readonly (string)[]; qudt_Unit$j$latexDefinition: readonly (string)[]; qudt_Unit$j$latexSymbol: readonly (string)[]; qudt_Unit$j$mathMLdefinition: purify.Maybe<string>; qudt_Unit$j$omUnit: readonly ((rdfjs.BlankNode | rdfjs.NamedNode | rdfjs.Literal))[]; qudt_Unit$j$prefix: purify.Maybe<Prefix>; qudt_Unit$j$qkdvDenominator: purify.Maybe<Quantity_Kind$W$Dimension$W$Vector>; qudt_Unit$j$qkdvNumerator: purify.Maybe<Quantity_Kind$W$Dimension$W$Vector>; qudt_Unit$j$scalingOf: purify.Maybe<Abstract_Unit>; qudt_Unit$j$siExactMatch: purify.Maybe<(rdfjs.BlankNode | rdfjs.NamedNode | rdfjs.Literal)>; qudt_Unit$j$siUnitsExpression: readonly (string)[]; qudt_Unit$j$symbol: purify.Maybe<(rdfjs.BlankNode | rdfjs.NamedNode | rdfjs.Literal)>; qudt_Unit$j$ucumCode: readonly (string)[]; qudt_Unit$j$udunitsCode: readonly (string)[]; qudt_Unit$j$uneceCommonCode: readonly (string)[]; qudt_Unit$j$unitOfSystem: readonly (System_of$W$Units)[]; } & UnwrapR<ReturnType<typeof Abstract_Unit._propertiesFromJson>>> {
        const _jsonSafeParseResult = unitJsonZodSchema().safeParse(_json);
        if (!_jsonSafeParseResult.success) { return purify.Left(_jsonSafeParseResult.error); }

        const _jsonObject = _jsonSafeParseResult.data;
        const _super0Either = Abstract_Unit._propertiesFromJson(_jsonObject);
        if (_super0Either.isLeft()) { return _super0Either; }

        const _super0 = _super0Either.unsafeCoerce()
        const identifier = (_jsonObject["@id"].startsWith("_:") ? dataFactory.blankNode(_jsonObject["@id"].substring(2)) : dataFactory.namedNode(_jsonObject["@id"]));
        const qudt_Unit$j$altSymbol = _jsonObject["qudt_Unit$j$altSymbol"].map(_item => (((_item.termType === "Literal") ? (dataFactory.literal(_item["@value"], typeof _item["@language"] !== "undefined" ? _item["@language"] : (typeof _item["@type"] !== "undefined" ? dataFactory.namedNode(_item["@type"]) : undefined))) : (((_item.termType === "NamedNode") ? (dataFactory.namedNode(_item["@id"])) : (dataFactory.blankNode(_item["@id"].substring(2))))))));
        const qudt_Unit$j$applicableSystem = _jsonObject["qudt_Unit$j$applicableSystem"].map(_item => (System_of$W$Units.fromJson(_item).unsafeCoerce()));
        const qudt_Unit$j$conversionMultiplier = purify.Maybe.fromNullable(_jsonObject["qudt_Unit$j$conversionMultiplier"]);
        const qudt_Unit$j$conversionMultiplierSN = purify.Maybe.fromNullable(_jsonObject["qudt_Unit$j$conversionMultiplierSN"]);
        const qudt_Unit$j$conversionOffset = purify.Maybe.fromNullable(_jsonObject["qudt_Unit$j$conversionOffset"]);
        const qudt_Unit$j$conversionOffsetSN = purify.Maybe.fromNullable(_jsonObject["qudt_Unit$j$conversionOffsetSN"]);
        const qudt_Unit$j$definedUnitOfSystem = _jsonObject["qudt_Unit$j$definedUnitOfSystem"].map(_item => (System_of$W$Units.fromJson(_item).unsafeCoerce()));
        const qudt_Unit$j$derivedCoherentUnitOfSystem = _jsonObject["qudt_Unit$j$derivedCoherentUnitOfSystem"].map(_item => (System_of$W$Units.fromJson(_item).unsafeCoerce()));
        const qudt_Unit$j$derivedUnitOfSystem = _jsonObject["qudt_Unit$j$derivedUnitOfSystem"].map(_item => (System_of$W$Units.fromJson(_item).unsafeCoerce()));
        const qudt_Unit$j$expression = _jsonObject["qudt_Unit$j$expression"].map(_item => (((_item.termType === "Literal") ? (dataFactory.literal(_item["@value"], typeof _item["@language"] !== "undefined" ? _item["@language"] : (typeof _item["@type"] !== "undefined" ? dataFactory.namedNode(_item["@type"]) : undefined))) : (((_item.termType === "NamedNode") ? (dataFactory.namedNode(_item["@id"])) : (dataFactory.blankNode(_item["@id"].substring(2))))))));
        const qudt_Unit$j$factorUnitScalar = purify.Maybe.fromNullable(_jsonObject["qudt_Unit$j$factorUnitScalar"]);
        const qudt_Unit$j$hasDimensionVector = Quantity_Kind$W$Dimension$W$Vector.fromJson(_jsonObject["qudt_Unit$j$hasDimensionVector"]).unsafeCoerce();
        const qudt_Unit$j$hasFactorUnit = _jsonObject["qudt_Unit$j$hasFactorUnit"].map(_item => ((_item["@id"].startsWith("_:") ? dataFactory.blankNode(_item["@id"].substring(2)) : dataFactory.namedNode(_item["@id"]))));
        const qudt_Unit$j$hasQuantityKind = purify.NonEmptyList.fromArray(_jsonObject["qudt_Unit$j$hasQuantityKind"]).unsafeCoerce().map(_item => (Quantity_Kind.fromJson(_item).unsafeCoerce()));
        const qudt_Unit$j$iec61360Code = _jsonObject["qudt_Unit$j$iec61360Code"];
        const qudt_Unit$j$latexDefinition = _jsonObject["qudt_Unit$j$latexDefinition"];
        const qudt_Unit$j$latexSymbol = _jsonObject["qudt_Unit$j$latexSymbol"];
        const qudt_Unit$j$mathMLdefinition = purify.Maybe.fromNullable(_jsonObject["qudt_Unit$j$mathMLdefinition"]);
        const qudt_Unit$j$omUnit = _jsonObject["qudt_Unit$j$omUnit"].map(_item => (((_item.termType === "Literal") ? (dataFactory.literal(_item["@value"], typeof _item["@language"] !== "undefined" ? _item["@language"] : (typeof _item["@type"] !== "undefined" ? dataFactory.namedNode(_item["@type"]) : undefined))) : (((_item.termType === "NamedNode") ? (dataFactory.namedNode(_item["@id"])) : (dataFactory.blankNode(_item["@id"].substring(2))))))));
        const qudt_Unit$j$prefix = purify.Maybe.fromNullable(_jsonObject["qudt_Unit$j$prefix"]).map(_item => (Prefix.fromJson(_item).unsafeCoerce()));
        const qudt_Unit$j$qkdvDenominator = purify.Maybe.fromNullable(_jsonObject["qudt_Unit$j$qkdvDenominator"]).map(_item => (Quantity_Kind$W$Dimension$W$Vector.fromJson(_item).unsafeCoerce()));
        const qudt_Unit$j$qkdvNumerator = purify.Maybe.fromNullable(_jsonObject["qudt_Unit$j$qkdvNumerator"]).map(_item => (Quantity_Kind$W$Dimension$W$Vector.fromJson(_item).unsafeCoerce()));
        const qudt_Unit$j$scalingOf = purify.Maybe.fromNullable(_jsonObject["qudt_Unit$j$scalingOf"]).map(_item => (Abstract_Unit.fromJson(_item).unsafeCoerce()));
        const qudt_Unit$j$siExactMatch = purify.Maybe.fromNullable(_jsonObject["qudt_Unit$j$siExactMatch"]).map(_item => (((_item.termType === "Literal") ? (dataFactory.literal(_item["@value"], typeof _item["@language"] !== "undefined" ? _item["@language"] : (typeof _item["@type"] !== "undefined" ? dataFactory.namedNode(_item["@type"]) : undefined))) : (((_item.termType === "NamedNode") ? (dataFactory.namedNode(_item["@id"])) : (dataFactory.blankNode(_item["@id"].substring(2))))))));
        const qudt_Unit$j$siUnitsExpression = _jsonObject["qudt_Unit$j$siUnitsExpression"];
        const qudt_Unit$j$symbol = purify.Maybe.fromNullable(_jsonObject["qudt_Unit$j$symbol"]).map(_item => (((_item.termType === "Literal") ? (dataFactory.literal(_item["@value"], typeof _item["@language"] !== "undefined" ? _item["@language"] : (typeof _item["@type"] !== "undefined" ? dataFactory.namedNode(_item["@type"]) : undefined))) : (((_item.termType === "NamedNode") ? (dataFactory.namedNode(_item["@id"])) : (dataFactory.blankNode(_item["@id"].substring(2))))))));
        const qudt_Unit$j$ucumCode = _jsonObject["qudt_Unit$j$ucumCode"];
        const qudt_Unit$j$udunitsCode = _jsonObject["qudt_Unit$j$udunitsCode"];
        const qudt_Unit$j$uneceCommonCode = _jsonObject["qudt_Unit$j$uneceCommonCode"];
        const qudt_Unit$j$unitOfSystem = _jsonObject["qudt_Unit$j$unitOfSystem"].map(_item => (System_of$W$Units.fromJson(_item).unsafeCoerce()));
        return purify.Either.of({ ..._super0, identifier, qudt_Unit$j$altSymbol, qudt_Unit$j$applicableSystem, qudt_Unit$j$conversionMultiplier, qudt_Unit$j$conversionMultiplierSN, qudt_Unit$j$conversionOffset, qudt_Unit$j$conversionOffsetSN, qudt_Unit$j$definedUnitOfSystem, qudt_Unit$j$derivedCoherentUnitOfSystem, qudt_Unit$j$derivedUnitOfSystem, qudt_Unit$j$expression, qudt_Unit$j$factorUnitScalar, qudt_Unit$j$hasDimensionVector, qudt_Unit$j$hasFactorUnit, qudt_Unit$j$hasQuantityKind, qudt_Unit$j$iec61360Code, qudt_Unit$j$latexDefinition, qudt_Unit$j$latexSymbol, qudt_Unit$j$mathMLdefinition, qudt_Unit$j$omUnit, qudt_Unit$j$prefix, qudt_Unit$j$qkdvDenominator, qudt_Unit$j$qkdvNumerator, qudt_Unit$j$scalingOf, qudt_Unit$j$siExactMatch, qudt_Unit$j$siUnitsExpression, qudt_Unit$j$symbol, qudt_Unit$j$ucumCode, qudt_Unit$j$udunitsCode, qudt_Unit$j$uneceCommonCode, qudt_Unit$j$unitOfSystem })
    }

    export function fromJson(json: unknown): purify.Either<zod.ZodError, Unit> {
        return (Dimensionless_Unit.fromJson(json) as purify.Either<zod.ZodError, Unit>).altLazy(() => (Contextual_Unit.fromJson(json) as purify.Either<zod.ZodError, Unit>)).altLazy(() => (Derived_Unit.fromJson(json) as purify.Either<zod.ZodError, Unit>)).altLazy(() => Unit._propertiesFromJson(json).map(properties => new Unit(properties)));
    }

    export function _propertiesFromRdf({ ignoreRdfType: _ignoreRdfType, languageIn: _languageIn, resource: _resource,
        // @ts-ignore
        ..._context }: { [_index: string]: any; ignoreRdfType?: boolean; languageIn?: readonly string[]; resource: rdfjsResource.Resource; }): purify.Either<rdfjsResource.Resource.ValueError, { identifier: (rdfjs.BlankNode | rdfjs.NamedNode); qudt_Unit$j$altSymbol: readonly ((rdfjs.BlankNode | rdfjs.NamedNode | rdfjs.Literal))[]; qudt_Unit$j$applicableSystem: readonly (System_of$W$Units)[]; qudt_Unit$j$conversionMultiplier: purify.Maybe<number>; qudt_Unit$j$conversionMultiplierSN: purify.Maybe<number>; qudt_Unit$j$conversionOffset: purify.Maybe<number>; qudt_Unit$j$conversionOffsetSN: purify.Maybe<number>; qudt_Unit$j$definedUnitOfSystem: readonly (System_of$W$Units)[]; qudt_Unit$j$derivedCoherentUnitOfSystem: readonly (System_of$W$Units)[]; qudt_Unit$j$derivedUnitOfSystem: readonly (System_of$W$Units)[]; qudt_Unit$j$expression: readonly ((rdfjs.BlankNode | rdfjs.NamedNode | rdfjs.Literal))[]; qudt_Unit$j$factorUnitScalar: purify.Maybe<number>; qudt_Unit$j$hasDimensionVector: Quantity_Kind$W$Dimension$W$Vector; qudt_Unit$j$hasFactorUnit: readonly ((rdfjs.BlankNode | rdfjs.NamedNode))[]; qudt_Unit$j$hasQuantityKind: purify.NonEmptyList<Quantity_Kind>; qudt_Unit$j$iec61360Code: readonly (string)[]; qudt_Unit$j$latexDefinition: readonly (string)[]; qudt_Unit$j$latexSymbol: readonly (string)[]; qudt_Unit$j$mathMLdefinition: purify.Maybe<string>; qudt_Unit$j$omUnit: readonly ((rdfjs.BlankNode | rdfjs.NamedNode | rdfjs.Literal))[]; qudt_Unit$j$prefix: purify.Maybe<Prefix>; qudt_Unit$j$qkdvDenominator: purify.Maybe<Quantity_Kind$W$Dimension$W$Vector>; qudt_Unit$j$qkdvNumerator: purify.Maybe<Quantity_Kind$W$Dimension$W$Vector>; qudt_Unit$j$scalingOf: purify.Maybe<Abstract_Unit>; qudt_Unit$j$siExactMatch: purify.Maybe<(rdfjs.BlankNode | rdfjs.NamedNode | rdfjs.Literal)>; qudt_Unit$j$siUnitsExpression: readonly (string)[]; qudt_Unit$j$symbol: purify.Maybe<(rdfjs.BlankNode | rdfjs.NamedNode | rdfjs.Literal)>; qudt_Unit$j$ucumCode: readonly (string)[]; qudt_Unit$j$udunitsCode: readonly (string)[]; qudt_Unit$j$uneceCommonCode: readonly (string)[]; qudt_Unit$j$unitOfSystem: readonly (System_of$W$Units)[]; } & UnwrapR<ReturnType<typeof Abstract_Unit._propertiesFromRdf>>> {
        const _super0Either = Abstract_Unit._propertiesFromRdf({ ..._context, ignoreRdfType: true, languageIn: _languageIn, resource: _resource });
        if (_super0Either.isLeft()) { return _super0Either; }

        const _super0 = _super0Either.unsafeCoerce()
        if (!_ignoreRdfType && !_resource.isInstanceOf(dataFactory.namedNode("http://qudt.org/schema/qudt/Unit"))) { return purify.Left(new rdfjsResource.Resource.ValueError({ focusResource: _resource, message: `${rdfjsResource.Resource.Identifier.toString(_resource.identifier)} has unexpected RDF type (expected http://qudt.org/schema/qudt/Unit)`, predicate: dataFactory.namedNode("http://qudt.org/schema/qudt/Unit") })); }

        const identifier = _resource.identifier
        const _qudt_Unit$j$altSymbolEither: purify.Either<rdfjsResource.Resource.ValueError, readonly ((rdfjs.BlankNode | rdfjs.NamedNode | rdfjs.Literal))[]> = purify.Either.of([..._resource.values(dataFactory.namedNode("http://qudt.org/schema/qudt/altSymbol"), { unique: true }).flatMap(_item => _item.toValues().head().chain(_value => purify.Either.of(_value.toTerm())).toMaybe().toList())]);
        if (_qudt_Unit$j$altSymbolEither.isLeft()) { return _qudt_Unit$j$altSymbolEither; }

        const qudt_Unit$j$altSymbol = _qudt_Unit$j$altSymbolEither.unsafeCoerce();
        const _qudt_Unit$j$applicableSystemEither: purify.Either<rdfjsResource.Resource.ValueError, readonly (System_of$W$Units)[]> = purify.Either.of([..._resource.values(dataFactory.namedNode("http://qudt.org/schema/qudt/applicableSystem"), { unique: true }).flatMap(_item => _item.toValues().head().chain(value => value.toResource()).chain(_resource => System_of$W$Units.fromRdf({ ..._context, ignoreRdfType: true, languageIn: _languageIn, resource: _resource })).toMaybe().toList())]);
        if (_qudt_Unit$j$applicableSystemEither.isLeft()) { return _qudt_Unit$j$applicableSystemEither; }

        const qudt_Unit$j$applicableSystem = _qudt_Unit$j$applicableSystemEither.unsafeCoerce();
        const _qudt_Unit$j$conversionMultiplierEither: purify.Either<rdfjsResource.Resource.ValueError, purify.Maybe<number>> = purify.Either.of(_resource.values(dataFactory.namedNode("http://qudt.org/schema/qudt/conversionMultiplier"), { unique: true }).head().chain(_value => _value.toNumber()).toMaybe());
        if (_qudt_Unit$j$conversionMultiplierEither.isLeft()) { return _qudt_Unit$j$conversionMultiplierEither; }

        const qudt_Unit$j$conversionMultiplier = _qudt_Unit$j$conversionMultiplierEither.unsafeCoerce();
        const _qudt_Unit$j$conversionMultiplierSNEither: purify.Either<rdfjsResource.Resource.ValueError, purify.Maybe<number>> = purify.Either.of(_resource.values(dataFactory.namedNode("http://qudt.org/schema/qudt/conversionMultiplierSN"), { unique: true }).head().chain(_value => _value.toNumber()).toMaybe());
        if (_qudt_Unit$j$conversionMultiplierSNEither.isLeft()) { return _qudt_Unit$j$conversionMultiplierSNEither; }

        const qudt_Unit$j$conversionMultiplierSN = _qudt_Unit$j$conversionMultiplierSNEither.unsafeCoerce();
        const _qudt_Unit$j$conversionOffsetEither: purify.Either<rdfjsResource.Resource.ValueError, purify.Maybe<number>> = purify.Either.of(_resource.values(dataFactory.namedNode("http://qudt.org/schema/qudt/conversionOffset"), { unique: true }).head().chain(_value => _value.toNumber()).toMaybe());
        if (_qudt_Unit$j$conversionOffsetEither.isLeft()) { return _qudt_Unit$j$conversionOffsetEither; }

        const qudt_Unit$j$conversionOffset = _qudt_Unit$j$conversionOffsetEither.unsafeCoerce();
        const _qudt_Unit$j$conversionOffsetSNEither: purify.Either<rdfjsResource.Resource.ValueError, purify.Maybe<number>> = purify.Either.of(_resource.values(dataFactory.namedNode("http://qudt.org/schema/qudt/conversionOffsetSN"), { unique: true }).head().chain(_value => _value.toNumber()).toMaybe());
        if (_qudt_Unit$j$conversionOffsetSNEither.isLeft()) { return _qudt_Unit$j$conversionOffsetSNEither; }

        const qudt_Unit$j$conversionOffsetSN = _qudt_Unit$j$conversionOffsetSNEither.unsafeCoerce();
        const _qudt_Unit$j$definedUnitOfSystemEither: purify.Either<rdfjsResource.Resource.ValueError, readonly (System_of$W$Units)[]> = purify.Either.of([..._resource.values(dataFactory.namedNode("http://qudt.org/schema/qudt/definedUnitOfSystem"), { unique: true }).flatMap(_item => _item.toValues().head().chain(value => value.toResource()).chain(_resource => System_of$W$Units.fromRdf({ ..._context, ignoreRdfType: true, languageIn: _languageIn, resource: _resource })).toMaybe().toList())]);
        if (_qudt_Unit$j$definedUnitOfSystemEither.isLeft()) { return _qudt_Unit$j$definedUnitOfSystemEither; }

        const qudt_Unit$j$definedUnitOfSystem = _qudt_Unit$j$definedUnitOfSystemEither.unsafeCoerce();
        const _qudt_Unit$j$derivedCoherentUnitOfSystemEither: purify.Either<rdfjsResource.Resource.ValueError, readonly (System_of$W$Units)[]> = purify.Either.of([..._resource.values(dataFactory.namedNode("http://qudt.org/schema/qudt/derivedCoherentUnitOfSystem"), { unique: true }).flatMap(_item => _item.toValues().head().chain(value => value.toResource()).chain(_resource => System_of$W$Units.fromRdf({ ..._context, ignoreRdfType: true, languageIn: _languageIn, resource: _resource })).toMaybe().toList())]);
        if (_qudt_Unit$j$derivedCoherentUnitOfSystemEither.isLeft()) { return _qudt_Unit$j$derivedCoherentUnitOfSystemEither; }

        const qudt_Unit$j$derivedCoherentUnitOfSystem = _qudt_Unit$j$derivedCoherentUnitOfSystemEither.unsafeCoerce();
        const _qudt_Unit$j$derivedUnitOfSystemEither: purify.Either<rdfjsResource.Resource.ValueError, readonly (System_of$W$Units)[]> = purify.Either.of([..._resource.values(dataFactory.namedNode("http://qudt.org/schema/qudt/derivedUnitOfSystem"), { unique: true }).flatMap(_item => _item.toValues().head().chain(value => value.toResource()).chain(_resource => System_of$W$Units.fromRdf({ ..._context, ignoreRdfType: true, languageIn: _languageIn, resource: _resource })).toMaybe().toList())]);
        if (_qudt_Unit$j$derivedUnitOfSystemEither.isLeft()) { return _qudt_Unit$j$derivedUnitOfSystemEither; }

        const qudt_Unit$j$derivedUnitOfSystem = _qudt_Unit$j$derivedUnitOfSystemEither.unsafeCoerce();
        const _qudt_Unit$j$expressionEither: purify.Either<rdfjsResource.Resource.ValueError, readonly ((rdfjs.BlankNode | rdfjs.NamedNode | rdfjs.Literal))[]> = purify.Either.of([..._resource.values(dataFactory.namedNode("http://qudt.org/schema/qudt/expression"), { unique: true }).flatMap(_item => _item.toValues().head().chain(_value => purify.Either.of(_value.toTerm())).toMaybe().toList())]);
        if (_qudt_Unit$j$expressionEither.isLeft()) { return _qudt_Unit$j$expressionEither; }

        const qudt_Unit$j$expression = _qudt_Unit$j$expressionEither.unsafeCoerce();
        const _qudt_Unit$j$factorUnitScalarEither: purify.Either<rdfjsResource.Resource.ValueError, purify.Maybe<number>> = purify.Either.of(_resource.values(dataFactory.namedNode("http://qudt.org/schema/qudt/factorUnitScalar"), { unique: true }).head().chain(_value => _value.toNumber()).toMaybe());
        if (_qudt_Unit$j$factorUnitScalarEither.isLeft()) { return _qudt_Unit$j$factorUnitScalarEither; }

        const qudt_Unit$j$factorUnitScalar = _qudt_Unit$j$factorUnitScalarEither.unsafeCoerce();
        const _qudt_Unit$j$hasDimensionVectorEither: purify.Either<rdfjsResource.Resource.ValueError, Quantity_Kind$W$Dimension$W$Vector> = _resource.values(dataFactory.namedNode("http://qudt.org/schema/qudt/hasDimensionVector"), { unique: true }).head().chain(value => value.toResource()).chain(_resource => Quantity_Kind$W$Dimension$W$Vector.fromRdf({ ..._context, ignoreRdfType: true, languageIn: _languageIn, resource: _resource }));
        if (_qudt_Unit$j$hasDimensionVectorEither.isLeft()) { return _qudt_Unit$j$hasDimensionVectorEither; }

        const qudt_Unit$j$hasDimensionVector = _qudt_Unit$j$hasDimensionVectorEither.unsafeCoerce();
        const _qudt_Unit$j$hasFactorUnitEither: purify.Either<rdfjsResource.Resource.ValueError, readonly ((rdfjs.BlankNode | rdfjs.NamedNode))[]> = purify.Either.of([..._resource.values(dataFactory.namedNode("http://qudt.org/schema/qudt/hasFactorUnit"), { unique: true }).flatMap(_item => _item.toValues().head().chain(_value => _value.toIdentifier()).toMaybe().toList())]);
        if (_qudt_Unit$j$hasFactorUnitEither.isLeft()) { return _qudt_Unit$j$hasFactorUnitEither; }

        const qudt_Unit$j$hasFactorUnit = _qudt_Unit$j$hasFactorUnitEither.unsafeCoerce();
        const _qudt_Unit$j$hasQuantityKindEither: purify.Either<rdfjsResource.Resource.ValueError, purify.NonEmptyList<Quantity_Kind>> = purify.NonEmptyList.fromArray([..._resource.values(dataFactory.namedNode("http://qudt.org/schema/qudt/hasQuantityKind"), { unique: true }).flatMap(_item => _item.toValues().head().chain(value => value.toResource()).chain(_resource => Quantity_Kind.fromRdf({ ..._context, ignoreRdfType: true, languageIn: _languageIn, resource: _resource })).toMaybe().toList())]).toEither(new rdfjsResource.Resource.ValueError({ focusResource: _resource, message: `${rdfjsResource.Resource.Identifier.toString(_resource.identifier)} is empty`, predicate: dataFactory.namedNode("http://qudt.org/schema/qudt/hasQuantityKind") }));
        if (_qudt_Unit$j$hasQuantityKindEither.isLeft()) { return _qudt_Unit$j$hasQuantityKindEither; }

        const qudt_Unit$j$hasQuantityKind = _qudt_Unit$j$hasQuantityKindEither.unsafeCoerce();
        const _qudt_Unit$j$iec61360CodeEither: purify.Either<rdfjsResource.Resource.ValueError, readonly (string)[]> = purify.Either.of([..._resource.values(dataFactory.namedNode("http://qudt.org/schema/qudt/iec61360Code"), { unique: true }).flatMap(_item => _item.toValues().head().chain(_value => _value.toString()).toMaybe().toList())]);
        if (_qudt_Unit$j$iec61360CodeEither.isLeft()) { return _qudt_Unit$j$iec61360CodeEither; }

        const qudt_Unit$j$iec61360Code = _qudt_Unit$j$iec61360CodeEither.unsafeCoerce();
        const _qudt_Unit$j$latexDefinitionEither: purify.Either<rdfjsResource.Resource.ValueError, readonly (string)[]> = purify.Either.of([..._resource.values(dataFactory.namedNode("http://qudt.org/schema/qudt/latexDefinition"), { unique: true }).flatMap(_item => _item.toValues().head().chain(_value => _value.toString()).toMaybe().toList())]);
        if (_qudt_Unit$j$latexDefinitionEither.isLeft()) { return _qudt_Unit$j$latexDefinitionEither; }

        const qudt_Unit$j$latexDefinition = _qudt_Unit$j$latexDefinitionEither.unsafeCoerce();
        const _qudt_Unit$j$latexSymbolEither: purify.Either<rdfjsResource.Resource.ValueError, readonly (string)[]> = purify.Either.of([..._resource.values(dataFactory.namedNode("http://qudt.org/schema/qudt/latexSymbol"), { unique: true }).flatMap(_item => _item.toValues().head().chain(_value => _value.toString()).toMaybe().toList())]);
        if (_qudt_Unit$j$latexSymbolEither.isLeft()) { return _qudt_Unit$j$latexSymbolEither; }

        const qudt_Unit$j$latexSymbol = _qudt_Unit$j$latexSymbolEither.unsafeCoerce();
        const _qudt_Unit$j$mathMLdefinitionEither: purify.Either<rdfjsResource.Resource.ValueError, purify.Maybe<string>> = purify.Either.of(_resource.values(dataFactory.namedNode("http://qudt.org/schema/qudt/mathMLdefinition"), { unique: true }).head().chain(_value => _value.toString()).toMaybe());
        if (_qudt_Unit$j$mathMLdefinitionEither.isLeft()) { return _qudt_Unit$j$mathMLdefinitionEither; }

        const qudt_Unit$j$mathMLdefinition = _qudt_Unit$j$mathMLdefinitionEither.unsafeCoerce();
        const _qudt_Unit$j$omUnitEither: purify.Either<rdfjsResource.Resource.ValueError, readonly ((rdfjs.BlankNode | rdfjs.NamedNode | rdfjs.Literal))[]> = purify.Either.of([..._resource.values(dataFactory.namedNode("http://qudt.org/schema/qudt/omUnit"), { unique: true }).flatMap(_item => _item.toValues().head().chain(_value => purify.Either.of(_value.toTerm())).toMaybe().toList())]);
        if (_qudt_Unit$j$omUnitEither.isLeft()) { return _qudt_Unit$j$omUnitEither; }

        const qudt_Unit$j$omUnit = _qudt_Unit$j$omUnitEither.unsafeCoerce();
        const _qudt_Unit$j$prefixEither: purify.Either<rdfjsResource.Resource.ValueError, purify.Maybe<Prefix>> = purify.Either.of(_resource.values(dataFactory.namedNode("http://qudt.org/schema/qudt/prefix"), { unique: true }).head().chain(value => value.toResource()).chain(_resource => Prefix.fromRdf({ ..._context, ignoreRdfType: true, languageIn: _languageIn, resource: _resource })).toMaybe());
        if (_qudt_Unit$j$prefixEither.isLeft()) { return _qudt_Unit$j$prefixEither; }

        const qudt_Unit$j$prefix = _qudt_Unit$j$prefixEither.unsafeCoerce();
        const _qudt_Unit$j$qkdvDenominatorEither: purify.Either<rdfjsResource.Resource.ValueError, purify.Maybe<Quantity_Kind$W$Dimension$W$Vector>> = purify.Either.of(_resource.values(dataFactory.namedNode("http://qudt.org/schema/qudt/qkdvDenominator"), { unique: true }).head().chain(value => value.toResource()).chain(_resource => Quantity_Kind$W$Dimension$W$Vector.fromRdf({ ..._context, ignoreRdfType: true, languageIn: _languageIn, resource: _resource })).toMaybe());
        if (_qudt_Unit$j$qkdvDenominatorEither.isLeft()) { return _qudt_Unit$j$qkdvDenominatorEither; }

        const qudt_Unit$j$qkdvDenominator = _qudt_Unit$j$qkdvDenominatorEither.unsafeCoerce();
        const _qudt_Unit$j$qkdvNumeratorEither: purify.Either<rdfjsResource.Resource.ValueError, purify.Maybe<Quantity_Kind$W$Dimension$W$Vector>> = purify.Either.of(_resource.values(dataFactory.namedNode("http://qudt.org/schema/qudt/qkdvNumerator"), { unique: true }).head().chain(value => value.toResource()).chain(_resource => Quantity_Kind$W$Dimension$W$Vector.fromRdf({ ..._context, ignoreRdfType: true, languageIn: _languageIn, resource: _resource })).toMaybe());
        if (_qudt_Unit$j$qkdvNumeratorEither.isLeft()) { return _qudt_Unit$j$qkdvNumeratorEither; }

        const qudt_Unit$j$qkdvNumerator = _qudt_Unit$j$qkdvNumeratorEither.unsafeCoerce();
        const _qudt_Unit$j$scalingOfEither: purify.Either<rdfjsResource.Resource.ValueError, purify.Maybe<Abstract_Unit>> = purify.Either.of(_resource.values(dataFactory.namedNode("http://qudt.org/schema/qudt/scalingOf"), { unique: true }).head().chain(value => value.toResource()).chain(_resource => Abstract_Unit.fromRdf({ ..._context, ignoreRdfType: true, languageIn: _languageIn, resource: _resource })).toMaybe());
        if (_qudt_Unit$j$scalingOfEither.isLeft()) { return _qudt_Unit$j$scalingOfEither; }

        const qudt_Unit$j$scalingOf = _qudt_Unit$j$scalingOfEither.unsafeCoerce();
        const _qudt_Unit$j$siExactMatchEither: purify.Either<rdfjsResource.Resource.ValueError, purify.Maybe<(rdfjs.BlankNode | rdfjs.NamedNode | rdfjs.Literal)>> = purify.Either.of(_resource.values(dataFactory.namedNode("http://qudt.org/schema/qudt/siExactMatch"), { unique: true }).head().chain(_value => purify.Either.of(_value.toTerm())).toMaybe());
        if (_qudt_Unit$j$siExactMatchEither.isLeft()) { return _qudt_Unit$j$siExactMatchEither; }

        const qudt_Unit$j$siExactMatch = _qudt_Unit$j$siExactMatchEither.unsafeCoerce();
        const _qudt_Unit$j$siUnitsExpressionEither: purify.Either<rdfjsResource.Resource.ValueError, readonly (string)[]> = purify.Either.of([..._resource.values(dataFactory.namedNode("http://qudt.org/schema/qudt/siUnitsExpression"), { unique: true }).flatMap(_item => _item.toValues().head().chain(_value => _value.toString()).toMaybe().toList())]);
        if (_qudt_Unit$j$siUnitsExpressionEither.isLeft()) { return _qudt_Unit$j$siUnitsExpressionEither; }

        const qudt_Unit$j$siUnitsExpression = _qudt_Unit$j$siUnitsExpressionEither.unsafeCoerce();
        const _qudt_Unit$j$symbolEither: purify.Either<rdfjsResource.Resource.ValueError, purify.Maybe<(rdfjs.BlankNode | rdfjs.NamedNode | rdfjs.Literal)>> = purify.Either.of(_resource.values(dataFactory.namedNode("http://qudt.org/schema/qudt/symbol"), { unique: true }).head().chain(_value => purify.Either.of(_value.toTerm())).toMaybe());
        if (_qudt_Unit$j$symbolEither.isLeft()) { return _qudt_Unit$j$symbolEither; }

        const qudt_Unit$j$symbol = _qudt_Unit$j$symbolEither.unsafeCoerce();
        const _qudt_Unit$j$ucumCodeEither: purify.Either<rdfjsResource.Resource.ValueError, readonly (string)[]> = purify.Either.of([..._resource.values(dataFactory.namedNode("http://qudt.org/schema/qudt/ucumCode"), { unique: true }).flatMap(_item => _item.toValues().head().chain(_value => _value.toString()).toMaybe().toList())]);
        if (_qudt_Unit$j$ucumCodeEither.isLeft()) { return _qudt_Unit$j$ucumCodeEither; }

        const qudt_Unit$j$ucumCode = _qudt_Unit$j$ucumCodeEither.unsafeCoerce();
        const _qudt_Unit$j$udunitsCodeEither: purify.Either<rdfjsResource.Resource.ValueError, readonly (string)[]> = purify.Either.of([..._resource.values(dataFactory.namedNode("http://qudt.org/schema/qudt/udunitsCode"), { unique: true }).flatMap(_item => _item.toValues().head().chain(_value => _value.toString()).toMaybe().toList())]);
        if (_qudt_Unit$j$udunitsCodeEither.isLeft()) { return _qudt_Unit$j$udunitsCodeEither; }

        const qudt_Unit$j$udunitsCode = _qudt_Unit$j$udunitsCodeEither.unsafeCoerce();
        const _qudt_Unit$j$uneceCommonCodeEither: purify.Either<rdfjsResource.Resource.ValueError, readonly (string)[]> = purify.Either.of([..._resource.values(dataFactory.namedNode("http://qudt.org/schema/qudt/uneceCommonCode"), { unique: true }).flatMap(_item => _item.toValues().head().chain(_value => _value.toString()).toMaybe().toList())]);
        if (_qudt_Unit$j$uneceCommonCodeEither.isLeft()) { return _qudt_Unit$j$uneceCommonCodeEither; }

        const qudt_Unit$j$uneceCommonCode = _qudt_Unit$j$uneceCommonCodeEither.unsafeCoerce();
        const _qudt_Unit$j$unitOfSystemEither: purify.Either<rdfjsResource.Resource.ValueError, readonly (System_of$W$Units)[]> = purify.Either.of([..._resource.values(dataFactory.namedNode("http://qudt.org/schema/qudt/isUnitOfSystem"), { unique: true }).flatMap(_item => _item.toValues().head().chain(value => value.toResource()).chain(_resource => System_of$W$Units.fromRdf({ ..._context, ignoreRdfType: true, languageIn: _languageIn, resource: _resource })).toMaybe().toList())]);
        if (_qudt_Unit$j$unitOfSystemEither.isLeft()) { return _qudt_Unit$j$unitOfSystemEither; }

        const qudt_Unit$j$unitOfSystem = _qudt_Unit$j$unitOfSystemEither.unsafeCoerce();
        return purify.Either.of({ ..._super0, identifier, qudt_Unit$j$altSymbol, qudt_Unit$j$applicableSystem, qudt_Unit$j$conversionMultiplier, qudt_Unit$j$conversionMultiplierSN, qudt_Unit$j$conversionOffset, qudt_Unit$j$conversionOffsetSN, qudt_Unit$j$definedUnitOfSystem, qudt_Unit$j$derivedCoherentUnitOfSystem, qudt_Unit$j$derivedUnitOfSystem, qudt_Unit$j$expression, qudt_Unit$j$factorUnitScalar, qudt_Unit$j$hasDimensionVector, qudt_Unit$j$hasFactorUnit, qudt_Unit$j$hasQuantityKind, qudt_Unit$j$iec61360Code, qudt_Unit$j$latexDefinition, qudt_Unit$j$latexSymbol, qudt_Unit$j$mathMLdefinition, qudt_Unit$j$omUnit, qudt_Unit$j$prefix, qudt_Unit$j$qkdvDenominator, qudt_Unit$j$qkdvNumerator, qudt_Unit$j$scalingOf, qudt_Unit$j$siExactMatch, qudt_Unit$j$siUnitsExpression, qudt_Unit$j$symbol, qudt_Unit$j$ucumCode, qudt_Unit$j$udunitsCode, qudt_Unit$j$uneceCommonCode, qudt_Unit$j$unitOfSystem })
    }

    export function fromRdf(parameters: Parameters<typeof Unit._propertiesFromRdf>[0]): purify.Either<rdfjsResource.Resource.ValueError, Unit> {
        const { ignoreRdfType: _ignoreRdfType, ...otherParameters } = parameters
        return (Dimensionless_Unit.fromRdf(otherParameters) as purify.Either<rdfjsResource.Resource.ValueError, Unit>).altLazy(() => (Contextual_Unit.fromRdf(otherParameters) as purify.Either<rdfjsResource.Resource.ValueError, Unit>)).altLazy(() => (Derived_Unit.fromRdf(otherParameters) as purify.Either<rdfjsResource.Resource.ValueError, Unit>)).altLazy(() => Unit._propertiesFromRdf(parameters).map(properties => new Unit(properties)));
    }

    export let fromRdfType: rdfjs.NamedNode<string> = dataFactory.namedNode("http://qudt.org/schema/qudt/Unit");

    export function jsonSchema() {
        return zodToJsonSchema(unitJsonZodSchema());
    }

    export function unitJsonUiSchema(parameters?: { scopePrefix?: string }) {
        const scopePrefix = parameters?.scopePrefix ?? "#";
        return { "elements": [ Abstract_Unit.abstractUnitJsonUiSchema({ scopePrefix }), { scope: `${scopePrefix}/properties/qudt_Unit$j$altSymbol`, type: "Control" }, System_of$W$Units.systemOfWUnitsJsonUiSchema({ scopePrefix: `${scopePrefix}/properties/qudt_Unit$j$applicableSystem` }), { scope: `${scopePrefix}/properties/qudt_Unit$j$conversionMultiplier`, type: "Control" }, { scope: `${scopePrefix}/properties/qudt_Unit$j$conversionMultiplierSN`, type: "Control" }, { scope: `${scopePrefix}/properties/qudt_Unit$j$conversionOffset`, type: "Control" }, { scope: `${scopePrefix}/properties/qudt_Unit$j$conversionOffsetSN`, type: "Control" }, System_of$W$Units.systemOfWUnitsJsonUiSchema({ scopePrefix: `${scopePrefix}/properties/qudt_Unit$j$definedUnitOfSystem` }), System_of$W$Units.systemOfWUnitsJsonUiSchema({ scopePrefix: `${scopePrefix}/properties/qudt_Unit$j$derivedCoherentUnitOfSystem` }), System_of$W$Units.systemOfWUnitsJsonUiSchema({ scopePrefix: `${scopePrefix}/properties/qudt_Unit$j$derivedUnitOfSystem` }), { scope: `${scopePrefix}/properties/qudt_Unit$j$expression`, type: "Control" }, { scope: `${scopePrefix}/properties/qudt_Unit$j$factorUnitScalar`, type: "Control" }, Quantity_Kind$W$Dimension$W$Vector.quantityKindWDimensionWVectorJsonUiSchema({ scopePrefix: `${scopePrefix}/properties/qudt_Unit$j$hasDimensionVector` }), { scope: `${scopePrefix}/properties/qudt_Unit$j$hasFactorUnit`, type: "Control" }, Quantity_Kind.quantityKindJsonUiSchema({ scopePrefix: `${scopePrefix}/properties/qudt_Unit$j$hasQuantityKind` }), { scope: `${scopePrefix}/properties/qudt_Unit$j$iec61360Code`, type: "Control" }, { scope: `${scopePrefix}/properties/qudt_Unit$j$latexDefinition`, type: "Control" }, { scope: `${scopePrefix}/properties/qudt_Unit$j$latexSymbol`, type: "Control" }, { scope: `${scopePrefix}/properties/qudt_Unit$j$mathMLdefinition`, type: "Control" }, { scope: `${scopePrefix}/properties/qudt_Unit$j$omUnit`, type: "Control" }, Prefix.prefixJsonUiSchema({ scopePrefix: `${scopePrefix}/properties/qudt_Unit$j$prefix` }), Quantity_Kind$W$Dimension$W$Vector.quantityKindWDimensionWVectorJsonUiSchema({ scopePrefix: `${scopePrefix}/properties/qudt_Unit$j$qkdvDenominator` }), Quantity_Kind$W$Dimension$W$Vector.quantityKindWDimensionWVectorJsonUiSchema({ scopePrefix: `${scopePrefix}/properties/qudt_Unit$j$qkdvNumerator` }), Abstract_Unit.abstractUnitJsonUiSchema({ scopePrefix: `${scopePrefix}/properties/qudt_Unit$j$scalingOf` }), { scope: `${scopePrefix}/properties/qudt_Unit$j$siExactMatch`, type: "Control" }, { scope: `${scopePrefix}/properties/qudt_Unit$j$siUnitsExpression`, type: "Control" }, { scope: `${scopePrefix}/properties/qudt_Unit$j$symbol`, type: "Control" }, { scope: `${scopePrefix}/properties/qudt_Unit$j$ucumCode`, type: "Control" }, { scope: `${scopePrefix}/properties/qudt_Unit$j$udunitsCode`, type: "Control" }, { scope: `${scopePrefix}/properties/qudt_Unit$j$uneceCommonCode`, type: "Control" }, System_of$W$Units.systemOfWUnitsJsonUiSchema({ scopePrefix: `${scopePrefix}/properties/qudt_Unit$j$unitOfSystem` }) ], label: "Unit", type: "Group" }
    }

    export function unitJsonZodSchema() {
        return Abstract_Unit.abstractUnitJsonZodSchema().merge(zod.object({ "@id": zod.string().min(1),"type": zod.enum(["Angle_unit","Contextual_Unit","Counting_Unit","Currency_Unit","Derived_Unit","Dimensionless_Unit","Logarithmic_Unit","Plane_Angle$W$Unit","Solid_Angle$W$Unit","Unit"]),"qudt_Unit$j$altSymbol": zod.discriminatedUnion("termType", [zod.object({ "@id": zod.string().min(1), termType: zod.literal("BlankNode") }), zod.object({ "@id": zod.string().min(1), termType: zod.literal("NamedNode") }), zod.object({ "@language": zod.string().optional(), "@type": zod.string().optional(), "@value": zod.string(), termType: zod.literal("Literal") })]).array(),"qudt_Unit$j$applicableSystem": System_of$W$Units.systemOfWUnitsJsonZodSchema().array(),"qudt_Unit$j$conversionMultiplier": zod.number().optional(),"qudt_Unit$j$conversionMultiplierSN": zod.number().optional(),"qudt_Unit$j$conversionOffset": zod.number().optional(),"qudt_Unit$j$conversionOffsetSN": zod.number().optional(),"qudt_Unit$j$definedUnitOfSystem": System_of$W$Units.systemOfWUnitsJsonZodSchema().array(),"qudt_Unit$j$derivedCoherentUnitOfSystem": System_of$W$Units.systemOfWUnitsJsonZodSchema().array(),"qudt_Unit$j$derivedUnitOfSystem": System_of$W$Units.systemOfWUnitsJsonZodSchema().array(),"qudt_Unit$j$expression": zod.discriminatedUnion("termType", [zod.object({ "@id": zod.string().min(1), termType: zod.literal("BlankNode") }), zod.object({ "@id": zod.string().min(1), termType: zod.literal("NamedNode") }), zod.object({ "@language": zod.string().optional(), "@type": zod.string().optional(), "@value": zod.string(), termType: zod.literal("Literal") })]).array(),"qudt_Unit$j$factorUnitScalar": zod.number().optional(),"qudt_Unit$j$hasDimensionVector": Quantity_Kind$W$Dimension$W$Vector.quantityKindWDimensionWVectorJsonZodSchema(),"qudt_Unit$j$hasFactorUnit": zod.object({ "@id": zod.string().min(1) }).array(),"qudt_Unit$j$hasQuantityKind": Quantity_Kind.quantityKindJsonZodSchema().array().nonempty().min(1),"qudt_Unit$j$iec61360Code": zod.string().array(),"qudt_Unit$j$latexDefinition": zod.string().array(),"qudt_Unit$j$latexSymbol": zod.string().array(),"qudt_Unit$j$mathMLdefinition": zod.string().optional(),"qudt_Unit$j$omUnit": zod.discriminatedUnion("termType", [zod.object({ "@id": zod.string().min(1), termType: zod.literal("BlankNode") }), zod.object({ "@id": zod.string().min(1), termType: zod.literal("NamedNode") }), zod.object({ "@language": zod.string().optional(), "@type": zod.string().optional(), "@value": zod.string(), termType: zod.literal("Literal") })]).array(),"qudt_Unit$j$prefix": Prefix.prefixJsonZodSchema().optional(),"qudt_Unit$j$qkdvDenominator": Quantity_Kind$W$Dimension$W$Vector.quantityKindWDimensionWVectorJsonZodSchema().optional(),"qudt_Unit$j$qkdvNumerator": Quantity_Kind$W$Dimension$W$Vector.quantityKindWDimensionWVectorJsonZodSchema().optional(),"qudt_Unit$j$scalingOf": Abstract_Unit.abstractUnitJsonZodSchema().optional(),"qudt_Unit$j$siExactMatch": zod.discriminatedUnion("termType", [zod.object({ "@id": zod.string().min(1), termType: zod.literal("BlankNode") }), zod.object({ "@id": zod.string().min(1), termType: zod.literal("NamedNode") }), zod.object({ "@language": zod.string().optional(), "@type": zod.string().optional(), "@value": zod.string(), termType: zod.literal("Literal") })]).optional(),"qudt_Unit$j$siUnitsExpression": zod.string().array(),"qudt_Unit$j$symbol": zod.discriminatedUnion("termType", [zod.object({ "@id": zod.string().min(1), termType: zod.literal("BlankNode") }), zod.object({ "@id": zod.string().min(1), termType: zod.literal("NamedNode") }), zod.object({ "@language": zod.string().optional(), "@type": zod.string().optional(), "@value": zod.string(), termType: zod.literal("Literal") })]).optional(),"qudt_Unit$j$ucumCode": zod.string().array(),"qudt_Unit$j$udunitsCode": zod.string().array(),"qudt_Unit$j$uneceCommonCode": zod.string().array(),"qudt_Unit$j$unitOfSystem": System_of$W$Units.systemOfWUnitsJsonZodSchema().array() }));
    }

    export function sparqlConstructQuery(parameters?: { ignoreRdfType?: boolean; prefixes?: { [prefix: string]: string }; subject?: sparqljs.Triple["subject"]; } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type">): sparqljs.ConstructQuery {
        const { ignoreRdfType, subject, ...queryParameters } = parameters ?? {}

        return { ...queryParameters, prefixes: parameters?.prefixes ?? {}, queryType: "CONSTRUCT", template: (queryParameters.template ?? []).concat(Unit.sparqlConstructTemplateTriples({ ignoreRdfType, subject })), type: "query", where: (queryParameters.where ?? []).concat(Unit.sparqlWherePatterns({ ignoreRdfType, subject })) };
    }

    export function sparqlConstructQueryString(parameters?: { ignoreRdfType?: boolean; subject?: sparqljs.Triple["subject"]; variablePrefix?: string; } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type"> & sparqljs.GeneratorOptions): string {
        return new sparqljs.Generator(parameters).stringify(Unit.sparqlConstructQuery(parameters));
    }

    export function sparqlConstructTemplateTriples(parameters?: { ignoreRdfType?: boolean; subject?: sparqljs.Triple["subject"], variablePrefix?: string }): readonly sparqljs.Triple[] {
        const subject = parameters?.subject ?? dataFactory.variable!("unit");
        const variablePrefix = parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "unit");
        return [...Abstract_Unit.sparqlConstructTemplateTriples({ ignoreRdfType: true, subject, variablePrefix }), ...(parameters?.ignoreRdfType ? [] : [{ subject, predicate: dataFactory.namedNode("http://www.w3.org/1999/02/22-rdf-syntax-ns#type"), object: dataFactory.variable!(`${variablePrefix}RdfType`) }]), { object: dataFactory.variable!(`${variablePrefix}QudtUnitJAltSymbol`), predicate: dataFactory.namedNode("http://qudt.org/schema/qudt/altSymbol"), subject }, { object: dataFactory.variable!(`${variablePrefix}QudtUnitJApplicableSystem`), predicate: dataFactory.namedNode("http://qudt.org/schema/qudt/applicableSystem"), subject }, ...System_of$W$Units.sparqlConstructTemplateTriples({ ignoreRdfType: true, subject: dataFactory.variable!(`${variablePrefix}QudtUnitJApplicableSystem`), variablePrefix: `${variablePrefix}QudtUnitJApplicableSystem` }), { object: dataFactory.variable!(`${variablePrefix}QudtUnitJConversionMultiplier`), predicate: dataFactory.namedNode("http://qudt.org/schema/qudt/conversionMultiplier"), subject }, { object: dataFactory.variable!(`${variablePrefix}QudtUnitJConversionMultiplierSn`), predicate: dataFactory.namedNode("http://qudt.org/schema/qudt/conversionMultiplierSN"), subject }, { object: dataFactory.variable!(`${variablePrefix}QudtUnitJConversionOffset`), predicate: dataFactory.namedNode("http://qudt.org/schema/qudt/conversionOffset"), subject }, { object: dataFactory.variable!(`${variablePrefix}QudtUnitJConversionOffsetSn`), predicate: dataFactory.namedNode("http://qudt.org/schema/qudt/conversionOffsetSN"), subject }, { object: dataFactory.variable!(`${variablePrefix}QudtUnitJDefinedUnitOfSystem`), predicate: dataFactory.namedNode("http://qudt.org/schema/qudt/definedUnitOfSystem"), subject }, ...System_of$W$Units.sparqlConstructTemplateTriples({ ignoreRdfType: true, subject: dataFactory.variable!(`${variablePrefix}QudtUnitJDefinedUnitOfSystem`), variablePrefix: `${variablePrefix}QudtUnitJDefinedUnitOfSystem` }), { object: dataFactory.variable!(`${variablePrefix}QudtUnitJDerivedCoherentUnitOfSystem`), predicate: dataFactory.namedNode("http://qudt.org/schema/qudt/derivedCoherentUnitOfSystem"), subject }, ...System_of$W$Units.sparqlConstructTemplateTriples({ ignoreRdfType: true, subject: dataFactory.variable!(`${variablePrefix}QudtUnitJDerivedCoherentUnitOfSystem`), variablePrefix: `${variablePrefix}QudtUnitJDerivedCoherentUnitOfSystem` }), { object: dataFactory.variable!(`${variablePrefix}QudtUnitJDerivedUnitOfSystem`), predicate: dataFactory.namedNode("http://qudt.org/schema/qudt/derivedUnitOfSystem"), subject }, ...System_of$W$Units.sparqlConstructTemplateTriples({ ignoreRdfType: true, subject: dataFactory.variable!(`${variablePrefix}QudtUnitJDerivedUnitOfSystem`), variablePrefix: `${variablePrefix}QudtUnitJDerivedUnitOfSystem` }), { object: dataFactory.variable!(`${variablePrefix}QudtUnitJExpression`), predicate: dataFactory.namedNode("http://qudt.org/schema/qudt/expression"), subject }, { object: dataFactory.variable!(`${variablePrefix}QudtUnitJFactorUnitScalar`), predicate: dataFactory.namedNode("http://qudt.org/schema/qudt/factorUnitScalar"), subject }, { object: dataFactory.variable!(`${variablePrefix}QudtUnitJHasDimensionVector`), predicate: dataFactory.namedNode("http://qudt.org/schema/qudt/hasDimensionVector"), subject }, ...Quantity_Kind$W$Dimension$W$Vector.sparqlConstructTemplateTriples({ ignoreRdfType: true, subject: dataFactory.variable!(`${variablePrefix}QudtUnitJHasDimensionVector`), variablePrefix: `${variablePrefix}QudtUnitJHasDimensionVector` }), { object: dataFactory.variable!(`${variablePrefix}QudtUnitJHasFactorUnit`), predicate: dataFactory.namedNode("http://qudt.org/schema/qudt/hasFactorUnit"), subject }, { object: dataFactory.variable!(`${variablePrefix}QudtUnitJHasQuantityKind`), predicate: dataFactory.namedNode("http://qudt.org/schema/qudt/hasQuantityKind"), subject }, ...Quantity_Kind.sparqlConstructTemplateTriples({ ignoreRdfType: true, subject: dataFactory.variable!(`${variablePrefix}QudtUnitJHasQuantityKind`), variablePrefix: `${variablePrefix}QudtUnitJHasQuantityKind` }), { object: dataFactory.variable!(`${variablePrefix}QudtUnitJIec61360Code`), predicate: dataFactory.namedNode("http://qudt.org/schema/qudt/iec61360Code"), subject }, { object: dataFactory.variable!(`${variablePrefix}QudtUnitJLatexDefinition`), predicate: dataFactory.namedNode("http://qudt.org/schema/qudt/latexDefinition"), subject }, { object: dataFactory.variable!(`${variablePrefix}QudtUnitJLatexSymbol`), predicate: dataFactory.namedNode("http://qudt.org/schema/qudt/latexSymbol"), subject }, { object: dataFactory.variable!(`${variablePrefix}QudtUnitJMathMLdefinition`), predicate: dataFactory.namedNode("http://qudt.org/schema/qudt/mathMLdefinition"), subject }, { object: dataFactory.variable!(`${variablePrefix}QudtUnitJOmUnit`), predicate: dataFactory.namedNode("http://qudt.org/schema/qudt/omUnit"), subject }, { object: dataFactory.variable!(`${variablePrefix}QudtUnitJPrefix`), predicate: dataFactory.namedNode("http://qudt.org/schema/qudt/prefix"), subject }, ...Prefix.sparqlConstructTemplateTriples({ ignoreRdfType: true, subject: dataFactory.variable!(`${variablePrefix}QudtUnitJPrefix`), variablePrefix: `${variablePrefix}QudtUnitJPrefix` }), { object: dataFactory.variable!(`${variablePrefix}QudtUnitJQkdvDenominator`), predicate: dataFactory.namedNode("http://qudt.org/schema/qudt/qkdvDenominator"), subject }, ...Quantity_Kind$W$Dimension$W$Vector.sparqlConstructTemplateTriples({ ignoreRdfType: true, subject: dataFactory.variable!(`${variablePrefix}QudtUnitJQkdvDenominator`), variablePrefix: `${variablePrefix}QudtUnitJQkdvDenominator` }), { object: dataFactory.variable!(`${variablePrefix}QudtUnitJQkdvNumerator`), predicate: dataFactory.namedNode("http://qudt.org/schema/qudt/qkdvNumerator"), subject }, ...Quantity_Kind$W$Dimension$W$Vector.sparqlConstructTemplateTriples({ ignoreRdfType: true, subject: dataFactory.variable!(`${variablePrefix}QudtUnitJQkdvNumerator`), variablePrefix: `${variablePrefix}QudtUnitJQkdvNumerator` }), { object: dataFactory.variable!(`${variablePrefix}QudtUnitJScalingOf`), predicate: dataFactory.namedNode("http://qudt.org/schema/qudt/scalingOf"), subject }, ...Abstract_Unit.sparqlConstructTemplateTriples({ ignoreRdfType: true, subject: dataFactory.variable!(`${variablePrefix}QudtUnitJScalingOf`), variablePrefix: `${variablePrefix}QudtUnitJScalingOf` }), { object: dataFactory.variable!(`${variablePrefix}QudtUnitJSiExactMatch`), predicate: dataFactory.namedNode("http://qudt.org/schema/qudt/siExactMatch"), subject }, { object: dataFactory.variable!(`${variablePrefix}QudtUnitJSiUnitsExpression`), predicate: dataFactory.namedNode("http://qudt.org/schema/qudt/siUnitsExpression"), subject }, { object: dataFactory.variable!(`${variablePrefix}QudtUnitJSymbol`), predicate: dataFactory.namedNode("http://qudt.org/schema/qudt/symbol"), subject }, { object: dataFactory.variable!(`${variablePrefix}QudtUnitJUcumCode`), predicate: dataFactory.namedNode("http://qudt.org/schema/qudt/ucumCode"), subject }, { object: dataFactory.variable!(`${variablePrefix}QudtUnitJUdunitsCode`), predicate: dataFactory.namedNode("http://qudt.org/schema/qudt/udunitsCode"), subject }, { object: dataFactory.variable!(`${variablePrefix}QudtUnitJUneceCommonCode`), predicate: dataFactory.namedNode("http://qudt.org/schema/qudt/uneceCommonCode"), subject }, { object: dataFactory.variable!(`${variablePrefix}QudtUnitJUnitOfSystem`), predicate: dataFactory.namedNode("http://qudt.org/schema/qudt/isUnitOfSystem"), subject }, ...System_of$W$Units.sparqlConstructTemplateTriples({ ignoreRdfType: true, subject: dataFactory.variable!(`${variablePrefix}QudtUnitJUnitOfSystem`), variablePrefix: `${variablePrefix}QudtUnitJUnitOfSystem` })];
    }

    export function sparqlWherePatterns(parameters: { ignoreRdfType?: boolean; subject?: sparqljs.Triple["subject"], variablePrefix?: string }): readonly sparqljs.Pattern[] {
        const subject = parameters?.subject ?? dataFactory.variable!("unit");
        const variablePrefix = parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "unit");
        return [...Abstract_Unit.sparqlWherePatterns({ ignoreRdfType: true, subject, variablePrefix }), ...(parameters?.ignoreRdfType ? [] : [{ triples: [{ subject, predicate: dataFactory.namedNode("http://www.w3.org/1999/02/22-rdf-syntax-ns#type"), object: dataFactory.namedNode("http://qudt.org/schema/qudt/Unit") }], type: "bgp" as const }, { triples: [{ subject, predicate: dataFactory.namedNode("http://www.w3.org/1999/02/22-rdf-syntax-ns#type"), object: dataFactory.variable!(`${variablePrefix}RdfType`) }], type: "bgp" as const }]), { patterns: [{ triples: [{ object: dataFactory.variable!(`${variablePrefix}QudtUnitJAltSymbol`), predicate: dataFactory.namedNode("http://qudt.org/schema/qudt/altSymbol"), subject }], type: "bgp" }], type: "optional" }, { patterns: [{ triples: [{ object: dataFactory.variable!(`${variablePrefix}QudtUnitJApplicableSystem`), predicate: dataFactory.namedNode("http://qudt.org/schema/qudt/applicableSystem"), subject }], type: "bgp" }, ...System_of$W$Units.sparqlWherePatterns({ ignoreRdfType: true, subject: dataFactory.variable!(`${variablePrefix}QudtUnitJApplicableSystem`), variablePrefix: `${variablePrefix}QudtUnitJApplicableSystem` })], type: "optional" }, { patterns: [{ triples: [{ object: dataFactory.variable!(`${variablePrefix}QudtUnitJConversionMultiplier`), predicate: dataFactory.namedNode("http://qudt.org/schema/qudt/conversionMultiplier"), subject }], type: "bgp" }], type: "optional" }, { patterns: [{ triples: [{ object: dataFactory.variable!(`${variablePrefix}QudtUnitJConversionMultiplierSn`), predicate: dataFactory.namedNode("http://qudt.org/schema/qudt/conversionMultiplierSN"), subject }], type: "bgp" }], type: "optional" }, { patterns: [{ triples: [{ object: dataFactory.variable!(`${variablePrefix}QudtUnitJConversionOffset`), predicate: dataFactory.namedNode("http://qudt.org/schema/qudt/conversionOffset"), subject }], type: "bgp" }], type: "optional" }, { patterns: [{ triples: [{ object: dataFactory.variable!(`${variablePrefix}QudtUnitJConversionOffsetSn`), predicate: dataFactory.namedNode("http://qudt.org/schema/qudt/conversionOffsetSN"), subject }], type: "bgp" }], type: "optional" }, { patterns: [{ triples: [{ object: dataFactory.variable!(`${variablePrefix}QudtUnitJDefinedUnitOfSystem`), predicate: dataFactory.namedNode("http://qudt.org/schema/qudt/definedUnitOfSystem"), subject }], type: "bgp" }, ...System_of$W$Units.sparqlWherePatterns({ ignoreRdfType: true, subject: dataFactory.variable!(`${variablePrefix}QudtUnitJDefinedUnitOfSystem`), variablePrefix: `${variablePrefix}QudtUnitJDefinedUnitOfSystem` })], type: "optional" }, { patterns: [{ triples: [{ object: dataFactory.variable!(`${variablePrefix}QudtUnitJDerivedCoherentUnitOfSystem`), predicate: dataFactory.namedNode("http://qudt.org/schema/qudt/derivedCoherentUnitOfSystem"), subject }], type: "bgp" }, ...System_of$W$Units.sparqlWherePatterns({ ignoreRdfType: true, subject: dataFactory.variable!(`${variablePrefix}QudtUnitJDerivedCoherentUnitOfSystem`), variablePrefix: `${variablePrefix}QudtUnitJDerivedCoherentUnitOfSystem` })], type: "optional" }, { patterns: [{ triples: [{ object: dataFactory.variable!(`${variablePrefix}QudtUnitJDerivedUnitOfSystem`), predicate: dataFactory.namedNode("http://qudt.org/schema/qudt/derivedUnitOfSystem"), subject }], type: "bgp" }, ...System_of$W$Units.sparqlWherePatterns({ ignoreRdfType: true, subject: dataFactory.variable!(`${variablePrefix}QudtUnitJDerivedUnitOfSystem`), variablePrefix: `${variablePrefix}QudtUnitJDerivedUnitOfSystem` })], type: "optional" }, { patterns: [{ triples: [{ object: dataFactory.variable!(`${variablePrefix}QudtUnitJExpression`), predicate: dataFactory.namedNode("http://qudt.org/schema/qudt/expression"), subject }], type: "bgp" }], type: "optional" }, { patterns: [{ triples: [{ object: dataFactory.variable!(`${variablePrefix}QudtUnitJFactorUnitScalar`), predicate: dataFactory.namedNode("http://qudt.org/schema/qudt/factorUnitScalar"), subject }], type: "bgp" }], type: "optional" }, { triples: [{ object: dataFactory.variable!(`${variablePrefix}QudtUnitJHasDimensionVector`), predicate: dataFactory.namedNode("http://qudt.org/schema/qudt/hasDimensionVector"), subject }], type: "bgp" }, ...Quantity_Kind$W$Dimension$W$Vector.sparqlWherePatterns({ ignoreRdfType: true, subject: dataFactory.variable!(`${variablePrefix}QudtUnitJHasDimensionVector`), variablePrefix: `${variablePrefix}QudtUnitJHasDimensionVector` }), { patterns: [{ triples: [{ object: dataFactory.variable!(`${variablePrefix}QudtUnitJHasFactorUnit`), predicate: dataFactory.namedNode("http://qudt.org/schema/qudt/hasFactorUnit"), subject }], type: "bgp" }], type: "optional" }, { triples: [{ object: dataFactory.variable!(`${variablePrefix}QudtUnitJHasQuantityKind`), predicate: dataFactory.namedNode("http://qudt.org/schema/qudt/hasQuantityKind"), subject }], type: "bgp" }, ...Quantity_Kind.sparqlWherePatterns({ ignoreRdfType: true, subject: dataFactory.variable!(`${variablePrefix}QudtUnitJHasQuantityKind`), variablePrefix: `${variablePrefix}QudtUnitJHasQuantityKind` }), { patterns: [{ triples: [{ object: dataFactory.variable!(`${variablePrefix}QudtUnitJIec61360Code`), predicate: dataFactory.namedNode("http://qudt.org/schema/qudt/iec61360Code"), subject }], type: "bgp" }], type: "optional" }, { patterns: [{ triples: [{ object: dataFactory.variable!(`${variablePrefix}QudtUnitJLatexDefinition`), predicate: dataFactory.namedNode("http://qudt.org/schema/qudt/latexDefinition"), subject }], type: "bgp" }], type: "optional" }, { patterns: [{ triples: [{ object: dataFactory.variable!(`${variablePrefix}QudtUnitJLatexSymbol`), predicate: dataFactory.namedNode("http://qudt.org/schema/qudt/latexSymbol"), subject }], type: "bgp" }], type: "optional" }, { patterns: [{ triples: [{ object: dataFactory.variable!(`${variablePrefix}QudtUnitJMathMLdefinition`), predicate: dataFactory.namedNode("http://qudt.org/schema/qudt/mathMLdefinition"), subject }], type: "bgp" }], type: "optional" }, { patterns: [{ triples: [{ object: dataFactory.variable!(`${variablePrefix}QudtUnitJOmUnit`), predicate: dataFactory.namedNode("http://qudt.org/schema/qudt/omUnit"), subject }], type: "bgp" }], type: "optional" }, { patterns: [{ triples: [{ object: dataFactory.variable!(`${variablePrefix}QudtUnitJPrefix`), predicate: dataFactory.namedNode("http://qudt.org/schema/qudt/prefix"), subject }], type: "bgp" }, ...Prefix.sparqlWherePatterns({ ignoreRdfType: true, subject: dataFactory.variable!(`${variablePrefix}QudtUnitJPrefix`), variablePrefix: `${variablePrefix}QudtUnitJPrefix` })], type: "optional" }, { patterns: [{ triples: [{ object: dataFactory.variable!(`${variablePrefix}QudtUnitJQkdvDenominator`), predicate: dataFactory.namedNode("http://qudt.org/schema/qudt/qkdvDenominator"), subject }], type: "bgp" }, ...Quantity_Kind$W$Dimension$W$Vector.sparqlWherePatterns({ ignoreRdfType: true, subject: dataFactory.variable!(`${variablePrefix}QudtUnitJQkdvDenominator`), variablePrefix: `${variablePrefix}QudtUnitJQkdvDenominator` })], type: "optional" }, { patterns: [{ triples: [{ object: dataFactory.variable!(`${variablePrefix}QudtUnitJQkdvNumerator`), predicate: dataFactory.namedNode("http://qudt.org/schema/qudt/qkdvNumerator"), subject }], type: "bgp" }, ...Quantity_Kind$W$Dimension$W$Vector.sparqlWherePatterns({ ignoreRdfType: true, subject: dataFactory.variable!(`${variablePrefix}QudtUnitJQkdvNumerator`), variablePrefix: `${variablePrefix}QudtUnitJQkdvNumerator` })], type: "optional" }, { patterns: [{ triples: [{ object: dataFactory.variable!(`${variablePrefix}QudtUnitJScalingOf`), predicate: dataFactory.namedNode("http://qudt.org/schema/qudt/scalingOf"), subject }], type: "bgp" }, ...Abstract_Unit.sparqlWherePatterns({ ignoreRdfType: true, subject: dataFactory.variable!(`${variablePrefix}QudtUnitJScalingOf`), variablePrefix: `${variablePrefix}QudtUnitJScalingOf` })], type: "optional" }, { patterns: [{ triples: [{ object: dataFactory.variable!(`${variablePrefix}QudtUnitJSiExactMatch`), predicate: dataFactory.namedNode("http://qudt.org/schema/qudt/siExactMatch"), subject }], type: "bgp" }], type: "optional" }, { patterns: [{ triples: [{ object: dataFactory.variable!(`${variablePrefix}QudtUnitJSiUnitsExpression`), predicate: dataFactory.namedNode("http://qudt.org/schema/qudt/siUnitsExpression"), subject }], type: "bgp" }], type: "optional" }, { patterns: [{ triples: [{ object: dataFactory.variable!(`${variablePrefix}QudtUnitJSymbol`), predicate: dataFactory.namedNode("http://qudt.org/schema/qudt/symbol"), subject }], type: "bgp" }], type: "optional" }, { patterns: [{ triples: [{ object: dataFactory.variable!(`${variablePrefix}QudtUnitJUcumCode`), predicate: dataFactory.namedNode("http://qudt.org/schema/qudt/ucumCode"), subject }], type: "bgp" }], type: "optional" }, { patterns: [{ triples: [{ object: dataFactory.variable!(`${variablePrefix}QudtUnitJUdunitsCode`), predicate: dataFactory.namedNode("http://qudt.org/schema/qudt/udunitsCode"), subject }], type: "bgp" }], type: "optional" }, { patterns: [{ triples: [{ object: dataFactory.variable!(`${variablePrefix}QudtUnitJUneceCommonCode`), predicate: dataFactory.namedNode("http://qudt.org/schema/qudt/uneceCommonCode"), subject }], type: "bgp" }], type: "optional" }, { patterns: [{ triples: [{ object: dataFactory.variable!(`${variablePrefix}QudtUnitJUnitOfSystem`), predicate: dataFactory.namedNode("http://qudt.org/schema/qudt/isUnitOfSystem"), subject }], type: "bgp" }, ...System_of$W$Units.sparqlWherePatterns({ ignoreRdfType: true, subject: dataFactory.variable!(`${variablePrefix}QudtUnitJUnitOfSystem`), variablePrefix: `${variablePrefix}QudtUnitJUnitOfSystem` })], type: "optional" }];
    }
}
/**
 * Dimensionless Unit
 */
export class Dimensionless_Unit extends Unit {
    override readonly type: "Angle_unit" | "Counting_Unit" | "Currency_Unit" | "Dimensionless_Unit" | "Logarithmic_Unit" | "Plane_Angle$W$Unit" | "Solid_Angle$W$Unit" = "Dimensionless_Unit";

    // biome-ignore lint/complexity/noUselessConstructor: Always have a constructor
    constructor(parameters: { readonly identifier?: (rdfjs.BlankNode | rdfjs.NamedNode) | string } & ConstructorParameters<typeof Unit>[0]) {
        super(parameters);
    }

    override get identifier(): (rdfjs.BlankNode | rdfjs.NamedNode) {
        if (typeof this._identifier === "undefined") { this._identifier = dataFactory.blankNode(); } return this._identifier;
    }

    override toRdf({ ignoreRdfType, mutateGraph, resourceSet }: { ignoreRdfType?: boolean; mutateGraph?: rdfjsResource.MutableResource.MutateGraph, resourceSet: rdfjsResource.MutableResourceSet }): rdfjsResource.MutableResource {
        const _resource = super.toRdf({ ignoreRdfType: true, mutateGraph, resourceSet });
        if (!ignoreRdfType) { _resource.add(_resource.dataFactory.namedNode("http://www.w3.org/1999/02/22-rdf-syntax-ns#type"), _resource.dataFactory.namedNode("http://qudt.org/schema/qudt/DimensionlessUnit")); }

        return _resource;
    }

    override toString(): string {
        return JSON.stringify(this.toJson());
    }
}

export namespace Dimensionless_Unit {
    export function _propertiesFromJson(_json: unknown): purify.Either<zod.ZodError, { identifier: (rdfjs.BlankNode | rdfjs.NamedNode); } & UnwrapR<ReturnType<typeof Unit._propertiesFromJson>>> {
        const _jsonSafeParseResult = dimensionlessUnitJsonZodSchema().safeParse(_json);
        if (!_jsonSafeParseResult.success) { return purify.Left(_jsonSafeParseResult.error); }

        const _jsonObject = _jsonSafeParseResult.data;
        const _super0Either = Unit._propertiesFromJson(_jsonObject);
        if (_super0Either.isLeft()) { return _super0Either; }

        const _super0 = _super0Either.unsafeCoerce()
        const identifier = (_jsonObject["@id"].startsWith("_:") ? dataFactory.blankNode(_jsonObject["@id"].substring(2)) : dataFactory.namedNode(_jsonObject["@id"]));
        return purify.Either.of({ ..._super0, identifier })
    }

    export function fromJson(json: unknown): purify.Either<zod.ZodError, Dimensionless_Unit> {
        return (Angle_unit.fromJson(json) as purify.Either<zod.ZodError, Dimensionless_Unit>).altLazy(() => (Counting_Unit.fromJson(json) as purify.Either<zod.ZodError, Dimensionless_Unit>)).altLazy(() => (Currency_Unit.fromJson(json) as purify.Either<zod.ZodError, Dimensionless_Unit>)).altLazy(() => (Logarithmic_Unit.fromJson(json) as purify.Either<zod.ZodError, Dimensionless_Unit>)).altLazy(() => Dimensionless_Unit._propertiesFromJson(json).map(properties => new Dimensionless_Unit(properties)));
    }

    export function _propertiesFromRdf({ ignoreRdfType: _ignoreRdfType, languageIn: _languageIn, resource: _resource,
        // @ts-ignore
        ..._context }: { [_index: string]: any; ignoreRdfType?: boolean; languageIn?: readonly string[]; resource: rdfjsResource.Resource; }): purify.Either<rdfjsResource.Resource.ValueError, { identifier: (rdfjs.BlankNode | rdfjs.NamedNode); } & UnwrapR<ReturnType<typeof Unit._propertiesFromRdf>>> {
        const _super0Either = Unit._propertiesFromRdf({ ..._context, ignoreRdfType: true, languageIn: _languageIn, resource: _resource });
        if (_super0Either.isLeft()) { return _super0Either; }

        const _super0 = _super0Either.unsafeCoerce()
        if (!_ignoreRdfType && !_resource.isInstanceOf(dataFactory.namedNode("http://qudt.org/schema/qudt/DimensionlessUnit"))) { return purify.Left(new rdfjsResource.Resource.ValueError({ focusResource: _resource, message: `${rdfjsResource.Resource.Identifier.toString(_resource.identifier)} has unexpected RDF type (expected http://qudt.org/schema/qudt/DimensionlessUnit)`, predicate: dataFactory.namedNode("http://qudt.org/schema/qudt/DimensionlessUnit") })); }

        const identifier = _resource.identifier
        return purify.Either.of({ ..._super0, identifier })
    }

    export function fromRdf(parameters: Parameters<typeof Dimensionless_Unit._propertiesFromRdf>[0]): purify.Either<rdfjsResource.Resource.ValueError, Dimensionless_Unit> {
        const { ignoreRdfType: _ignoreRdfType, ...otherParameters } = parameters
        return (Angle_unit.fromRdf(otherParameters) as purify.Either<rdfjsResource.Resource.ValueError, Dimensionless_Unit>).altLazy(() => (Counting_Unit.fromRdf(otherParameters) as purify.Either<rdfjsResource.Resource.ValueError, Dimensionless_Unit>)).altLazy(() => (Currency_Unit.fromRdf(otherParameters) as purify.Either<rdfjsResource.Resource.ValueError, Dimensionless_Unit>)).altLazy(() => (Logarithmic_Unit.fromRdf(otherParameters) as purify.Either<rdfjsResource.Resource.ValueError, Dimensionless_Unit>)).altLazy(() => Dimensionless_Unit._propertiesFromRdf(parameters).map(properties => new Dimensionless_Unit(properties)));
    }

    export let fromRdfType: rdfjs.NamedNode<string> = dataFactory.namedNode("http://qudt.org/schema/qudt/DimensionlessUnit");

    export function jsonSchema() {
        return zodToJsonSchema(dimensionlessUnitJsonZodSchema());
    }

    export function dimensionlessUnitJsonUiSchema(parameters?: { scopePrefix?: string }) {
        const scopePrefix = parameters?.scopePrefix ?? "#";
        return { "elements": [ Unit.unitJsonUiSchema({ scopePrefix }) ], label: "Dimensionless Unit", type: "Group" }
    }

    export function dimensionlessUnitJsonZodSchema() {
        return Unit.unitJsonZodSchema().merge(zod.object({ "@id": zod.string().min(1),"type": zod.enum(["Angle_unit","Counting_Unit","Currency_Unit","Dimensionless_Unit","Logarithmic_Unit","Plane_Angle$W$Unit","Solid_Angle$W$Unit"]) }));
    }

    export function sparqlConstructQuery(parameters?: { ignoreRdfType?: boolean; prefixes?: { [prefix: string]: string }; subject?: sparqljs.Triple["subject"]; } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type">): sparqljs.ConstructQuery {
        const { ignoreRdfType, subject, ...queryParameters } = parameters ?? {}

        return { ...queryParameters, prefixes: parameters?.prefixes ?? {}, queryType: "CONSTRUCT", template: (queryParameters.template ?? []).concat(Dimensionless_Unit.sparqlConstructTemplateTriples({ ignoreRdfType, subject })), type: "query", where: (queryParameters.where ?? []).concat(Dimensionless_Unit.sparqlWherePatterns({ ignoreRdfType, subject })) };
    }

    export function sparqlConstructQueryString(parameters?: { ignoreRdfType?: boolean; subject?: sparqljs.Triple["subject"]; variablePrefix?: string; } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type"> & sparqljs.GeneratorOptions): string {
        return new sparqljs.Generator(parameters).stringify(Dimensionless_Unit.sparqlConstructQuery(parameters));
    }

    export function sparqlConstructTemplateTriples(parameters?: { ignoreRdfType?: boolean; subject?: sparqljs.Triple["subject"], variablePrefix?: string }): readonly sparqljs.Triple[] {
        const subject = parameters?.subject ?? dataFactory.variable!("dimensionlessUnit");
        const variablePrefix = parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "dimensionlessUnit");
        return [...Unit.sparqlConstructTemplateTriples({ ignoreRdfType: true, subject, variablePrefix }), ...(parameters?.ignoreRdfType ? [] : [{ subject, predicate: dataFactory.namedNode("http://www.w3.org/1999/02/22-rdf-syntax-ns#type"), object: dataFactory.variable!(`${variablePrefix}RdfType`) }])];
    }

    export function sparqlWherePatterns(parameters: { ignoreRdfType?: boolean; subject?: sparqljs.Triple["subject"], variablePrefix?: string }): readonly sparqljs.Pattern[] {
        const subject = parameters?.subject ?? dataFactory.variable!("dimensionlessUnit");
        const variablePrefix = parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "dimensionlessUnit");
        return [...Unit.sparqlWherePatterns({ ignoreRdfType: true, subject, variablePrefix }), ...(parameters?.ignoreRdfType ? [] : [{ triples: [{ subject, predicate: dataFactory.namedNode("http://www.w3.org/1999/02/22-rdf-syntax-ns#type"), object: dataFactory.namedNode("http://qudt.org/schema/qudt/DimensionlessUnit") }], type: "bgp" as const }, { triples: [{ subject, predicate: dataFactory.namedNode("http://www.w3.org/1999/02/22-rdf-syntax-ns#type"), object: dataFactory.variable!(`${variablePrefix}RdfType`) }], type: "bgp" as const }])];
    }
}
/**
 * Angle unit
 */
export class Angle_unit extends Dimensionless_Unit {
    override readonly type: "Angle_unit" | "Plane_Angle$W$Unit" | "Solid_Angle$W$Unit" = "Angle_unit";

    // biome-ignore lint/complexity/noUselessConstructor: Always have a constructor
    constructor(parameters: { readonly identifier?: (rdfjs.BlankNode | rdfjs.NamedNode) | string } & ConstructorParameters<typeof Dimensionless_Unit>[0]) {
        super(parameters);
    }

    override get identifier(): (rdfjs.BlankNode | rdfjs.NamedNode) {
        if (typeof this._identifier === "undefined") { this._identifier = dataFactory.blankNode(); } return this._identifier;
    }

    override toRdf({ ignoreRdfType, mutateGraph, resourceSet }: { ignoreRdfType?: boolean; mutateGraph?: rdfjsResource.MutableResource.MutateGraph, resourceSet: rdfjsResource.MutableResourceSet }): rdfjsResource.MutableResource {
        const _resource = super.toRdf({ ignoreRdfType: true, mutateGraph, resourceSet });
        if (!ignoreRdfType) { _resource.add(_resource.dataFactory.namedNode("http://www.w3.org/1999/02/22-rdf-syntax-ns#type"), _resource.dataFactory.namedNode("http://qudt.org/schema/qudt/AngleUnit")); }

        return _resource;
    }

    override toString(): string {
        return JSON.stringify(this.toJson());
    }
}

export namespace Angle_unit {
    export function _propertiesFromJson(_json: unknown): purify.Either<zod.ZodError, { identifier: (rdfjs.BlankNode | rdfjs.NamedNode); } & UnwrapR<ReturnType<typeof Dimensionless_Unit._propertiesFromJson>>> {
        const _jsonSafeParseResult = angleUnitJsonZodSchema().safeParse(_json);
        if (!_jsonSafeParseResult.success) { return purify.Left(_jsonSafeParseResult.error); }

        const _jsonObject = _jsonSafeParseResult.data;
        const _super0Either = Dimensionless_Unit._propertiesFromJson(_jsonObject);
        if (_super0Either.isLeft()) { return _super0Either; }

        const _super0 = _super0Either.unsafeCoerce()
        const identifier = (_jsonObject["@id"].startsWith("_:") ? dataFactory.blankNode(_jsonObject["@id"].substring(2)) : dataFactory.namedNode(_jsonObject["@id"]));
        return purify.Either.of({ ..._super0, identifier })
    }

    export function fromJson(json: unknown): purify.Either<zod.ZodError, Angle_unit> {
        return (Plane_Angle$W$Unit.fromJson(json) as purify.Either<zod.ZodError, Angle_unit>).altLazy(() => (Solid_Angle$W$Unit.fromJson(json) as purify.Either<zod.ZodError, Angle_unit>)).altLazy(() => Angle_unit._propertiesFromJson(json).map(properties => new Angle_unit(properties)));
    }

    export function _propertiesFromRdf({ ignoreRdfType: _ignoreRdfType, languageIn: _languageIn, resource: _resource,
        // @ts-ignore
        ..._context }: { [_index: string]: any; ignoreRdfType?: boolean; languageIn?: readonly string[]; resource: rdfjsResource.Resource; }): purify.Either<rdfjsResource.Resource.ValueError, { identifier: (rdfjs.BlankNode | rdfjs.NamedNode); } & UnwrapR<ReturnType<typeof Dimensionless_Unit._propertiesFromRdf>>> {
        const _super0Either = Dimensionless_Unit._propertiesFromRdf({ ..._context, ignoreRdfType: true, languageIn: _languageIn, resource: _resource });
        if (_super0Either.isLeft()) { return _super0Either; }

        const _super0 = _super0Either.unsafeCoerce()
        if (!_ignoreRdfType && !_resource.isInstanceOf(dataFactory.namedNode("http://qudt.org/schema/qudt/AngleUnit"))) { return purify.Left(new rdfjsResource.Resource.ValueError({ focusResource: _resource, message: `${rdfjsResource.Resource.Identifier.toString(_resource.identifier)} has unexpected RDF type (expected http://qudt.org/schema/qudt/AngleUnit)`, predicate: dataFactory.namedNode("http://qudt.org/schema/qudt/AngleUnit") })); }

        const identifier = _resource.identifier
        return purify.Either.of({ ..._super0, identifier })
    }

    export function fromRdf(parameters: Parameters<typeof Angle_unit._propertiesFromRdf>[0]): purify.Either<rdfjsResource.Resource.ValueError, Angle_unit> {
        const { ignoreRdfType: _ignoreRdfType, ...otherParameters } = parameters
        return (Plane_Angle$W$Unit.fromRdf(otherParameters) as purify.Either<rdfjsResource.Resource.ValueError, Angle_unit>).altLazy(() => (Solid_Angle$W$Unit.fromRdf(otherParameters) as purify.Either<rdfjsResource.Resource.ValueError, Angle_unit>)).altLazy(() => Angle_unit._propertiesFromRdf(parameters).map(properties => new Angle_unit(properties)));
    }

    export let fromRdfType: rdfjs.NamedNode<string> = dataFactory.namedNode("http://qudt.org/schema/qudt/AngleUnit");

    export function jsonSchema() {
        return zodToJsonSchema(angleUnitJsonZodSchema());
    }

    export function angleUnitJsonUiSchema(parameters?: { scopePrefix?: string }) {
        const scopePrefix = parameters?.scopePrefix ?? "#";
        return { "elements": [ Dimensionless_Unit.dimensionlessUnitJsonUiSchema({ scopePrefix }) ], label: "Angle unit", type: "Group" }
    }

    export function angleUnitJsonZodSchema() {
        return Dimensionless_Unit.dimensionlessUnitJsonZodSchema().merge(zod.object({ "@id": zod.string().min(1),"type": zod.enum(["Angle_unit","Plane_Angle$W$Unit","Solid_Angle$W$Unit"]) }));
    }

    export function sparqlConstructQuery(parameters?: { ignoreRdfType?: boolean; prefixes?: { [prefix: string]: string }; subject?: sparqljs.Triple["subject"]; } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type">): sparqljs.ConstructQuery {
        const { ignoreRdfType, subject, ...queryParameters } = parameters ?? {}

        return { ...queryParameters, prefixes: parameters?.prefixes ?? {}, queryType: "CONSTRUCT", template: (queryParameters.template ?? []).concat(Angle_unit.sparqlConstructTemplateTriples({ ignoreRdfType, subject })), type: "query", where: (queryParameters.where ?? []).concat(Angle_unit.sparqlWherePatterns({ ignoreRdfType, subject })) };
    }

    export function sparqlConstructQueryString(parameters?: { ignoreRdfType?: boolean; subject?: sparqljs.Triple["subject"]; variablePrefix?: string; } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type"> & sparqljs.GeneratorOptions): string {
        return new sparqljs.Generator(parameters).stringify(Angle_unit.sparqlConstructQuery(parameters));
    }

    export function sparqlConstructTemplateTriples(parameters?: { ignoreRdfType?: boolean; subject?: sparqljs.Triple["subject"], variablePrefix?: string }): readonly sparqljs.Triple[] {
        const subject = parameters?.subject ?? dataFactory.variable!("angleUnit");
        const variablePrefix = parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "angleUnit");
        return [...Dimensionless_Unit.sparqlConstructTemplateTriples({ ignoreRdfType: true, subject, variablePrefix }), ...(parameters?.ignoreRdfType ? [] : [{ subject, predicate: dataFactory.namedNode("http://www.w3.org/1999/02/22-rdf-syntax-ns#type"), object: dataFactory.variable!(`${variablePrefix}RdfType`) }])];
    }

    export function sparqlWherePatterns(parameters: { ignoreRdfType?: boolean; subject?: sparqljs.Triple["subject"], variablePrefix?: string }): readonly sparqljs.Pattern[] {
        const subject = parameters?.subject ?? dataFactory.variable!("angleUnit");
        const variablePrefix = parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "angleUnit");
        return [...Dimensionless_Unit.sparqlWherePatterns({ ignoreRdfType: true, subject, variablePrefix }), ...(parameters?.ignoreRdfType ? [] : [{ triples: [{ subject, predicate: dataFactory.namedNode("http://www.w3.org/1999/02/22-rdf-syntax-ns#type"), object: dataFactory.namedNode("http://qudt.org/schema/qudt/AngleUnit") }], type: "bgp" as const }, { triples: [{ subject, predicate: dataFactory.namedNode("http://www.w3.org/1999/02/22-rdf-syntax-ns#type"), object: dataFactory.variable!(`${variablePrefix}RdfType`) }], type: "bgp" as const }])];
    }
}
/**
 * Solid Angle Unit
 */
export class Solid_Angle$W$Unit extends Angle_unit {
    override readonly type = "Solid_Angle$W$Unit";

    // biome-ignore lint/complexity/noUselessConstructor: Always have a constructor
    constructor(parameters: { readonly identifier?: (rdfjs.BlankNode | rdfjs.NamedNode) | string } & ConstructorParameters<typeof Angle_unit>[0]) {
        super(parameters);
    }

    override get identifier(): (rdfjs.BlankNode | rdfjs.NamedNode) {
        if (typeof this._identifier === "undefined") { this._identifier = dataFactory.blankNode(); } return this._identifier;
    }

    override toRdf({ ignoreRdfType, mutateGraph, resourceSet }: { ignoreRdfType?: boolean; mutateGraph?: rdfjsResource.MutableResource.MutateGraph, resourceSet: rdfjsResource.MutableResourceSet }): rdfjsResource.MutableResource {
        const _resource = super.toRdf({ ignoreRdfType: true, mutateGraph, resourceSet });
        if (!ignoreRdfType) { _resource.add(_resource.dataFactory.namedNode("http://www.w3.org/1999/02/22-rdf-syntax-ns#type"), _resource.dataFactory.namedNode("http://qudt.org/schema/qudt/SolidAngleUnit")); }

        return _resource;
    }

    override toString(): string {
        return JSON.stringify(this.toJson());
    }
}

export namespace Solid_Angle$W$Unit {
    export function _propertiesFromJson(_json: unknown): purify.Either<zod.ZodError, { identifier: (rdfjs.BlankNode | rdfjs.NamedNode); } & UnwrapR<ReturnType<typeof Angle_unit._propertiesFromJson>>> {
        const _jsonSafeParseResult = solidAngleWUnitJsonZodSchema().safeParse(_json);
        if (!_jsonSafeParseResult.success) { return purify.Left(_jsonSafeParseResult.error); }

        const _jsonObject = _jsonSafeParseResult.data;
        const _super0Either = Angle_unit._propertiesFromJson(_jsonObject);
        if (_super0Either.isLeft()) { return _super0Either; }

        const _super0 = _super0Either.unsafeCoerce()
        const identifier = (_jsonObject["@id"].startsWith("_:") ? dataFactory.blankNode(_jsonObject["@id"].substring(2)) : dataFactory.namedNode(_jsonObject["@id"]));
        return purify.Either.of({ ..._super0, identifier })
    }

    export function fromJson(json: unknown): purify.Either<zod.ZodError, Solid_Angle$W$Unit> {
        return Solid_Angle$W$Unit._propertiesFromJson(json).map(properties => new Solid_Angle$W$Unit(properties));
    }

    export function _propertiesFromRdf({ ignoreRdfType: _ignoreRdfType, languageIn: _languageIn, resource: _resource,
        // @ts-ignore
        ..._context }: { [_index: string]: any; ignoreRdfType?: boolean; languageIn?: readonly string[]; resource: rdfjsResource.Resource; }): purify.Either<rdfjsResource.Resource.ValueError, { identifier: (rdfjs.BlankNode | rdfjs.NamedNode); } & UnwrapR<ReturnType<typeof Angle_unit._propertiesFromRdf>>> {
        const _super0Either = Angle_unit._propertiesFromRdf({ ..._context, ignoreRdfType: true, languageIn: _languageIn, resource: _resource });
        if (_super0Either.isLeft()) { return _super0Either; }

        const _super0 = _super0Either.unsafeCoerce()
        if (!_ignoreRdfType && !_resource.isInstanceOf(dataFactory.namedNode("http://qudt.org/schema/qudt/SolidAngleUnit"))) { return purify.Left(new rdfjsResource.Resource.ValueError({ focusResource: _resource, message: `${rdfjsResource.Resource.Identifier.toString(_resource.identifier)} has unexpected RDF type (expected http://qudt.org/schema/qudt/SolidAngleUnit)`, predicate: dataFactory.namedNode("http://qudt.org/schema/qudt/SolidAngleUnit") })); }

        const identifier = _resource.identifier
        return purify.Either.of({ ..._super0, identifier })
    }

    export function fromRdf(parameters: Parameters<typeof Solid_Angle$W$Unit._propertiesFromRdf>[0]): purify.Either<rdfjsResource.Resource.ValueError, Solid_Angle$W$Unit> {
        return Solid_Angle$W$Unit._propertiesFromRdf(parameters).map(properties => new Solid_Angle$W$Unit(properties));
    }

    export let fromRdfType: rdfjs.NamedNode<string> = dataFactory.namedNode("http://qudt.org/schema/qudt/SolidAngleUnit");

    export function jsonSchema() {
        return zodToJsonSchema(solidAngleWUnitJsonZodSchema());
    }

    export function solidAngleWUnitJsonUiSchema(parameters?: { scopePrefix?: string }) {
        const scopePrefix = parameters?.scopePrefix ?? "#";
        return { "elements": [ Angle_unit.angleUnitJsonUiSchema({ scopePrefix }) ], label: "Solid Angle Unit", type: "Group" }
    }

    export function solidAngleWUnitJsonZodSchema() {
        return Angle_unit.angleUnitJsonZodSchema().merge(zod.object({ "@id": zod.string().min(1),"type": zod.literal("Solid_Angle$W$Unit") }));
    }

    export function sparqlConstructQuery(parameters?: { ignoreRdfType?: boolean; prefixes?: { [prefix: string]: string }; subject?: sparqljs.Triple["subject"]; } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type">): sparqljs.ConstructQuery {
        const { ignoreRdfType, subject, ...queryParameters } = parameters ?? {}

        return { ...queryParameters, prefixes: parameters?.prefixes ?? {}, queryType: "CONSTRUCT", template: (queryParameters.template ?? []).concat(Solid_Angle$W$Unit.sparqlConstructTemplateTriples({ ignoreRdfType, subject })), type: "query", where: (queryParameters.where ?? []).concat(Solid_Angle$W$Unit.sparqlWherePatterns({ ignoreRdfType, subject })) };
    }

    export function sparqlConstructQueryString(parameters?: { ignoreRdfType?: boolean; subject?: sparqljs.Triple["subject"]; variablePrefix?: string; } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type"> & sparqljs.GeneratorOptions): string {
        return new sparqljs.Generator(parameters).stringify(Solid_Angle$W$Unit.sparqlConstructQuery(parameters));
    }

    export function sparqlConstructTemplateTriples(parameters?: { ignoreRdfType?: boolean; subject?: sparqljs.Triple["subject"], variablePrefix?: string }): readonly sparqljs.Triple[] {
        const subject = parameters?.subject ?? dataFactory.variable!("solidAngleWUnit");
        const variablePrefix = parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "solidAngleWUnit");
        return [...Angle_unit.sparqlConstructTemplateTriples({ ignoreRdfType: true, subject, variablePrefix }), ...(parameters?.ignoreRdfType ? [] : [{ subject, predicate: dataFactory.namedNode("http://www.w3.org/1999/02/22-rdf-syntax-ns#type"), object: dataFactory.variable!(`${variablePrefix}RdfType`) }])];
    }

    export function sparqlWherePatterns(parameters: { ignoreRdfType?: boolean; subject?: sparqljs.Triple["subject"], variablePrefix?: string }): readonly sparqljs.Pattern[] {
        const subject = parameters?.subject ?? dataFactory.variable!("solidAngleWUnit");
        const variablePrefix = parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "solidAngleWUnit");
        return [...Angle_unit.sparqlWherePatterns({ ignoreRdfType: true, subject, variablePrefix }), ...(parameters?.ignoreRdfType ? [] : [{ triples: [{ subject, predicate: dataFactory.namedNode("http://www.w3.org/1999/02/22-rdf-syntax-ns#type"), object: dataFactory.namedNode("http://qudt.org/schema/qudt/SolidAngleUnit") }], type: "bgp" as const }, { triples: [{ subject, predicate: dataFactory.namedNode("http://www.w3.org/1999/02/22-rdf-syntax-ns#type"), object: dataFactory.variable!(`${variablePrefix}RdfType`) }], type: "bgp" as const }])];
    }
}
/**
 * Scale type
 */
export class Scale_type extends Enumerated_Value {
    override readonly type = "Scale_type";
    readonly qudt_ScaleType$j$dataStructure: purify.Maybe<string>;
    readonly qudt_ScaleType$j$permissibleMaths: readonly ((rdfjs.BlankNode | rdfjs.NamedNode | rdfjs.Literal))[];
    readonly qudt_ScaleType$j$permissibleTransformation: readonly (Transform_type)[];

    constructor(parameters: { readonly identifier?: (rdfjs.BlankNode | rdfjs.NamedNode) | string, readonly qudt_ScaleType$j$dataStructure?: purify.Maybe<string> | string, readonly qudt_ScaleType$j$permissibleMaths?: readonly ((rdfjs.BlankNode | rdfjs.NamedNode | rdfjs.Literal))[], readonly qudt_ScaleType$j$permissibleTransformation?: readonly (Transform_type)[] } & ConstructorParameters<typeof Enumerated_Value>[0]) {
        super(parameters);
        if (purify.Maybe.isMaybe(parameters.qudt_ScaleType$j$dataStructure)) { this.qudt_ScaleType$j$dataStructure = parameters.qudt_ScaleType$j$dataStructure; } else if (typeof parameters.qudt_ScaleType$j$dataStructure === "string") { this.qudt_ScaleType$j$dataStructure = purify.Maybe.of(parameters.qudt_ScaleType$j$dataStructure); } else if (typeof parameters.qudt_ScaleType$j$dataStructure === "undefined") { this.qudt_ScaleType$j$dataStructure = purify.Maybe.empty(); } else { this.qudt_ScaleType$j$dataStructure =( parameters.qudt_ScaleType$j$dataStructure) as never;
         }

        if (typeof parameters.qudt_ScaleType$j$permissibleMaths === "undefined") { this.qudt_ScaleType$j$permissibleMaths = []; } else if (Array.isArray(parameters.qudt_ScaleType$j$permissibleMaths)) { this.qudt_ScaleType$j$permissibleMaths = parameters.qudt_ScaleType$j$permissibleMaths; } else { this.qudt_ScaleType$j$permissibleMaths =( parameters.qudt_ScaleType$j$permissibleMaths) as never;
         }

        if (typeof parameters.qudt_ScaleType$j$permissibleTransformation === "undefined") { this.qudt_ScaleType$j$permissibleTransformation = []; } else if (Array.isArray(parameters.qudt_ScaleType$j$permissibleTransformation)) { this.qudt_ScaleType$j$permissibleTransformation = parameters.qudt_ScaleType$j$permissibleTransformation; } else { this.qudt_ScaleType$j$permissibleTransformation =( parameters.qudt_ScaleType$j$permissibleTransformation) as never;
         }
    }

    override get identifier(): (rdfjs.BlankNode | rdfjs.NamedNode) {
        if (typeof this._identifier === "undefined") { this._identifier = dataFactory.blankNode(); } return this._identifier;
    }

    override equals(other: Scale_type): EqualsResult {
        return super.equals(other).chain(() => (((left, right) => maybeEquals(left, right, strictEquals)))(this.qudt_ScaleType$j$dataStructure, other.qudt_ScaleType$j$dataStructure).mapLeft(propertyValuesUnequal => ({ left: this, right: other, propertyName: "qudt_ScaleType$j$dataStructure", propertyValuesUnequal, type: "Property" as const }))).chain(() => (((left, right) => arrayEquals(left, right, booleanEquals)))(this.qudt_ScaleType$j$permissibleMaths, other.qudt_ScaleType$j$permissibleMaths).mapLeft(propertyValuesUnequal => ({ left: this, right: other, propertyName: "qudt_ScaleType$j$permissibleMaths", propertyValuesUnequal, type: "Property" as const }))).chain(() => (((left, right) => arrayEquals(left, right, ((left, right) => left.equals(right)))))(this.qudt_ScaleType$j$permissibleTransformation, other.qudt_ScaleType$j$permissibleTransformation).mapLeft(propertyValuesUnequal => ({ left: this, right: other, propertyName: "qudt_ScaleType$j$permissibleTransformation", propertyValuesUnequal, type: "Property" as const })));
    }

    override hash<HasherT extends { update: (message: string | number[] | ArrayBuffer | Uint8Array) => void; }>(_hasher: HasherT): HasherT {
        this.hashShaclProperties(_hasher);
        return _hasher;
    }

    protected override hashShaclProperties<HasherT extends { update: (message: string | number[] | ArrayBuffer | Uint8Array) => void; }>(_hasher: HasherT): HasherT {
        super.hashShaclProperties(_hasher);
        this.qudt_ScaleType$j$dataStructure.ifJust((_value0) => { _hasher.update(_value0); })
        for (const _item0 of this.qudt_ScaleType$j$permissibleMaths) { _hasher.update(_item0.termType);
        _hasher.update(_item0.value); }

        for (const _item0 of this.qudt_ScaleType$j$permissibleTransformation) { _item0.hash(_hasher); }

        return _hasher;
    }

    override toJson(): { readonly "qudt_ScaleType$j$dataStructure": (string) | undefined; readonly "qudt_ScaleType$j$permissibleMaths": readonly ({ readonly "@id": string, readonly termType: "BlankNode" | "NamedNode" } | { readonly "@language": string | undefined, readonly "@type": string | undefined, readonly "@value": string, readonly termType: "Literal" })[]; readonly "qudt_ScaleType$j$permissibleTransformation": readonly (ReturnType<Transform_type["toJson"]>)[] } & ReturnType<Enumerated_Value["toJson"]> {
        return JSON.parse(JSON.stringify({ ...super.toJson(),qudt_ScaleType$j$dataStructure: this.qudt_ScaleType$j$dataStructure.map(_item => (_item)).extract(),qudt_ScaleType$j$permissibleMaths: this.qudt_ScaleType$j$permissibleMaths.map(_item => ((_item.termType === "Literal") ? { "@language": _item.language.length > 0 ? _item.language : undefined, "@type": _item.datatype.value !== "http://www.w3.org/2001/XMLSchema#string" ? _item.datatype.value : undefined, "@value": _item.value, termType: "Literal" as const } : (_item.termType === "NamedNode") ? { "@id": _item.value, termType: "NamedNode" as const } : { "@id": `_:${_item.value}`, termType: "BlankNode" as const })),qudt_ScaleType$j$permissibleTransformation: this.qudt_ScaleType$j$permissibleTransformation.map(_item => (_item.toJson())) } satisfies ReturnType<Scale_type["toJson"]>));
    }

    override toRdf({ ignoreRdfType, mutateGraph, resourceSet }: { ignoreRdfType?: boolean; mutateGraph?: rdfjsResource.MutableResource.MutateGraph, resourceSet: rdfjsResource.MutableResourceSet }): rdfjsResource.MutableResource {
        const _resource = super.toRdf({ ignoreRdfType: true, mutateGraph, resourceSet });
        if (!ignoreRdfType) { _resource.add(_resource.dataFactory.namedNode("http://www.w3.org/1999/02/22-rdf-syntax-ns#type"), _resource.dataFactory.namedNode("http://qudt.org/schema/qudt/ScaleType")); }

        _resource.add(dataFactory.namedNode("http://qudt.org/schema/qudt/dataStructure"), this.qudt_ScaleType$j$dataStructure);
        _resource.add(dataFactory.namedNode("http://qudt.org/schema/qudt/permissibleMaths"), this.qudt_ScaleType$j$permissibleMaths.map((_item) => _item));
        _resource.add(dataFactory.namedNode("http://qudt.org/schema/qudt/permissibleTransformation"), this.qudt_ScaleType$j$permissibleTransformation.map((_item) => _item.toRdf({ mutateGraph: mutateGraph, resourceSet: resourceSet })));
        return _resource;
    }

    override toString(): string {
        return JSON.stringify(this.toJson());
    }
}

export namespace Scale_type {
    export function _propertiesFromJson(_json: unknown): purify.Either<zod.ZodError, { identifier: (rdfjs.BlankNode | rdfjs.NamedNode); qudt_ScaleType$j$dataStructure: purify.Maybe<string>; qudt_ScaleType$j$permissibleMaths: readonly ((rdfjs.BlankNode | rdfjs.NamedNode | rdfjs.Literal))[]; qudt_ScaleType$j$permissibleTransformation: readonly (Transform_type)[]; } & UnwrapR<ReturnType<typeof Enumerated_Value._propertiesFromJson>>> {
        const _jsonSafeParseResult = scaleTypeJsonZodSchema().safeParse(_json);
        if (!_jsonSafeParseResult.success) { return purify.Left(_jsonSafeParseResult.error); }

        const _jsonObject = _jsonSafeParseResult.data;
        const _super0Either = Enumerated_Value._propertiesFromJson(_jsonObject);
        if (_super0Either.isLeft()) { return _super0Either; }

        const _super0 = _super0Either.unsafeCoerce()
        const identifier = (_jsonObject["@id"].startsWith("_:") ? dataFactory.blankNode(_jsonObject["@id"].substring(2)) : dataFactory.namedNode(_jsonObject["@id"]));
        const qudt_ScaleType$j$dataStructure = purify.Maybe.fromNullable(_jsonObject["qudt_ScaleType$j$dataStructure"]);
        const qudt_ScaleType$j$permissibleMaths = _jsonObject["qudt_ScaleType$j$permissibleMaths"].map(_item => (((_item.termType === "Literal") ? (dataFactory.literal(_item["@value"], typeof _item["@language"] !== "undefined" ? _item["@language"] : (typeof _item["@type"] !== "undefined" ? dataFactory.namedNode(_item["@type"]) : undefined))) : (((_item.termType === "NamedNode") ? (dataFactory.namedNode(_item["@id"])) : (dataFactory.blankNode(_item["@id"].substring(2))))))));
        const qudt_ScaleType$j$permissibleTransformation = _jsonObject["qudt_ScaleType$j$permissibleTransformation"].map(_item => (Transform_type.fromJson(_item).unsafeCoerce()));
        return purify.Either.of({ ..._super0, identifier, qudt_ScaleType$j$dataStructure, qudt_ScaleType$j$permissibleMaths, qudt_ScaleType$j$permissibleTransformation })
    }

    export function fromJson(json: unknown): purify.Either<zod.ZodError, Scale_type> {
        return Scale_type._propertiesFromJson(json).map(properties => new Scale_type(properties));
    }

    export function _propertiesFromRdf({ ignoreRdfType: _ignoreRdfType, languageIn: _languageIn, resource: _resource,
        // @ts-ignore
        ..._context }: { [_index: string]: any; ignoreRdfType?: boolean; languageIn?: readonly string[]; resource: rdfjsResource.Resource; }): purify.Either<rdfjsResource.Resource.ValueError, { identifier: (rdfjs.BlankNode | rdfjs.NamedNode); qudt_ScaleType$j$dataStructure: purify.Maybe<string>; qudt_ScaleType$j$permissibleMaths: readonly ((rdfjs.BlankNode | rdfjs.NamedNode | rdfjs.Literal))[]; qudt_ScaleType$j$permissibleTransformation: readonly (Transform_type)[]; } & UnwrapR<ReturnType<typeof Enumerated_Value._propertiesFromRdf>>> {
        const _super0Either = Enumerated_Value._propertiesFromRdf({ ..._context, ignoreRdfType: true, languageIn: _languageIn, resource: _resource });
        if (_super0Either.isLeft()) { return _super0Either; }

        const _super0 = _super0Either.unsafeCoerce()
        if (!_ignoreRdfType && !_resource.isInstanceOf(dataFactory.namedNode("http://qudt.org/schema/qudt/ScaleType"))) { return purify.Left(new rdfjsResource.Resource.ValueError({ focusResource: _resource, message: `${rdfjsResource.Resource.Identifier.toString(_resource.identifier)} has unexpected RDF type (expected http://qudt.org/schema/qudt/ScaleType)`, predicate: dataFactory.namedNode("http://qudt.org/schema/qudt/ScaleType") })); }

        const identifier = _resource.identifier
        const _qudt_ScaleType$j$dataStructureEither: purify.Either<rdfjsResource.Resource.ValueError, purify.Maybe<string>> = purify.Either.of(_resource.values(dataFactory.namedNode("http://qudt.org/schema/qudt/dataStructure"), { unique: true }).head().chain(_value => _value.toString()).toMaybe());
        if (_qudt_ScaleType$j$dataStructureEither.isLeft()) { return _qudt_ScaleType$j$dataStructureEither; }

        const qudt_ScaleType$j$dataStructure = _qudt_ScaleType$j$dataStructureEither.unsafeCoerce();
        const _qudt_ScaleType$j$permissibleMathsEither: purify.Either<rdfjsResource.Resource.ValueError, readonly ((rdfjs.BlankNode | rdfjs.NamedNode | rdfjs.Literal))[]> = purify.Either.of([..._resource.values(dataFactory.namedNode("http://qudt.org/schema/qudt/permissibleMaths"), { unique: true }).flatMap(_item => _item.toValues().head().chain(_value => purify.Either.of(_value.toTerm())).toMaybe().toList())]);
        if (_qudt_ScaleType$j$permissibleMathsEither.isLeft()) { return _qudt_ScaleType$j$permissibleMathsEither; }

        const qudt_ScaleType$j$permissibleMaths = _qudt_ScaleType$j$permissibleMathsEither.unsafeCoerce();
        const _qudt_ScaleType$j$permissibleTransformationEither: purify.Either<rdfjsResource.Resource.ValueError, readonly (Transform_type)[]> = purify.Either.of([..._resource.values(dataFactory.namedNode("http://qudt.org/schema/qudt/permissibleTransformation"), { unique: true }).flatMap(_item => _item.toValues().head().chain(value => value.toResource()).chain(_resource => Transform_type.fromRdf({ ..._context, ignoreRdfType: true, languageIn: _languageIn, resource: _resource })).toMaybe().toList())]);
        if (_qudt_ScaleType$j$permissibleTransformationEither.isLeft()) { return _qudt_ScaleType$j$permissibleTransformationEither; }

        const qudt_ScaleType$j$permissibleTransformation = _qudt_ScaleType$j$permissibleTransformationEither.unsafeCoerce();
        return purify.Either.of({ ..._super0, identifier, qudt_ScaleType$j$dataStructure, qudt_ScaleType$j$permissibleMaths, qudt_ScaleType$j$permissibleTransformation })
    }

    export function fromRdf(parameters: Parameters<typeof Scale_type._propertiesFromRdf>[0]): purify.Either<rdfjsResource.Resource.ValueError, Scale_type> {
        return Scale_type._propertiesFromRdf(parameters).map(properties => new Scale_type(properties));
    }

    export let fromRdfType: rdfjs.NamedNode<string> = dataFactory.namedNode("http://qudt.org/schema/qudt/ScaleType");

    export function jsonSchema() {
        return zodToJsonSchema(scaleTypeJsonZodSchema());
    }

    export function scaleTypeJsonUiSchema(parameters?: { scopePrefix?: string }) {
        const scopePrefix = parameters?.scopePrefix ?? "#";
        return { "elements": [ Enumerated_Value.enumeratedValueJsonUiSchema({ scopePrefix }), { scope: `${scopePrefix}/properties/qudt_ScaleType$j$dataStructure`, type: "Control" }, { scope: `${scopePrefix}/properties/qudt_ScaleType$j$permissibleMaths`, type: "Control" }, Transform_type.transformTypeJsonUiSchema({ scopePrefix: `${scopePrefix}/properties/qudt_ScaleType$j$permissibleTransformation` }) ], label: "Scale type", type: "Group" }
    }

    export function scaleTypeJsonZodSchema() {
        return Enumerated_Value.enumeratedValueJsonZodSchema().merge(zod.object({ "@id": zod.string().min(1),"type": zod.literal("Scale_type"),"qudt_ScaleType$j$dataStructure": zod.string().optional(),"qudt_ScaleType$j$permissibleMaths": zod.discriminatedUnion("termType", [zod.object({ "@id": zod.string().min(1), termType: zod.literal("BlankNode") }), zod.object({ "@id": zod.string().min(1), termType: zod.literal("NamedNode") }), zod.object({ "@language": zod.string().optional(), "@type": zod.string().optional(), "@value": zod.string(), termType: zod.literal("Literal") })]).array(),"qudt_ScaleType$j$permissibleTransformation": Transform_type.transformTypeJsonZodSchema().array() }));
    }

    export function sparqlConstructQuery(parameters?: { ignoreRdfType?: boolean; prefixes?: { [prefix: string]: string }; subject?: sparqljs.Triple["subject"]; } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type">): sparqljs.ConstructQuery {
        const { ignoreRdfType, subject, ...queryParameters } = parameters ?? {}

        return { ...queryParameters, prefixes: parameters?.prefixes ?? {}, queryType: "CONSTRUCT", template: (queryParameters.template ?? []).concat(Scale_type.sparqlConstructTemplateTriples({ ignoreRdfType, subject })), type: "query", where: (queryParameters.where ?? []).concat(Scale_type.sparqlWherePatterns({ ignoreRdfType, subject })) };
    }

    export function sparqlConstructQueryString(parameters?: { ignoreRdfType?: boolean; subject?: sparqljs.Triple["subject"]; variablePrefix?: string; } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type"> & sparqljs.GeneratorOptions): string {
        return new sparqljs.Generator(parameters).stringify(Scale_type.sparqlConstructQuery(parameters));
    }

    export function sparqlConstructTemplateTriples(parameters?: { ignoreRdfType?: boolean; subject?: sparqljs.Triple["subject"], variablePrefix?: string }): readonly sparqljs.Triple[] {
        const subject = parameters?.subject ?? dataFactory.variable!("scaleType");
        const variablePrefix = parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "scaleType");
        return [...Enumerated_Value.sparqlConstructTemplateTriples({ ignoreRdfType: true, subject, variablePrefix }), ...(parameters?.ignoreRdfType ? [] : [{ subject, predicate: dataFactory.namedNode("http://www.w3.org/1999/02/22-rdf-syntax-ns#type"), object: dataFactory.variable!(`${variablePrefix}RdfType`) }]), { object: dataFactory.variable!(`${variablePrefix}QudtScaleTypeJDataStructure`), predicate: dataFactory.namedNode("http://qudt.org/schema/qudt/dataStructure"), subject }, { object: dataFactory.variable!(`${variablePrefix}QudtScaleTypeJPermissibleMaths`), predicate: dataFactory.namedNode("http://qudt.org/schema/qudt/permissibleMaths"), subject }, { object: dataFactory.variable!(`${variablePrefix}QudtScaleTypeJPermissibleTransformation`), predicate: dataFactory.namedNode("http://qudt.org/schema/qudt/permissibleTransformation"), subject }, ...Transform_type.sparqlConstructTemplateTriples({ ignoreRdfType: true, subject: dataFactory.variable!(`${variablePrefix}QudtScaleTypeJPermissibleTransformation`), variablePrefix: `${variablePrefix}QudtScaleTypeJPermissibleTransformation` })];
    }

    export function sparqlWherePatterns(parameters: { ignoreRdfType?: boolean; subject?: sparqljs.Triple["subject"], variablePrefix?: string }): readonly sparqljs.Pattern[] {
        const subject = parameters?.subject ?? dataFactory.variable!("scaleType");
        const variablePrefix = parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "scaleType");
        return [...Enumerated_Value.sparqlWherePatterns({ ignoreRdfType: true, subject, variablePrefix }), ...(parameters?.ignoreRdfType ? [] : [{ triples: [{ subject, predicate: dataFactory.namedNode("http://www.w3.org/1999/02/22-rdf-syntax-ns#type"), object: dataFactory.namedNode("http://qudt.org/schema/qudt/ScaleType") }], type: "bgp" as const }, { triples: [{ subject, predicate: dataFactory.namedNode("http://www.w3.org/1999/02/22-rdf-syntax-ns#type"), object: dataFactory.variable!(`${variablePrefix}RdfType`) }], type: "bgp" as const }]), { patterns: [{ triples: [{ object: dataFactory.variable!(`${variablePrefix}QudtScaleTypeJDataStructure`), predicate: dataFactory.namedNode("http://qudt.org/schema/qudt/dataStructure"), subject }], type: "bgp" }], type: "optional" }, { patterns: [{ triples: [{ object: dataFactory.variable!(`${variablePrefix}QudtScaleTypeJPermissibleMaths`), predicate: dataFactory.namedNode("http://qudt.org/schema/qudt/permissibleMaths"), subject }], type: "bgp" }], type: "optional" }, { patterns: [{ triples: [{ object: dataFactory.variable!(`${variablePrefix}QudtScaleTypeJPermissibleTransformation`), predicate: dataFactory.namedNode("http://qudt.org/schema/qudt/permissibleTransformation"), subject }], type: "bgp" }, ...Transform_type.sparqlWherePatterns({ ignoreRdfType: true, subject: dataFactory.variable!(`${variablePrefix}QudtScaleTypeJPermissibleTransformation`), variablePrefix: `${variablePrefix}QudtScaleTypeJPermissibleTransformation` })], type: "optional" }];
    }
}
/**
 * Datatype
 */
export class Datatype extends QUDT_Concept {
    override readonly type: "Datatype" | "Scalar_Datatype" = "Datatype";

    // biome-ignore lint/complexity/noUselessConstructor: Always have a constructor
    constructor(parameters: { readonly identifier?: (rdfjs.BlankNode | rdfjs.NamedNode) | string } & ConstructorParameters<typeof QUDT_Concept>[0]) {
        super(parameters);
    }

    override get identifier(): (rdfjs.BlankNode | rdfjs.NamedNode) {
        if (typeof this._identifier === "undefined") { this._identifier = dataFactory.blankNode(); } return this._identifier;
    }

    override toRdf({ ignoreRdfType, mutateGraph, resourceSet }: { ignoreRdfType?: boolean; mutateGraph?: rdfjsResource.MutableResource.MutateGraph, resourceSet: rdfjsResource.MutableResourceSet }): rdfjsResource.MutableResource {
        const _resource = super.toRdf({ ignoreRdfType: true, mutateGraph, resourceSet });
        if (!ignoreRdfType) { _resource.add(_resource.dataFactory.namedNode("http://www.w3.org/1999/02/22-rdf-syntax-ns#type"), _resource.dataFactory.namedNode("http://qudt.org/schema/qudt/Datatype")); }

        return _resource;
    }

    override toString(): string {
        return JSON.stringify(this.toJson());
    }
}

export namespace Datatype {
    export function _propertiesFromJson(_json: unknown): purify.Either<zod.ZodError, { identifier: (rdfjs.BlankNode | rdfjs.NamedNode); } & UnwrapR<ReturnType<typeof QUDT_Concept._propertiesFromJson>>> {
        const _jsonSafeParseResult = datatypeJsonZodSchema().safeParse(_json);
        if (!_jsonSafeParseResult.success) { return purify.Left(_jsonSafeParseResult.error); }

        const _jsonObject = _jsonSafeParseResult.data;
        const _super0Either = QUDT_Concept._propertiesFromJson(_jsonObject);
        if (_super0Either.isLeft()) { return _super0Either; }

        const _super0 = _super0Either.unsafeCoerce()
        const identifier = (_jsonObject["@id"].startsWith("_:") ? dataFactory.blankNode(_jsonObject["@id"].substring(2)) : dataFactory.namedNode(_jsonObject["@id"]));
        return purify.Either.of({ ..._super0, identifier })
    }

    export function fromJson(json: unknown): purify.Either<zod.ZodError, Datatype> {
        return (Scalar_Datatype.fromJson(json) as purify.Either<zod.ZodError, Datatype>).altLazy(() => Datatype._propertiesFromJson(json).map(properties => new Datatype(properties)));
    }

    export function _propertiesFromRdf({ ignoreRdfType: _ignoreRdfType, languageIn: _languageIn, resource: _resource,
        // @ts-ignore
        ..._context }: { [_index: string]: any; ignoreRdfType?: boolean; languageIn?: readonly string[]; resource: rdfjsResource.Resource; }): purify.Either<rdfjsResource.Resource.ValueError, { identifier: (rdfjs.BlankNode | rdfjs.NamedNode); } & UnwrapR<ReturnType<typeof QUDT_Concept._propertiesFromRdf>>> {
        const _super0Either = QUDT_Concept._propertiesFromRdf({ ..._context, ignoreRdfType: true, languageIn: _languageIn, resource: _resource });
        if (_super0Either.isLeft()) { return _super0Either; }

        const _super0 = _super0Either.unsafeCoerce()
        if (!_ignoreRdfType && !_resource.isInstanceOf(dataFactory.namedNode("http://qudt.org/schema/qudt/Datatype"))) { return purify.Left(new rdfjsResource.Resource.ValueError({ focusResource: _resource, message: `${rdfjsResource.Resource.Identifier.toString(_resource.identifier)} has unexpected RDF type (expected http://qudt.org/schema/qudt/Datatype)`, predicate: dataFactory.namedNode("http://qudt.org/schema/qudt/Datatype") })); }

        const identifier = _resource.identifier
        return purify.Either.of({ ..._super0, identifier })
    }

    export function fromRdf(parameters: Parameters<typeof Datatype._propertiesFromRdf>[0]): purify.Either<rdfjsResource.Resource.ValueError, Datatype> {
        const { ignoreRdfType: _ignoreRdfType, ...otherParameters } = parameters
        return (Scalar_Datatype.fromRdf(otherParameters) as purify.Either<rdfjsResource.Resource.ValueError, Datatype>).altLazy(() => Datatype._propertiesFromRdf(parameters).map(properties => new Datatype(properties)));
    }

    export let fromRdfType: rdfjs.NamedNode<string> = dataFactory.namedNode("http://qudt.org/schema/qudt/Datatype");

    export function jsonSchema() {
        return zodToJsonSchema(datatypeJsonZodSchema());
    }

    export function datatypeJsonUiSchema(parameters?: { scopePrefix?: string }) {
        const scopePrefix = parameters?.scopePrefix ?? "#";
        return { "elements": [ QUDT_Concept.qudtConceptJsonUiSchema({ scopePrefix }) ], label: "Datatype", type: "Group" }
    }

    export function datatypeJsonZodSchema() {
        return QUDT_Concept.qudtConceptJsonZodSchema().merge(zod.object({ "@id": zod.string().min(1),"type": zod.enum(["Datatype","Scalar_Datatype"]) }));
    }

    export function sparqlConstructQuery(parameters?: { ignoreRdfType?: boolean; prefixes?: { [prefix: string]: string }; subject?: sparqljs.Triple["subject"]; } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type">): sparqljs.ConstructQuery {
        const { ignoreRdfType, subject, ...queryParameters } = parameters ?? {}

        return { ...queryParameters, prefixes: parameters?.prefixes ?? {}, queryType: "CONSTRUCT", template: (queryParameters.template ?? []).concat(Datatype.sparqlConstructTemplateTriples({ ignoreRdfType, subject })), type: "query", where: (queryParameters.where ?? []).concat(Datatype.sparqlWherePatterns({ ignoreRdfType, subject })) };
    }

    export function sparqlConstructQueryString(parameters?: { ignoreRdfType?: boolean; subject?: sparqljs.Triple["subject"]; variablePrefix?: string; } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type"> & sparqljs.GeneratorOptions): string {
        return new sparqljs.Generator(parameters).stringify(Datatype.sparqlConstructQuery(parameters));
    }

    export function sparqlConstructTemplateTriples(parameters?: { ignoreRdfType?: boolean; subject?: sparqljs.Triple["subject"], variablePrefix?: string }): readonly sparqljs.Triple[] {
        const subject = parameters?.subject ?? dataFactory.variable!("datatype");
        const variablePrefix = parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "datatype");
        return [...QUDT_Concept.sparqlConstructTemplateTriples({ ignoreRdfType: true, subject, variablePrefix }), ...(parameters?.ignoreRdfType ? [] : [{ subject, predicate: dataFactory.namedNode("http://www.w3.org/1999/02/22-rdf-syntax-ns#type"), object: dataFactory.variable!(`${variablePrefix}RdfType`) }])];
    }

    export function sparqlWherePatterns(parameters: { ignoreRdfType?: boolean; subject?: sparqljs.Triple["subject"], variablePrefix?: string }): readonly sparqljs.Pattern[] {
        const subject = parameters?.subject ?? dataFactory.variable!("datatype");
        const variablePrefix = parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "datatype");
        return [...QUDT_Concept.sparqlWherePatterns({ ignoreRdfType: true, subject, variablePrefix }), ...(parameters?.ignoreRdfType ? [] : [{ triples: [{ subject, predicate: dataFactory.namedNode("http://www.w3.org/1999/02/22-rdf-syntax-ns#type"), object: dataFactory.namedNode("http://qudt.org/schema/qudt/Datatype") }], type: "bgp" as const }, { triples: [{ subject, predicate: dataFactory.namedNode("http://www.w3.org/1999/02/22-rdf-syntax-ns#type"), object: dataFactory.variable!(`${variablePrefix}RdfType`) }], type: "bgp" as const }])];
    }
}
/**
 * Scalar Datatype
 */
export class Scalar_Datatype extends Datatype {
    override readonly type = "Scalar_Datatype";

    // biome-ignore lint/complexity/noUselessConstructor: Always have a constructor
    constructor(parameters: { readonly identifier?: (rdfjs.BlankNode | rdfjs.NamedNode) | string } & ConstructorParameters<typeof Datatype>[0]) {
        super(parameters);
    }

    override get identifier(): (rdfjs.BlankNode | rdfjs.NamedNode) {
        if (typeof this._identifier === "undefined") { this._identifier = dataFactory.blankNode(); } return this._identifier;
    }

    override toRdf({ ignoreRdfType, mutateGraph, resourceSet }: { ignoreRdfType?: boolean; mutateGraph?: rdfjsResource.MutableResource.MutateGraph, resourceSet: rdfjsResource.MutableResourceSet }): rdfjsResource.MutableResource {
        const _resource = super.toRdf({ ignoreRdfType: true, mutateGraph, resourceSet });
        if (!ignoreRdfType) { _resource.add(_resource.dataFactory.namedNode("http://www.w3.org/1999/02/22-rdf-syntax-ns#type"), _resource.dataFactory.namedNode("http://qudt.org/schema/qudt/ScalarDatatype")); }

        return _resource;
    }

    override toString(): string {
        return JSON.stringify(this.toJson());
    }
}

export namespace Scalar_Datatype {
    export function _propertiesFromJson(_json: unknown): purify.Either<zod.ZodError, { identifier: (rdfjs.BlankNode | rdfjs.NamedNode); } & UnwrapR<ReturnType<typeof Datatype._propertiesFromJson>>> {
        const _jsonSafeParseResult = scalarDatatypeJsonZodSchema().safeParse(_json);
        if (!_jsonSafeParseResult.success) { return purify.Left(_jsonSafeParseResult.error); }

        const _jsonObject = _jsonSafeParseResult.data;
        const _super0Either = Datatype._propertiesFromJson(_jsonObject);
        if (_super0Either.isLeft()) { return _super0Either; }

        const _super0 = _super0Either.unsafeCoerce()
        const identifier = (_jsonObject["@id"].startsWith("_:") ? dataFactory.blankNode(_jsonObject["@id"].substring(2)) : dataFactory.namedNode(_jsonObject["@id"]));
        return purify.Either.of({ ..._super0, identifier })
    }

    export function fromJson(json: unknown): purify.Either<zod.ZodError, Scalar_Datatype> {
        return Scalar_Datatype._propertiesFromJson(json).map(properties => new Scalar_Datatype(properties));
    }

    export function _propertiesFromRdf({ ignoreRdfType: _ignoreRdfType, languageIn: _languageIn, resource: _resource,
        // @ts-ignore
        ..._context }: { [_index: string]: any; ignoreRdfType?: boolean; languageIn?: readonly string[]; resource: rdfjsResource.Resource; }): purify.Either<rdfjsResource.Resource.ValueError, { identifier: (rdfjs.BlankNode | rdfjs.NamedNode); } & UnwrapR<ReturnType<typeof Datatype._propertiesFromRdf>>> {
        const _super0Either = Datatype._propertiesFromRdf({ ..._context, ignoreRdfType: true, languageIn: _languageIn, resource: _resource });
        if (_super0Either.isLeft()) { return _super0Either; }

        const _super0 = _super0Either.unsafeCoerce()
        if (!_ignoreRdfType && !_resource.isInstanceOf(dataFactory.namedNode("http://qudt.org/schema/qudt/ScalarDatatype"))) { return purify.Left(new rdfjsResource.Resource.ValueError({ focusResource: _resource, message: `${rdfjsResource.Resource.Identifier.toString(_resource.identifier)} has unexpected RDF type (expected http://qudt.org/schema/qudt/ScalarDatatype)`, predicate: dataFactory.namedNode("http://qudt.org/schema/qudt/ScalarDatatype") })); }

        const identifier = _resource.identifier
        return purify.Either.of({ ..._super0, identifier })
    }

    export function fromRdf(parameters: Parameters<typeof Scalar_Datatype._propertiesFromRdf>[0]): purify.Either<rdfjsResource.Resource.ValueError, Scalar_Datatype> {
        return Scalar_Datatype._propertiesFromRdf(parameters).map(properties => new Scalar_Datatype(properties));
    }

    export let fromRdfType: rdfjs.NamedNode<string> = dataFactory.namedNode("http://qudt.org/schema/qudt/ScalarDatatype");

    export function jsonSchema() {
        return zodToJsonSchema(scalarDatatypeJsonZodSchema());
    }

    export function scalarDatatypeJsonUiSchema(parameters?: { scopePrefix?: string }) {
        const scopePrefix = parameters?.scopePrefix ?? "#";
        return { "elements": [ Datatype.datatypeJsonUiSchema({ scopePrefix }) ], label: "Scalar Datatype", type: "Group" }
    }

    export function scalarDatatypeJsonZodSchema() {
        return Datatype.datatypeJsonZodSchema().merge(zod.object({ "@id": zod.string().min(1),"type": zod.literal("Scalar_Datatype") }));
    }

    export function sparqlConstructQuery(parameters?: { ignoreRdfType?: boolean; prefixes?: { [prefix: string]: string }; subject?: sparqljs.Triple["subject"]; } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type">): sparqljs.ConstructQuery {
        const { ignoreRdfType, subject, ...queryParameters } = parameters ?? {}

        return { ...queryParameters, prefixes: parameters?.prefixes ?? {}, queryType: "CONSTRUCT", template: (queryParameters.template ?? []).concat(Scalar_Datatype.sparqlConstructTemplateTriples({ ignoreRdfType, subject })), type: "query", where: (queryParameters.where ?? []).concat(Scalar_Datatype.sparqlWherePatterns({ ignoreRdfType, subject })) };
    }

    export function sparqlConstructQueryString(parameters?: { ignoreRdfType?: boolean; subject?: sparqljs.Triple["subject"]; variablePrefix?: string; } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type"> & sparqljs.GeneratorOptions): string {
        return new sparqljs.Generator(parameters).stringify(Scalar_Datatype.sparqlConstructQuery(parameters));
    }

    export function sparqlConstructTemplateTriples(parameters?: { ignoreRdfType?: boolean; subject?: sparqljs.Triple["subject"], variablePrefix?: string }): readonly sparqljs.Triple[] {
        const subject = parameters?.subject ?? dataFactory.variable!("scalarDatatype");
        const variablePrefix = parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "scalarDatatype");
        return [...Datatype.sparqlConstructTemplateTriples({ ignoreRdfType: true, subject, variablePrefix }), ...(parameters?.ignoreRdfType ? [] : [{ subject, predicate: dataFactory.namedNode("http://www.w3.org/1999/02/22-rdf-syntax-ns#type"), object: dataFactory.variable!(`${variablePrefix}RdfType`) }])];
    }

    export function sparqlWherePatterns(parameters: { ignoreRdfType?: boolean; subject?: sparqljs.Triple["subject"], variablePrefix?: string }): readonly sparqljs.Pattern[] {
        const subject = parameters?.subject ?? dataFactory.variable!("scalarDatatype");
        const variablePrefix = parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "scalarDatatype");
        return [...Datatype.sparqlWherePatterns({ ignoreRdfType: true, subject, variablePrefix }), ...(parameters?.ignoreRdfType ? [] : [{ triples: [{ subject, predicate: dataFactory.namedNode("http://www.w3.org/1999/02/22-rdf-syntax-ns#type"), object: dataFactory.namedNode("http://qudt.org/schema/qudt/ScalarDatatype") }], type: "bgp" as const }, { triples: [{ subject, predicate: dataFactory.namedNode("http://www.w3.org/1999/02/22-rdf-syntax-ns#type"), object: dataFactory.variable!(`${variablePrefix}RdfType`) }], type: "bgp" as const }])];
    }
}
/**
 * Scalar Data Item
 */
export class Scalar_Data$W$Item extends QUDT_Concept {
    override readonly type = "Scalar_Data$W$Item";
    readonly qudt_ScalarDataItem$j$datatype: purify.Maybe<Scalar_Datatype>;
    readonly qudt_ScalarDataItem$j$value: purify.Maybe<(rdfjs.BlankNode | rdfjs.NamedNode | rdfjs.Literal)>;

    constructor(parameters: { readonly identifier?: (rdfjs.BlankNode | rdfjs.NamedNode) | string, readonly qudt_ScalarDataItem$j$datatype?: Scalar_Datatype | purify.Maybe<Scalar_Datatype>, readonly qudt_ScalarDataItem$j$value?: (rdfjs.BlankNode | rdfjs.NamedNode | rdfjs.Literal) | Date | boolean | number | purify.Maybe<(rdfjs.BlankNode | rdfjs.NamedNode | rdfjs.Literal)> | string } & ConstructorParameters<typeof QUDT_Concept>[0]) {
        super(parameters);
        if (purify.Maybe.isMaybe(parameters.qudt_ScalarDataItem$j$datatype)) { this.qudt_ScalarDataItem$j$datatype = parameters.qudt_ScalarDataItem$j$datatype; } else if (typeof parameters.qudt_ScalarDataItem$j$datatype === "object" && parameters.qudt_ScalarDataItem$j$datatype instanceof Scalar_Datatype) { this.qudt_ScalarDataItem$j$datatype = purify.Maybe.of(parameters.qudt_ScalarDataItem$j$datatype); } else if (typeof parameters.qudt_ScalarDataItem$j$datatype === "undefined") { this.qudt_ScalarDataItem$j$datatype = purify.Maybe.empty(); } else { this.qudt_ScalarDataItem$j$datatype =( parameters.qudt_ScalarDataItem$j$datatype) as never;
         }

        if (purify.Maybe.isMaybe(parameters.qudt_ScalarDataItem$j$value)) { this.qudt_ScalarDataItem$j$value = parameters.qudt_ScalarDataItem$j$value; } else if (typeof parameters.qudt_ScalarDataItem$j$value === "boolean") { this.qudt_ScalarDataItem$j$value = purify.Maybe.of(rdfLiteral.toRdf(parameters.qudt_ScalarDataItem$j$value, { dataFactory })); } else if (typeof parameters.qudt_ScalarDataItem$j$value === "object" && parameters.qudt_ScalarDataItem$j$value instanceof Date) { this.qudt_ScalarDataItem$j$value = purify.Maybe.of(rdfLiteral.toRdf(parameters.qudt_ScalarDataItem$j$value, { dataFactory })); } else if (typeof parameters.qudt_ScalarDataItem$j$value === "number") { this.qudt_ScalarDataItem$j$value = purify.Maybe.of(rdfLiteral.toRdf(parameters.qudt_ScalarDataItem$j$value, { dataFactory })); } else if (typeof parameters.qudt_ScalarDataItem$j$value === "string") { this.qudt_ScalarDataItem$j$value = purify.Maybe.of(dataFactory.literal(parameters.qudt_ScalarDataItem$j$value)); } else if (typeof parameters.qudt_ScalarDataItem$j$value === "object") { this.qudt_ScalarDataItem$j$value = purify.Maybe.of(parameters.qudt_ScalarDataItem$j$value); } else if (typeof parameters.qudt_ScalarDataItem$j$value === "undefined") { this.qudt_ScalarDataItem$j$value = purify.Maybe.empty(); } else { this.qudt_ScalarDataItem$j$value =( parameters.qudt_ScalarDataItem$j$value) as never;
         }
    }

    override get identifier(): (rdfjs.BlankNode | rdfjs.NamedNode) {
        if (typeof this._identifier === "undefined") { this._identifier = dataFactory.blankNode(); } return this._identifier;
    }

    override equals(other: Scalar_Data$W$Item): EqualsResult {
        return super.equals(other).chain(() => (((left, right) => maybeEquals(left, right, ((left, right) => left.equals(right)))))(this.qudt_ScalarDataItem$j$datatype, other.qudt_ScalarDataItem$j$datatype).mapLeft(propertyValuesUnequal => ({ left: this, right: other, propertyName: "qudt_ScalarDataItem$j$datatype", propertyValuesUnequal, type: "Property" as const }))).chain(() => (((left, right) => maybeEquals(left, right, booleanEquals)))(this.qudt_ScalarDataItem$j$value, other.qudt_ScalarDataItem$j$value).mapLeft(propertyValuesUnequal => ({ left: this, right: other, propertyName: "qudt_ScalarDataItem$j$value", propertyValuesUnequal, type: "Property" as const })));
    }

    override hash<HasherT extends { update: (message: string | number[] | ArrayBuffer | Uint8Array) => void; }>(_hasher: HasherT): HasherT {
        this.hashShaclProperties(_hasher);
        return _hasher;
    }

    protected override hashShaclProperties<HasherT extends { update: (message: string | number[] | ArrayBuffer | Uint8Array) => void; }>(_hasher: HasherT): HasherT {
        super.hashShaclProperties(_hasher);
        this.qudt_ScalarDataItem$j$datatype.ifJust((_value0) => { _value0.hash(_hasher); })
        this.qudt_ScalarDataItem$j$value.ifJust((_value0) => { _hasher.update(_value0.termType);
        _hasher.update(_value0.value); })
        return _hasher;
    }

    override toJson(): { readonly "qudt_ScalarDataItem$j$datatype": (ReturnType<Scalar_Datatype["toJson"]>) | undefined; readonly "qudt_ScalarDataItem$j$value": ({ readonly "@id": string, readonly termType: "BlankNode" | "NamedNode" } | { readonly "@language": string | undefined, readonly "@type": string | undefined, readonly "@value": string, readonly termType: "Literal" }) | undefined } & ReturnType<QUDT_Concept["toJson"]> {
        return JSON.parse(JSON.stringify({ ...super.toJson(),qudt_ScalarDataItem$j$datatype: this.qudt_ScalarDataItem$j$datatype.map(_item => (_item.toJson())).extract(),qudt_ScalarDataItem$j$value: this.qudt_ScalarDataItem$j$value.map(_item => ((_item.termType === "Literal") ? { "@language": _item.language.length > 0 ? _item.language : undefined, "@type": _item.datatype.value !== "http://www.w3.org/2001/XMLSchema#string" ? _item.datatype.value : undefined, "@value": _item.value, termType: "Literal" as const } : (_item.termType === "NamedNode") ? { "@id": _item.value, termType: "NamedNode" as const } : { "@id": `_:${_item.value}`, termType: "BlankNode" as const })).extract() } satisfies ReturnType<Scalar_Data$W$Item["toJson"]>));
    }

    override toRdf({ ignoreRdfType, mutateGraph, resourceSet }: { ignoreRdfType?: boolean; mutateGraph?: rdfjsResource.MutableResource.MutateGraph, resourceSet: rdfjsResource.MutableResourceSet }): rdfjsResource.MutableResource {
        const _resource = super.toRdf({ ignoreRdfType: true, mutateGraph, resourceSet });
        if (!ignoreRdfType) { _resource.add(_resource.dataFactory.namedNode("http://www.w3.org/1999/02/22-rdf-syntax-ns#type"), _resource.dataFactory.namedNode("http://qudt.org/schema/qudt/ScalarDataItem")); }

        _resource.add(dataFactory.namedNode("http://qudt.org/schema/qudt/datatype"), this.qudt_ScalarDataItem$j$datatype.map((_value) => _value.toRdf({ mutateGraph: mutateGraph, resourceSet: resourceSet })));
        _resource.add(dataFactory.namedNode("http://qudt.org/schema/qudt/value"), this.qudt_ScalarDataItem$j$value);
        return _resource;
    }

    override toString(): string {
        return JSON.stringify(this.toJson());
    }
}

export namespace Scalar_Data$W$Item {
    export function _propertiesFromJson(_json: unknown): purify.Either<zod.ZodError, { identifier: (rdfjs.BlankNode | rdfjs.NamedNode); qudt_ScalarDataItem$j$datatype: purify.Maybe<Scalar_Datatype>; qudt_ScalarDataItem$j$value: purify.Maybe<(rdfjs.BlankNode | rdfjs.NamedNode | rdfjs.Literal)>; } & UnwrapR<ReturnType<typeof QUDT_Concept._propertiesFromJson>>> {
        const _jsonSafeParseResult = scalarDataWItemJsonZodSchema().safeParse(_json);
        if (!_jsonSafeParseResult.success) { return purify.Left(_jsonSafeParseResult.error); }

        const _jsonObject = _jsonSafeParseResult.data;
        const _super0Either = QUDT_Concept._propertiesFromJson(_jsonObject);
        if (_super0Either.isLeft()) { return _super0Either; }

        const _super0 = _super0Either.unsafeCoerce()
        const identifier = (_jsonObject["@id"].startsWith("_:") ? dataFactory.blankNode(_jsonObject["@id"].substring(2)) : dataFactory.namedNode(_jsonObject["@id"]));
        const qudt_ScalarDataItem$j$datatype = purify.Maybe.fromNullable(_jsonObject["qudt_ScalarDataItem$j$datatype"]).map(_item => (Scalar_Datatype.fromJson(_item).unsafeCoerce()));
        const qudt_ScalarDataItem$j$value = purify.Maybe.fromNullable(_jsonObject["qudt_ScalarDataItem$j$value"]).map(_item => (((_item.termType === "Literal") ? (dataFactory.literal(_item["@value"], typeof _item["@language"] !== "undefined" ? _item["@language"] : (typeof _item["@type"] !== "undefined" ? dataFactory.namedNode(_item["@type"]) : undefined))) : (((_item.termType === "NamedNode") ? (dataFactory.namedNode(_item["@id"])) : (dataFactory.blankNode(_item["@id"].substring(2))))))));
        return purify.Either.of({ ..._super0, identifier, qudt_ScalarDataItem$j$datatype, qudt_ScalarDataItem$j$value })
    }

    export function fromJson(json: unknown): purify.Either<zod.ZodError, Scalar_Data$W$Item> {
        return Scalar_Data$W$Item._propertiesFromJson(json).map(properties => new Scalar_Data$W$Item(properties));
    }

    export function _propertiesFromRdf({ ignoreRdfType: _ignoreRdfType, languageIn: _languageIn, resource: _resource,
        // @ts-ignore
        ..._context }: { [_index: string]: any; ignoreRdfType?: boolean; languageIn?: readonly string[]; resource: rdfjsResource.Resource; }): purify.Either<rdfjsResource.Resource.ValueError, { identifier: (rdfjs.BlankNode | rdfjs.NamedNode); qudt_ScalarDataItem$j$datatype: purify.Maybe<Scalar_Datatype>; qudt_ScalarDataItem$j$value: purify.Maybe<(rdfjs.BlankNode | rdfjs.NamedNode | rdfjs.Literal)>; } & UnwrapR<ReturnType<typeof QUDT_Concept._propertiesFromRdf>>> {
        const _super0Either = QUDT_Concept._propertiesFromRdf({ ..._context, ignoreRdfType: true, languageIn: _languageIn, resource: _resource });
        if (_super0Either.isLeft()) { return _super0Either; }

        const _super0 = _super0Either.unsafeCoerce()
        if (!_ignoreRdfType && !_resource.isInstanceOf(dataFactory.namedNode("http://qudt.org/schema/qudt/ScalarDataItem"))) { return purify.Left(new rdfjsResource.Resource.ValueError({ focusResource: _resource, message: `${rdfjsResource.Resource.Identifier.toString(_resource.identifier)} has unexpected RDF type (expected http://qudt.org/schema/qudt/ScalarDataItem)`, predicate: dataFactory.namedNode("http://qudt.org/schema/qudt/ScalarDataItem") })); }

        const identifier = _resource.identifier
        const _qudt_ScalarDataItem$j$datatypeEither: purify.Either<rdfjsResource.Resource.ValueError, purify.Maybe<Scalar_Datatype>> = purify.Either.of(_resource.values(dataFactory.namedNode("http://qudt.org/schema/qudt/datatype"), { unique: true }).head().chain(value => value.toResource()).chain(_resource => Scalar_Datatype.fromRdf({ ..._context, ignoreRdfType: true, languageIn: _languageIn, resource: _resource })).toMaybe());
        if (_qudt_ScalarDataItem$j$datatypeEither.isLeft()) { return _qudt_ScalarDataItem$j$datatypeEither; }

        const qudt_ScalarDataItem$j$datatype = _qudt_ScalarDataItem$j$datatypeEither.unsafeCoerce();
        const _qudt_ScalarDataItem$j$valueEither: purify.Either<rdfjsResource.Resource.ValueError, purify.Maybe<(rdfjs.BlankNode | rdfjs.NamedNode | rdfjs.Literal)>> = purify.Either.of(_resource.values(dataFactory.namedNode("http://qudt.org/schema/qudt/value"), { unique: true }).head().chain(_value => purify.Either.of(_value.toTerm())).toMaybe());
        if (_qudt_ScalarDataItem$j$valueEither.isLeft()) { return _qudt_ScalarDataItem$j$valueEither; }

        const qudt_ScalarDataItem$j$value = _qudt_ScalarDataItem$j$valueEither.unsafeCoerce();
        return purify.Either.of({ ..._super0, identifier, qudt_ScalarDataItem$j$datatype, qudt_ScalarDataItem$j$value })
    }

    export function fromRdf(parameters: Parameters<typeof Scalar_Data$W$Item._propertiesFromRdf>[0]): purify.Either<rdfjsResource.Resource.ValueError, Scalar_Data$W$Item> {
        return Scalar_Data$W$Item._propertiesFromRdf(parameters).map(properties => new Scalar_Data$W$Item(properties));
    }

    export let fromRdfType: rdfjs.NamedNode<string> = dataFactory.namedNode("http://qudt.org/schema/qudt/ScalarDataItem");

    export function jsonSchema() {
        return zodToJsonSchema(scalarDataWItemJsonZodSchema());
    }

    export function scalarDataWItemJsonUiSchema(parameters?: { scopePrefix?: string }) {
        const scopePrefix = parameters?.scopePrefix ?? "#";
        return { "elements": [ QUDT_Concept.qudtConceptJsonUiSchema({ scopePrefix }), Scalar_Datatype.scalarDatatypeJsonUiSchema({ scopePrefix: `${scopePrefix}/properties/qudt_ScalarDataItem$j$datatype` }), { scope: `${scopePrefix}/properties/qudt_ScalarDataItem$j$value`, type: "Control" } ], label: "Scalar Data Item", type: "Group" }
    }

    export function scalarDataWItemJsonZodSchema() {
        return QUDT_Concept.qudtConceptJsonZodSchema().merge(zod.object({ "@id": zod.string().min(1),"type": zod.literal("Scalar_Data$W$Item"),"qudt_ScalarDataItem$j$datatype": Scalar_Datatype.scalarDatatypeJsonZodSchema().optional(),"qudt_ScalarDataItem$j$value": zod.discriminatedUnion("termType", [zod.object({ "@id": zod.string().min(1), termType: zod.literal("BlankNode") }), zod.object({ "@id": zod.string().min(1), termType: zod.literal("NamedNode") }), zod.object({ "@language": zod.string().optional(), "@type": zod.string().optional(), "@value": zod.string(), termType: zod.literal("Literal") })]).optional() }));
    }

    export function sparqlConstructQuery(parameters?: { ignoreRdfType?: boolean; prefixes?: { [prefix: string]: string }; subject?: sparqljs.Triple["subject"]; } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type">): sparqljs.ConstructQuery {
        const { ignoreRdfType, subject, ...queryParameters } = parameters ?? {}

        return { ...queryParameters, prefixes: parameters?.prefixes ?? {}, queryType: "CONSTRUCT", template: (queryParameters.template ?? []).concat(Scalar_Data$W$Item.sparqlConstructTemplateTriples({ ignoreRdfType, subject })), type: "query", where: (queryParameters.where ?? []).concat(Scalar_Data$W$Item.sparqlWherePatterns({ ignoreRdfType, subject })) };
    }

    export function sparqlConstructQueryString(parameters?: { ignoreRdfType?: boolean; subject?: sparqljs.Triple["subject"]; variablePrefix?: string; } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type"> & sparqljs.GeneratorOptions): string {
        return new sparqljs.Generator(parameters).stringify(Scalar_Data$W$Item.sparqlConstructQuery(parameters));
    }

    export function sparqlConstructTemplateTriples(parameters?: { ignoreRdfType?: boolean; subject?: sparqljs.Triple["subject"], variablePrefix?: string }): readonly sparqljs.Triple[] {
        const subject = parameters?.subject ?? dataFactory.variable!("scalarDataWItem");
        const variablePrefix = parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "scalarDataWItem");
        return [...QUDT_Concept.sparqlConstructTemplateTriples({ ignoreRdfType: true, subject, variablePrefix }), ...(parameters?.ignoreRdfType ? [] : [{ subject, predicate: dataFactory.namedNode("http://www.w3.org/1999/02/22-rdf-syntax-ns#type"), object: dataFactory.variable!(`${variablePrefix}RdfType`) }]), { object: dataFactory.variable!(`${variablePrefix}QudtScalarDataItemJDatatype`), predicate: dataFactory.namedNode("http://qudt.org/schema/qudt/datatype"), subject }, ...Scalar_Datatype.sparqlConstructTemplateTriples({ ignoreRdfType: true, subject: dataFactory.variable!(`${variablePrefix}QudtScalarDataItemJDatatype`), variablePrefix: `${variablePrefix}QudtScalarDataItemJDatatype` }), { object: dataFactory.variable!(`${variablePrefix}QudtScalarDataItemJValue`), predicate: dataFactory.namedNode("http://qudt.org/schema/qudt/value"), subject }];
    }

    export function sparqlWherePatterns(parameters: { ignoreRdfType?: boolean; subject?: sparqljs.Triple["subject"], variablePrefix?: string }): readonly sparqljs.Pattern[] {
        const subject = parameters?.subject ?? dataFactory.variable!("scalarDataWItem");
        const variablePrefix = parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "scalarDataWItem");
        return [...QUDT_Concept.sparqlWherePatterns({ ignoreRdfType: true, subject, variablePrefix }), ...(parameters?.ignoreRdfType ? [] : [{ triples: [{ subject, predicate: dataFactory.namedNode("http://www.w3.org/1999/02/22-rdf-syntax-ns#type"), object: dataFactory.namedNode("http://qudt.org/schema/qudt/ScalarDataItem") }], type: "bgp" as const }, { triples: [{ subject, predicate: dataFactory.namedNode("http://www.w3.org/1999/02/22-rdf-syntax-ns#type"), object: dataFactory.variable!(`${variablePrefix}RdfType`) }], type: "bgp" as const }]), { patterns: [{ triples: [{ object: dataFactory.variable!(`${variablePrefix}QudtScalarDataItemJDatatype`), predicate: dataFactory.namedNode("http://qudt.org/schema/qudt/datatype"), subject }], type: "bgp" }, ...Scalar_Datatype.sparqlWherePatterns({ ignoreRdfType: true, subject: dataFactory.variable!(`${variablePrefix}QudtScalarDataItemJDatatype`), variablePrefix: `${variablePrefix}QudtScalarDataItemJDatatype` })], type: "optional" }, { patterns: [{ triples: [{ object: dataFactory.variable!(`${variablePrefix}QudtScalarDataItemJValue`), predicate: dataFactory.namedNode("http://qudt.org/schema/qudt/value"), subject }], type: "bgp" }], type: "optional" }];
    }
}
/**
 * Rule Type
 */
export class Rule_Type extends Enumerated_Value {
    override readonly type = "Rule_Type";

    // biome-ignore lint/complexity/noUselessConstructor: Always have a constructor
    constructor(parameters: { readonly identifier?: (rdfjs.BlankNode | rdfjs.NamedNode) | string } & ConstructorParameters<typeof Enumerated_Value>[0]) {
        super(parameters);
    }

    override get identifier(): (rdfjs.BlankNode | rdfjs.NamedNode) {
        if (typeof this._identifier === "undefined") { this._identifier = dataFactory.blankNode(); } return this._identifier;
    }

    override toRdf({ ignoreRdfType, mutateGraph, resourceSet }: { ignoreRdfType?: boolean; mutateGraph?: rdfjsResource.MutableResource.MutateGraph, resourceSet: rdfjsResource.MutableResourceSet }): rdfjsResource.MutableResource {
        const _resource = super.toRdf({ ignoreRdfType: true, mutateGraph, resourceSet });
        if (!ignoreRdfType) { _resource.add(_resource.dataFactory.namedNode("http://www.w3.org/1999/02/22-rdf-syntax-ns#type"), _resource.dataFactory.namedNode("http://qudt.org/schema/qudt/RuleType")); }

        return _resource;
    }

    override toString(): string {
        return JSON.stringify(this.toJson());
    }
}

export namespace Rule_Type {
    export function _propertiesFromJson(_json: unknown): purify.Either<zod.ZodError, { identifier: (rdfjs.BlankNode | rdfjs.NamedNode); } & UnwrapR<ReturnType<typeof Enumerated_Value._propertiesFromJson>>> {
        const _jsonSafeParseResult = ruleTypeJsonZodSchema().safeParse(_json);
        if (!_jsonSafeParseResult.success) { return purify.Left(_jsonSafeParseResult.error); }

        const _jsonObject = _jsonSafeParseResult.data;
        const _super0Either = Enumerated_Value._propertiesFromJson(_jsonObject);
        if (_super0Either.isLeft()) { return _super0Either; }

        const _super0 = _super0Either.unsafeCoerce()
        const identifier = (_jsonObject["@id"].startsWith("_:") ? dataFactory.blankNode(_jsonObject["@id"].substring(2)) : dataFactory.namedNode(_jsonObject["@id"]));
        return purify.Either.of({ ..._super0, identifier })
    }

    export function fromJson(json: unknown): purify.Either<zod.ZodError, Rule_Type> {
        return Rule_Type._propertiesFromJson(json).map(properties => new Rule_Type(properties));
    }

    export function _propertiesFromRdf({ ignoreRdfType: _ignoreRdfType, languageIn: _languageIn, resource: _resource,
        // @ts-ignore
        ..._context }: { [_index: string]: any; ignoreRdfType?: boolean; languageIn?: readonly string[]; resource: rdfjsResource.Resource; }): purify.Either<rdfjsResource.Resource.ValueError, { identifier: (rdfjs.BlankNode | rdfjs.NamedNode); } & UnwrapR<ReturnType<typeof Enumerated_Value._propertiesFromRdf>>> {
        const _super0Either = Enumerated_Value._propertiesFromRdf({ ..._context, ignoreRdfType: true, languageIn: _languageIn, resource: _resource });
        if (_super0Either.isLeft()) { return _super0Either; }

        const _super0 = _super0Either.unsafeCoerce()
        if (!_ignoreRdfType && !_resource.isInstanceOf(dataFactory.namedNode("http://qudt.org/schema/qudt/RuleType"))) { return purify.Left(new rdfjsResource.Resource.ValueError({ focusResource: _resource, message: `${rdfjsResource.Resource.Identifier.toString(_resource.identifier)} has unexpected RDF type (expected http://qudt.org/schema/qudt/RuleType)`, predicate: dataFactory.namedNode("http://qudt.org/schema/qudt/RuleType") })); }

        const identifier = _resource.identifier
        return purify.Either.of({ ..._super0, identifier })
    }

    export function fromRdf(parameters: Parameters<typeof Rule_Type._propertiesFromRdf>[0]): purify.Either<rdfjsResource.Resource.ValueError, Rule_Type> {
        return Rule_Type._propertiesFromRdf(parameters).map(properties => new Rule_Type(properties));
    }

    export let fromRdfType: rdfjs.NamedNode<string> = dataFactory.namedNode("http://qudt.org/schema/qudt/RuleType");

    export function jsonSchema() {
        return zodToJsonSchema(ruleTypeJsonZodSchema());
    }

    export function ruleTypeJsonUiSchema(parameters?: { scopePrefix?: string }) {
        const scopePrefix = parameters?.scopePrefix ?? "#";
        return { "elements": [ Enumerated_Value.enumeratedValueJsonUiSchema({ scopePrefix }) ], label: "Rule Type", type: "Group" }
    }

    export function ruleTypeJsonZodSchema() {
        return Enumerated_Value.enumeratedValueJsonZodSchema().merge(zod.object({ "@id": zod.string().min(1),"type": zod.literal("Rule_Type") }));
    }

    export function sparqlConstructQuery(parameters?: { ignoreRdfType?: boolean; prefixes?: { [prefix: string]: string }; subject?: sparqljs.Triple["subject"]; } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type">): sparqljs.ConstructQuery {
        const { ignoreRdfType, subject, ...queryParameters } = parameters ?? {}

        return { ...queryParameters, prefixes: parameters?.prefixes ?? {}, queryType: "CONSTRUCT", template: (queryParameters.template ?? []).concat(Rule_Type.sparqlConstructTemplateTriples({ ignoreRdfType, subject })), type: "query", where: (queryParameters.where ?? []).concat(Rule_Type.sparqlWherePatterns({ ignoreRdfType, subject })) };
    }

    export function sparqlConstructQueryString(parameters?: { ignoreRdfType?: boolean; subject?: sparqljs.Triple["subject"]; variablePrefix?: string; } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type"> & sparqljs.GeneratorOptions): string {
        return new sparqljs.Generator(parameters).stringify(Rule_Type.sparqlConstructQuery(parameters));
    }

    export function sparqlConstructTemplateTriples(parameters?: { ignoreRdfType?: boolean; subject?: sparqljs.Triple["subject"], variablePrefix?: string }): readonly sparqljs.Triple[] {
        const subject = parameters?.subject ?? dataFactory.variable!("ruleType");
        const variablePrefix = parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "ruleType");
        return [...Enumerated_Value.sparqlConstructTemplateTriples({ ignoreRdfType: true, subject, variablePrefix }), ...(parameters?.ignoreRdfType ? [] : [{ subject, predicate: dataFactory.namedNode("http://www.w3.org/1999/02/22-rdf-syntax-ns#type"), object: dataFactory.variable!(`${variablePrefix}RdfType`) }])];
    }

    export function sparqlWherePatterns(parameters: { ignoreRdfType?: boolean; subject?: sparqljs.Triple["subject"], variablePrefix?: string }): readonly sparqljs.Pattern[] {
        const subject = parameters?.subject ?? dataFactory.variable!("ruleType");
        const variablePrefix = parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "ruleType");
        return [...Enumerated_Value.sparqlWherePatterns({ ignoreRdfType: true, subject, variablePrefix }), ...(parameters?.ignoreRdfType ? [] : [{ triples: [{ subject, predicate: dataFactory.namedNode("http://www.w3.org/1999/02/22-rdf-syntax-ns#type"), object: dataFactory.namedNode("http://qudt.org/schema/qudt/RuleType") }], type: "bgp" as const }, { triples: [{ subject, predicate: dataFactory.namedNode("http://www.w3.org/1999/02/22-rdf-syntax-ns#type"), object: dataFactory.variable!(`${variablePrefix}RdfType`) }], type: "bgp" as const }])];
    }
}
/**
 * Rule
 */
export class Rule extends QUDT_Concept {
    override readonly type = "Rule";
    readonly qudt_Rule$j$example: readonly ((rdfjs.BlankNode | rdfjs.NamedNode | rdfjs.Literal))[];
    readonly qudt_Rule$j$rationale: readonly (string)[];
    readonly qudt_Rule$j$ruleType: readonly (Rule_Type)[];

    constructor(parameters: { readonly identifier?: (rdfjs.BlankNode | rdfjs.NamedNode) | string, readonly qudt_Rule$j$example?: readonly ((rdfjs.BlankNode | rdfjs.NamedNode | rdfjs.Literal))[], readonly qudt_Rule$j$rationale?: readonly (string)[], readonly qudt_Rule$j$ruleType?: readonly (Rule_Type)[] } & ConstructorParameters<typeof QUDT_Concept>[0]) {
        super(parameters);
        if (typeof parameters.qudt_Rule$j$example === "undefined") { this.qudt_Rule$j$example = []; } else if (Array.isArray(parameters.qudt_Rule$j$example)) { this.qudt_Rule$j$example = parameters.qudt_Rule$j$example; } else { this.qudt_Rule$j$example =( parameters.qudt_Rule$j$example) as never;
         }

        if (typeof parameters.qudt_Rule$j$rationale === "undefined") { this.qudt_Rule$j$rationale = []; } else if (Array.isArray(parameters.qudt_Rule$j$rationale)) { this.qudt_Rule$j$rationale = parameters.qudt_Rule$j$rationale; } else { this.qudt_Rule$j$rationale =( parameters.qudt_Rule$j$rationale) as never;
         }

        if (typeof parameters.qudt_Rule$j$ruleType === "undefined") { this.qudt_Rule$j$ruleType = []; } else if (Array.isArray(parameters.qudt_Rule$j$ruleType)) { this.qudt_Rule$j$ruleType = parameters.qudt_Rule$j$ruleType; } else { this.qudt_Rule$j$ruleType =( parameters.qudt_Rule$j$ruleType) as never;
         }
    }

    override get identifier(): (rdfjs.BlankNode | rdfjs.NamedNode) {
        if (typeof this._identifier === "undefined") { this._identifier = dataFactory.blankNode(); } return this._identifier;
    }

    override equals(other: Rule): EqualsResult {
        return super.equals(other).chain(() => (((left, right) => arrayEquals(left, right, booleanEquals)))(this.qudt_Rule$j$example, other.qudt_Rule$j$example).mapLeft(propertyValuesUnequal => ({ left: this, right: other, propertyName: "qudt_Rule$j$example", propertyValuesUnequal, type: "Property" as const }))).chain(() => (((left, right) => arrayEquals(left, right, strictEquals)))(this.qudt_Rule$j$rationale, other.qudt_Rule$j$rationale).mapLeft(propertyValuesUnequal => ({ left: this, right: other, propertyName: "qudt_Rule$j$rationale", propertyValuesUnequal, type: "Property" as const }))).chain(() => (((left, right) => arrayEquals(left, right, ((left, right) => left.equals(right)))))(this.qudt_Rule$j$ruleType, other.qudt_Rule$j$ruleType).mapLeft(propertyValuesUnequal => ({ left: this, right: other, propertyName: "qudt_Rule$j$ruleType", propertyValuesUnequal, type: "Property" as const })));
    }

    override hash<HasherT extends { update: (message: string | number[] | ArrayBuffer | Uint8Array) => void; }>(_hasher: HasherT): HasherT {
        this.hashShaclProperties(_hasher);
        return _hasher;
    }

    protected override hashShaclProperties<HasherT extends { update: (message: string | number[] | ArrayBuffer | Uint8Array) => void; }>(_hasher: HasherT): HasherT {
        super.hashShaclProperties(_hasher);
        for (const _item0 of this.qudt_Rule$j$example) { _hasher.update(_item0.termType);
        _hasher.update(_item0.value); }

        for (const _item0 of this.qudt_Rule$j$rationale) { _hasher.update(_item0); }

        for (const _item0 of this.qudt_Rule$j$ruleType) { _item0.hash(_hasher); }

        return _hasher;
    }

    override toJson(): { readonly "qudt_Rule$j$example": readonly ({ readonly "@id": string, readonly termType: "BlankNode" | "NamedNode" } | { readonly "@language": string | undefined, readonly "@type": string | undefined, readonly "@value": string, readonly termType: "Literal" })[]; readonly "qudt_Rule$j$rationale": readonly (string)[]; readonly "qudt_Rule$j$ruleType": readonly (ReturnType<Rule_Type["toJson"]>)[] } & ReturnType<QUDT_Concept["toJson"]> {
        return JSON.parse(JSON.stringify({ ...super.toJson(),qudt_Rule$j$example: this.qudt_Rule$j$example.map(_item => ((_item.termType === "Literal") ? { "@language": _item.language.length > 0 ? _item.language : undefined, "@type": _item.datatype.value !== "http://www.w3.org/2001/XMLSchema#string" ? _item.datatype.value : undefined, "@value": _item.value, termType: "Literal" as const } : (_item.termType === "NamedNode") ? { "@id": _item.value, termType: "NamedNode" as const } : { "@id": `_:${_item.value}`, termType: "BlankNode" as const })),qudt_Rule$j$rationale: this.qudt_Rule$j$rationale.map(_item => (_item)),qudt_Rule$j$ruleType: this.qudt_Rule$j$ruleType.map(_item => (_item.toJson())) } satisfies ReturnType<Rule["toJson"]>));
    }

    override toRdf({ ignoreRdfType, mutateGraph, resourceSet }: { ignoreRdfType?: boolean; mutateGraph?: rdfjsResource.MutableResource.MutateGraph, resourceSet: rdfjsResource.MutableResourceSet }): rdfjsResource.MutableResource {
        const _resource = super.toRdf({ ignoreRdfType: true, mutateGraph, resourceSet });
        if (!ignoreRdfType) { _resource.add(_resource.dataFactory.namedNode("http://www.w3.org/1999/02/22-rdf-syntax-ns#type"), _resource.dataFactory.namedNode("http://qudt.org/schema/qudt/Rule")); }

        _resource.add(dataFactory.namedNode("http://qudt.org/schema/qudt/example"), this.qudt_Rule$j$example.map((_item) => _item));
        _resource.add(dataFactory.namedNode("http://qudt.org/schema/qudt/rationale"), this.qudt_Rule$j$rationale.map((_item) => _item));
        _resource.add(dataFactory.namedNode("http://qudt.org/schema/qudt/ruleType"), this.qudt_Rule$j$ruleType.map((_item) => _item.toRdf({ mutateGraph: mutateGraph, resourceSet: resourceSet })));
        return _resource;
    }

    override toString(): string {
        return JSON.stringify(this.toJson());
    }
}

export namespace Rule {
    export function _propertiesFromJson(_json: unknown): purify.Either<zod.ZodError, { identifier: (rdfjs.BlankNode | rdfjs.NamedNode); qudt_Rule$j$example: readonly ((rdfjs.BlankNode | rdfjs.NamedNode | rdfjs.Literal))[]; qudt_Rule$j$rationale: readonly (string)[]; qudt_Rule$j$ruleType: readonly (Rule_Type)[]; } & UnwrapR<ReturnType<typeof QUDT_Concept._propertiesFromJson>>> {
        const _jsonSafeParseResult = ruleJsonZodSchema().safeParse(_json);
        if (!_jsonSafeParseResult.success) { return purify.Left(_jsonSafeParseResult.error); }

        const _jsonObject = _jsonSafeParseResult.data;
        const _super0Either = QUDT_Concept._propertiesFromJson(_jsonObject);
        if (_super0Either.isLeft()) { return _super0Either; }

        const _super0 = _super0Either.unsafeCoerce()
        const identifier = (_jsonObject["@id"].startsWith("_:") ? dataFactory.blankNode(_jsonObject["@id"].substring(2)) : dataFactory.namedNode(_jsonObject["@id"]));
        const qudt_Rule$j$example = _jsonObject["qudt_Rule$j$example"].map(_item => (((_item.termType === "Literal") ? (dataFactory.literal(_item["@value"], typeof _item["@language"] !== "undefined" ? _item["@language"] : (typeof _item["@type"] !== "undefined" ? dataFactory.namedNode(_item["@type"]) : undefined))) : (((_item.termType === "NamedNode") ? (dataFactory.namedNode(_item["@id"])) : (dataFactory.blankNode(_item["@id"].substring(2))))))));
        const qudt_Rule$j$rationale = _jsonObject["qudt_Rule$j$rationale"];
        const qudt_Rule$j$ruleType = _jsonObject["qudt_Rule$j$ruleType"].map(_item => (Rule_Type.fromJson(_item).unsafeCoerce()));
        return purify.Either.of({ ..._super0, identifier, qudt_Rule$j$example, qudt_Rule$j$rationale, qudt_Rule$j$ruleType })
    }

    export function fromJson(json: unknown): purify.Either<zod.ZodError, Rule> {
        return Rule._propertiesFromJson(json).map(properties => new Rule(properties));
    }

    export function _propertiesFromRdf({ ignoreRdfType: _ignoreRdfType, languageIn: _languageIn, resource: _resource,
        // @ts-ignore
        ..._context }: { [_index: string]: any; ignoreRdfType?: boolean; languageIn?: readonly string[]; resource: rdfjsResource.Resource; }): purify.Either<rdfjsResource.Resource.ValueError, { identifier: (rdfjs.BlankNode | rdfjs.NamedNode); qudt_Rule$j$example: readonly ((rdfjs.BlankNode | rdfjs.NamedNode | rdfjs.Literal))[]; qudt_Rule$j$rationale: readonly (string)[]; qudt_Rule$j$ruleType: readonly (Rule_Type)[]; } & UnwrapR<ReturnType<typeof QUDT_Concept._propertiesFromRdf>>> {
        const _super0Either = QUDT_Concept._propertiesFromRdf({ ..._context, ignoreRdfType: true, languageIn: _languageIn, resource: _resource });
        if (_super0Either.isLeft()) { return _super0Either; }

        const _super0 = _super0Either.unsafeCoerce()
        if (!_ignoreRdfType && !_resource.isInstanceOf(dataFactory.namedNode("http://qudt.org/schema/qudt/Rule"))) { return purify.Left(new rdfjsResource.Resource.ValueError({ focusResource: _resource, message: `${rdfjsResource.Resource.Identifier.toString(_resource.identifier)} has unexpected RDF type (expected http://qudt.org/schema/qudt/Rule)`, predicate: dataFactory.namedNode("http://qudt.org/schema/qudt/Rule") })); }

        const identifier = _resource.identifier
        const _qudt_Rule$j$exampleEither: purify.Either<rdfjsResource.Resource.ValueError, readonly ((rdfjs.BlankNode | rdfjs.NamedNode | rdfjs.Literal))[]> = purify.Either.of([..._resource.values(dataFactory.namedNode("http://qudt.org/schema/qudt/example"), { unique: true }).flatMap(_item => _item.toValues().head().chain(_value => purify.Either.of(_value.toTerm())).toMaybe().toList())]);
        if (_qudt_Rule$j$exampleEither.isLeft()) { return _qudt_Rule$j$exampleEither; }

        const qudt_Rule$j$example = _qudt_Rule$j$exampleEither.unsafeCoerce();
        const _qudt_Rule$j$rationaleEither: purify.Either<rdfjsResource.Resource.ValueError, readonly (string)[]> = purify.Either.of([..._resource.values(dataFactory.namedNode("http://qudt.org/schema/qudt/rationale"), { unique: true }).flatMap(_item => _item.toValues().head().chain(_value => _value.toString()).toMaybe().toList())]);
        if (_qudt_Rule$j$rationaleEither.isLeft()) { return _qudt_Rule$j$rationaleEither; }

        const qudt_Rule$j$rationale = _qudt_Rule$j$rationaleEither.unsafeCoerce();
        const _qudt_Rule$j$ruleTypeEither: purify.Either<rdfjsResource.Resource.ValueError, readonly (Rule_Type)[]> = purify.Either.of([..._resource.values(dataFactory.namedNode("http://qudt.org/schema/qudt/ruleType"), { unique: true }).flatMap(_item => _item.toValues().head().chain(value => value.toResource()).chain(_resource => Rule_Type.fromRdf({ ..._context, ignoreRdfType: true, languageIn: _languageIn, resource: _resource })).toMaybe().toList())]);
        if (_qudt_Rule$j$ruleTypeEither.isLeft()) { return _qudt_Rule$j$ruleTypeEither; }

        const qudt_Rule$j$ruleType = _qudt_Rule$j$ruleTypeEither.unsafeCoerce();
        return purify.Either.of({ ..._super0, identifier, qudt_Rule$j$example, qudt_Rule$j$rationale, qudt_Rule$j$ruleType })
    }

    export function fromRdf(parameters: Parameters<typeof Rule._propertiesFromRdf>[0]): purify.Either<rdfjsResource.Resource.ValueError, Rule> {
        return Rule._propertiesFromRdf(parameters).map(properties => new Rule(properties));
    }

    export let fromRdfType: rdfjs.NamedNode<string> = dataFactory.namedNode("http://qudt.org/schema/qudt/Rule");

    export function jsonSchema() {
        return zodToJsonSchema(ruleJsonZodSchema());
    }

    export function ruleJsonUiSchema(parameters?: { scopePrefix?: string }) {
        const scopePrefix = parameters?.scopePrefix ?? "#";
        return { "elements": [ QUDT_Concept.qudtConceptJsonUiSchema({ scopePrefix }), { scope: `${scopePrefix}/properties/qudt_Rule$j$example`, type: "Control" }, { scope: `${scopePrefix}/properties/qudt_Rule$j$rationale`, type: "Control" }, Rule_Type.ruleTypeJsonUiSchema({ scopePrefix: `${scopePrefix}/properties/qudt_Rule$j$ruleType` }) ], label: "Rule", type: "Group" }
    }

    export function ruleJsonZodSchema() {
        return QUDT_Concept.qudtConceptJsonZodSchema().merge(zod.object({ "@id": zod.string().min(1),"type": zod.literal("Rule"),"qudt_Rule$j$example": zod.discriminatedUnion("termType", [zod.object({ "@id": zod.string().min(1), termType: zod.literal("BlankNode") }), zod.object({ "@id": zod.string().min(1), termType: zod.literal("NamedNode") }), zod.object({ "@language": zod.string().optional(), "@type": zod.string().optional(), "@value": zod.string(), termType: zod.literal("Literal") })]).array(),"qudt_Rule$j$rationale": zod.string().array(),"qudt_Rule$j$ruleType": Rule_Type.ruleTypeJsonZodSchema().array() }));
    }

    export function sparqlConstructQuery(parameters?: { ignoreRdfType?: boolean; prefixes?: { [prefix: string]: string }; subject?: sparqljs.Triple["subject"]; } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type">): sparqljs.ConstructQuery {
        const { ignoreRdfType, subject, ...queryParameters } = parameters ?? {}

        return { ...queryParameters, prefixes: parameters?.prefixes ?? {}, queryType: "CONSTRUCT", template: (queryParameters.template ?? []).concat(Rule.sparqlConstructTemplateTriples({ ignoreRdfType, subject })), type: "query", where: (queryParameters.where ?? []).concat(Rule.sparqlWherePatterns({ ignoreRdfType, subject })) };
    }

    export function sparqlConstructQueryString(parameters?: { ignoreRdfType?: boolean; subject?: sparqljs.Triple["subject"]; variablePrefix?: string; } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type"> & sparqljs.GeneratorOptions): string {
        return new sparqljs.Generator(parameters).stringify(Rule.sparqlConstructQuery(parameters));
    }

    export function sparqlConstructTemplateTriples(parameters?: { ignoreRdfType?: boolean; subject?: sparqljs.Triple["subject"], variablePrefix?: string }): readonly sparqljs.Triple[] {
        const subject = parameters?.subject ?? dataFactory.variable!("rule");
        const variablePrefix = parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "rule");
        return [...QUDT_Concept.sparqlConstructTemplateTriples({ ignoreRdfType: true, subject, variablePrefix }), ...(parameters?.ignoreRdfType ? [] : [{ subject, predicate: dataFactory.namedNode("http://www.w3.org/1999/02/22-rdf-syntax-ns#type"), object: dataFactory.variable!(`${variablePrefix}RdfType`) }]), { object: dataFactory.variable!(`${variablePrefix}QudtRuleJExample`), predicate: dataFactory.namedNode("http://qudt.org/schema/qudt/example"), subject }, { object: dataFactory.variable!(`${variablePrefix}QudtRuleJRationale`), predicate: dataFactory.namedNode("http://qudt.org/schema/qudt/rationale"), subject }, { object: dataFactory.variable!(`${variablePrefix}QudtRuleJRuleType`), predicate: dataFactory.namedNode("http://qudt.org/schema/qudt/ruleType"), subject }, ...Rule_Type.sparqlConstructTemplateTriples({ ignoreRdfType: true, subject: dataFactory.variable!(`${variablePrefix}QudtRuleJRuleType`), variablePrefix: `${variablePrefix}QudtRuleJRuleType` })];
    }

    export function sparqlWherePatterns(parameters: { ignoreRdfType?: boolean; subject?: sparqljs.Triple["subject"], variablePrefix?: string }): readonly sparqljs.Pattern[] {
        const subject = parameters?.subject ?? dataFactory.variable!("rule");
        const variablePrefix = parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "rule");
        return [...QUDT_Concept.sparqlWherePatterns({ ignoreRdfType: true, subject, variablePrefix }), ...(parameters?.ignoreRdfType ? [] : [{ triples: [{ subject, predicate: dataFactory.namedNode("http://www.w3.org/1999/02/22-rdf-syntax-ns#type"), object: dataFactory.namedNode("http://qudt.org/schema/qudt/Rule") }], type: "bgp" as const }, { triples: [{ subject, predicate: dataFactory.namedNode("http://www.w3.org/1999/02/22-rdf-syntax-ns#type"), object: dataFactory.variable!(`${variablePrefix}RdfType`) }], type: "bgp" as const }]), { patterns: [{ triples: [{ object: dataFactory.variable!(`${variablePrefix}QudtRuleJExample`), predicate: dataFactory.namedNode("http://qudt.org/schema/qudt/example"), subject }], type: "bgp" }], type: "optional" }, { patterns: [{ triples: [{ object: dataFactory.variable!(`${variablePrefix}QudtRuleJRationale`), predicate: dataFactory.namedNode("http://qudt.org/schema/qudt/rationale"), subject }], type: "bgp" }], type: "optional" }, { patterns: [{ triples: [{ object: dataFactory.variable!(`${variablePrefix}QudtRuleJRuleType`), predicate: dataFactory.namedNode("http://qudt.org/schema/qudt/ruleType"), subject }], type: "bgp" }, ...Rule_Type.sparqlWherePatterns({ ignoreRdfType: true, subject: dataFactory.variable!(`${variablePrefix}QudtRuleJRuleType`), variablePrefix: `${variablePrefix}QudtRuleJRuleType` })], type: "optional" }];
    }
}
/**
 * Quantity type
 */
export class Quantity_type extends Enumerated_Value {
    override readonly type = "Quantity_type";
    readonly qudt_QuantityType$j$value: readonly (Quantity_Kind)[];

    constructor(parameters: { readonly identifier?: (rdfjs.BlankNode | rdfjs.NamedNode) | string, readonly qudt_QuantityType$j$value?: readonly (Quantity_Kind)[] } & ConstructorParameters<typeof Enumerated_Value>[0]) {
        super(parameters);
        if (typeof parameters.qudt_QuantityType$j$value === "undefined") { this.qudt_QuantityType$j$value = []; } else if (Array.isArray(parameters.qudt_QuantityType$j$value)) { this.qudt_QuantityType$j$value = parameters.qudt_QuantityType$j$value; } else { this.qudt_QuantityType$j$value =( parameters.qudt_QuantityType$j$value) as never;
         }
    }

    override get identifier(): (rdfjs.BlankNode | rdfjs.NamedNode) {
        if (typeof this._identifier === "undefined") { this._identifier = dataFactory.blankNode(); } return this._identifier;
    }

    override equals(other: Quantity_type): EqualsResult {
        return super.equals(other).chain(() => (((left, right) => arrayEquals(left, right, ((left, right) => left.equals(right)))))(this.qudt_QuantityType$j$value, other.qudt_QuantityType$j$value).mapLeft(propertyValuesUnequal => ({ left: this, right: other, propertyName: "qudt_QuantityType$j$value", propertyValuesUnequal, type: "Property" as const })));
    }

    override hash<HasherT extends { update: (message: string | number[] | ArrayBuffer | Uint8Array) => void; }>(_hasher: HasherT): HasherT {
        this.hashShaclProperties(_hasher);
        return _hasher;
    }

    protected override hashShaclProperties<HasherT extends { update: (message: string | number[] | ArrayBuffer | Uint8Array) => void; }>(_hasher: HasherT): HasherT {
        super.hashShaclProperties(_hasher);
        for (const _item0 of this.qudt_QuantityType$j$value) { _item0.hash(_hasher); }

        return _hasher;
    }

    override toJson(): { readonly "qudt_QuantityType$j$value": readonly (ReturnType<Quantity_Kind["toJson"]>)[] } & ReturnType<Enumerated_Value["toJson"]> {
        return JSON.parse(JSON.stringify({ ...super.toJson(),qudt_QuantityType$j$value: this.qudt_QuantityType$j$value.map(_item => (_item.toJson())) } satisfies ReturnType<Quantity_type["toJson"]>));
    }

    override toRdf({ ignoreRdfType, mutateGraph, resourceSet }: { ignoreRdfType?: boolean; mutateGraph?: rdfjsResource.MutableResource.MutateGraph, resourceSet: rdfjsResource.MutableResourceSet }): rdfjsResource.MutableResource {
        const _resource = super.toRdf({ ignoreRdfType: true, mutateGraph, resourceSet });
        if (!ignoreRdfType) { _resource.add(_resource.dataFactory.namedNode("http://www.w3.org/1999/02/22-rdf-syntax-ns#type"), _resource.dataFactory.namedNode("http://qudt.org/schema/qudt/QuantityType")); }

        _resource.add(dataFactory.namedNode("http://www.linkedmodel.org/schema/dtype#value"), this.qudt_QuantityType$j$value.map((_item) => _item.toRdf({ mutateGraph: mutateGraph, resourceSet: resourceSet })));
        return _resource;
    }

    override toString(): string {
        return JSON.stringify(this.toJson());
    }
}

export namespace Quantity_type {
    export function _propertiesFromJson(_json: unknown): purify.Either<zod.ZodError, { identifier: (rdfjs.BlankNode | rdfjs.NamedNode); qudt_QuantityType$j$value: readonly (Quantity_Kind)[]; } & UnwrapR<ReturnType<typeof Enumerated_Value._propertiesFromJson>>> {
        const _jsonSafeParseResult = quantityTypeJsonZodSchema().safeParse(_json);
        if (!_jsonSafeParseResult.success) { return purify.Left(_jsonSafeParseResult.error); }

        const _jsonObject = _jsonSafeParseResult.data;
        const _super0Either = Enumerated_Value._propertiesFromJson(_jsonObject);
        if (_super0Either.isLeft()) { return _super0Either; }

        const _super0 = _super0Either.unsafeCoerce()
        const identifier = (_jsonObject["@id"].startsWith("_:") ? dataFactory.blankNode(_jsonObject["@id"].substring(2)) : dataFactory.namedNode(_jsonObject["@id"]));
        const qudt_QuantityType$j$value = _jsonObject["qudt_QuantityType$j$value"].map(_item => (Quantity_Kind.fromJson(_item).unsafeCoerce()));
        return purify.Either.of({ ..._super0, identifier, qudt_QuantityType$j$value })
    }

    export function fromJson(json: unknown): purify.Either<zod.ZodError, Quantity_type> {
        return Quantity_type._propertiesFromJson(json).map(properties => new Quantity_type(properties));
    }

    export function _propertiesFromRdf({ ignoreRdfType: _ignoreRdfType, languageIn: _languageIn, resource: _resource,
        // @ts-ignore
        ..._context }: { [_index: string]: any; ignoreRdfType?: boolean; languageIn?: readonly string[]; resource: rdfjsResource.Resource; }): purify.Either<rdfjsResource.Resource.ValueError, { identifier: (rdfjs.BlankNode | rdfjs.NamedNode); qudt_QuantityType$j$value: readonly (Quantity_Kind)[]; } & UnwrapR<ReturnType<typeof Enumerated_Value._propertiesFromRdf>>> {
        const _super0Either = Enumerated_Value._propertiesFromRdf({ ..._context, ignoreRdfType: true, languageIn: _languageIn, resource: _resource });
        if (_super0Either.isLeft()) { return _super0Either; }

        const _super0 = _super0Either.unsafeCoerce()
        if (!_ignoreRdfType && !_resource.isInstanceOf(dataFactory.namedNode("http://qudt.org/schema/qudt/QuantityType"))) { return purify.Left(new rdfjsResource.Resource.ValueError({ focusResource: _resource, message: `${rdfjsResource.Resource.Identifier.toString(_resource.identifier)} has unexpected RDF type (expected http://qudt.org/schema/qudt/QuantityType)`, predicate: dataFactory.namedNode("http://qudt.org/schema/qudt/QuantityType") })); }

        const identifier = _resource.identifier
        const _qudt_QuantityType$j$valueEither: purify.Either<rdfjsResource.Resource.ValueError, readonly (Quantity_Kind)[]> = purify.Either.of([..._resource.values(dataFactory.namedNode("http://www.linkedmodel.org/schema/dtype#value"), { unique: true }).flatMap(_item => _item.toValues().head().chain(value => value.toResource()).chain(_resource => Quantity_Kind.fromRdf({ ..._context, ignoreRdfType: true, languageIn: _languageIn, resource: _resource })).toMaybe().toList())]);
        if (_qudt_QuantityType$j$valueEither.isLeft()) { return _qudt_QuantityType$j$valueEither; }

        const qudt_QuantityType$j$value = _qudt_QuantityType$j$valueEither.unsafeCoerce();
        return purify.Either.of({ ..._super0, identifier, qudt_QuantityType$j$value })
    }

    export function fromRdf(parameters: Parameters<typeof Quantity_type._propertiesFromRdf>[0]): purify.Either<rdfjsResource.Resource.ValueError, Quantity_type> {
        return Quantity_type._propertiesFromRdf(parameters).map(properties => new Quantity_type(properties));
    }

    export let fromRdfType: rdfjs.NamedNode<string> = dataFactory.namedNode("http://qudt.org/schema/qudt/QuantityType");

    export function jsonSchema() {
        return zodToJsonSchema(quantityTypeJsonZodSchema());
    }

    export function quantityTypeJsonUiSchema(parameters?: { scopePrefix?: string }) {
        const scopePrefix = parameters?.scopePrefix ?? "#";
        return { "elements": [ Enumerated_Value.enumeratedValueJsonUiSchema({ scopePrefix }), Quantity_Kind.quantityKindJsonUiSchema({ scopePrefix: `${scopePrefix}/properties/qudt_QuantityType$j$value` }) ], label: "Quantity type", type: "Group" }
    }

    export function quantityTypeJsonZodSchema() {
        return Enumerated_Value.enumeratedValueJsonZodSchema().merge(zod.object({ "@id": zod.string().min(1),"type": zod.literal("Quantity_type"),"qudt_QuantityType$j$value": Quantity_Kind.quantityKindJsonZodSchema().array() }));
    }

    export function sparqlConstructQuery(parameters?: { ignoreRdfType?: boolean; prefixes?: { [prefix: string]: string }; subject?: sparqljs.Triple["subject"]; } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type">): sparqljs.ConstructQuery {
        const { ignoreRdfType, subject, ...queryParameters } = parameters ?? {}

        return { ...queryParameters, prefixes: parameters?.prefixes ?? {}, queryType: "CONSTRUCT", template: (queryParameters.template ?? []).concat(Quantity_type.sparqlConstructTemplateTriples({ ignoreRdfType, subject })), type: "query", where: (queryParameters.where ?? []).concat(Quantity_type.sparqlWherePatterns({ ignoreRdfType, subject })) };
    }

    export function sparqlConstructQueryString(parameters?: { ignoreRdfType?: boolean; subject?: sparqljs.Triple["subject"]; variablePrefix?: string; } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type"> & sparqljs.GeneratorOptions): string {
        return new sparqljs.Generator(parameters).stringify(Quantity_type.sparqlConstructQuery(parameters));
    }

    export function sparqlConstructTemplateTriples(parameters?: { ignoreRdfType?: boolean; subject?: sparqljs.Triple["subject"], variablePrefix?: string }): readonly sparqljs.Triple[] {
        const subject = parameters?.subject ?? dataFactory.variable!("quantityType");
        const variablePrefix = parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "quantityType");
        return [...Enumerated_Value.sparqlConstructTemplateTriples({ ignoreRdfType: true, subject, variablePrefix }), ...(parameters?.ignoreRdfType ? [] : [{ subject, predicate: dataFactory.namedNode("http://www.w3.org/1999/02/22-rdf-syntax-ns#type"), object: dataFactory.variable!(`${variablePrefix}RdfType`) }]), { object: dataFactory.variable!(`${variablePrefix}QudtQuantityTypeJValue`), predicate: dataFactory.namedNode("http://www.linkedmodel.org/schema/dtype#value"), subject }, ...Quantity_Kind.sparqlConstructTemplateTriples({ ignoreRdfType: true, subject: dataFactory.variable!(`${variablePrefix}QudtQuantityTypeJValue`), variablePrefix: `${variablePrefix}QudtQuantityTypeJValue` })];
    }

    export function sparqlWherePatterns(parameters: { ignoreRdfType?: boolean; subject?: sparqljs.Triple["subject"], variablePrefix?: string }): readonly sparqljs.Pattern[] {
        const subject = parameters?.subject ?? dataFactory.variable!("quantityType");
        const variablePrefix = parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "quantityType");
        return [...Enumerated_Value.sparqlWherePatterns({ ignoreRdfType: true, subject, variablePrefix }), ...(parameters?.ignoreRdfType ? [] : [{ triples: [{ subject, predicate: dataFactory.namedNode("http://www.w3.org/1999/02/22-rdf-syntax-ns#type"), object: dataFactory.namedNode("http://qudt.org/schema/qudt/QuantityType") }], type: "bgp" as const }, { triples: [{ subject, predicate: dataFactory.namedNode("http://www.w3.org/1999/02/22-rdf-syntax-ns#type"), object: dataFactory.variable!(`${variablePrefix}RdfType`) }], type: "bgp" as const }]), { patterns: [{ triples: [{ object: dataFactory.variable!(`${variablePrefix}QudtQuantityTypeJValue`), predicate: dataFactory.namedNode("http://www.linkedmodel.org/schema/dtype#value"), subject }], type: "bgp" }, ...Quantity_Kind.sparqlWherePatterns({ ignoreRdfType: true, subject: dataFactory.variable!(`${variablePrefix}QudtQuantityTypeJValue`), variablePrefix: `${variablePrefix}QudtQuantityTypeJValue` })], type: "optional" }];
    }
}
/**
 * Quantity Kind Dimension Vector
 */
export class Quantity_Kind$W$Dimension$W$Vector extends QUDT_Concept {
    override readonly type: "CGS_Dimension$W$vector" | "CGS_EMU$W$Dimension$W$vector" | "CGS_ESU$W$Dimension$W$vector" | "CGS_GAUSS$W$Dimension$W$vector" | "CGS_LH$W$Dimension$W$vector" | "ISO_Dimension$W$vector" | "Imperial_dimension$W$vector" | "Quantity_Kind$W$Dimension$W$Vector" | "Quantity_Kind$W$Dimension$W$vector$W$$e$SI$f$" = "Quantity_Kind$W$Dimension$W$Vector";
    readonly qudt_QuantityKindDimensionVector$j$dimensionExponentForAmountOfSubstance: (rdfjs.BlankNode | rdfjs.NamedNode | rdfjs.Literal);
    readonly qudt_QuantityKindDimensionVector$j$dimensionExponentForElectricCurrent: number;
    readonly qudt_QuantityKindDimensionVector$j$dimensionExponentForLength: (rdfjs.BlankNode | rdfjs.NamedNode | rdfjs.Literal);
    readonly qudt_QuantityKindDimensionVector$j$dimensionExponentForLuminousIntensity: (rdfjs.BlankNode | rdfjs.NamedNode | rdfjs.Literal);
    readonly qudt_QuantityKindDimensionVector$j$dimensionExponentForMass: (rdfjs.BlankNode | rdfjs.NamedNode | rdfjs.Literal);
    readonly qudt_QuantityKindDimensionVector$j$dimensionExponentForThermodynamicTemperature: (rdfjs.BlankNode | rdfjs.NamedNode | rdfjs.Literal);
    readonly qudt_QuantityKindDimensionVector$j$dimensionExponentForTime: (rdfjs.BlankNode | rdfjs.NamedNode | rdfjs.Literal);
    readonly qudt_QuantityKindDimensionVector$j$dimensionlessExponent: (rdfjs.BlankNode | rdfjs.NamedNode | rdfjs.Literal);
    readonly qudt_QuantityKindDimensionVector$j$hasReferenceQuantityKind: readonly ((rdfjs.BlankNode | rdfjs.NamedNode | rdfjs.Literal))[];
    readonly qudt_QuantityKindDimensionVector$j$latexDefinition: purify.Maybe<string>;
    readonly qudt_QuantityKindDimensionVector$j$latexSymbol: readonly (string)[];

    constructor(parameters: { readonly identifier?: (rdfjs.BlankNode | rdfjs.NamedNode) | string, readonly qudt_QuantityKindDimensionVector$j$dimensionExponentForAmountOfSubstance: (rdfjs.BlankNode | rdfjs.NamedNode | rdfjs.Literal) | Date | boolean | number | string, readonly qudt_QuantityKindDimensionVector$j$dimensionExponentForElectricCurrent: number, readonly qudt_QuantityKindDimensionVector$j$dimensionExponentForLength: (rdfjs.BlankNode | rdfjs.NamedNode | rdfjs.Literal) | Date | boolean | number | string, readonly qudt_QuantityKindDimensionVector$j$dimensionExponentForLuminousIntensity: (rdfjs.BlankNode | rdfjs.NamedNode | rdfjs.Literal) | Date | boolean | number | string, readonly qudt_QuantityKindDimensionVector$j$dimensionExponentForMass: (rdfjs.BlankNode | rdfjs.NamedNode | rdfjs.Literal) | Date | boolean | number | string, readonly qudt_QuantityKindDimensionVector$j$dimensionExponentForThermodynamicTemperature: (rdfjs.BlankNode | rdfjs.NamedNode | rdfjs.Literal) | Date | boolean | number | string, readonly qudt_QuantityKindDimensionVector$j$dimensionExponentForTime: (rdfjs.BlankNode | rdfjs.NamedNode | rdfjs.Literal) | Date | boolean | number | string, readonly qudt_QuantityKindDimensionVector$j$dimensionlessExponent: (rdfjs.BlankNode | rdfjs.NamedNode | rdfjs.Literal) | Date | boolean | number | string, readonly qudt_QuantityKindDimensionVector$j$hasReferenceQuantityKind?: readonly ((rdfjs.BlankNode | rdfjs.NamedNode | rdfjs.Literal))[], readonly qudt_QuantityKindDimensionVector$j$latexDefinition?: purify.Maybe<string> | string, readonly qudt_QuantityKindDimensionVector$j$latexSymbol?: readonly (string)[] } & ConstructorParameters<typeof QUDT_Concept>[0]) {
        super(parameters);
        if (typeof parameters.qudt_QuantityKindDimensionVector$j$dimensionExponentForAmountOfSubstance === "boolean") { this.qudt_QuantityKindDimensionVector$j$dimensionExponentForAmountOfSubstance = rdfLiteral.toRdf(parameters.qudt_QuantityKindDimensionVector$j$dimensionExponentForAmountOfSubstance, { dataFactory }); } else if (typeof parameters.qudt_QuantityKindDimensionVector$j$dimensionExponentForAmountOfSubstance === "object" && parameters.qudt_QuantityKindDimensionVector$j$dimensionExponentForAmountOfSubstance instanceof Date) { this.qudt_QuantityKindDimensionVector$j$dimensionExponentForAmountOfSubstance = rdfLiteral.toRdf(parameters.qudt_QuantityKindDimensionVector$j$dimensionExponentForAmountOfSubstance, { dataFactory }); } else if (typeof parameters.qudt_QuantityKindDimensionVector$j$dimensionExponentForAmountOfSubstance === "number") { this.qudt_QuantityKindDimensionVector$j$dimensionExponentForAmountOfSubstance = rdfLiteral.toRdf(parameters.qudt_QuantityKindDimensionVector$j$dimensionExponentForAmountOfSubstance, { dataFactory }); } else if (typeof parameters.qudt_QuantityKindDimensionVector$j$dimensionExponentForAmountOfSubstance === "string") { this.qudt_QuantityKindDimensionVector$j$dimensionExponentForAmountOfSubstance = dataFactory.literal(parameters.qudt_QuantityKindDimensionVector$j$dimensionExponentForAmountOfSubstance); } else if (typeof parameters.qudt_QuantityKindDimensionVector$j$dimensionExponentForAmountOfSubstance === "object") { this.qudt_QuantityKindDimensionVector$j$dimensionExponentForAmountOfSubstance = parameters.qudt_QuantityKindDimensionVector$j$dimensionExponentForAmountOfSubstance; } else { this.qudt_QuantityKindDimensionVector$j$dimensionExponentForAmountOfSubstance =( parameters.qudt_QuantityKindDimensionVector$j$dimensionExponentForAmountOfSubstance) as never;
         }

        this.qudt_QuantityKindDimensionVector$j$dimensionExponentForElectricCurrent = parameters.qudt_QuantityKindDimensionVector$j$dimensionExponentForElectricCurrent;
        if (typeof parameters.qudt_QuantityKindDimensionVector$j$dimensionExponentForLength === "boolean") { this.qudt_QuantityKindDimensionVector$j$dimensionExponentForLength = rdfLiteral.toRdf(parameters.qudt_QuantityKindDimensionVector$j$dimensionExponentForLength, { dataFactory }); } else if (typeof parameters.qudt_QuantityKindDimensionVector$j$dimensionExponentForLength === "object" && parameters.qudt_QuantityKindDimensionVector$j$dimensionExponentForLength instanceof Date) { this.qudt_QuantityKindDimensionVector$j$dimensionExponentForLength = rdfLiteral.toRdf(parameters.qudt_QuantityKindDimensionVector$j$dimensionExponentForLength, { dataFactory }); } else if (typeof parameters.qudt_QuantityKindDimensionVector$j$dimensionExponentForLength === "number") { this.qudt_QuantityKindDimensionVector$j$dimensionExponentForLength = rdfLiteral.toRdf(parameters.qudt_QuantityKindDimensionVector$j$dimensionExponentForLength, { dataFactory }); } else if (typeof parameters.qudt_QuantityKindDimensionVector$j$dimensionExponentForLength === "string") { this.qudt_QuantityKindDimensionVector$j$dimensionExponentForLength = dataFactory.literal(parameters.qudt_QuantityKindDimensionVector$j$dimensionExponentForLength); } else if (typeof parameters.qudt_QuantityKindDimensionVector$j$dimensionExponentForLength === "object") { this.qudt_QuantityKindDimensionVector$j$dimensionExponentForLength = parameters.qudt_QuantityKindDimensionVector$j$dimensionExponentForLength; } else { this.qudt_QuantityKindDimensionVector$j$dimensionExponentForLength =( parameters.qudt_QuantityKindDimensionVector$j$dimensionExponentForLength) as never;
         }

        if (typeof parameters.qudt_QuantityKindDimensionVector$j$dimensionExponentForLuminousIntensity === "boolean") { this.qudt_QuantityKindDimensionVector$j$dimensionExponentForLuminousIntensity = rdfLiteral.toRdf(parameters.qudt_QuantityKindDimensionVector$j$dimensionExponentForLuminousIntensity, { dataFactory }); } else if (typeof parameters.qudt_QuantityKindDimensionVector$j$dimensionExponentForLuminousIntensity === "object" && parameters.qudt_QuantityKindDimensionVector$j$dimensionExponentForLuminousIntensity instanceof Date) { this.qudt_QuantityKindDimensionVector$j$dimensionExponentForLuminousIntensity = rdfLiteral.toRdf(parameters.qudt_QuantityKindDimensionVector$j$dimensionExponentForLuminousIntensity, { dataFactory }); } else if (typeof parameters.qudt_QuantityKindDimensionVector$j$dimensionExponentForLuminousIntensity === "number") { this.qudt_QuantityKindDimensionVector$j$dimensionExponentForLuminousIntensity = rdfLiteral.toRdf(parameters.qudt_QuantityKindDimensionVector$j$dimensionExponentForLuminousIntensity, { dataFactory }); } else if (typeof parameters.qudt_QuantityKindDimensionVector$j$dimensionExponentForLuminousIntensity === "string") { this.qudt_QuantityKindDimensionVector$j$dimensionExponentForLuminousIntensity = dataFactory.literal(parameters.qudt_QuantityKindDimensionVector$j$dimensionExponentForLuminousIntensity); } else if (typeof parameters.qudt_QuantityKindDimensionVector$j$dimensionExponentForLuminousIntensity === "object") { this.qudt_QuantityKindDimensionVector$j$dimensionExponentForLuminousIntensity = parameters.qudt_QuantityKindDimensionVector$j$dimensionExponentForLuminousIntensity; } else { this.qudt_QuantityKindDimensionVector$j$dimensionExponentForLuminousIntensity =( parameters.qudt_QuantityKindDimensionVector$j$dimensionExponentForLuminousIntensity) as never;
         }

        if (typeof parameters.qudt_QuantityKindDimensionVector$j$dimensionExponentForMass === "boolean") { this.qudt_QuantityKindDimensionVector$j$dimensionExponentForMass = rdfLiteral.toRdf(parameters.qudt_QuantityKindDimensionVector$j$dimensionExponentForMass, { dataFactory }); } else if (typeof parameters.qudt_QuantityKindDimensionVector$j$dimensionExponentForMass === "object" && parameters.qudt_QuantityKindDimensionVector$j$dimensionExponentForMass instanceof Date) { this.qudt_QuantityKindDimensionVector$j$dimensionExponentForMass = rdfLiteral.toRdf(parameters.qudt_QuantityKindDimensionVector$j$dimensionExponentForMass, { dataFactory }); } else if (typeof parameters.qudt_QuantityKindDimensionVector$j$dimensionExponentForMass === "number") { this.qudt_QuantityKindDimensionVector$j$dimensionExponentForMass = rdfLiteral.toRdf(parameters.qudt_QuantityKindDimensionVector$j$dimensionExponentForMass, { dataFactory }); } else if (typeof parameters.qudt_QuantityKindDimensionVector$j$dimensionExponentForMass === "string") { this.qudt_QuantityKindDimensionVector$j$dimensionExponentForMass = dataFactory.literal(parameters.qudt_QuantityKindDimensionVector$j$dimensionExponentForMass); } else if (typeof parameters.qudt_QuantityKindDimensionVector$j$dimensionExponentForMass === "object") { this.qudt_QuantityKindDimensionVector$j$dimensionExponentForMass = parameters.qudt_QuantityKindDimensionVector$j$dimensionExponentForMass; } else { this.qudt_QuantityKindDimensionVector$j$dimensionExponentForMass =( parameters.qudt_QuantityKindDimensionVector$j$dimensionExponentForMass) as never;
         }

        if (typeof parameters.qudt_QuantityKindDimensionVector$j$dimensionExponentForThermodynamicTemperature === "boolean") { this.qudt_QuantityKindDimensionVector$j$dimensionExponentForThermodynamicTemperature = rdfLiteral.toRdf(parameters.qudt_QuantityKindDimensionVector$j$dimensionExponentForThermodynamicTemperature, { dataFactory }); } else if (typeof parameters.qudt_QuantityKindDimensionVector$j$dimensionExponentForThermodynamicTemperature === "object" && parameters.qudt_QuantityKindDimensionVector$j$dimensionExponentForThermodynamicTemperature instanceof Date) { this.qudt_QuantityKindDimensionVector$j$dimensionExponentForThermodynamicTemperature = rdfLiteral.toRdf(parameters.qudt_QuantityKindDimensionVector$j$dimensionExponentForThermodynamicTemperature, { dataFactory }); } else if (typeof parameters.qudt_QuantityKindDimensionVector$j$dimensionExponentForThermodynamicTemperature === "number") { this.qudt_QuantityKindDimensionVector$j$dimensionExponentForThermodynamicTemperature = rdfLiteral.toRdf(parameters.qudt_QuantityKindDimensionVector$j$dimensionExponentForThermodynamicTemperature, { dataFactory }); } else if (typeof parameters.qudt_QuantityKindDimensionVector$j$dimensionExponentForThermodynamicTemperature === "string") { this.qudt_QuantityKindDimensionVector$j$dimensionExponentForThermodynamicTemperature = dataFactory.literal(parameters.qudt_QuantityKindDimensionVector$j$dimensionExponentForThermodynamicTemperature); } else if (typeof parameters.qudt_QuantityKindDimensionVector$j$dimensionExponentForThermodynamicTemperature === "object") { this.qudt_QuantityKindDimensionVector$j$dimensionExponentForThermodynamicTemperature = parameters.qudt_QuantityKindDimensionVector$j$dimensionExponentForThermodynamicTemperature; } else { this.qudt_QuantityKindDimensionVector$j$dimensionExponentForThermodynamicTemperature =( parameters.qudt_QuantityKindDimensionVector$j$dimensionExponentForThermodynamicTemperature) as never;
         }

        if (typeof parameters.qudt_QuantityKindDimensionVector$j$dimensionExponentForTime === "boolean") { this.qudt_QuantityKindDimensionVector$j$dimensionExponentForTime = rdfLiteral.toRdf(parameters.qudt_QuantityKindDimensionVector$j$dimensionExponentForTime, { dataFactory }); } else if (typeof parameters.qudt_QuantityKindDimensionVector$j$dimensionExponentForTime === "object" && parameters.qudt_QuantityKindDimensionVector$j$dimensionExponentForTime instanceof Date) { this.qudt_QuantityKindDimensionVector$j$dimensionExponentForTime = rdfLiteral.toRdf(parameters.qudt_QuantityKindDimensionVector$j$dimensionExponentForTime, { dataFactory }); } else if (typeof parameters.qudt_QuantityKindDimensionVector$j$dimensionExponentForTime === "number") { this.qudt_QuantityKindDimensionVector$j$dimensionExponentForTime = rdfLiteral.toRdf(parameters.qudt_QuantityKindDimensionVector$j$dimensionExponentForTime, { dataFactory }); } else if (typeof parameters.qudt_QuantityKindDimensionVector$j$dimensionExponentForTime === "string") { this.qudt_QuantityKindDimensionVector$j$dimensionExponentForTime = dataFactory.literal(parameters.qudt_QuantityKindDimensionVector$j$dimensionExponentForTime); } else if (typeof parameters.qudt_QuantityKindDimensionVector$j$dimensionExponentForTime === "object") { this.qudt_QuantityKindDimensionVector$j$dimensionExponentForTime = parameters.qudt_QuantityKindDimensionVector$j$dimensionExponentForTime; } else { this.qudt_QuantityKindDimensionVector$j$dimensionExponentForTime =( parameters.qudt_QuantityKindDimensionVector$j$dimensionExponentForTime) as never;
         }

        if (typeof parameters.qudt_QuantityKindDimensionVector$j$dimensionlessExponent === "boolean") { this.qudt_QuantityKindDimensionVector$j$dimensionlessExponent = rdfLiteral.toRdf(parameters.qudt_QuantityKindDimensionVector$j$dimensionlessExponent, { dataFactory }); } else if (typeof parameters.qudt_QuantityKindDimensionVector$j$dimensionlessExponent === "object" && parameters.qudt_QuantityKindDimensionVector$j$dimensionlessExponent instanceof Date) { this.qudt_QuantityKindDimensionVector$j$dimensionlessExponent = rdfLiteral.toRdf(parameters.qudt_QuantityKindDimensionVector$j$dimensionlessExponent, { dataFactory }); } else if (typeof parameters.qudt_QuantityKindDimensionVector$j$dimensionlessExponent === "number") { this.qudt_QuantityKindDimensionVector$j$dimensionlessExponent = rdfLiteral.toRdf(parameters.qudt_QuantityKindDimensionVector$j$dimensionlessExponent, { dataFactory }); } else if (typeof parameters.qudt_QuantityKindDimensionVector$j$dimensionlessExponent === "string") { this.qudt_QuantityKindDimensionVector$j$dimensionlessExponent = dataFactory.literal(parameters.qudt_QuantityKindDimensionVector$j$dimensionlessExponent); } else if (typeof parameters.qudt_QuantityKindDimensionVector$j$dimensionlessExponent === "object") { this.qudt_QuantityKindDimensionVector$j$dimensionlessExponent = parameters.qudt_QuantityKindDimensionVector$j$dimensionlessExponent; } else { this.qudt_QuantityKindDimensionVector$j$dimensionlessExponent =( parameters.qudt_QuantityKindDimensionVector$j$dimensionlessExponent) as never;
         }

        if (typeof parameters.qudt_QuantityKindDimensionVector$j$hasReferenceQuantityKind === "undefined") { this.qudt_QuantityKindDimensionVector$j$hasReferenceQuantityKind = []; } else if (Array.isArray(parameters.qudt_QuantityKindDimensionVector$j$hasReferenceQuantityKind)) { this.qudt_QuantityKindDimensionVector$j$hasReferenceQuantityKind = parameters.qudt_QuantityKindDimensionVector$j$hasReferenceQuantityKind; } else { this.qudt_QuantityKindDimensionVector$j$hasReferenceQuantityKind =( parameters.qudt_QuantityKindDimensionVector$j$hasReferenceQuantityKind) as never;
         }

        if (purify.Maybe.isMaybe(parameters.qudt_QuantityKindDimensionVector$j$latexDefinition)) { this.qudt_QuantityKindDimensionVector$j$latexDefinition = parameters.qudt_QuantityKindDimensionVector$j$latexDefinition; } else if (typeof parameters.qudt_QuantityKindDimensionVector$j$latexDefinition === "string") { this.qudt_QuantityKindDimensionVector$j$latexDefinition = purify.Maybe.of(parameters.qudt_QuantityKindDimensionVector$j$latexDefinition); } else if (typeof parameters.qudt_QuantityKindDimensionVector$j$latexDefinition === "undefined") { this.qudt_QuantityKindDimensionVector$j$latexDefinition = purify.Maybe.empty(); } else { this.qudt_QuantityKindDimensionVector$j$latexDefinition =( parameters.qudt_QuantityKindDimensionVector$j$latexDefinition) as never;
         }

        if (typeof parameters.qudt_QuantityKindDimensionVector$j$latexSymbol === "undefined") { this.qudt_QuantityKindDimensionVector$j$latexSymbol = []; } else if (Array.isArray(parameters.qudt_QuantityKindDimensionVector$j$latexSymbol)) { this.qudt_QuantityKindDimensionVector$j$latexSymbol = parameters.qudt_QuantityKindDimensionVector$j$latexSymbol; } else { this.qudt_QuantityKindDimensionVector$j$latexSymbol =( parameters.qudt_QuantityKindDimensionVector$j$latexSymbol) as never;
         }
    }

    override get identifier(): (rdfjs.BlankNode | rdfjs.NamedNode) {
        if (typeof this._identifier === "undefined") { this._identifier = dataFactory.blankNode(); } return this._identifier;
    }

    override equals(other: Quantity_Kind$W$Dimension$W$Vector): EqualsResult {
        return super.equals(other).chain(() => (booleanEquals)(this.qudt_QuantityKindDimensionVector$j$dimensionExponentForAmountOfSubstance, other.qudt_QuantityKindDimensionVector$j$dimensionExponentForAmountOfSubstance).mapLeft(propertyValuesUnequal => ({ left: this, right: other, propertyName: "qudt_QuantityKindDimensionVector$j$dimensionExponentForAmountOfSubstance", propertyValuesUnequal, type: "Property" as const }))).chain(() => (strictEquals)(this.qudt_QuantityKindDimensionVector$j$dimensionExponentForElectricCurrent, other.qudt_QuantityKindDimensionVector$j$dimensionExponentForElectricCurrent).mapLeft(propertyValuesUnequal => ({ left: this, right: other, propertyName: "qudt_QuantityKindDimensionVector$j$dimensionExponentForElectricCurrent", propertyValuesUnequal, type: "Property" as const }))).chain(() => (booleanEquals)(this.qudt_QuantityKindDimensionVector$j$dimensionExponentForLength, other.qudt_QuantityKindDimensionVector$j$dimensionExponentForLength).mapLeft(propertyValuesUnequal => ({ left: this, right: other, propertyName: "qudt_QuantityKindDimensionVector$j$dimensionExponentForLength", propertyValuesUnequal, type: "Property" as const }))).chain(() => (booleanEquals)(this.qudt_QuantityKindDimensionVector$j$dimensionExponentForLuminousIntensity, other.qudt_QuantityKindDimensionVector$j$dimensionExponentForLuminousIntensity).mapLeft(propertyValuesUnequal => ({ left: this, right: other, propertyName: "qudt_QuantityKindDimensionVector$j$dimensionExponentForLuminousIntensity", propertyValuesUnequal, type: "Property" as const }))).chain(() => (booleanEquals)(this.qudt_QuantityKindDimensionVector$j$dimensionExponentForMass, other.qudt_QuantityKindDimensionVector$j$dimensionExponentForMass).mapLeft(propertyValuesUnequal => ({ left: this, right: other, propertyName: "qudt_QuantityKindDimensionVector$j$dimensionExponentForMass", propertyValuesUnequal, type: "Property" as const }))).chain(() => (booleanEquals)(this.qudt_QuantityKindDimensionVector$j$dimensionExponentForThermodynamicTemperature, other.qudt_QuantityKindDimensionVector$j$dimensionExponentForThermodynamicTemperature).mapLeft(propertyValuesUnequal => ({ left: this, right: other, propertyName: "qudt_QuantityKindDimensionVector$j$dimensionExponentForThermodynamicTemperature", propertyValuesUnequal, type: "Property" as const }))).chain(() => (booleanEquals)(this.qudt_QuantityKindDimensionVector$j$dimensionExponentForTime, other.qudt_QuantityKindDimensionVector$j$dimensionExponentForTime).mapLeft(propertyValuesUnequal => ({ left: this, right: other, propertyName: "qudt_QuantityKindDimensionVector$j$dimensionExponentForTime", propertyValuesUnequal, type: "Property" as const }))).chain(() => (booleanEquals)(this.qudt_QuantityKindDimensionVector$j$dimensionlessExponent, other.qudt_QuantityKindDimensionVector$j$dimensionlessExponent).mapLeft(propertyValuesUnequal => ({ left: this, right: other, propertyName: "qudt_QuantityKindDimensionVector$j$dimensionlessExponent", propertyValuesUnequal, type: "Property" as const }))).chain(() => (((left, right) => arrayEquals(left, right, booleanEquals)))(this.qudt_QuantityKindDimensionVector$j$hasReferenceQuantityKind, other.qudt_QuantityKindDimensionVector$j$hasReferenceQuantityKind).mapLeft(propertyValuesUnequal => ({ left: this, right: other, propertyName: "qudt_QuantityKindDimensionVector$j$hasReferenceQuantityKind", propertyValuesUnequal, type: "Property" as const }))).chain(() => (((left, right) => maybeEquals(left, right, strictEquals)))(this.qudt_QuantityKindDimensionVector$j$latexDefinition, other.qudt_QuantityKindDimensionVector$j$latexDefinition).mapLeft(propertyValuesUnequal => ({ left: this, right: other, propertyName: "qudt_QuantityKindDimensionVector$j$latexDefinition", propertyValuesUnequal, type: "Property" as const }))).chain(() => (((left, right) => arrayEquals(left, right, strictEquals)))(this.qudt_QuantityKindDimensionVector$j$latexSymbol, other.qudt_QuantityKindDimensionVector$j$latexSymbol).mapLeft(propertyValuesUnequal => ({ left: this, right: other, propertyName: "qudt_QuantityKindDimensionVector$j$latexSymbol", propertyValuesUnequal, type: "Property" as const })));
    }

    override hash<HasherT extends { update: (message: string | number[] | ArrayBuffer | Uint8Array) => void; }>(_hasher: HasherT): HasherT {
        this.hashShaclProperties(_hasher);
        return _hasher;
    }

    protected override hashShaclProperties<HasherT extends { update: (message: string | number[] | ArrayBuffer | Uint8Array) => void; }>(_hasher: HasherT): HasherT {
        super.hashShaclProperties(_hasher);
        _hasher.update(this.qudt_QuantityKindDimensionVector$j$dimensionExponentForAmountOfSubstance.termType);
        _hasher.update(this.qudt_QuantityKindDimensionVector$j$dimensionExponentForAmountOfSubstance.value);
        _hasher.update(this.qudt_QuantityKindDimensionVector$j$dimensionExponentForElectricCurrent.toString());
        _hasher.update(this.qudt_QuantityKindDimensionVector$j$dimensionExponentForLength.termType);
        _hasher.update(this.qudt_QuantityKindDimensionVector$j$dimensionExponentForLength.value);
        _hasher.update(this.qudt_QuantityKindDimensionVector$j$dimensionExponentForLuminousIntensity.termType);
        _hasher.update(this.qudt_QuantityKindDimensionVector$j$dimensionExponentForLuminousIntensity.value);
        _hasher.update(this.qudt_QuantityKindDimensionVector$j$dimensionExponentForMass.termType);
        _hasher.update(this.qudt_QuantityKindDimensionVector$j$dimensionExponentForMass.value);
        _hasher.update(this.qudt_QuantityKindDimensionVector$j$dimensionExponentForThermodynamicTemperature.termType);
        _hasher.update(this.qudt_QuantityKindDimensionVector$j$dimensionExponentForThermodynamicTemperature.value);
        _hasher.update(this.qudt_QuantityKindDimensionVector$j$dimensionExponentForTime.termType);
        _hasher.update(this.qudt_QuantityKindDimensionVector$j$dimensionExponentForTime.value);
        _hasher.update(this.qudt_QuantityKindDimensionVector$j$dimensionlessExponent.termType);
        _hasher.update(this.qudt_QuantityKindDimensionVector$j$dimensionlessExponent.value);
        for (const _item0 of this.qudt_QuantityKindDimensionVector$j$hasReferenceQuantityKind) { _hasher.update(_item0.termType);
        _hasher.update(_item0.value); }

        this.qudt_QuantityKindDimensionVector$j$latexDefinition.ifJust((_value0) => { _hasher.update(_value0); })
        for (const _item0 of this.qudt_QuantityKindDimensionVector$j$latexSymbol) { _hasher.update(_item0); }

        return _hasher;
    }

    override toJson(): { readonly "qudt_QuantityKindDimensionVector$j$dimensionExponentForAmountOfSubstance": { readonly "@id": string, readonly termType: "BlankNode" | "NamedNode" } | { readonly "@language": string | undefined, readonly "@type": string | undefined, readonly "@value": string, readonly termType: "Literal" }; readonly "qudt_QuantityKindDimensionVector$j$dimensionExponentForElectricCurrent": number; readonly "qudt_QuantityKindDimensionVector$j$dimensionExponentForLength": { readonly "@id": string, readonly termType: "BlankNode" | "NamedNode" } | { readonly "@language": string | undefined, readonly "@type": string | undefined, readonly "@value": string, readonly termType: "Literal" }; readonly "qudt_QuantityKindDimensionVector$j$dimensionExponentForLuminousIntensity": { readonly "@id": string, readonly termType: "BlankNode" | "NamedNode" } | { readonly "@language": string | undefined, readonly "@type": string | undefined, readonly "@value": string, readonly termType: "Literal" }; readonly "qudt_QuantityKindDimensionVector$j$dimensionExponentForMass": { readonly "@id": string, readonly termType: "BlankNode" | "NamedNode" } | { readonly "@language": string | undefined, readonly "@type": string | undefined, readonly "@value": string, readonly termType: "Literal" }; readonly "qudt_QuantityKindDimensionVector$j$dimensionExponentForThermodynamicTemperature": { readonly "@id": string, readonly termType: "BlankNode" | "NamedNode" } | { readonly "@language": string | undefined, readonly "@type": string | undefined, readonly "@value": string, readonly termType: "Literal" }; readonly "qudt_QuantityKindDimensionVector$j$dimensionExponentForTime": { readonly "@id": string, readonly termType: "BlankNode" | "NamedNode" } | { readonly "@language": string | undefined, readonly "@type": string | undefined, readonly "@value": string, readonly termType: "Literal" }; readonly "qudt_QuantityKindDimensionVector$j$dimensionlessExponent": { readonly "@id": string, readonly termType: "BlankNode" | "NamedNode" } | { readonly "@language": string | undefined, readonly "@type": string | undefined, readonly "@value": string, readonly termType: "Literal" }; readonly "qudt_QuantityKindDimensionVector$j$hasReferenceQuantityKind": readonly ({ readonly "@id": string, readonly termType: "BlankNode" | "NamedNode" } | { readonly "@language": string | undefined, readonly "@type": string | undefined, readonly "@value": string, readonly termType: "Literal" })[]; readonly "qudt_QuantityKindDimensionVector$j$latexDefinition": (string) | undefined; readonly "qudt_QuantityKindDimensionVector$j$latexSymbol": readonly (string)[] } & ReturnType<QUDT_Concept["toJson"]> {
        return JSON.parse(JSON.stringify({ ...super.toJson(),qudt_QuantityKindDimensionVector$j$dimensionExponentForAmountOfSubstance: (this.qudt_QuantityKindDimensionVector$j$dimensionExponentForAmountOfSubstance.termType === "Literal") ? { "@language": this.qudt_QuantityKindDimensionVector$j$dimensionExponentForAmountOfSubstance.language.length > 0 ? this.qudt_QuantityKindDimensionVector$j$dimensionExponentForAmountOfSubstance.language : undefined, "@type": this.qudt_QuantityKindDimensionVector$j$dimensionExponentForAmountOfSubstance.datatype.value !== "http://www.w3.org/2001/XMLSchema#string" ? this.qudt_QuantityKindDimensionVector$j$dimensionExponentForAmountOfSubstance.datatype.value : undefined, "@value": this.qudt_QuantityKindDimensionVector$j$dimensionExponentForAmountOfSubstance.value, termType: "Literal" as const } : (this.qudt_QuantityKindDimensionVector$j$dimensionExponentForAmountOfSubstance.termType === "NamedNode") ? { "@id": this.qudt_QuantityKindDimensionVector$j$dimensionExponentForAmountOfSubstance.value, termType: "NamedNode" as const } : { "@id": `_:${this.qudt_QuantityKindDimensionVector$j$dimensionExponentForAmountOfSubstance.value}`, termType: "BlankNode" as const },qudt_QuantityKindDimensionVector$j$dimensionExponentForElectricCurrent: this.qudt_QuantityKindDimensionVector$j$dimensionExponentForElectricCurrent,qudt_QuantityKindDimensionVector$j$dimensionExponentForLength: (this.qudt_QuantityKindDimensionVector$j$dimensionExponentForLength.termType === "Literal") ? { "@language": this.qudt_QuantityKindDimensionVector$j$dimensionExponentForLength.language.length > 0 ? this.qudt_QuantityKindDimensionVector$j$dimensionExponentForLength.language : undefined, "@type": this.qudt_QuantityKindDimensionVector$j$dimensionExponentForLength.datatype.value !== "http://www.w3.org/2001/XMLSchema#string" ? this.qudt_QuantityKindDimensionVector$j$dimensionExponentForLength.datatype.value : undefined, "@value": this.qudt_QuantityKindDimensionVector$j$dimensionExponentForLength.value, termType: "Literal" as const } : (this.qudt_QuantityKindDimensionVector$j$dimensionExponentForLength.termType === "NamedNode") ? { "@id": this.qudt_QuantityKindDimensionVector$j$dimensionExponentForLength.value, termType: "NamedNode" as const } : { "@id": `_:${this.qudt_QuantityKindDimensionVector$j$dimensionExponentForLength.value}`, termType: "BlankNode" as const },qudt_QuantityKindDimensionVector$j$dimensionExponentForLuminousIntensity: (this.qudt_QuantityKindDimensionVector$j$dimensionExponentForLuminousIntensity.termType === "Literal") ? { "@language": this.qudt_QuantityKindDimensionVector$j$dimensionExponentForLuminousIntensity.language.length > 0 ? this.qudt_QuantityKindDimensionVector$j$dimensionExponentForLuminousIntensity.language : undefined, "@type": this.qudt_QuantityKindDimensionVector$j$dimensionExponentForLuminousIntensity.datatype.value !== "http://www.w3.org/2001/XMLSchema#string" ? this.qudt_QuantityKindDimensionVector$j$dimensionExponentForLuminousIntensity.datatype.value : undefined, "@value": this.qudt_QuantityKindDimensionVector$j$dimensionExponentForLuminousIntensity.value, termType: "Literal" as const } : (this.qudt_QuantityKindDimensionVector$j$dimensionExponentForLuminousIntensity.termType === "NamedNode") ? { "@id": this.qudt_QuantityKindDimensionVector$j$dimensionExponentForLuminousIntensity.value, termType: "NamedNode" as const } : { "@id": `_:${this.qudt_QuantityKindDimensionVector$j$dimensionExponentForLuminousIntensity.value}`, termType: "BlankNode" as const },qudt_QuantityKindDimensionVector$j$dimensionExponentForMass: (this.qudt_QuantityKindDimensionVector$j$dimensionExponentForMass.termType === "Literal") ? { "@language": this.qudt_QuantityKindDimensionVector$j$dimensionExponentForMass.language.length > 0 ? this.qudt_QuantityKindDimensionVector$j$dimensionExponentForMass.language : undefined, "@type": this.qudt_QuantityKindDimensionVector$j$dimensionExponentForMass.datatype.value !== "http://www.w3.org/2001/XMLSchema#string" ? this.qudt_QuantityKindDimensionVector$j$dimensionExponentForMass.datatype.value : undefined, "@value": this.qudt_QuantityKindDimensionVector$j$dimensionExponentForMass.value, termType: "Literal" as const } : (this.qudt_QuantityKindDimensionVector$j$dimensionExponentForMass.termType === "NamedNode") ? { "@id": this.qudt_QuantityKindDimensionVector$j$dimensionExponentForMass.value, termType: "NamedNode" as const } : { "@id": `_:${this.qudt_QuantityKindDimensionVector$j$dimensionExponentForMass.value}`, termType: "BlankNode" as const },qudt_QuantityKindDimensionVector$j$dimensionExponentForThermodynamicTemperature: (this.qudt_QuantityKindDimensionVector$j$dimensionExponentForThermodynamicTemperature.termType === "Literal") ? { "@language": this.qudt_QuantityKindDimensionVector$j$dimensionExponentForThermodynamicTemperature.language.length > 0 ? this.qudt_QuantityKindDimensionVector$j$dimensionExponentForThermodynamicTemperature.language : undefined, "@type": this.qudt_QuantityKindDimensionVector$j$dimensionExponentForThermodynamicTemperature.datatype.value !== "http://www.w3.org/2001/XMLSchema#string" ? this.qudt_QuantityKindDimensionVector$j$dimensionExponentForThermodynamicTemperature.datatype.value : undefined, "@value": this.qudt_QuantityKindDimensionVector$j$dimensionExponentForThermodynamicTemperature.value, termType: "Literal" as const } : (this.qudt_QuantityKindDimensionVector$j$dimensionExponentForThermodynamicTemperature.termType === "NamedNode") ? { "@id": this.qudt_QuantityKindDimensionVector$j$dimensionExponentForThermodynamicTemperature.value, termType: "NamedNode" as const } : { "@id": `_:${this.qudt_QuantityKindDimensionVector$j$dimensionExponentForThermodynamicTemperature.value}`, termType: "BlankNode" as const },qudt_QuantityKindDimensionVector$j$dimensionExponentForTime: (this.qudt_QuantityKindDimensionVector$j$dimensionExponentForTime.termType === "Literal") ? { "@language": this.qudt_QuantityKindDimensionVector$j$dimensionExponentForTime.language.length > 0 ? this.qudt_QuantityKindDimensionVector$j$dimensionExponentForTime.language : undefined, "@type": this.qudt_QuantityKindDimensionVector$j$dimensionExponentForTime.datatype.value !== "http://www.w3.org/2001/XMLSchema#string" ? this.qudt_QuantityKindDimensionVector$j$dimensionExponentForTime.datatype.value : undefined, "@value": this.qudt_QuantityKindDimensionVector$j$dimensionExponentForTime.value, termType: "Literal" as const } : (this.qudt_QuantityKindDimensionVector$j$dimensionExponentForTime.termType === "NamedNode") ? { "@id": this.qudt_QuantityKindDimensionVector$j$dimensionExponentForTime.value, termType: "NamedNode" as const } : { "@id": `_:${this.qudt_QuantityKindDimensionVector$j$dimensionExponentForTime.value}`, termType: "BlankNode" as const },qudt_QuantityKindDimensionVector$j$dimensionlessExponent: (this.qudt_QuantityKindDimensionVector$j$dimensionlessExponent.termType === "Literal") ? { "@language": this.qudt_QuantityKindDimensionVector$j$dimensionlessExponent.language.length > 0 ? this.qudt_QuantityKindDimensionVector$j$dimensionlessExponent.language : undefined, "@type": this.qudt_QuantityKindDimensionVector$j$dimensionlessExponent.datatype.value !== "http://www.w3.org/2001/XMLSchema#string" ? this.qudt_QuantityKindDimensionVector$j$dimensionlessExponent.datatype.value : undefined, "@value": this.qudt_QuantityKindDimensionVector$j$dimensionlessExponent.value, termType: "Literal" as const } : (this.qudt_QuantityKindDimensionVector$j$dimensionlessExponent.termType === "NamedNode") ? { "@id": this.qudt_QuantityKindDimensionVector$j$dimensionlessExponent.value, termType: "NamedNode" as const } : { "@id": `_:${this.qudt_QuantityKindDimensionVector$j$dimensionlessExponent.value}`, termType: "BlankNode" as const },qudt_QuantityKindDimensionVector$j$hasReferenceQuantityKind: this.qudt_QuantityKindDimensionVector$j$hasReferenceQuantityKind.map(_item => ((_item.termType === "Literal") ? { "@language": _item.language.length > 0 ? _item.language : undefined, "@type": _item.datatype.value !== "http://www.w3.org/2001/XMLSchema#string" ? _item.datatype.value : undefined, "@value": _item.value, termType: "Literal" as const } : (_item.termType === "NamedNode") ? { "@id": _item.value, termType: "NamedNode" as const } : { "@id": `_:${_item.value}`, termType: "BlankNode" as const })),qudt_QuantityKindDimensionVector$j$latexDefinition: this.qudt_QuantityKindDimensionVector$j$latexDefinition.map(_item => (_item)).extract(),qudt_QuantityKindDimensionVector$j$latexSymbol: this.qudt_QuantityKindDimensionVector$j$latexSymbol.map(_item => (_item)) } satisfies ReturnType<Quantity_Kind$W$Dimension$W$Vector["toJson"]>));
    }

    override toRdf({ ignoreRdfType, mutateGraph, resourceSet }: { ignoreRdfType?: boolean; mutateGraph?: rdfjsResource.MutableResource.MutateGraph, resourceSet: rdfjsResource.MutableResourceSet }): rdfjsResource.MutableResource {
        const _resource = super.toRdf({ ignoreRdfType: true, mutateGraph, resourceSet });
        if (!ignoreRdfType) { _resource.add(_resource.dataFactory.namedNode("http://www.w3.org/1999/02/22-rdf-syntax-ns#type"), _resource.dataFactory.namedNode("http://qudt.org/schema/qudt/QuantityKindDimensionVector")); }

        _resource.add(dataFactory.namedNode("http://qudt.org/schema/qudt/dimensionExponentForAmountOfSubstance"), this.qudt_QuantityKindDimensionVector$j$dimensionExponentForAmountOfSubstance);
        _resource.add(dataFactory.namedNode("http://qudt.org/schema/qudt/dimensionExponentForElectricCurrent"), this.qudt_QuantityKindDimensionVector$j$dimensionExponentForElectricCurrent);
        _resource.add(dataFactory.namedNode("http://qudt.org/schema/qudt/dimensionExponentForLength"), this.qudt_QuantityKindDimensionVector$j$dimensionExponentForLength);
        _resource.add(dataFactory.namedNode("http://qudt.org/schema/qudt/dimensionExponentForLuminousIntensity"), this.qudt_QuantityKindDimensionVector$j$dimensionExponentForLuminousIntensity);
        _resource.add(dataFactory.namedNode("http://qudt.org/schema/qudt/dimensionExponentForMass"), this.qudt_QuantityKindDimensionVector$j$dimensionExponentForMass);
        _resource.add(dataFactory.namedNode("http://qudt.org/schema/qudt/dimensionExponentForThermodynamicTemperature"), this.qudt_QuantityKindDimensionVector$j$dimensionExponentForThermodynamicTemperature);
        _resource.add(dataFactory.namedNode("http://qudt.org/schema/qudt/dimensionExponentForTime"), this.qudt_QuantityKindDimensionVector$j$dimensionExponentForTime);
        _resource.add(dataFactory.namedNode("http://qudt.org/schema/qudt/dimensionlessExponent"), this.qudt_QuantityKindDimensionVector$j$dimensionlessExponent);
        _resource.add(dataFactory.namedNode("http://qudt.org/schema/qudt/hasReferenceQuantityKind"), this.qudt_QuantityKindDimensionVector$j$hasReferenceQuantityKind.map((_item) => _item));
        _resource.add(dataFactory.namedNode("http://qudt.org/schema/qudt/latexDefinition"), this.qudt_QuantityKindDimensionVector$j$latexDefinition);
        _resource.add(dataFactory.namedNode("http://qudt.org/schema/qudt/latexSymbol"), this.qudt_QuantityKindDimensionVector$j$latexSymbol.map((_item) => _item));
        return _resource;
    }

    override toString(): string {
        return JSON.stringify(this.toJson());
    }
}

export namespace Quantity_Kind$W$Dimension$W$Vector {
    export function _propertiesFromJson(_json: unknown): purify.Either<zod.ZodError, { identifier: (rdfjs.BlankNode | rdfjs.NamedNode); qudt_QuantityKindDimensionVector$j$dimensionExponentForAmountOfSubstance: (rdfjs.BlankNode | rdfjs.NamedNode | rdfjs.Literal); qudt_QuantityKindDimensionVector$j$dimensionExponentForElectricCurrent: number; qudt_QuantityKindDimensionVector$j$dimensionExponentForLength: (rdfjs.BlankNode | rdfjs.NamedNode | rdfjs.Literal); qudt_QuantityKindDimensionVector$j$dimensionExponentForLuminousIntensity: (rdfjs.BlankNode | rdfjs.NamedNode | rdfjs.Literal); qudt_QuantityKindDimensionVector$j$dimensionExponentForMass: (rdfjs.BlankNode | rdfjs.NamedNode | rdfjs.Literal); qudt_QuantityKindDimensionVector$j$dimensionExponentForThermodynamicTemperature: (rdfjs.BlankNode | rdfjs.NamedNode | rdfjs.Literal); qudt_QuantityKindDimensionVector$j$dimensionExponentForTime: (rdfjs.BlankNode | rdfjs.NamedNode | rdfjs.Literal); qudt_QuantityKindDimensionVector$j$dimensionlessExponent: (rdfjs.BlankNode | rdfjs.NamedNode | rdfjs.Literal); qudt_QuantityKindDimensionVector$j$hasReferenceQuantityKind: readonly ((rdfjs.BlankNode | rdfjs.NamedNode | rdfjs.Literal))[]; qudt_QuantityKindDimensionVector$j$latexDefinition: purify.Maybe<string>; qudt_QuantityKindDimensionVector$j$latexSymbol: readonly (string)[]; } & UnwrapR<ReturnType<typeof QUDT_Concept._propertiesFromJson>>> {
        const _jsonSafeParseResult = quantityKindWDimensionWVectorJsonZodSchema().safeParse(_json);
        if (!_jsonSafeParseResult.success) { return purify.Left(_jsonSafeParseResult.error); }

        const _jsonObject = _jsonSafeParseResult.data;
        const _super0Either = QUDT_Concept._propertiesFromJson(_jsonObject);
        if (_super0Either.isLeft()) { return _super0Either; }

        const _super0 = _super0Either.unsafeCoerce()
        const identifier = (_jsonObject["@id"].startsWith("_:") ? dataFactory.blankNode(_jsonObject["@id"].substring(2)) : dataFactory.namedNode(_jsonObject["@id"]));
        const qudt_QuantityKindDimensionVector$j$dimensionExponentForAmountOfSubstance = ((_jsonObject["qudt_QuantityKindDimensionVector$j$dimensionExponentForAmountOfSubstance"].termType === "Literal") ? (dataFactory.literal(_jsonObject["qudt_QuantityKindDimensionVector$j$dimensionExponentForAmountOfSubstance"]["@value"], typeof _jsonObject["qudt_QuantityKindDimensionVector$j$dimensionExponentForAmountOfSubstance"]["@language"] !== "undefined" ? _jsonObject["qudt_QuantityKindDimensionVector$j$dimensionExponentForAmountOfSubstance"]["@language"] : (typeof _jsonObject["qudt_QuantityKindDimensionVector$j$dimensionExponentForAmountOfSubstance"]["@type"] !== "undefined" ? dataFactory.namedNode(_jsonObject["qudt_QuantityKindDimensionVector$j$dimensionExponentForAmountOfSubstance"]["@type"]) : undefined))) : (((_jsonObject["qudt_QuantityKindDimensionVector$j$dimensionExponentForAmountOfSubstance"].termType === "NamedNode") ? (dataFactory.namedNode(_jsonObject["qudt_QuantityKindDimensionVector$j$dimensionExponentForAmountOfSubstance"]["@id"])) : (dataFactory.blankNode(_jsonObject["qudt_QuantityKindDimensionVector$j$dimensionExponentForAmountOfSubstance"]["@id"].substring(2))))));
        const qudt_QuantityKindDimensionVector$j$dimensionExponentForElectricCurrent = _jsonObject["qudt_QuantityKindDimensionVector$j$dimensionExponentForElectricCurrent"];
        const qudt_QuantityKindDimensionVector$j$dimensionExponentForLength = ((_jsonObject["qudt_QuantityKindDimensionVector$j$dimensionExponentForLength"].termType === "Literal") ? (dataFactory.literal(_jsonObject["qudt_QuantityKindDimensionVector$j$dimensionExponentForLength"]["@value"], typeof _jsonObject["qudt_QuantityKindDimensionVector$j$dimensionExponentForLength"]["@language"] !== "undefined" ? _jsonObject["qudt_QuantityKindDimensionVector$j$dimensionExponentForLength"]["@language"] : (typeof _jsonObject["qudt_QuantityKindDimensionVector$j$dimensionExponentForLength"]["@type"] !== "undefined" ? dataFactory.namedNode(_jsonObject["qudt_QuantityKindDimensionVector$j$dimensionExponentForLength"]["@type"]) : undefined))) : (((_jsonObject["qudt_QuantityKindDimensionVector$j$dimensionExponentForLength"].termType === "NamedNode") ? (dataFactory.namedNode(_jsonObject["qudt_QuantityKindDimensionVector$j$dimensionExponentForLength"]["@id"])) : (dataFactory.blankNode(_jsonObject["qudt_QuantityKindDimensionVector$j$dimensionExponentForLength"]["@id"].substring(2))))));
        const qudt_QuantityKindDimensionVector$j$dimensionExponentForLuminousIntensity = ((_jsonObject["qudt_QuantityKindDimensionVector$j$dimensionExponentForLuminousIntensity"].termType === "Literal") ? (dataFactory.literal(_jsonObject["qudt_QuantityKindDimensionVector$j$dimensionExponentForLuminousIntensity"]["@value"], typeof _jsonObject["qudt_QuantityKindDimensionVector$j$dimensionExponentForLuminousIntensity"]["@language"] !== "undefined" ? _jsonObject["qudt_QuantityKindDimensionVector$j$dimensionExponentForLuminousIntensity"]["@language"] : (typeof _jsonObject["qudt_QuantityKindDimensionVector$j$dimensionExponentForLuminousIntensity"]["@type"] !== "undefined" ? dataFactory.namedNode(_jsonObject["qudt_QuantityKindDimensionVector$j$dimensionExponentForLuminousIntensity"]["@type"]) : undefined))) : (((_jsonObject["qudt_QuantityKindDimensionVector$j$dimensionExponentForLuminousIntensity"].termType === "NamedNode") ? (dataFactory.namedNode(_jsonObject["qudt_QuantityKindDimensionVector$j$dimensionExponentForLuminousIntensity"]["@id"])) : (dataFactory.blankNode(_jsonObject["qudt_QuantityKindDimensionVector$j$dimensionExponentForLuminousIntensity"]["@id"].substring(2))))));
        const qudt_QuantityKindDimensionVector$j$dimensionExponentForMass = ((_jsonObject["qudt_QuantityKindDimensionVector$j$dimensionExponentForMass"].termType === "Literal") ? (dataFactory.literal(_jsonObject["qudt_QuantityKindDimensionVector$j$dimensionExponentForMass"]["@value"], typeof _jsonObject["qudt_QuantityKindDimensionVector$j$dimensionExponentForMass"]["@language"] !== "undefined" ? _jsonObject["qudt_QuantityKindDimensionVector$j$dimensionExponentForMass"]["@language"] : (typeof _jsonObject["qudt_QuantityKindDimensionVector$j$dimensionExponentForMass"]["@type"] !== "undefined" ? dataFactory.namedNode(_jsonObject["qudt_QuantityKindDimensionVector$j$dimensionExponentForMass"]["@type"]) : undefined))) : (((_jsonObject["qudt_QuantityKindDimensionVector$j$dimensionExponentForMass"].termType === "NamedNode") ? (dataFactory.namedNode(_jsonObject["qudt_QuantityKindDimensionVector$j$dimensionExponentForMass"]["@id"])) : (dataFactory.blankNode(_jsonObject["qudt_QuantityKindDimensionVector$j$dimensionExponentForMass"]["@id"].substring(2))))));
        const qudt_QuantityKindDimensionVector$j$dimensionExponentForThermodynamicTemperature = ((_jsonObject["qudt_QuantityKindDimensionVector$j$dimensionExponentForThermodynamicTemperature"].termType === "Literal") ? (dataFactory.literal(_jsonObject["qudt_QuantityKindDimensionVector$j$dimensionExponentForThermodynamicTemperature"]["@value"], typeof _jsonObject["qudt_QuantityKindDimensionVector$j$dimensionExponentForThermodynamicTemperature"]["@language"] !== "undefined" ? _jsonObject["qudt_QuantityKindDimensionVector$j$dimensionExponentForThermodynamicTemperature"]["@language"] : (typeof _jsonObject["qudt_QuantityKindDimensionVector$j$dimensionExponentForThermodynamicTemperature"]["@type"] !== "undefined" ? dataFactory.namedNode(_jsonObject["qudt_QuantityKindDimensionVector$j$dimensionExponentForThermodynamicTemperature"]["@type"]) : undefined))) : (((_jsonObject["qudt_QuantityKindDimensionVector$j$dimensionExponentForThermodynamicTemperature"].termType === "NamedNode") ? (dataFactory.namedNode(_jsonObject["qudt_QuantityKindDimensionVector$j$dimensionExponentForThermodynamicTemperature"]["@id"])) : (dataFactory.blankNode(_jsonObject["qudt_QuantityKindDimensionVector$j$dimensionExponentForThermodynamicTemperature"]["@id"].substring(2))))));
        const qudt_QuantityKindDimensionVector$j$dimensionExponentForTime = ((_jsonObject["qudt_QuantityKindDimensionVector$j$dimensionExponentForTime"].termType === "Literal") ? (dataFactory.literal(_jsonObject["qudt_QuantityKindDimensionVector$j$dimensionExponentForTime"]["@value"], typeof _jsonObject["qudt_QuantityKindDimensionVector$j$dimensionExponentForTime"]["@language"] !== "undefined" ? _jsonObject["qudt_QuantityKindDimensionVector$j$dimensionExponentForTime"]["@language"] : (typeof _jsonObject["qudt_QuantityKindDimensionVector$j$dimensionExponentForTime"]["@type"] !== "undefined" ? dataFactory.namedNode(_jsonObject["qudt_QuantityKindDimensionVector$j$dimensionExponentForTime"]["@type"]) : undefined))) : (((_jsonObject["qudt_QuantityKindDimensionVector$j$dimensionExponentForTime"].termType === "NamedNode") ? (dataFactory.namedNode(_jsonObject["qudt_QuantityKindDimensionVector$j$dimensionExponentForTime"]["@id"])) : (dataFactory.blankNode(_jsonObject["qudt_QuantityKindDimensionVector$j$dimensionExponentForTime"]["@id"].substring(2))))));
        const qudt_QuantityKindDimensionVector$j$dimensionlessExponent = ((_jsonObject["qudt_QuantityKindDimensionVector$j$dimensionlessExponent"].termType === "Literal") ? (dataFactory.literal(_jsonObject["qudt_QuantityKindDimensionVector$j$dimensionlessExponent"]["@value"], typeof _jsonObject["qudt_QuantityKindDimensionVector$j$dimensionlessExponent"]["@language"] !== "undefined" ? _jsonObject["qudt_QuantityKindDimensionVector$j$dimensionlessExponent"]["@language"] : (typeof _jsonObject["qudt_QuantityKindDimensionVector$j$dimensionlessExponent"]["@type"] !== "undefined" ? dataFactory.namedNode(_jsonObject["qudt_QuantityKindDimensionVector$j$dimensionlessExponent"]["@type"]) : undefined))) : (((_jsonObject["qudt_QuantityKindDimensionVector$j$dimensionlessExponent"].termType === "NamedNode") ? (dataFactory.namedNode(_jsonObject["qudt_QuantityKindDimensionVector$j$dimensionlessExponent"]["@id"])) : (dataFactory.blankNode(_jsonObject["qudt_QuantityKindDimensionVector$j$dimensionlessExponent"]["@id"].substring(2))))));
        const qudt_QuantityKindDimensionVector$j$hasReferenceQuantityKind = _jsonObject["qudt_QuantityKindDimensionVector$j$hasReferenceQuantityKind"].map(_item => (((_item.termType === "Literal") ? (dataFactory.literal(_item["@value"], typeof _item["@language"] !== "undefined" ? _item["@language"] : (typeof _item["@type"] !== "undefined" ? dataFactory.namedNode(_item["@type"]) : undefined))) : (((_item.termType === "NamedNode") ? (dataFactory.namedNode(_item["@id"])) : (dataFactory.blankNode(_item["@id"].substring(2))))))));
        const qudt_QuantityKindDimensionVector$j$latexDefinition = purify.Maybe.fromNullable(_jsonObject["qudt_QuantityKindDimensionVector$j$latexDefinition"]);
        const qudt_QuantityKindDimensionVector$j$latexSymbol = _jsonObject["qudt_QuantityKindDimensionVector$j$latexSymbol"];
        return purify.Either.of({ ..._super0, identifier, qudt_QuantityKindDimensionVector$j$dimensionExponentForAmountOfSubstance, qudt_QuantityKindDimensionVector$j$dimensionExponentForElectricCurrent, qudt_QuantityKindDimensionVector$j$dimensionExponentForLength, qudt_QuantityKindDimensionVector$j$dimensionExponentForLuminousIntensity, qudt_QuantityKindDimensionVector$j$dimensionExponentForMass, qudt_QuantityKindDimensionVector$j$dimensionExponentForThermodynamicTemperature, qudt_QuantityKindDimensionVector$j$dimensionExponentForTime, qudt_QuantityKindDimensionVector$j$dimensionlessExponent, qudt_QuantityKindDimensionVector$j$hasReferenceQuantityKind, qudt_QuantityKindDimensionVector$j$latexDefinition, qudt_QuantityKindDimensionVector$j$latexSymbol })
    }

    export function fromJson(json: unknown): purify.Either<zod.ZodError, Quantity_Kind$W$Dimension$W$Vector> {
        return (CGS_Dimension$W$vector.fromJson(json) as purify.Either<zod.ZodError, Quantity_Kind$W$Dimension$W$Vector>).altLazy(() => (ISO_Dimension$W$vector.fromJson(json) as purify.Either<zod.ZodError, Quantity_Kind$W$Dimension$W$Vector>)).altLazy(() => (Imperial_dimension$W$vector.fromJson(json) as purify.Either<zod.ZodError, Quantity_Kind$W$Dimension$W$Vector>)).altLazy(() => (Quantity_Kind$W$Dimension$W$vector$W$$e$SI$f$.fromJson(json) as purify.Either<zod.ZodError, Quantity_Kind$W$Dimension$W$Vector>)).altLazy(() => Quantity_Kind$W$Dimension$W$Vector._propertiesFromJson(json).map(properties => new Quantity_Kind$W$Dimension$W$Vector(properties)));
    }

    export function _propertiesFromRdf({ ignoreRdfType: _ignoreRdfType, languageIn: _languageIn, resource: _resource,
        // @ts-ignore
        ..._context }: { [_index: string]: any; ignoreRdfType?: boolean; languageIn?: readonly string[]; resource: rdfjsResource.Resource; }): purify.Either<rdfjsResource.Resource.ValueError, { identifier: (rdfjs.BlankNode | rdfjs.NamedNode); qudt_QuantityKindDimensionVector$j$dimensionExponentForAmountOfSubstance: (rdfjs.BlankNode | rdfjs.NamedNode | rdfjs.Literal); qudt_QuantityKindDimensionVector$j$dimensionExponentForElectricCurrent: number; qudt_QuantityKindDimensionVector$j$dimensionExponentForLength: (rdfjs.BlankNode | rdfjs.NamedNode | rdfjs.Literal); qudt_QuantityKindDimensionVector$j$dimensionExponentForLuminousIntensity: (rdfjs.BlankNode | rdfjs.NamedNode | rdfjs.Literal); qudt_QuantityKindDimensionVector$j$dimensionExponentForMass: (rdfjs.BlankNode | rdfjs.NamedNode | rdfjs.Literal); qudt_QuantityKindDimensionVector$j$dimensionExponentForThermodynamicTemperature: (rdfjs.BlankNode | rdfjs.NamedNode | rdfjs.Literal); qudt_QuantityKindDimensionVector$j$dimensionExponentForTime: (rdfjs.BlankNode | rdfjs.NamedNode | rdfjs.Literal); qudt_QuantityKindDimensionVector$j$dimensionlessExponent: (rdfjs.BlankNode | rdfjs.NamedNode | rdfjs.Literal); qudt_QuantityKindDimensionVector$j$hasReferenceQuantityKind: readonly ((rdfjs.BlankNode | rdfjs.NamedNode | rdfjs.Literal))[]; qudt_QuantityKindDimensionVector$j$latexDefinition: purify.Maybe<string>; qudt_QuantityKindDimensionVector$j$latexSymbol: readonly (string)[]; } & UnwrapR<ReturnType<typeof QUDT_Concept._propertiesFromRdf>>> {
        const _super0Either = QUDT_Concept._propertiesFromRdf({ ..._context, ignoreRdfType: true, languageIn: _languageIn, resource: _resource });
        if (_super0Either.isLeft()) { return _super0Either; }

        const _super0 = _super0Either.unsafeCoerce()
        if (!_ignoreRdfType && !_resource.isInstanceOf(dataFactory.namedNode("http://qudt.org/schema/qudt/QuantityKindDimensionVector"))) { return purify.Left(new rdfjsResource.Resource.ValueError({ focusResource: _resource, message: `${rdfjsResource.Resource.Identifier.toString(_resource.identifier)} has unexpected RDF type (expected http://qudt.org/schema/qudt/QuantityKindDimensionVector)`, predicate: dataFactory.namedNode("http://qudt.org/schema/qudt/QuantityKindDimensionVector") })); }

        const identifier = _resource.identifier
        const _qudt_QuantityKindDimensionVector$j$dimensionExponentForAmountOfSubstanceEither: purify.Either<rdfjsResource.Resource.ValueError, (rdfjs.BlankNode | rdfjs.NamedNode | rdfjs.Literal)> = _resource.values(dataFactory.namedNode("http://qudt.org/schema/qudt/dimensionExponentForAmountOfSubstance"), { unique: true }).head().chain(_value => purify.Either.of(_value.toTerm()));
        if (_qudt_QuantityKindDimensionVector$j$dimensionExponentForAmountOfSubstanceEither.isLeft()) { return _qudt_QuantityKindDimensionVector$j$dimensionExponentForAmountOfSubstanceEither; }

        const qudt_QuantityKindDimensionVector$j$dimensionExponentForAmountOfSubstance = _qudt_QuantityKindDimensionVector$j$dimensionExponentForAmountOfSubstanceEither.unsafeCoerce();
        const _qudt_QuantityKindDimensionVector$j$dimensionExponentForElectricCurrentEither: purify.Either<rdfjsResource.Resource.ValueError, number> = _resource.values(dataFactory.namedNode("http://qudt.org/schema/qudt/dimensionExponentForElectricCurrent"), { unique: true }).head().chain(_value => _value.toNumber());
        if (_qudt_QuantityKindDimensionVector$j$dimensionExponentForElectricCurrentEither.isLeft()) { return _qudt_QuantityKindDimensionVector$j$dimensionExponentForElectricCurrentEither; }

        const qudt_QuantityKindDimensionVector$j$dimensionExponentForElectricCurrent = _qudt_QuantityKindDimensionVector$j$dimensionExponentForElectricCurrentEither.unsafeCoerce();
        const _qudt_QuantityKindDimensionVector$j$dimensionExponentForLengthEither: purify.Either<rdfjsResource.Resource.ValueError, (rdfjs.BlankNode | rdfjs.NamedNode | rdfjs.Literal)> = _resource.values(dataFactory.namedNode("http://qudt.org/schema/qudt/dimensionExponentForLength"), { unique: true }).head().chain(_value => purify.Either.of(_value.toTerm()));
        if (_qudt_QuantityKindDimensionVector$j$dimensionExponentForLengthEither.isLeft()) { return _qudt_QuantityKindDimensionVector$j$dimensionExponentForLengthEither; }

        const qudt_QuantityKindDimensionVector$j$dimensionExponentForLength = _qudt_QuantityKindDimensionVector$j$dimensionExponentForLengthEither.unsafeCoerce();
        const _qudt_QuantityKindDimensionVector$j$dimensionExponentForLuminousIntensityEither: purify.Either<rdfjsResource.Resource.ValueError, (rdfjs.BlankNode | rdfjs.NamedNode | rdfjs.Literal)> = _resource.values(dataFactory.namedNode("http://qudt.org/schema/qudt/dimensionExponentForLuminousIntensity"), { unique: true }).head().chain(_value => purify.Either.of(_value.toTerm()));
        if (_qudt_QuantityKindDimensionVector$j$dimensionExponentForLuminousIntensityEither.isLeft()) { return _qudt_QuantityKindDimensionVector$j$dimensionExponentForLuminousIntensityEither; }

        const qudt_QuantityKindDimensionVector$j$dimensionExponentForLuminousIntensity = _qudt_QuantityKindDimensionVector$j$dimensionExponentForLuminousIntensityEither.unsafeCoerce();
        const _qudt_QuantityKindDimensionVector$j$dimensionExponentForMassEither: purify.Either<rdfjsResource.Resource.ValueError, (rdfjs.BlankNode | rdfjs.NamedNode | rdfjs.Literal)> = _resource.values(dataFactory.namedNode("http://qudt.org/schema/qudt/dimensionExponentForMass"), { unique: true }).head().chain(_value => purify.Either.of(_value.toTerm()));
        if (_qudt_QuantityKindDimensionVector$j$dimensionExponentForMassEither.isLeft()) { return _qudt_QuantityKindDimensionVector$j$dimensionExponentForMassEither; }

        const qudt_QuantityKindDimensionVector$j$dimensionExponentForMass = _qudt_QuantityKindDimensionVector$j$dimensionExponentForMassEither.unsafeCoerce();
        const _qudt_QuantityKindDimensionVector$j$dimensionExponentForThermodynamicTemperatureEither: purify.Either<rdfjsResource.Resource.ValueError, (rdfjs.BlankNode | rdfjs.NamedNode | rdfjs.Literal)> = _resource.values(dataFactory.namedNode("http://qudt.org/schema/qudt/dimensionExponentForThermodynamicTemperature"), { unique: true }).head().chain(_value => purify.Either.of(_value.toTerm()));
        if (_qudt_QuantityKindDimensionVector$j$dimensionExponentForThermodynamicTemperatureEither.isLeft()) { return _qudt_QuantityKindDimensionVector$j$dimensionExponentForThermodynamicTemperatureEither; }

        const qudt_QuantityKindDimensionVector$j$dimensionExponentForThermodynamicTemperature = _qudt_QuantityKindDimensionVector$j$dimensionExponentForThermodynamicTemperatureEither.unsafeCoerce();
        const _qudt_QuantityKindDimensionVector$j$dimensionExponentForTimeEither: purify.Either<rdfjsResource.Resource.ValueError, (rdfjs.BlankNode | rdfjs.NamedNode | rdfjs.Literal)> = _resource.values(dataFactory.namedNode("http://qudt.org/schema/qudt/dimensionExponentForTime"), { unique: true }).head().chain(_value => purify.Either.of(_value.toTerm()));
        if (_qudt_QuantityKindDimensionVector$j$dimensionExponentForTimeEither.isLeft()) { return _qudt_QuantityKindDimensionVector$j$dimensionExponentForTimeEither; }

        const qudt_QuantityKindDimensionVector$j$dimensionExponentForTime = _qudt_QuantityKindDimensionVector$j$dimensionExponentForTimeEither.unsafeCoerce();
        const _qudt_QuantityKindDimensionVector$j$dimensionlessExponentEither: purify.Either<rdfjsResource.Resource.ValueError, (rdfjs.BlankNode | rdfjs.NamedNode | rdfjs.Literal)> = _resource.values(dataFactory.namedNode("http://qudt.org/schema/qudt/dimensionlessExponent"), { unique: true }).head().chain(_value => purify.Either.of(_value.toTerm()));
        if (_qudt_QuantityKindDimensionVector$j$dimensionlessExponentEither.isLeft()) { return _qudt_QuantityKindDimensionVector$j$dimensionlessExponentEither; }

        const qudt_QuantityKindDimensionVector$j$dimensionlessExponent = _qudt_QuantityKindDimensionVector$j$dimensionlessExponentEither.unsafeCoerce();
        const _qudt_QuantityKindDimensionVector$j$hasReferenceQuantityKindEither: purify.Either<rdfjsResource.Resource.ValueError, readonly ((rdfjs.BlankNode | rdfjs.NamedNode | rdfjs.Literal))[]> = purify.Either.of([..._resource.values(dataFactory.namedNode("http://qudt.org/schema/qudt/hasReferenceQuantityKind"), { unique: true }).flatMap(_item => _item.toValues().head().chain(_value => purify.Either.of(_value.toTerm())).toMaybe().toList())]);
        if (_qudt_QuantityKindDimensionVector$j$hasReferenceQuantityKindEither.isLeft()) { return _qudt_QuantityKindDimensionVector$j$hasReferenceQuantityKindEither; }

        const qudt_QuantityKindDimensionVector$j$hasReferenceQuantityKind = _qudt_QuantityKindDimensionVector$j$hasReferenceQuantityKindEither.unsafeCoerce();
        const _qudt_QuantityKindDimensionVector$j$latexDefinitionEither: purify.Either<rdfjsResource.Resource.ValueError, purify.Maybe<string>> = purify.Either.of(_resource.values(dataFactory.namedNode("http://qudt.org/schema/qudt/latexDefinition"), { unique: true }).head().chain(_value => _value.toString()).toMaybe());
        if (_qudt_QuantityKindDimensionVector$j$latexDefinitionEither.isLeft()) { return _qudt_QuantityKindDimensionVector$j$latexDefinitionEither; }

        const qudt_QuantityKindDimensionVector$j$latexDefinition = _qudt_QuantityKindDimensionVector$j$latexDefinitionEither.unsafeCoerce();
        const _qudt_QuantityKindDimensionVector$j$latexSymbolEither: purify.Either<rdfjsResource.Resource.ValueError, readonly (string)[]> = purify.Either.of([..._resource.values(dataFactory.namedNode("http://qudt.org/schema/qudt/latexSymbol"), { unique: true }).flatMap(_item => _item.toValues().head().chain(_value => _value.toString()).toMaybe().toList())]);
        if (_qudt_QuantityKindDimensionVector$j$latexSymbolEither.isLeft()) { return _qudt_QuantityKindDimensionVector$j$latexSymbolEither; }

        const qudt_QuantityKindDimensionVector$j$latexSymbol = _qudt_QuantityKindDimensionVector$j$latexSymbolEither.unsafeCoerce();
        return purify.Either.of({ ..._super0, identifier, qudt_QuantityKindDimensionVector$j$dimensionExponentForAmountOfSubstance, qudt_QuantityKindDimensionVector$j$dimensionExponentForElectricCurrent, qudt_QuantityKindDimensionVector$j$dimensionExponentForLength, qudt_QuantityKindDimensionVector$j$dimensionExponentForLuminousIntensity, qudt_QuantityKindDimensionVector$j$dimensionExponentForMass, qudt_QuantityKindDimensionVector$j$dimensionExponentForThermodynamicTemperature, qudt_QuantityKindDimensionVector$j$dimensionExponentForTime, qudt_QuantityKindDimensionVector$j$dimensionlessExponent, qudt_QuantityKindDimensionVector$j$hasReferenceQuantityKind, qudt_QuantityKindDimensionVector$j$latexDefinition, qudt_QuantityKindDimensionVector$j$latexSymbol })
    }

    export function fromRdf(parameters: Parameters<typeof Quantity_Kind$W$Dimension$W$Vector._propertiesFromRdf>[0]): purify.Either<rdfjsResource.Resource.ValueError, Quantity_Kind$W$Dimension$W$Vector> {
        const { ignoreRdfType: _ignoreRdfType, ...otherParameters } = parameters
        return (CGS_Dimension$W$vector.fromRdf(otherParameters) as purify.Either<rdfjsResource.Resource.ValueError, Quantity_Kind$W$Dimension$W$Vector>).altLazy(() => (ISO_Dimension$W$vector.fromRdf(otherParameters) as purify.Either<rdfjsResource.Resource.ValueError, Quantity_Kind$W$Dimension$W$Vector>)).altLazy(() => (Imperial_dimension$W$vector.fromRdf(otherParameters) as purify.Either<rdfjsResource.Resource.ValueError, Quantity_Kind$W$Dimension$W$Vector>)).altLazy(() => (Quantity_Kind$W$Dimension$W$vector$W$$e$SI$f$.fromRdf(otherParameters) as purify.Either<rdfjsResource.Resource.ValueError, Quantity_Kind$W$Dimension$W$Vector>)).altLazy(() => Quantity_Kind$W$Dimension$W$Vector._propertiesFromRdf(parameters).map(properties => new Quantity_Kind$W$Dimension$W$Vector(properties)));
    }

    export let fromRdfType: rdfjs.NamedNode<string> = dataFactory.namedNode("http://qudt.org/schema/qudt/QuantityKindDimensionVector");

    export function jsonSchema() {
        return zodToJsonSchema(quantityKindWDimensionWVectorJsonZodSchema());
    }

    export function quantityKindWDimensionWVectorJsonUiSchema(parameters?: { scopePrefix?: string }) {
        const scopePrefix = parameters?.scopePrefix ?? "#";
        return { "elements": [ QUDT_Concept.qudtConceptJsonUiSchema({ scopePrefix }), { scope: `${scopePrefix}/properties/qudt_QuantityKindDimensionVector$j$dimensionExponentForAmountOfSubstance`, type: "Control" }, { scope: `${scopePrefix}/properties/qudt_QuantityKindDimensionVector$j$dimensionExponentForElectricCurrent`, type: "Control" }, { scope: `${scopePrefix}/properties/qudt_QuantityKindDimensionVector$j$dimensionExponentForLength`, type: "Control" }, { scope: `${scopePrefix}/properties/qudt_QuantityKindDimensionVector$j$dimensionExponentForLuminousIntensity`, type: "Control" }, { scope: `${scopePrefix}/properties/qudt_QuantityKindDimensionVector$j$dimensionExponentForMass`, type: "Control" }, { scope: `${scopePrefix}/properties/qudt_QuantityKindDimensionVector$j$dimensionExponentForThermodynamicTemperature`, type: "Control" }, { scope: `${scopePrefix}/properties/qudt_QuantityKindDimensionVector$j$dimensionExponentForTime`, type: "Control" }, { scope: `${scopePrefix}/properties/qudt_QuantityKindDimensionVector$j$dimensionlessExponent`, type: "Control" }, { scope: `${scopePrefix}/properties/qudt_QuantityKindDimensionVector$j$hasReferenceQuantityKind`, type: "Control" }, { scope: `${scopePrefix}/properties/qudt_QuantityKindDimensionVector$j$latexDefinition`, type: "Control" }, { scope: `${scopePrefix}/properties/qudt_QuantityKindDimensionVector$j$latexSymbol`, type: "Control" } ], label: "Quantity Kind Dimension Vector", type: "Group" }
    }

    export function quantityKindWDimensionWVectorJsonZodSchema() {
        return QUDT_Concept.qudtConceptJsonZodSchema().merge(zod.object({ "@id": zod.string().min(1),"type": zod.enum(["CGS_Dimension$W$vector","CGS_EMU$W$Dimension$W$vector","CGS_ESU$W$Dimension$W$vector","CGS_GAUSS$W$Dimension$W$vector","CGS_LH$W$Dimension$W$vector","ISO_Dimension$W$vector","Imperial_dimension$W$vector","Quantity_Kind$W$Dimension$W$Vector","Quantity_Kind$W$Dimension$W$vector$W$$e$SI$f$"]),"qudt_QuantityKindDimensionVector$j$dimensionExponentForAmountOfSubstance": zod.discriminatedUnion("termType", [zod.object({ "@id": zod.string().min(1), termType: zod.literal("BlankNode") }), zod.object({ "@id": zod.string().min(1), termType: zod.literal("NamedNode") }), zod.object({ "@language": zod.string().optional(), "@type": zod.string().optional(), "@value": zod.string(), termType: zod.literal("Literal") })]),"qudt_QuantityKindDimensionVector$j$dimensionExponentForElectricCurrent": zod.number(),"qudt_QuantityKindDimensionVector$j$dimensionExponentForLength": zod.discriminatedUnion("termType", [zod.object({ "@id": zod.string().min(1), termType: zod.literal("BlankNode") }), zod.object({ "@id": zod.string().min(1), termType: zod.literal("NamedNode") }), zod.object({ "@language": zod.string().optional(), "@type": zod.string().optional(), "@value": zod.string(), termType: zod.literal("Literal") })]),"qudt_QuantityKindDimensionVector$j$dimensionExponentForLuminousIntensity": zod.discriminatedUnion("termType", [zod.object({ "@id": zod.string().min(1), termType: zod.literal("BlankNode") }), zod.object({ "@id": zod.string().min(1), termType: zod.literal("NamedNode") }), zod.object({ "@language": zod.string().optional(), "@type": zod.string().optional(), "@value": zod.string(), termType: zod.literal("Literal") })]),"qudt_QuantityKindDimensionVector$j$dimensionExponentForMass": zod.discriminatedUnion("termType", [zod.object({ "@id": zod.string().min(1), termType: zod.literal("BlankNode") }), zod.object({ "@id": zod.string().min(1), termType: zod.literal("NamedNode") }), zod.object({ "@language": zod.string().optional(), "@type": zod.string().optional(), "@value": zod.string(), termType: zod.literal("Literal") })]),"qudt_QuantityKindDimensionVector$j$dimensionExponentForThermodynamicTemperature": zod.discriminatedUnion("termType", [zod.object({ "@id": zod.string().min(1), termType: zod.literal("BlankNode") }), zod.object({ "@id": zod.string().min(1), termType: zod.literal("NamedNode") }), zod.object({ "@language": zod.string().optional(), "@type": zod.string().optional(), "@value": zod.string(), termType: zod.literal("Literal") })]),"qudt_QuantityKindDimensionVector$j$dimensionExponentForTime": zod.discriminatedUnion("termType", [zod.object({ "@id": zod.string().min(1), termType: zod.literal("BlankNode") }), zod.object({ "@id": zod.string().min(1), termType: zod.literal("NamedNode") }), zod.object({ "@language": zod.string().optional(), "@type": zod.string().optional(), "@value": zod.string(), termType: zod.literal("Literal") })]),"qudt_QuantityKindDimensionVector$j$dimensionlessExponent": zod.discriminatedUnion("termType", [zod.object({ "@id": zod.string().min(1), termType: zod.literal("BlankNode") }), zod.object({ "@id": zod.string().min(1), termType: zod.literal("NamedNode") }), zod.object({ "@language": zod.string().optional(), "@type": zod.string().optional(), "@value": zod.string(), termType: zod.literal("Literal") })]),"qudt_QuantityKindDimensionVector$j$hasReferenceQuantityKind": zod.discriminatedUnion("termType", [zod.object({ "@id": zod.string().min(1), termType: zod.literal("BlankNode") }), zod.object({ "@id": zod.string().min(1), termType: zod.literal("NamedNode") }), zod.object({ "@language": zod.string().optional(), "@type": zod.string().optional(), "@value": zod.string(), termType: zod.literal("Literal") })]).array(),"qudt_QuantityKindDimensionVector$j$latexDefinition": zod.string().optional(),"qudt_QuantityKindDimensionVector$j$latexSymbol": zod.string().array() }));
    }

    export function sparqlConstructQuery(parameters?: { ignoreRdfType?: boolean; prefixes?: { [prefix: string]: string }; subject?: sparqljs.Triple["subject"]; } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type">): sparqljs.ConstructQuery {
        const { ignoreRdfType, subject, ...queryParameters } = parameters ?? {}

        return { ...queryParameters, prefixes: parameters?.prefixes ?? {}, queryType: "CONSTRUCT", template: (queryParameters.template ?? []).concat(Quantity_Kind$W$Dimension$W$Vector.sparqlConstructTemplateTriples({ ignoreRdfType, subject })), type: "query", where: (queryParameters.where ?? []).concat(Quantity_Kind$W$Dimension$W$Vector.sparqlWherePatterns({ ignoreRdfType, subject })) };
    }

    export function sparqlConstructQueryString(parameters?: { ignoreRdfType?: boolean; subject?: sparqljs.Triple["subject"]; variablePrefix?: string; } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type"> & sparqljs.GeneratorOptions): string {
        return new sparqljs.Generator(parameters).stringify(Quantity_Kind$W$Dimension$W$Vector.sparqlConstructQuery(parameters));
    }

    export function sparqlConstructTemplateTriples(parameters?: { ignoreRdfType?: boolean; subject?: sparqljs.Triple["subject"], variablePrefix?: string }): readonly sparqljs.Triple[] {
        const subject = parameters?.subject ?? dataFactory.variable!("quantityKindWDimensionWVector");
        const variablePrefix = parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "quantityKindWDimensionWVector");
        return [...QUDT_Concept.sparqlConstructTemplateTriples({ ignoreRdfType: true, subject, variablePrefix }), ...(parameters?.ignoreRdfType ? [] : [{ subject, predicate: dataFactory.namedNode("http://www.w3.org/1999/02/22-rdf-syntax-ns#type"), object: dataFactory.variable!(`${variablePrefix}RdfType`) }]), { object: dataFactory.variable!(`${variablePrefix}QudtQuantityKindDimensionVectorJDimensionExponentForAmountOfSubstance`), predicate: dataFactory.namedNode("http://qudt.org/schema/qudt/dimensionExponentForAmountOfSubstance"), subject }, { object: dataFactory.variable!(`${variablePrefix}QudtQuantityKindDimensionVectorJDimensionExponentForElectricCurrent`), predicate: dataFactory.namedNode("http://qudt.org/schema/qudt/dimensionExponentForElectricCurrent"), subject }, { object: dataFactory.variable!(`${variablePrefix}QudtQuantityKindDimensionVectorJDimensionExponentForLength`), predicate: dataFactory.namedNode("http://qudt.org/schema/qudt/dimensionExponentForLength"), subject }, { object: dataFactory.variable!(`${variablePrefix}QudtQuantityKindDimensionVectorJDimensionExponentForLuminousIntensity`), predicate: dataFactory.namedNode("http://qudt.org/schema/qudt/dimensionExponentForLuminousIntensity"), subject }, { object: dataFactory.variable!(`${variablePrefix}QudtQuantityKindDimensionVectorJDimensionExponentForMass`), predicate: dataFactory.namedNode("http://qudt.org/schema/qudt/dimensionExponentForMass"), subject }, { object: dataFactory.variable!(`${variablePrefix}QudtQuantityKindDimensionVectorJDimensionExponentForThermodynamicTemperature`), predicate: dataFactory.namedNode("http://qudt.org/schema/qudt/dimensionExponentForThermodynamicTemperature"), subject }, { object: dataFactory.variable!(`${variablePrefix}QudtQuantityKindDimensionVectorJDimensionExponentForTime`), predicate: dataFactory.namedNode("http://qudt.org/schema/qudt/dimensionExponentForTime"), subject }, { object: dataFactory.variable!(`${variablePrefix}QudtQuantityKindDimensionVectorJDimensionlessExponent`), predicate: dataFactory.namedNode("http://qudt.org/schema/qudt/dimensionlessExponent"), subject }, { object: dataFactory.variable!(`${variablePrefix}QudtQuantityKindDimensionVectorJHasReferenceQuantityKind`), predicate: dataFactory.namedNode("http://qudt.org/schema/qudt/hasReferenceQuantityKind"), subject }, { object: dataFactory.variable!(`${variablePrefix}QudtQuantityKindDimensionVectorJLatexDefinition`), predicate: dataFactory.namedNode("http://qudt.org/schema/qudt/latexDefinition"), subject }, { object: dataFactory.variable!(`${variablePrefix}QudtQuantityKindDimensionVectorJLatexSymbol`), predicate: dataFactory.namedNode("http://qudt.org/schema/qudt/latexSymbol"), subject }];
    }

    export function sparqlWherePatterns(parameters: { ignoreRdfType?: boolean; subject?: sparqljs.Triple["subject"], variablePrefix?: string }): readonly sparqljs.Pattern[] {
        const subject = parameters?.subject ?? dataFactory.variable!("quantityKindWDimensionWVector");
        const variablePrefix = parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "quantityKindWDimensionWVector");
        return [...QUDT_Concept.sparqlWherePatterns({ ignoreRdfType: true, subject, variablePrefix }), ...(parameters?.ignoreRdfType ? [] : [{ triples: [{ subject, predicate: dataFactory.namedNode("http://www.w3.org/1999/02/22-rdf-syntax-ns#type"), object: dataFactory.namedNode("http://qudt.org/schema/qudt/QuantityKindDimensionVector") }], type: "bgp" as const }, { triples: [{ subject, predicate: dataFactory.namedNode("http://www.w3.org/1999/02/22-rdf-syntax-ns#type"), object: dataFactory.variable!(`${variablePrefix}RdfType`) }], type: "bgp" as const }]), { triples: [{ object: dataFactory.variable!(`${variablePrefix}QudtQuantityKindDimensionVectorJDimensionExponentForAmountOfSubstance`), predicate: dataFactory.namedNode("http://qudt.org/schema/qudt/dimensionExponentForAmountOfSubstance"), subject }], type: "bgp" }, { triples: [{ object: dataFactory.variable!(`${variablePrefix}QudtQuantityKindDimensionVectorJDimensionExponentForElectricCurrent`), predicate: dataFactory.namedNode("http://qudt.org/schema/qudt/dimensionExponentForElectricCurrent"), subject }], type: "bgp" }, { triples: [{ object: dataFactory.variable!(`${variablePrefix}QudtQuantityKindDimensionVectorJDimensionExponentForLength`), predicate: dataFactory.namedNode("http://qudt.org/schema/qudt/dimensionExponentForLength"), subject }], type: "bgp" }, { triples: [{ object: dataFactory.variable!(`${variablePrefix}QudtQuantityKindDimensionVectorJDimensionExponentForLuminousIntensity`), predicate: dataFactory.namedNode("http://qudt.org/schema/qudt/dimensionExponentForLuminousIntensity"), subject }], type: "bgp" }, { triples: [{ object: dataFactory.variable!(`${variablePrefix}QudtQuantityKindDimensionVectorJDimensionExponentForMass`), predicate: dataFactory.namedNode("http://qudt.org/schema/qudt/dimensionExponentForMass"), subject }], type: "bgp" }, { triples: [{ object: dataFactory.variable!(`${variablePrefix}QudtQuantityKindDimensionVectorJDimensionExponentForThermodynamicTemperature`), predicate: dataFactory.namedNode("http://qudt.org/schema/qudt/dimensionExponentForThermodynamicTemperature"), subject }], type: "bgp" }, { triples: [{ object: dataFactory.variable!(`${variablePrefix}QudtQuantityKindDimensionVectorJDimensionExponentForTime`), predicate: dataFactory.namedNode("http://qudt.org/schema/qudt/dimensionExponentForTime"), subject }], type: "bgp" }, { triples: [{ object: dataFactory.variable!(`${variablePrefix}QudtQuantityKindDimensionVectorJDimensionlessExponent`), predicate: dataFactory.namedNode("http://qudt.org/schema/qudt/dimensionlessExponent"), subject }], type: "bgp" }, { patterns: [{ triples: [{ object: dataFactory.variable!(`${variablePrefix}QudtQuantityKindDimensionVectorJHasReferenceQuantityKind`), predicate: dataFactory.namedNode("http://qudt.org/schema/qudt/hasReferenceQuantityKind"), subject }], type: "bgp" }], type: "optional" }, { patterns: [{ triples: [{ object: dataFactory.variable!(`${variablePrefix}QudtQuantityKindDimensionVectorJLatexDefinition`), predicate: dataFactory.namedNode("http://qudt.org/schema/qudt/latexDefinition"), subject }], type: "bgp" }], type: "optional" }, { patterns: [{ triples: [{ object: dataFactory.variable!(`${variablePrefix}QudtQuantityKindDimensionVectorJLatexSymbol`), predicate: dataFactory.namedNode("http://qudt.org/schema/qudt/latexSymbol"), subject }], type: "bgp" }], type: "optional" }];
    }
}
/**
 * Quantity Kind Dimension vector (SI)
 */
export class Quantity_Kind$W$Dimension$W$vector$W$$e$SI$f$ extends Quantity_Kind$W$Dimension$W$Vector {
    override readonly type = "Quantity_Kind$W$Dimension$W$vector$W$$e$SI$f$";

    // biome-ignore lint/complexity/noUselessConstructor: Always have a constructor
    constructor(parameters: { readonly identifier?: (rdfjs.BlankNode | rdfjs.NamedNode) | string } & ConstructorParameters<typeof Quantity_Kind$W$Dimension$W$Vector>[0]) {
        super(parameters);
    }

    override get identifier(): (rdfjs.BlankNode | rdfjs.NamedNode) {
        if (typeof this._identifier === "undefined") { this._identifier = dataFactory.blankNode(); } return this._identifier;
    }

    override toRdf({ ignoreRdfType, mutateGraph, resourceSet }: { ignoreRdfType?: boolean; mutateGraph?: rdfjsResource.MutableResource.MutateGraph, resourceSet: rdfjsResource.MutableResourceSet }): rdfjsResource.MutableResource {
        const _resource = super.toRdf({ ignoreRdfType: true, mutateGraph, resourceSet });
        if (!ignoreRdfType) { _resource.add(_resource.dataFactory.namedNode("http://www.w3.org/1999/02/22-rdf-syntax-ns#type"), _resource.dataFactory.namedNode("http://qudt.org/schema/qudt/QuantityKindDimensionVector_SI")); }

        return _resource;
    }

    override toString(): string {
        return JSON.stringify(this.toJson());
    }
}

export namespace Quantity_Kind$W$Dimension$W$vector$W$$e$SI$f$ {
    export function _propertiesFromJson(_json: unknown): purify.Either<zod.ZodError, { identifier: (rdfjs.BlankNode | rdfjs.NamedNode); } & UnwrapR<ReturnType<typeof Quantity_Kind$W$Dimension$W$Vector._propertiesFromJson>>> {
        const _jsonSafeParseResult = quantityKindWDimensionWVectorWESiFJsonZodSchema().safeParse(_json);
        if (!_jsonSafeParseResult.success) { return purify.Left(_jsonSafeParseResult.error); }

        const _jsonObject = _jsonSafeParseResult.data;
        const _super0Either = Quantity_Kind$W$Dimension$W$Vector._propertiesFromJson(_jsonObject);
        if (_super0Either.isLeft()) { return _super0Either; }

        const _super0 = _super0Either.unsafeCoerce()
        const identifier = (_jsonObject["@id"].startsWith("_:") ? dataFactory.blankNode(_jsonObject["@id"].substring(2)) : dataFactory.namedNode(_jsonObject["@id"]));
        return purify.Either.of({ ..._super0, identifier })
    }

    export function fromJson(json: unknown): purify.Either<zod.ZodError, Quantity_Kind$W$Dimension$W$vector$W$$e$SI$f$> {
        return Quantity_Kind$W$Dimension$W$vector$W$$e$SI$f$._propertiesFromJson(json).map(properties => new Quantity_Kind$W$Dimension$W$vector$W$$e$SI$f$(properties));
    }

    export function _propertiesFromRdf({ ignoreRdfType: _ignoreRdfType, languageIn: _languageIn, resource: _resource,
        // @ts-ignore
        ..._context }: { [_index: string]: any; ignoreRdfType?: boolean; languageIn?: readonly string[]; resource: rdfjsResource.Resource; }): purify.Either<rdfjsResource.Resource.ValueError, { identifier: (rdfjs.BlankNode | rdfjs.NamedNode); } & UnwrapR<ReturnType<typeof Quantity_Kind$W$Dimension$W$Vector._propertiesFromRdf>>> {
        const _super0Either = Quantity_Kind$W$Dimension$W$Vector._propertiesFromRdf({ ..._context, ignoreRdfType: true, languageIn: _languageIn, resource: _resource });
        if (_super0Either.isLeft()) { return _super0Either; }

        const _super0 = _super0Either.unsafeCoerce()
        if (!_ignoreRdfType && !_resource.isInstanceOf(dataFactory.namedNode("http://qudt.org/schema/qudt/QuantityKindDimensionVector_SI"))) { return purify.Left(new rdfjsResource.Resource.ValueError({ focusResource: _resource, message: `${rdfjsResource.Resource.Identifier.toString(_resource.identifier)} has unexpected RDF type (expected http://qudt.org/schema/qudt/QuantityKindDimensionVector_SI)`, predicate: dataFactory.namedNode("http://qudt.org/schema/qudt/QuantityKindDimensionVector_SI") })); }

        const identifier = _resource.identifier
        return purify.Either.of({ ..._super0, identifier })
    }

    export function fromRdf(parameters: Parameters<typeof Quantity_Kind$W$Dimension$W$vector$W$$e$SI$f$._propertiesFromRdf>[0]): purify.Either<rdfjsResource.Resource.ValueError, Quantity_Kind$W$Dimension$W$vector$W$$e$SI$f$> {
        return Quantity_Kind$W$Dimension$W$vector$W$$e$SI$f$._propertiesFromRdf(parameters).map(properties => new Quantity_Kind$W$Dimension$W$vector$W$$e$SI$f$(properties));
    }

    export let fromRdfType: rdfjs.NamedNode<string> = dataFactory.namedNode("http://qudt.org/schema/qudt/QuantityKindDimensionVector_SI");

    export function jsonSchema() {
        return zodToJsonSchema(quantityKindWDimensionWVectorWESiFJsonZodSchema());
    }

    export function quantityKindWDimensionWVectorWESiFJsonUiSchema(parameters?: { scopePrefix?: string }) {
        const scopePrefix = parameters?.scopePrefix ?? "#";
        return { "elements": [ Quantity_Kind$W$Dimension$W$Vector.quantityKindWDimensionWVectorJsonUiSchema({ scopePrefix }) ], label: "Quantity Kind Dimension vector (SI)", type: "Group" }
    }

    export function quantityKindWDimensionWVectorWESiFJsonZodSchema() {
        return Quantity_Kind$W$Dimension$W$Vector.quantityKindWDimensionWVectorJsonZodSchema().merge(zod.object({ "@id": zod.string().min(1),"type": zod.literal("Quantity_Kind$W$Dimension$W$vector$W$$e$SI$f$") }));
    }

    export function sparqlConstructQuery(parameters?: { ignoreRdfType?: boolean; prefixes?: { [prefix: string]: string }; subject?: sparqljs.Triple["subject"]; } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type">): sparqljs.ConstructQuery {
        const { ignoreRdfType, subject, ...queryParameters } = parameters ?? {}

        return { ...queryParameters, prefixes: parameters?.prefixes ?? {}, queryType: "CONSTRUCT", template: (queryParameters.template ?? []).concat(Quantity_Kind$W$Dimension$W$vector$W$$e$SI$f$.sparqlConstructTemplateTriples({ ignoreRdfType, subject })), type: "query", where: (queryParameters.where ?? []).concat(Quantity_Kind$W$Dimension$W$vector$W$$e$SI$f$.sparqlWherePatterns({ ignoreRdfType, subject })) };
    }

    export function sparqlConstructQueryString(parameters?: { ignoreRdfType?: boolean; subject?: sparqljs.Triple["subject"]; variablePrefix?: string; } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type"> & sparqljs.GeneratorOptions): string {
        return new sparqljs.Generator(parameters).stringify(Quantity_Kind$W$Dimension$W$vector$W$$e$SI$f$.sparqlConstructQuery(parameters));
    }

    export function sparqlConstructTemplateTriples(parameters?: { ignoreRdfType?: boolean; subject?: sparqljs.Triple["subject"], variablePrefix?: string }): readonly sparqljs.Triple[] {
        const subject = parameters?.subject ?? dataFactory.variable!("quantityKindWDimensionWVectorWESiF");
        const variablePrefix = parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "quantityKindWDimensionWVectorWESiF");
        return [...Quantity_Kind$W$Dimension$W$Vector.sparqlConstructTemplateTriples({ ignoreRdfType: true, subject, variablePrefix }), ...(parameters?.ignoreRdfType ? [] : [{ subject, predicate: dataFactory.namedNode("http://www.w3.org/1999/02/22-rdf-syntax-ns#type"), object: dataFactory.variable!(`${variablePrefix}RdfType`) }])];
    }

    export function sparqlWherePatterns(parameters: { ignoreRdfType?: boolean; subject?: sparqljs.Triple["subject"], variablePrefix?: string }): readonly sparqljs.Pattern[] {
        const subject = parameters?.subject ?? dataFactory.variable!("quantityKindWDimensionWVectorWESiF");
        const variablePrefix = parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "quantityKindWDimensionWVectorWESiF");
        return [...Quantity_Kind$W$Dimension$W$Vector.sparqlWherePatterns({ ignoreRdfType: true, subject, variablePrefix }), ...(parameters?.ignoreRdfType ? [] : [{ triples: [{ subject, predicate: dataFactory.namedNode("http://www.w3.org/1999/02/22-rdf-syntax-ns#type"), object: dataFactory.namedNode("http://qudt.org/schema/qudt/QuantityKindDimensionVector_SI") }], type: "bgp" as const }, { triples: [{ subject, predicate: dataFactory.namedNode("http://www.w3.org/1999/02/22-rdf-syntax-ns#type"), object: dataFactory.variable!(`${variablePrefix}RdfType`) }], type: "bgp" as const }])];
    }
}
/**
 * Imperial dimension vector
 */
export class Imperial_dimension$W$vector extends Quantity_Kind$W$Dimension$W$Vector {
    override readonly type = "Imperial_dimension$W$vector";

    // biome-ignore lint/complexity/noUselessConstructor: Always have a constructor
    constructor(parameters: { readonly identifier?: (rdfjs.BlankNode | rdfjs.NamedNode) | string } & ConstructorParameters<typeof Quantity_Kind$W$Dimension$W$Vector>[0]) {
        super(parameters);
    }

    override get identifier(): (rdfjs.BlankNode | rdfjs.NamedNode) {
        if (typeof this._identifier === "undefined") { this._identifier = dataFactory.blankNode(); } return this._identifier;
    }

    override toRdf({ ignoreRdfType, mutateGraph, resourceSet }: { ignoreRdfType?: boolean; mutateGraph?: rdfjsResource.MutableResource.MutateGraph, resourceSet: rdfjsResource.MutableResourceSet }): rdfjsResource.MutableResource {
        const _resource = super.toRdf({ ignoreRdfType: true, mutateGraph, resourceSet });
        if (!ignoreRdfType) { _resource.add(_resource.dataFactory.namedNode("http://www.w3.org/1999/02/22-rdf-syntax-ns#type"), _resource.dataFactory.namedNode("http://qudt.org/schema/qudt/QuantityKindDimensionVector_Imperial")); }

        return _resource;
    }

    override toString(): string {
        return JSON.stringify(this.toJson());
    }
}

export namespace Imperial_dimension$W$vector {
    export function _propertiesFromJson(_json: unknown): purify.Either<zod.ZodError, { identifier: (rdfjs.BlankNode | rdfjs.NamedNode); } & UnwrapR<ReturnType<typeof Quantity_Kind$W$Dimension$W$Vector._propertiesFromJson>>> {
        const _jsonSafeParseResult = imperialDimensionWVectorJsonZodSchema().safeParse(_json);
        if (!_jsonSafeParseResult.success) { return purify.Left(_jsonSafeParseResult.error); }

        const _jsonObject = _jsonSafeParseResult.data;
        const _super0Either = Quantity_Kind$W$Dimension$W$Vector._propertiesFromJson(_jsonObject);
        if (_super0Either.isLeft()) { return _super0Either; }

        const _super0 = _super0Either.unsafeCoerce()
        const identifier = (_jsonObject["@id"].startsWith("_:") ? dataFactory.blankNode(_jsonObject["@id"].substring(2)) : dataFactory.namedNode(_jsonObject["@id"]));
        return purify.Either.of({ ..._super0, identifier })
    }

    export function fromJson(json: unknown): purify.Either<zod.ZodError, Imperial_dimension$W$vector> {
        return Imperial_dimension$W$vector._propertiesFromJson(json).map(properties => new Imperial_dimension$W$vector(properties));
    }

    export function _propertiesFromRdf({ ignoreRdfType: _ignoreRdfType, languageIn: _languageIn, resource: _resource,
        // @ts-ignore
        ..._context }: { [_index: string]: any; ignoreRdfType?: boolean; languageIn?: readonly string[]; resource: rdfjsResource.Resource; }): purify.Either<rdfjsResource.Resource.ValueError, { identifier: (rdfjs.BlankNode | rdfjs.NamedNode); } & UnwrapR<ReturnType<typeof Quantity_Kind$W$Dimension$W$Vector._propertiesFromRdf>>> {
        const _super0Either = Quantity_Kind$W$Dimension$W$Vector._propertiesFromRdf({ ..._context, ignoreRdfType: true, languageIn: _languageIn, resource: _resource });
        if (_super0Either.isLeft()) { return _super0Either; }

        const _super0 = _super0Either.unsafeCoerce()
        if (!_ignoreRdfType && !_resource.isInstanceOf(dataFactory.namedNode("http://qudt.org/schema/qudt/QuantityKindDimensionVector_Imperial"))) { return purify.Left(new rdfjsResource.Resource.ValueError({ focusResource: _resource, message: `${rdfjsResource.Resource.Identifier.toString(_resource.identifier)} has unexpected RDF type (expected http://qudt.org/schema/qudt/QuantityKindDimensionVector_Imperial)`, predicate: dataFactory.namedNode("http://qudt.org/schema/qudt/QuantityKindDimensionVector_Imperial") })); }

        const identifier = _resource.identifier
        return purify.Either.of({ ..._super0, identifier })
    }

    export function fromRdf(parameters: Parameters<typeof Imperial_dimension$W$vector._propertiesFromRdf>[0]): purify.Either<rdfjsResource.Resource.ValueError, Imperial_dimension$W$vector> {
        return Imperial_dimension$W$vector._propertiesFromRdf(parameters).map(properties => new Imperial_dimension$W$vector(properties));
    }

    export let fromRdfType: rdfjs.NamedNode<string> = dataFactory.namedNode("http://qudt.org/schema/qudt/QuantityKindDimensionVector_Imperial");

    export function jsonSchema() {
        return zodToJsonSchema(imperialDimensionWVectorJsonZodSchema());
    }

    export function imperialDimensionWVectorJsonUiSchema(parameters?: { scopePrefix?: string }) {
        const scopePrefix = parameters?.scopePrefix ?? "#";
        return { "elements": [ Quantity_Kind$W$Dimension$W$Vector.quantityKindWDimensionWVectorJsonUiSchema({ scopePrefix }) ], label: "Imperial dimension vector", type: "Group" }
    }

    export function imperialDimensionWVectorJsonZodSchema() {
        return Quantity_Kind$W$Dimension$W$Vector.quantityKindWDimensionWVectorJsonZodSchema().merge(zod.object({ "@id": zod.string().min(1),"type": zod.literal("Imperial_dimension$W$vector") }));
    }

    export function sparqlConstructQuery(parameters?: { ignoreRdfType?: boolean; prefixes?: { [prefix: string]: string }; subject?: sparqljs.Triple["subject"]; } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type">): sparqljs.ConstructQuery {
        const { ignoreRdfType, subject, ...queryParameters } = parameters ?? {}

        return { ...queryParameters, prefixes: parameters?.prefixes ?? {}, queryType: "CONSTRUCT", template: (queryParameters.template ?? []).concat(Imperial_dimension$W$vector.sparqlConstructTemplateTriples({ ignoreRdfType, subject })), type: "query", where: (queryParameters.where ?? []).concat(Imperial_dimension$W$vector.sparqlWherePatterns({ ignoreRdfType, subject })) };
    }

    export function sparqlConstructQueryString(parameters?: { ignoreRdfType?: boolean; subject?: sparqljs.Triple["subject"]; variablePrefix?: string; } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type"> & sparqljs.GeneratorOptions): string {
        return new sparqljs.Generator(parameters).stringify(Imperial_dimension$W$vector.sparqlConstructQuery(parameters));
    }

    export function sparqlConstructTemplateTriples(parameters?: { ignoreRdfType?: boolean; subject?: sparqljs.Triple["subject"], variablePrefix?: string }): readonly sparqljs.Triple[] {
        const subject = parameters?.subject ?? dataFactory.variable!("imperialDimensionWVector");
        const variablePrefix = parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "imperialDimensionWVector");
        return [...Quantity_Kind$W$Dimension$W$Vector.sparqlConstructTemplateTriples({ ignoreRdfType: true, subject, variablePrefix }), ...(parameters?.ignoreRdfType ? [] : [{ subject, predicate: dataFactory.namedNode("http://www.w3.org/1999/02/22-rdf-syntax-ns#type"), object: dataFactory.variable!(`${variablePrefix}RdfType`) }])];
    }

    export function sparqlWherePatterns(parameters: { ignoreRdfType?: boolean; subject?: sparqljs.Triple["subject"], variablePrefix?: string }): readonly sparqljs.Pattern[] {
        const subject = parameters?.subject ?? dataFactory.variable!("imperialDimensionWVector");
        const variablePrefix = parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "imperialDimensionWVector");
        return [...Quantity_Kind$W$Dimension$W$Vector.sparqlWherePatterns({ ignoreRdfType: true, subject, variablePrefix }), ...(parameters?.ignoreRdfType ? [] : [{ triples: [{ subject, predicate: dataFactory.namedNode("http://www.w3.org/1999/02/22-rdf-syntax-ns#type"), object: dataFactory.namedNode("http://qudt.org/schema/qudt/QuantityKindDimensionVector_Imperial") }], type: "bgp" as const }, { triples: [{ subject, predicate: dataFactory.namedNode("http://www.w3.org/1999/02/22-rdf-syntax-ns#type"), object: dataFactory.variable!(`${variablePrefix}RdfType`) }], type: "bgp" as const }])];
    }
}
/**
 * ISO Dimension vector
 */
export class ISO_Dimension$W$vector extends Quantity_Kind$W$Dimension$W$Vector {
    override readonly type = "ISO_Dimension$W$vector";

    // biome-ignore lint/complexity/noUselessConstructor: Always have a constructor
    constructor(parameters: { readonly identifier?: (rdfjs.BlankNode | rdfjs.NamedNode) | string } & ConstructorParameters<typeof Quantity_Kind$W$Dimension$W$Vector>[0]) {
        super(parameters);
    }

    override get identifier(): (rdfjs.BlankNode | rdfjs.NamedNode) {
        if (typeof this._identifier === "undefined") { this._identifier = dataFactory.blankNode(); } return this._identifier;
    }

    override toRdf({ ignoreRdfType, mutateGraph, resourceSet }: { ignoreRdfType?: boolean; mutateGraph?: rdfjsResource.MutableResource.MutateGraph, resourceSet: rdfjsResource.MutableResourceSet }): rdfjsResource.MutableResource {
        const _resource = super.toRdf({ ignoreRdfType: true, mutateGraph, resourceSet });
        if (!ignoreRdfType) { _resource.add(_resource.dataFactory.namedNode("http://www.w3.org/1999/02/22-rdf-syntax-ns#type"), _resource.dataFactory.namedNode("http://qudt.org/schema/qudt/QuantityKindDimensionVector_ISO")); }

        return _resource;
    }

    override toString(): string {
        return JSON.stringify(this.toJson());
    }
}

export namespace ISO_Dimension$W$vector {
    export function _propertiesFromJson(_json: unknown): purify.Either<zod.ZodError, { identifier: (rdfjs.BlankNode | rdfjs.NamedNode); } & UnwrapR<ReturnType<typeof Quantity_Kind$W$Dimension$W$Vector._propertiesFromJson>>> {
        const _jsonSafeParseResult = isoDimensionWVectorJsonZodSchema().safeParse(_json);
        if (!_jsonSafeParseResult.success) { return purify.Left(_jsonSafeParseResult.error); }

        const _jsonObject = _jsonSafeParseResult.data;
        const _super0Either = Quantity_Kind$W$Dimension$W$Vector._propertiesFromJson(_jsonObject);
        if (_super0Either.isLeft()) { return _super0Either; }

        const _super0 = _super0Either.unsafeCoerce()
        const identifier = (_jsonObject["@id"].startsWith("_:") ? dataFactory.blankNode(_jsonObject["@id"].substring(2)) : dataFactory.namedNode(_jsonObject["@id"]));
        return purify.Either.of({ ..._super0, identifier })
    }

    export function fromJson(json: unknown): purify.Either<zod.ZodError, ISO_Dimension$W$vector> {
        return ISO_Dimension$W$vector._propertiesFromJson(json).map(properties => new ISO_Dimension$W$vector(properties));
    }

    export function _propertiesFromRdf({ ignoreRdfType: _ignoreRdfType, languageIn: _languageIn, resource: _resource,
        // @ts-ignore
        ..._context }: { [_index: string]: any; ignoreRdfType?: boolean; languageIn?: readonly string[]; resource: rdfjsResource.Resource; }): purify.Either<rdfjsResource.Resource.ValueError, { identifier: (rdfjs.BlankNode | rdfjs.NamedNode); } & UnwrapR<ReturnType<typeof Quantity_Kind$W$Dimension$W$Vector._propertiesFromRdf>>> {
        const _super0Either = Quantity_Kind$W$Dimension$W$Vector._propertiesFromRdf({ ..._context, ignoreRdfType: true, languageIn: _languageIn, resource: _resource });
        if (_super0Either.isLeft()) { return _super0Either; }

        const _super0 = _super0Either.unsafeCoerce()
        if (!_ignoreRdfType && !_resource.isInstanceOf(dataFactory.namedNode("http://qudt.org/schema/qudt/QuantityKindDimensionVector_ISO"))) { return purify.Left(new rdfjsResource.Resource.ValueError({ focusResource: _resource, message: `${rdfjsResource.Resource.Identifier.toString(_resource.identifier)} has unexpected RDF type (expected http://qudt.org/schema/qudt/QuantityKindDimensionVector_ISO)`, predicate: dataFactory.namedNode("http://qudt.org/schema/qudt/QuantityKindDimensionVector_ISO") })); }

        const identifier = _resource.identifier
        return purify.Either.of({ ..._super0, identifier })
    }

    export function fromRdf(parameters: Parameters<typeof ISO_Dimension$W$vector._propertiesFromRdf>[0]): purify.Either<rdfjsResource.Resource.ValueError, ISO_Dimension$W$vector> {
        return ISO_Dimension$W$vector._propertiesFromRdf(parameters).map(properties => new ISO_Dimension$W$vector(properties));
    }

    export let fromRdfType: rdfjs.NamedNode<string> = dataFactory.namedNode("http://qudt.org/schema/qudt/QuantityKindDimensionVector_ISO");

    export function jsonSchema() {
        return zodToJsonSchema(isoDimensionWVectorJsonZodSchema());
    }

    export function isoDimensionWVectorJsonUiSchema(parameters?: { scopePrefix?: string }) {
        const scopePrefix = parameters?.scopePrefix ?? "#";
        return { "elements": [ Quantity_Kind$W$Dimension$W$Vector.quantityKindWDimensionWVectorJsonUiSchema({ scopePrefix }) ], label: "ISO Dimension vector", type: "Group" }
    }

    export function isoDimensionWVectorJsonZodSchema() {
        return Quantity_Kind$W$Dimension$W$Vector.quantityKindWDimensionWVectorJsonZodSchema().merge(zod.object({ "@id": zod.string().min(1),"type": zod.literal("ISO_Dimension$W$vector") }));
    }

    export function sparqlConstructQuery(parameters?: { ignoreRdfType?: boolean; prefixes?: { [prefix: string]: string }; subject?: sparqljs.Triple["subject"]; } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type">): sparqljs.ConstructQuery {
        const { ignoreRdfType, subject, ...queryParameters } = parameters ?? {}

        return { ...queryParameters, prefixes: parameters?.prefixes ?? {}, queryType: "CONSTRUCT", template: (queryParameters.template ?? []).concat(ISO_Dimension$W$vector.sparqlConstructTemplateTriples({ ignoreRdfType, subject })), type: "query", where: (queryParameters.where ?? []).concat(ISO_Dimension$W$vector.sparqlWherePatterns({ ignoreRdfType, subject })) };
    }

    export function sparqlConstructQueryString(parameters?: { ignoreRdfType?: boolean; subject?: sparqljs.Triple["subject"]; variablePrefix?: string; } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type"> & sparqljs.GeneratorOptions): string {
        return new sparqljs.Generator(parameters).stringify(ISO_Dimension$W$vector.sparqlConstructQuery(parameters));
    }

    export function sparqlConstructTemplateTriples(parameters?: { ignoreRdfType?: boolean; subject?: sparqljs.Triple["subject"], variablePrefix?: string }): readonly sparqljs.Triple[] {
        const subject = parameters?.subject ?? dataFactory.variable!("isoDimensionWVector");
        const variablePrefix = parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "isoDimensionWVector");
        return [...Quantity_Kind$W$Dimension$W$Vector.sparqlConstructTemplateTriples({ ignoreRdfType: true, subject, variablePrefix }), ...(parameters?.ignoreRdfType ? [] : [{ subject, predicate: dataFactory.namedNode("http://www.w3.org/1999/02/22-rdf-syntax-ns#type"), object: dataFactory.variable!(`${variablePrefix}RdfType`) }])];
    }

    export function sparqlWherePatterns(parameters: { ignoreRdfType?: boolean; subject?: sparqljs.Triple["subject"], variablePrefix?: string }): readonly sparqljs.Pattern[] {
        const subject = parameters?.subject ?? dataFactory.variable!("isoDimensionWVector");
        const variablePrefix = parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "isoDimensionWVector");
        return [...Quantity_Kind$W$Dimension$W$Vector.sparqlWherePatterns({ ignoreRdfType: true, subject, variablePrefix }), ...(parameters?.ignoreRdfType ? [] : [{ triples: [{ subject, predicate: dataFactory.namedNode("http://www.w3.org/1999/02/22-rdf-syntax-ns#type"), object: dataFactory.namedNode("http://qudt.org/schema/qudt/QuantityKindDimensionVector_ISO") }], type: "bgp" as const }, { triples: [{ subject, predicate: dataFactory.namedNode("http://www.w3.org/1999/02/22-rdf-syntax-ns#type"), object: dataFactory.variable!(`${variablePrefix}RdfType`) }], type: "bgp" as const }])];
    }
}
/**
 * CGS Dimension vector
 */
export class CGS_Dimension$W$vector extends Quantity_Kind$W$Dimension$W$Vector {
    override readonly type: "CGS_Dimension$W$vector" | "CGS_EMU$W$Dimension$W$vector" | "CGS_ESU$W$Dimension$W$vector" | "CGS_GAUSS$W$Dimension$W$vector" | "CGS_LH$W$Dimension$W$vector" = "CGS_Dimension$W$vector";

    // biome-ignore lint/complexity/noUselessConstructor: Always have a constructor
    constructor(parameters: { readonly identifier?: (rdfjs.BlankNode | rdfjs.NamedNode) | string } & ConstructorParameters<typeof Quantity_Kind$W$Dimension$W$Vector>[0]) {
        super(parameters);
    }

    override get identifier(): (rdfjs.BlankNode | rdfjs.NamedNode) {
        if (typeof this._identifier === "undefined") { this._identifier = dataFactory.blankNode(); } return this._identifier;
    }

    override toRdf({ ignoreRdfType, mutateGraph, resourceSet }: { ignoreRdfType?: boolean; mutateGraph?: rdfjsResource.MutableResource.MutateGraph, resourceSet: rdfjsResource.MutableResourceSet }): rdfjsResource.MutableResource {
        const _resource = super.toRdf({ ignoreRdfType: true, mutateGraph, resourceSet });
        if (!ignoreRdfType) { _resource.add(_resource.dataFactory.namedNode("http://www.w3.org/1999/02/22-rdf-syntax-ns#type"), _resource.dataFactory.namedNode("http://qudt.org/schema/qudt/QuantityKindDimensionVector_CGS")); }

        return _resource;
    }

    override toString(): string {
        return JSON.stringify(this.toJson());
    }
}

export namespace CGS_Dimension$W$vector {
    export function _propertiesFromJson(_json: unknown): purify.Either<zod.ZodError, { identifier: (rdfjs.BlankNode | rdfjs.NamedNode); } & UnwrapR<ReturnType<typeof Quantity_Kind$W$Dimension$W$Vector._propertiesFromJson>>> {
        const _jsonSafeParseResult = cgsDimensionWVectorJsonZodSchema().safeParse(_json);
        if (!_jsonSafeParseResult.success) { return purify.Left(_jsonSafeParseResult.error); }

        const _jsonObject = _jsonSafeParseResult.data;
        const _super0Either = Quantity_Kind$W$Dimension$W$Vector._propertiesFromJson(_jsonObject);
        if (_super0Either.isLeft()) { return _super0Either; }

        const _super0 = _super0Either.unsafeCoerce()
        const identifier = (_jsonObject["@id"].startsWith("_:") ? dataFactory.blankNode(_jsonObject["@id"].substring(2)) : dataFactory.namedNode(_jsonObject["@id"]));
        return purify.Either.of({ ..._super0, identifier })
    }

    export function fromJson(json: unknown): purify.Either<zod.ZodError, CGS_Dimension$W$vector> {
        return (CGS_EMU$W$Dimension$W$vector.fromJson(json) as purify.Either<zod.ZodError, CGS_Dimension$W$vector>).altLazy(() => (CGS_ESU$W$Dimension$W$vector.fromJson(json) as purify.Either<zod.ZodError, CGS_Dimension$W$vector>)).altLazy(() => (CGS_GAUSS$W$Dimension$W$vector.fromJson(json) as purify.Either<zod.ZodError, CGS_Dimension$W$vector>)).altLazy(() => (CGS_LH$W$Dimension$W$vector.fromJson(json) as purify.Either<zod.ZodError, CGS_Dimension$W$vector>)).altLazy(() => CGS_Dimension$W$vector._propertiesFromJson(json).map(properties => new CGS_Dimension$W$vector(properties)));
    }

    export function _propertiesFromRdf({ ignoreRdfType: _ignoreRdfType, languageIn: _languageIn, resource: _resource,
        // @ts-ignore
        ..._context }: { [_index: string]: any; ignoreRdfType?: boolean; languageIn?: readonly string[]; resource: rdfjsResource.Resource; }): purify.Either<rdfjsResource.Resource.ValueError, { identifier: (rdfjs.BlankNode | rdfjs.NamedNode); } & UnwrapR<ReturnType<typeof Quantity_Kind$W$Dimension$W$Vector._propertiesFromRdf>>> {
        const _super0Either = Quantity_Kind$W$Dimension$W$Vector._propertiesFromRdf({ ..._context, ignoreRdfType: true, languageIn: _languageIn, resource: _resource });
        if (_super0Either.isLeft()) { return _super0Either; }

        const _super0 = _super0Either.unsafeCoerce()
        if (!_ignoreRdfType && !_resource.isInstanceOf(dataFactory.namedNode("http://qudt.org/schema/qudt/QuantityKindDimensionVector_CGS"))) { return purify.Left(new rdfjsResource.Resource.ValueError({ focusResource: _resource, message: `${rdfjsResource.Resource.Identifier.toString(_resource.identifier)} has unexpected RDF type (expected http://qudt.org/schema/qudt/QuantityKindDimensionVector_CGS)`, predicate: dataFactory.namedNode("http://qudt.org/schema/qudt/QuantityKindDimensionVector_CGS") })); }

        const identifier = _resource.identifier
        return purify.Either.of({ ..._super0, identifier })
    }

    export function fromRdf(parameters: Parameters<typeof CGS_Dimension$W$vector._propertiesFromRdf>[0]): purify.Either<rdfjsResource.Resource.ValueError, CGS_Dimension$W$vector> {
        const { ignoreRdfType: _ignoreRdfType, ...otherParameters } = parameters
        return (CGS_EMU$W$Dimension$W$vector.fromRdf(otherParameters) as purify.Either<rdfjsResource.Resource.ValueError, CGS_Dimension$W$vector>).altLazy(() => (CGS_ESU$W$Dimension$W$vector.fromRdf(otherParameters) as purify.Either<rdfjsResource.Resource.ValueError, CGS_Dimension$W$vector>)).altLazy(() => (CGS_GAUSS$W$Dimension$W$vector.fromRdf(otherParameters) as purify.Either<rdfjsResource.Resource.ValueError, CGS_Dimension$W$vector>)).altLazy(() => (CGS_LH$W$Dimension$W$vector.fromRdf(otherParameters) as purify.Either<rdfjsResource.Resource.ValueError, CGS_Dimension$W$vector>)).altLazy(() => CGS_Dimension$W$vector._propertiesFromRdf(parameters).map(properties => new CGS_Dimension$W$vector(properties)));
    }

    export let fromRdfType: rdfjs.NamedNode<string> = dataFactory.namedNode("http://qudt.org/schema/qudt/QuantityKindDimensionVector_CGS");

    export function jsonSchema() {
        return zodToJsonSchema(cgsDimensionWVectorJsonZodSchema());
    }

    export function cgsDimensionWVectorJsonUiSchema(parameters?: { scopePrefix?: string }) {
        const scopePrefix = parameters?.scopePrefix ?? "#";
        return { "elements": [ Quantity_Kind$W$Dimension$W$Vector.quantityKindWDimensionWVectorJsonUiSchema({ scopePrefix }) ], label: "CGS Dimension vector", type: "Group" }
    }

    export function cgsDimensionWVectorJsonZodSchema() {
        return Quantity_Kind$W$Dimension$W$Vector.quantityKindWDimensionWVectorJsonZodSchema().merge(zod.object({ "@id": zod.string().min(1),"type": zod.enum(["CGS_Dimension$W$vector","CGS_EMU$W$Dimension$W$vector","CGS_ESU$W$Dimension$W$vector","CGS_GAUSS$W$Dimension$W$vector","CGS_LH$W$Dimension$W$vector"]) }));
    }

    export function sparqlConstructQuery(parameters?: { ignoreRdfType?: boolean; prefixes?: { [prefix: string]: string }; subject?: sparqljs.Triple["subject"]; } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type">): sparqljs.ConstructQuery {
        const { ignoreRdfType, subject, ...queryParameters } = parameters ?? {}

        return { ...queryParameters, prefixes: parameters?.prefixes ?? {}, queryType: "CONSTRUCT", template: (queryParameters.template ?? []).concat(CGS_Dimension$W$vector.sparqlConstructTemplateTriples({ ignoreRdfType, subject })), type: "query", where: (queryParameters.where ?? []).concat(CGS_Dimension$W$vector.sparqlWherePatterns({ ignoreRdfType, subject })) };
    }

    export function sparqlConstructQueryString(parameters?: { ignoreRdfType?: boolean; subject?: sparqljs.Triple["subject"]; variablePrefix?: string; } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type"> & sparqljs.GeneratorOptions): string {
        return new sparqljs.Generator(parameters).stringify(CGS_Dimension$W$vector.sparqlConstructQuery(parameters));
    }

    export function sparqlConstructTemplateTriples(parameters?: { ignoreRdfType?: boolean; subject?: sparqljs.Triple["subject"], variablePrefix?: string }): readonly sparqljs.Triple[] {
        const subject = parameters?.subject ?? dataFactory.variable!("cgsDimensionWVector");
        const variablePrefix = parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "cgsDimensionWVector");
        return [...Quantity_Kind$W$Dimension$W$Vector.sparqlConstructTemplateTriples({ ignoreRdfType: true, subject, variablePrefix }), ...(parameters?.ignoreRdfType ? [] : [{ subject, predicate: dataFactory.namedNode("http://www.w3.org/1999/02/22-rdf-syntax-ns#type"), object: dataFactory.variable!(`${variablePrefix}RdfType`) }])];
    }

    export function sparqlWherePatterns(parameters: { ignoreRdfType?: boolean; subject?: sparqljs.Triple["subject"], variablePrefix?: string }): readonly sparqljs.Pattern[] {
        const subject = parameters?.subject ?? dataFactory.variable!("cgsDimensionWVector");
        const variablePrefix = parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "cgsDimensionWVector");
        return [...Quantity_Kind$W$Dimension$W$Vector.sparqlWherePatterns({ ignoreRdfType: true, subject, variablePrefix }), ...(parameters?.ignoreRdfType ? [] : [{ triples: [{ subject, predicate: dataFactory.namedNode("http://www.w3.org/1999/02/22-rdf-syntax-ns#type"), object: dataFactory.namedNode("http://qudt.org/schema/qudt/QuantityKindDimensionVector_CGS") }], type: "bgp" as const }, { triples: [{ subject, predicate: dataFactory.namedNode("http://www.w3.org/1999/02/22-rdf-syntax-ns#type"), object: dataFactory.variable!(`${variablePrefix}RdfType`) }], type: "bgp" as const }])];
    }
}
/**
 * CGS LH Dimension vector
 */
export class CGS_LH$W$Dimension$W$vector extends CGS_Dimension$W$vector {
    override readonly type = "CGS_LH$W$Dimension$W$vector";

    // biome-ignore lint/complexity/noUselessConstructor: Always have a constructor
    constructor(parameters: { readonly identifier?: (rdfjs.BlankNode | rdfjs.NamedNode) | string } & ConstructorParameters<typeof CGS_Dimension$W$vector>[0]) {
        super(parameters);
    }

    override get identifier(): (rdfjs.BlankNode | rdfjs.NamedNode) {
        if (typeof this._identifier === "undefined") { this._identifier = dataFactory.blankNode(); } return this._identifier;
    }

    override toRdf({ ignoreRdfType, mutateGraph, resourceSet }: { ignoreRdfType?: boolean; mutateGraph?: rdfjsResource.MutableResource.MutateGraph, resourceSet: rdfjsResource.MutableResourceSet }): rdfjsResource.MutableResource {
        const _resource = super.toRdf({ ignoreRdfType: true, mutateGraph, resourceSet });
        if (!ignoreRdfType) { _resource.add(_resource.dataFactory.namedNode("http://www.w3.org/1999/02/22-rdf-syntax-ns#type"), _resource.dataFactory.namedNode("http://qudt.org/schema/qudt/QuantityKindDimensionVector_CGS-LH")); }

        return _resource;
    }

    override toString(): string {
        return JSON.stringify(this.toJson());
    }
}

export namespace CGS_LH$W$Dimension$W$vector {
    export function _propertiesFromJson(_json: unknown): purify.Either<zod.ZodError, { identifier: (rdfjs.BlankNode | rdfjs.NamedNode); } & UnwrapR<ReturnType<typeof CGS_Dimension$W$vector._propertiesFromJson>>> {
        const _jsonSafeParseResult = cgsLhWDimensionWVectorJsonZodSchema().safeParse(_json);
        if (!_jsonSafeParseResult.success) { return purify.Left(_jsonSafeParseResult.error); }

        const _jsonObject = _jsonSafeParseResult.data;
        const _super0Either = CGS_Dimension$W$vector._propertiesFromJson(_jsonObject);
        if (_super0Either.isLeft()) { return _super0Either; }

        const _super0 = _super0Either.unsafeCoerce()
        const identifier = (_jsonObject["@id"].startsWith("_:") ? dataFactory.blankNode(_jsonObject["@id"].substring(2)) : dataFactory.namedNode(_jsonObject["@id"]));
        return purify.Either.of({ ..._super0, identifier })
    }

    export function fromJson(json: unknown): purify.Either<zod.ZodError, CGS_LH$W$Dimension$W$vector> {
        return CGS_LH$W$Dimension$W$vector._propertiesFromJson(json).map(properties => new CGS_LH$W$Dimension$W$vector(properties));
    }

    export function _propertiesFromRdf({ ignoreRdfType: _ignoreRdfType, languageIn: _languageIn, resource: _resource,
        // @ts-ignore
        ..._context }: { [_index: string]: any; ignoreRdfType?: boolean; languageIn?: readonly string[]; resource: rdfjsResource.Resource; }): purify.Either<rdfjsResource.Resource.ValueError, { identifier: (rdfjs.BlankNode | rdfjs.NamedNode); } & UnwrapR<ReturnType<typeof CGS_Dimension$W$vector._propertiesFromRdf>>> {
        const _super0Either = CGS_Dimension$W$vector._propertiesFromRdf({ ..._context, ignoreRdfType: true, languageIn: _languageIn, resource: _resource });
        if (_super0Either.isLeft()) { return _super0Either; }

        const _super0 = _super0Either.unsafeCoerce()
        if (!_ignoreRdfType && !_resource.isInstanceOf(dataFactory.namedNode("http://qudt.org/schema/qudt/QuantityKindDimensionVector_CGS-LH"))) { return purify.Left(new rdfjsResource.Resource.ValueError({ focusResource: _resource, message: `${rdfjsResource.Resource.Identifier.toString(_resource.identifier)} has unexpected RDF type (expected http://qudt.org/schema/qudt/QuantityKindDimensionVector_CGS-LH)`, predicate: dataFactory.namedNode("http://qudt.org/schema/qudt/QuantityKindDimensionVector_CGS-LH") })); }

        const identifier = _resource.identifier
        return purify.Either.of({ ..._super0, identifier })
    }

    export function fromRdf(parameters: Parameters<typeof CGS_LH$W$Dimension$W$vector._propertiesFromRdf>[0]): purify.Either<rdfjsResource.Resource.ValueError, CGS_LH$W$Dimension$W$vector> {
        return CGS_LH$W$Dimension$W$vector._propertiesFromRdf(parameters).map(properties => new CGS_LH$W$Dimension$W$vector(properties));
    }

    export let fromRdfType: rdfjs.NamedNode<string> = dataFactory.namedNode("http://qudt.org/schema/qudt/QuantityKindDimensionVector_CGS-LH");

    export function jsonSchema() {
        return zodToJsonSchema(cgsLhWDimensionWVectorJsonZodSchema());
    }

    export function cgsLhWDimensionWVectorJsonUiSchema(parameters?: { scopePrefix?: string }) {
        const scopePrefix = parameters?.scopePrefix ?? "#";
        return { "elements": [ CGS_Dimension$W$vector.cgsDimensionWVectorJsonUiSchema({ scopePrefix }) ], label: "CGS LH Dimension vector", type: "Group" }
    }

    export function cgsLhWDimensionWVectorJsonZodSchema() {
        return CGS_Dimension$W$vector.cgsDimensionWVectorJsonZodSchema().merge(zod.object({ "@id": zod.string().min(1),"type": zod.literal("CGS_LH$W$Dimension$W$vector") }));
    }

    export function sparqlConstructQuery(parameters?: { ignoreRdfType?: boolean; prefixes?: { [prefix: string]: string }; subject?: sparqljs.Triple["subject"]; } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type">): sparqljs.ConstructQuery {
        const { ignoreRdfType, subject, ...queryParameters } = parameters ?? {}

        return { ...queryParameters, prefixes: parameters?.prefixes ?? {}, queryType: "CONSTRUCT", template: (queryParameters.template ?? []).concat(CGS_LH$W$Dimension$W$vector.sparqlConstructTemplateTriples({ ignoreRdfType, subject })), type: "query", where: (queryParameters.where ?? []).concat(CGS_LH$W$Dimension$W$vector.sparqlWherePatterns({ ignoreRdfType, subject })) };
    }

    export function sparqlConstructQueryString(parameters?: { ignoreRdfType?: boolean; subject?: sparqljs.Triple["subject"]; variablePrefix?: string; } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type"> & sparqljs.GeneratorOptions): string {
        return new sparqljs.Generator(parameters).stringify(CGS_LH$W$Dimension$W$vector.sparqlConstructQuery(parameters));
    }

    export function sparqlConstructTemplateTriples(parameters?: { ignoreRdfType?: boolean; subject?: sparqljs.Triple["subject"], variablePrefix?: string }): readonly sparqljs.Triple[] {
        const subject = parameters?.subject ?? dataFactory.variable!("cgsLhWDimensionWVector");
        const variablePrefix = parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "cgsLhWDimensionWVector");
        return [...CGS_Dimension$W$vector.sparqlConstructTemplateTriples({ ignoreRdfType: true, subject, variablePrefix }), ...(parameters?.ignoreRdfType ? [] : [{ subject, predicate: dataFactory.namedNode("http://www.w3.org/1999/02/22-rdf-syntax-ns#type"), object: dataFactory.variable!(`${variablePrefix}RdfType`) }])];
    }

    export function sparqlWherePatterns(parameters: { ignoreRdfType?: boolean; subject?: sparqljs.Triple["subject"], variablePrefix?: string }): readonly sparqljs.Pattern[] {
        const subject = parameters?.subject ?? dataFactory.variable!("cgsLhWDimensionWVector");
        const variablePrefix = parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "cgsLhWDimensionWVector");
        return [...CGS_Dimension$W$vector.sparqlWherePatterns({ ignoreRdfType: true, subject, variablePrefix }), ...(parameters?.ignoreRdfType ? [] : [{ triples: [{ subject, predicate: dataFactory.namedNode("http://www.w3.org/1999/02/22-rdf-syntax-ns#type"), object: dataFactory.namedNode("http://qudt.org/schema/qudt/QuantityKindDimensionVector_CGS-LH") }], type: "bgp" as const }, { triples: [{ subject, predicate: dataFactory.namedNode("http://www.w3.org/1999/02/22-rdf-syntax-ns#type"), object: dataFactory.variable!(`${variablePrefix}RdfType`) }], type: "bgp" as const }])];
    }
}
/**
 * CGS GAUSS Dimension vector
 */
export class CGS_GAUSS$W$Dimension$W$vector extends CGS_Dimension$W$vector {
    override readonly type = "CGS_GAUSS$W$Dimension$W$vector";

    // biome-ignore lint/complexity/noUselessConstructor: Always have a constructor
    constructor(parameters: { readonly identifier?: (rdfjs.BlankNode | rdfjs.NamedNode) | string } & ConstructorParameters<typeof CGS_Dimension$W$vector>[0]) {
        super(parameters);
    }

    override get identifier(): (rdfjs.BlankNode | rdfjs.NamedNode) {
        if (typeof this._identifier === "undefined") { this._identifier = dataFactory.blankNode(); } return this._identifier;
    }

    override toRdf({ ignoreRdfType, mutateGraph, resourceSet }: { ignoreRdfType?: boolean; mutateGraph?: rdfjsResource.MutableResource.MutateGraph, resourceSet: rdfjsResource.MutableResourceSet }): rdfjsResource.MutableResource {
        const _resource = super.toRdf({ ignoreRdfType: true, mutateGraph, resourceSet });
        if (!ignoreRdfType) { _resource.add(_resource.dataFactory.namedNode("http://www.w3.org/1999/02/22-rdf-syntax-ns#type"), _resource.dataFactory.namedNode("http://qudt.org/schema/qudt/QuantityKindDimensionVector_CGS-GAUSS")); }

        return _resource;
    }

    override toString(): string {
        return JSON.stringify(this.toJson());
    }
}

export namespace CGS_GAUSS$W$Dimension$W$vector {
    export function _propertiesFromJson(_json: unknown): purify.Either<zod.ZodError, { identifier: (rdfjs.BlankNode | rdfjs.NamedNode); } & UnwrapR<ReturnType<typeof CGS_Dimension$W$vector._propertiesFromJson>>> {
        const _jsonSafeParseResult = cgsGaussWDimensionWVectorJsonZodSchema().safeParse(_json);
        if (!_jsonSafeParseResult.success) { return purify.Left(_jsonSafeParseResult.error); }

        const _jsonObject = _jsonSafeParseResult.data;
        const _super0Either = CGS_Dimension$W$vector._propertiesFromJson(_jsonObject);
        if (_super0Either.isLeft()) { return _super0Either; }

        const _super0 = _super0Either.unsafeCoerce()
        const identifier = (_jsonObject["@id"].startsWith("_:") ? dataFactory.blankNode(_jsonObject["@id"].substring(2)) : dataFactory.namedNode(_jsonObject["@id"]));
        return purify.Either.of({ ..._super0, identifier })
    }

    export function fromJson(json: unknown): purify.Either<zod.ZodError, CGS_GAUSS$W$Dimension$W$vector> {
        return CGS_GAUSS$W$Dimension$W$vector._propertiesFromJson(json).map(properties => new CGS_GAUSS$W$Dimension$W$vector(properties));
    }

    export function _propertiesFromRdf({ ignoreRdfType: _ignoreRdfType, languageIn: _languageIn, resource: _resource,
        // @ts-ignore
        ..._context }: { [_index: string]: any; ignoreRdfType?: boolean; languageIn?: readonly string[]; resource: rdfjsResource.Resource; }): purify.Either<rdfjsResource.Resource.ValueError, { identifier: (rdfjs.BlankNode | rdfjs.NamedNode); } & UnwrapR<ReturnType<typeof CGS_Dimension$W$vector._propertiesFromRdf>>> {
        const _super0Either = CGS_Dimension$W$vector._propertiesFromRdf({ ..._context, ignoreRdfType: true, languageIn: _languageIn, resource: _resource });
        if (_super0Either.isLeft()) { return _super0Either; }

        const _super0 = _super0Either.unsafeCoerce()
        if (!_ignoreRdfType && !_resource.isInstanceOf(dataFactory.namedNode("http://qudt.org/schema/qudt/QuantityKindDimensionVector_CGS-GAUSS"))) { return purify.Left(new rdfjsResource.Resource.ValueError({ focusResource: _resource, message: `${rdfjsResource.Resource.Identifier.toString(_resource.identifier)} has unexpected RDF type (expected http://qudt.org/schema/qudt/QuantityKindDimensionVector_CGS-GAUSS)`, predicate: dataFactory.namedNode("http://qudt.org/schema/qudt/QuantityKindDimensionVector_CGS-GAUSS") })); }

        const identifier = _resource.identifier
        return purify.Either.of({ ..._super0, identifier })
    }

    export function fromRdf(parameters: Parameters<typeof CGS_GAUSS$W$Dimension$W$vector._propertiesFromRdf>[0]): purify.Either<rdfjsResource.Resource.ValueError, CGS_GAUSS$W$Dimension$W$vector> {
        return CGS_GAUSS$W$Dimension$W$vector._propertiesFromRdf(parameters).map(properties => new CGS_GAUSS$W$Dimension$W$vector(properties));
    }

    export let fromRdfType: rdfjs.NamedNode<string> = dataFactory.namedNode("http://qudt.org/schema/qudt/QuantityKindDimensionVector_CGS-GAUSS");

    export function jsonSchema() {
        return zodToJsonSchema(cgsGaussWDimensionWVectorJsonZodSchema());
    }

    export function cgsGaussWDimensionWVectorJsonUiSchema(parameters?: { scopePrefix?: string }) {
        const scopePrefix = parameters?.scopePrefix ?? "#";
        return { "elements": [ CGS_Dimension$W$vector.cgsDimensionWVectorJsonUiSchema({ scopePrefix }) ], label: "CGS GAUSS Dimension vector", type: "Group" }
    }

    export function cgsGaussWDimensionWVectorJsonZodSchema() {
        return CGS_Dimension$W$vector.cgsDimensionWVectorJsonZodSchema().merge(zod.object({ "@id": zod.string().min(1),"type": zod.literal("CGS_GAUSS$W$Dimension$W$vector") }));
    }

    export function sparqlConstructQuery(parameters?: { ignoreRdfType?: boolean; prefixes?: { [prefix: string]: string }; subject?: sparqljs.Triple["subject"]; } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type">): sparqljs.ConstructQuery {
        const { ignoreRdfType, subject, ...queryParameters } = parameters ?? {}

        return { ...queryParameters, prefixes: parameters?.prefixes ?? {}, queryType: "CONSTRUCT", template: (queryParameters.template ?? []).concat(CGS_GAUSS$W$Dimension$W$vector.sparqlConstructTemplateTriples({ ignoreRdfType, subject })), type: "query", where: (queryParameters.where ?? []).concat(CGS_GAUSS$W$Dimension$W$vector.sparqlWherePatterns({ ignoreRdfType, subject })) };
    }

    export function sparqlConstructQueryString(parameters?: { ignoreRdfType?: boolean; subject?: sparqljs.Triple["subject"]; variablePrefix?: string; } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type"> & sparqljs.GeneratorOptions): string {
        return new sparqljs.Generator(parameters).stringify(CGS_GAUSS$W$Dimension$W$vector.sparqlConstructQuery(parameters));
    }

    export function sparqlConstructTemplateTriples(parameters?: { ignoreRdfType?: boolean; subject?: sparqljs.Triple["subject"], variablePrefix?: string }): readonly sparqljs.Triple[] {
        const subject = parameters?.subject ?? dataFactory.variable!("cgsGaussWDimensionWVector");
        const variablePrefix = parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "cgsGaussWDimensionWVector");
        return [...CGS_Dimension$W$vector.sparqlConstructTemplateTriples({ ignoreRdfType: true, subject, variablePrefix }), ...(parameters?.ignoreRdfType ? [] : [{ subject, predicate: dataFactory.namedNode("http://www.w3.org/1999/02/22-rdf-syntax-ns#type"), object: dataFactory.variable!(`${variablePrefix}RdfType`) }])];
    }

    export function sparqlWherePatterns(parameters: { ignoreRdfType?: boolean; subject?: sparqljs.Triple["subject"], variablePrefix?: string }): readonly sparqljs.Pattern[] {
        const subject = parameters?.subject ?? dataFactory.variable!("cgsGaussWDimensionWVector");
        const variablePrefix = parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "cgsGaussWDimensionWVector");
        return [...CGS_Dimension$W$vector.sparqlWherePatterns({ ignoreRdfType: true, subject, variablePrefix }), ...(parameters?.ignoreRdfType ? [] : [{ triples: [{ subject, predicate: dataFactory.namedNode("http://www.w3.org/1999/02/22-rdf-syntax-ns#type"), object: dataFactory.namedNode("http://qudt.org/schema/qudt/QuantityKindDimensionVector_CGS-GAUSS") }], type: "bgp" as const }, { triples: [{ subject, predicate: dataFactory.namedNode("http://www.w3.org/1999/02/22-rdf-syntax-ns#type"), object: dataFactory.variable!(`${variablePrefix}RdfType`) }], type: "bgp" as const }])];
    }
}
/**
 * CGS ESU Dimension vector
 */
export class CGS_ESU$W$Dimension$W$vector extends CGS_Dimension$W$vector {
    override readonly type = "CGS_ESU$W$Dimension$W$vector";

    // biome-ignore lint/complexity/noUselessConstructor: Always have a constructor
    constructor(parameters: { readonly identifier?: (rdfjs.BlankNode | rdfjs.NamedNode) | string } & ConstructorParameters<typeof CGS_Dimension$W$vector>[0]) {
        super(parameters);
    }

    override get identifier(): (rdfjs.BlankNode | rdfjs.NamedNode) {
        if (typeof this._identifier === "undefined") { this._identifier = dataFactory.blankNode(); } return this._identifier;
    }

    override toRdf({ ignoreRdfType, mutateGraph, resourceSet }: { ignoreRdfType?: boolean; mutateGraph?: rdfjsResource.MutableResource.MutateGraph, resourceSet: rdfjsResource.MutableResourceSet }): rdfjsResource.MutableResource {
        const _resource = super.toRdf({ ignoreRdfType: true, mutateGraph, resourceSet });
        if (!ignoreRdfType) { _resource.add(_resource.dataFactory.namedNode("http://www.w3.org/1999/02/22-rdf-syntax-ns#type"), _resource.dataFactory.namedNode("http://qudt.org/schema/qudt/QuantityKindDimensionVector_CGS-ESU")); }

        return _resource;
    }

    override toString(): string {
        return JSON.stringify(this.toJson());
    }
}

export namespace CGS_ESU$W$Dimension$W$vector {
    export function _propertiesFromJson(_json: unknown): purify.Either<zod.ZodError, { identifier: (rdfjs.BlankNode | rdfjs.NamedNode); } & UnwrapR<ReturnType<typeof CGS_Dimension$W$vector._propertiesFromJson>>> {
        const _jsonSafeParseResult = cgsEsuWDimensionWVectorJsonZodSchema().safeParse(_json);
        if (!_jsonSafeParseResult.success) { return purify.Left(_jsonSafeParseResult.error); }

        const _jsonObject = _jsonSafeParseResult.data;
        const _super0Either = CGS_Dimension$W$vector._propertiesFromJson(_jsonObject);
        if (_super0Either.isLeft()) { return _super0Either; }

        const _super0 = _super0Either.unsafeCoerce()
        const identifier = (_jsonObject["@id"].startsWith("_:") ? dataFactory.blankNode(_jsonObject["@id"].substring(2)) : dataFactory.namedNode(_jsonObject["@id"]));
        return purify.Either.of({ ..._super0, identifier })
    }

    export function fromJson(json: unknown): purify.Either<zod.ZodError, CGS_ESU$W$Dimension$W$vector> {
        return CGS_ESU$W$Dimension$W$vector._propertiesFromJson(json).map(properties => new CGS_ESU$W$Dimension$W$vector(properties));
    }

    export function _propertiesFromRdf({ ignoreRdfType: _ignoreRdfType, languageIn: _languageIn, resource: _resource,
        // @ts-ignore
        ..._context }: { [_index: string]: any; ignoreRdfType?: boolean; languageIn?: readonly string[]; resource: rdfjsResource.Resource; }): purify.Either<rdfjsResource.Resource.ValueError, { identifier: (rdfjs.BlankNode | rdfjs.NamedNode); } & UnwrapR<ReturnType<typeof CGS_Dimension$W$vector._propertiesFromRdf>>> {
        const _super0Either = CGS_Dimension$W$vector._propertiesFromRdf({ ..._context, ignoreRdfType: true, languageIn: _languageIn, resource: _resource });
        if (_super0Either.isLeft()) { return _super0Either; }

        const _super0 = _super0Either.unsafeCoerce()
        if (!_ignoreRdfType && !_resource.isInstanceOf(dataFactory.namedNode("http://qudt.org/schema/qudt/QuantityKindDimensionVector_CGS-ESU"))) { return purify.Left(new rdfjsResource.Resource.ValueError({ focusResource: _resource, message: `${rdfjsResource.Resource.Identifier.toString(_resource.identifier)} has unexpected RDF type (expected http://qudt.org/schema/qudt/QuantityKindDimensionVector_CGS-ESU)`, predicate: dataFactory.namedNode("http://qudt.org/schema/qudt/QuantityKindDimensionVector_CGS-ESU") })); }

        const identifier = _resource.identifier
        return purify.Either.of({ ..._super0, identifier })
    }

    export function fromRdf(parameters: Parameters<typeof CGS_ESU$W$Dimension$W$vector._propertiesFromRdf>[0]): purify.Either<rdfjsResource.Resource.ValueError, CGS_ESU$W$Dimension$W$vector> {
        return CGS_ESU$W$Dimension$W$vector._propertiesFromRdf(parameters).map(properties => new CGS_ESU$W$Dimension$W$vector(properties));
    }

    export let fromRdfType: rdfjs.NamedNode<string> = dataFactory.namedNode("http://qudt.org/schema/qudt/QuantityKindDimensionVector_CGS-ESU");

    export function jsonSchema() {
        return zodToJsonSchema(cgsEsuWDimensionWVectorJsonZodSchema());
    }

    export function cgsEsuWDimensionWVectorJsonUiSchema(parameters?: { scopePrefix?: string }) {
        const scopePrefix = parameters?.scopePrefix ?? "#";
        return { "elements": [ CGS_Dimension$W$vector.cgsDimensionWVectorJsonUiSchema({ scopePrefix }) ], label: "CGS ESU Dimension vector", type: "Group" }
    }

    export function cgsEsuWDimensionWVectorJsonZodSchema() {
        return CGS_Dimension$W$vector.cgsDimensionWVectorJsonZodSchema().merge(zod.object({ "@id": zod.string().min(1),"type": zod.literal("CGS_ESU$W$Dimension$W$vector") }));
    }

    export function sparqlConstructQuery(parameters?: { ignoreRdfType?: boolean; prefixes?: { [prefix: string]: string }; subject?: sparqljs.Triple["subject"]; } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type">): sparqljs.ConstructQuery {
        const { ignoreRdfType, subject, ...queryParameters } = parameters ?? {}

        return { ...queryParameters, prefixes: parameters?.prefixes ?? {}, queryType: "CONSTRUCT", template: (queryParameters.template ?? []).concat(CGS_ESU$W$Dimension$W$vector.sparqlConstructTemplateTriples({ ignoreRdfType, subject })), type: "query", where: (queryParameters.where ?? []).concat(CGS_ESU$W$Dimension$W$vector.sparqlWherePatterns({ ignoreRdfType, subject })) };
    }

    export function sparqlConstructQueryString(parameters?: { ignoreRdfType?: boolean; subject?: sparqljs.Triple["subject"]; variablePrefix?: string; } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type"> & sparqljs.GeneratorOptions): string {
        return new sparqljs.Generator(parameters).stringify(CGS_ESU$W$Dimension$W$vector.sparqlConstructQuery(parameters));
    }

    export function sparqlConstructTemplateTriples(parameters?: { ignoreRdfType?: boolean; subject?: sparqljs.Triple["subject"], variablePrefix?: string }): readonly sparqljs.Triple[] {
        const subject = parameters?.subject ?? dataFactory.variable!("cgsEsuWDimensionWVector");
        const variablePrefix = parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "cgsEsuWDimensionWVector");
        return [...CGS_Dimension$W$vector.sparqlConstructTemplateTriples({ ignoreRdfType: true, subject, variablePrefix }), ...(parameters?.ignoreRdfType ? [] : [{ subject, predicate: dataFactory.namedNode("http://www.w3.org/1999/02/22-rdf-syntax-ns#type"), object: dataFactory.variable!(`${variablePrefix}RdfType`) }])];
    }

    export function sparqlWherePatterns(parameters: { ignoreRdfType?: boolean; subject?: sparqljs.Triple["subject"], variablePrefix?: string }): readonly sparqljs.Pattern[] {
        const subject = parameters?.subject ?? dataFactory.variable!("cgsEsuWDimensionWVector");
        const variablePrefix = parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "cgsEsuWDimensionWVector");
        return [...CGS_Dimension$W$vector.sparqlWherePatterns({ ignoreRdfType: true, subject, variablePrefix }), ...(parameters?.ignoreRdfType ? [] : [{ triples: [{ subject, predicate: dataFactory.namedNode("http://www.w3.org/1999/02/22-rdf-syntax-ns#type"), object: dataFactory.namedNode("http://qudt.org/schema/qudt/QuantityKindDimensionVector_CGS-ESU") }], type: "bgp" as const }, { triples: [{ subject, predicate: dataFactory.namedNode("http://www.w3.org/1999/02/22-rdf-syntax-ns#type"), object: dataFactory.variable!(`${variablePrefix}RdfType`) }], type: "bgp" as const }])];
    }
}
/**
 * CGS EMU Dimension vector
 */
export class CGS_EMU$W$Dimension$W$vector extends CGS_Dimension$W$vector {
    override readonly type = "CGS_EMU$W$Dimension$W$vector";

    // biome-ignore lint/complexity/noUselessConstructor: Always have a constructor
    constructor(parameters: { readonly identifier?: (rdfjs.BlankNode | rdfjs.NamedNode) | string } & ConstructorParameters<typeof CGS_Dimension$W$vector>[0]) {
        super(parameters);
    }

    override get identifier(): (rdfjs.BlankNode | rdfjs.NamedNode) {
        if (typeof this._identifier === "undefined") { this._identifier = dataFactory.blankNode(); } return this._identifier;
    }

    override toRdf({ ignoreRdfType, mutateGraph, resourceSet }: { ignoreRdfType?: boolean; mutateGraph?: rdfjsResource.MutableResource.MutateGraph, resourceSet: rdfjsResource.MutableResourceSet }): rdfjsResource.MutableResource {
        const _resource = super.toRdf({ ignoreRdfType: true, mutateGraph, resourceSet });
        if (!ignoreRdfType) { _resource.add(_resource.dataFactory.namedNode("http://www.w3.org/1999/02/22-rdf-syntax-ns#type"), _resource.dataFactory.namedNode("http://qudt.org/schema/qudt/QuantityKindDimensionVector_CGS-EMU")); }

        return _resource;
    }

    override toString(): string {
        return JSON.stringify(this.toJson());
    }
}

export namespace CGS_EMU$W$Dimension$W$vector {
    export function _propertiesFromJson(_json: unknown): purify.Either<zod.ZodError, { identifier: (rdfjs.BlankNode | rdfjs.NamedNode); } & UnwrapR<ReturnType<typeof CGS_Dimension$W$vector._propertiesFromJson>>> {
        const _jsonSafeParseResult = cgsEmuWDimensionWVectorJsonZodSchema().safeParse(_json);
        if (!_jsonSafeParseResult.success) { return purify.Left(_jsonSafeParseResult.error); }

        const _jsonObject = _jsonSafeParseResult.data;
        const _super0Either = CGS_Dimension$W$vector._propertiesFromJson(_jsonObject);
        if (_super0Either.isLeft()) { return _super0Either; }

        const _super0 = _super0Either.unsafeCoerce()
        const identifier = (_jsonObject["@id"].startsWith("_:") ? dataFactory.blankNode(_jsonObject["@id"].substring(2)) : dataFactory.namedNode(_jsonObject["@id"]));
        return purify.Either.of({ ..._super0, identifier })
    }

    export function fromJson(json: unknown): purify.Either<zod.ZodError, CGS_EMU$W$Dimension$W$vector> {
        return CGS_EMU$W$Dimension$W$vector._propertiesFromJson(json).map(properties => new CGS_EMU$W$Dimension$W$vector(properties));
    }

    export function _propertiesFromRdf({ ignoreRdfType: _ignoreRdfType, languageIn: _languageIn, resource: _resource,
        // @ts-ignore
        ..._context }: { [_index: string]: any; ignoreRdfType?: boolean; languageIn?: readonly string[]; resource: rdfjsResource.Resource; }): purify.Either<rdfjsResource.Resource.ValueError, { identifier: (rdfjs.BlankNode | rdfjs.NamedNode); } & UnwrapR<ReturnType<typeof CGS_Dimension$W$vector._propertiesFromRdf>>> {
        const _super0Either = CGS_Dimension$W$vector._propertiesFromRdf({ ..._context, ignoreRdfType: true, languageIn: _languageIn, resource: _resource });
        if (_super0Either.isLeft()) { return _super0Either; }

        const _super0 = _super0Either.unsafeCoerce()
        if (!_ignoreRdfType && !_resource.isInstanceOf(dataFactory.namedNode("http://qudt.org/schema/qudt/QuantityKindDimensionVector_CGS-EMU"))) { return purify.Left(new rdfjsResource.Resource.ValueError({ focusResource: _resource, message: `${rdfjsResource.Resource.Identifier.toString(_resource.identifier)} has unexpected RDF type (expected http://qudt.org/schema/qudt/QuantityKindDimensionVector_CGS-EMU)`, predicate: dataFactory.namedNode("http://qudt.org/schema/qudt/QuantityKindDimensionVector_CGS-EMU") })); }

        const identifier = _resource.identifier
        return purify.Either.of({ ..._super0, identifier })
    }

    export function fromRdf(parameters: Parameters<typeof CGS_EMU$W$Dimension$W$vector._propertiesFromRdf>[0]): purify.Either<rdfjsResource.Resource.ValueError, CGS_EMU$W$Dimension$W$vector> {
        return CGS_EMU$W$Dimension$W$vector._propertiesFromRdf(parameters).map(properties => new CGS_EMU$W$Dimension$W$vector(properties));
    }

    export let fromRdfType: rdfjs.NamedNode<string> = dataFactory.namedNode("http://qudt.org/schema/qudt/QuantityKindDimensionVector_CGS-EMU");

    export function jsonSchema() {
        return zodToJsonSchema(cgsEmuWDimensionWVectorJsonZodSchema());
    }

    export function cgsEmuWDimensionWVectorJsonUiSchema(parameters?: { scopePrefix?: string }) {
        const scopePrefix = parameters?.scopePrefix ?? "#";
        return { "elements": [ CGS_Dimension$W$vector.cgsDimensionWVectorJsonUiSchema({ scopePrefix }) ], label: "CGS EMU Dimension vector", type: "Group" }
    }

    export function cgsEmuWDimensionWVectorJsonZodSchema() {
        return CGS_Dimension$W$vector.cgsDimensionWVectorJsonZodSchema().merge(zod.object({ "@id": zod.string().min(1),"type": zod.literal("CGS_EMU$W$Dimension$W$vector") }));
    }

    export function sparqlConstructQuery(parameters?: { ignoreRdfType?: boolean; prefixes?: { [prefix: string]: string }; subject?: sparqljs.Triple["subject"]; } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type">): sparqljs.ConstructQuery {
        const { ignoreRdfType, subject, ...queryParameters } = parameters ?? {}

        return { ...queryParameters, prefixes: parameters?.prefixes ?? {}, queryType: "CONSTRUCT", template: (queryParameters.template ?? []).concat(CGS_EMU$W$Dimension$W$vector.sparqlConstructTemplateTriples({ ignoreRdfType, subject })), type: "query", where: (queryParameters.where ?? []).concat(CGS_EMU$W$Dimension$W$vector.sparqlWherePatterns({ ignoreRdfType, subject })) };
    }

    export function sparqlConstructQueryString(parameters?: { ignoreRdfType?: boolean; subject?: sparqljs.Triple["subject"]; variablePrefix?: string; } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type"> & sparqljs.GeneratorOptions): string {
        return new sparqljs.Generator(parameters).stringify(CGS_EMU$W$Dimension$W$vector.sparqlConstructQuery(parameters));
    }

    export function sparqlConstructTemplateTriples(parameters?: { ignoreRdfType?: boolean; subject?: sparqljs.Triple["subject"], variablePrefix?: string }): readonly sparqljs.Triple[] {
        const subject = parameters?.subject ?? dataFactory.variable!("cgsEmuWDimensionWVector");
        const variablePrefix = parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "cgsEmuWDimensionWVector");
        return [...CGS_Dimension$W$vector.sparqlConstructTemplateTriples({ ignoreRdfType: true, subject, variablePrefix }), ...(parameters?.ignoreRdfType ? [] : [{ subject, predicate: dataFactory.namedNode("http://www.w3.org/1999/02/22-rdf-syntax-ns#type"), object: dataFactory.variable!(`${variablePrefix}RdfType`) }])];
    }

    export function sparqlWherePatterns(parameters: { ignoreRdfType?: boolean; subject?: sparqljs.Triple["subject"], variablePrefix?: string }): readonly sparqljs.Pattern[] {
        const subject = parameters?.subject ?? dataFactory.variable!("cgsEmuWDimensionWVector");
        const variablePrefix = parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "cgsEmuWDimensionWVector");
        return [...CGS_Dimension$W$vector.sparqlWherePatterns({ ignoreRdfType: true, subject, variablePrefix }), ...(parameters?.ignoreRdfType ? [] : [{ triples: [{ subject, predicate: dataFactory.namedNode("http://www.w3.org/1999/02/22-rdf-syntax-ns#type"), object: dataFactory.namedNode("http://qudt.org/schema/qudt/QuantityKindDimensionVector_CGS-EMU") }], type: "bgp" as const }, { triples: [{ subject, predicate: dataFactory.namedNode("http://www.w3.org/1999/02/22-rdf-syntax-ns#type"), object: dataFactory.variable!(`${variablePrefix}RdfType`) }], type: "bgp" as const }])];
    }
}
/**
 * Quantity Kind
 */
export class Quantity_Kind extends Quantity_Kind$W$$e$abstract$f$ {
    override readonly type = "Quantity_Kind";
    readonly qudt_QuantityKind$j$applicableCGSUnit: readonly (Abstract_Unit)[];
    readonly qudt_QuantityKind$j$applicableImperialUnit: readonly (Abstract_Unit)[];
    readonly qudt_QuantityKind$j$applicableISOUnit: readonly (Abstract_Unit)[];
    readonly qudt_QuantityKind$j$applicableSIUnit: readonly (Abstract_Unit)[];
    readonly qudt_QuantityKind$j$applicableUnit: readonly (Abstract_Unit)[];
    readonly qudt_QuantityKind$j$applicableUSCustomaryUnit: readonly (Abstract_Unit)[];
    readonly qudt_QuantityKind$j$baseCGSUnitDimensions: purify.Maybe<(rdfjs.BlankNode | rdfjs.NamedNode | rdfjs.Literal)>;
    readonly qudt_QuantityKind$j$baseImperialUnitDimensions: purify.Maybe<(rdfjs.BlankNode | rdfjs.NamedNode | rdfjs.Literal)>;
    readonly qudt_QuantityKind$j$baseISOUnitDimensions: purify.Maybe<(rdfjs.BlankNode | rdfjs.NamedNode | rdfjs.Literal)>;
    readonly qudt_QuantityKind$j$baseSIUnitDimensions: purify.Maybe<(rdfjs.BlankNode | rdfjs.NamedNode | rdfjs.Literal)>;
    readonly qudt_QuantityKind$j$baseUSCustomaryUnitDimensions: purify.Maybe<(rdfjs.BlankNode | rdfjs.NamedNode | rdfjs.Literal)>;
    readonly qudt_QuantityKind$j$belongsToSystemOfQuantities: readonly (System_of$W$Quantity$W$Kinds)[];
    readonly qudt_QuantityKind$j$dimensionVectorForSI: purify.Maybe<Quantity_Kind$W$Dimension$W$vector$W$$e$SI$f$>;
    readonly qudt_QuantityKind$j$expression: readonly ((rdfjs.BlankNode | rdfjs.NamedNode | rdfjs.Literal))[];
    readonly qudt_QuantityKind$j$hasDimensionVector: Quantity_Kind$W$Dimension$W$Vector;
    readonly qudt_QuantityKind$j$iec61360Code: readonly (string)[];
    readonly qudt_QuantityKind$j$latexDefinition: purify.Maybe<string>;
    readonly qudt_QuantityKind$j$mathMLdefinition: purify.Maybe<string>;
    readonly qudt_QuantityKind$j$qkdvDenominator: purify.Maybe<Quantity_Kind$W$Dimension$W$Vector>;
    readonly qudt_QuantityKind$j$qkdvNumerator: purify.Maybe<Quantity_Kind$W$Dimension$W$Vector>;
    readonly qudt_QuantityKind$j$siExactMatch: purify.Maybe<(rdfjs.BlankNode | rdfjs.NamedNode | rdfjs.Literal)>;

    constructor(parameters: { readonly identifier?: (rdfjs.BlankNode | rdfjs.NamedNode) | string, readonly qudt_QuantityKind$j$applicableCGSUnit?: readonly (Abstract_Unit)[], readonly qudt_QuantityKind$j$applicableImperialUnit?: readonly (Abstract_Unit)[], readonly qudt_QuantityKind$j$applicableISOUnit?: readonly (Abstract_Unit)[], readonly qudt_QuantityKind$j$applicableSIUnit?: readonly (Abstract_Unit)[], readonly qudt_QuantityKind$j$applicableUnit?: readonly (Abstract_Unit)[], readonly qudt_QuantityKind$j$applicableUSCustomaryUnit?: readonly (Abstract_Unit)[], readonly qudt_QuantityKind$j$baseCGSUnitDimensions?: (rdfjs.BlankNode | rdfjs.NamedNode | rdfjs.Literal) | Date | boolean | number | purify.Maybe<(rdfjs.BlankNode | rdfjs.NamedNode | rdfjs.Literal)> | string, readonly qudt_QuantityKind$j$baseImperialUnitDimensions?: (rdfjs.BlankNode | rdfjs.NamedNode | rdfjs.Literal) | Date | boolean | number | purify.Maybe<(rdfjs.BlankNode | rdfjs.NamedNode | rdfjs.Literal)> | string, readonly qudt_QuantityKind$j$baseISOUnitDimensions?: (rdfjs.BlankNode | rdfjs.NamedNode | rdfjs.Literal) | Date | boolean | number | purify.Maybe<(rdfjs.BlankNode | rdfjs.NamedNode | rdfjs.Literal)> | string, readonly qudt_QuantityKind$j$baseSIUnitDimensions?: (rdfjs.BlankNode | rdfjs.NamedNode | rdfjs.Literal) | Date | boolean | number | purify.Maybe<(rdfjs.BlankNode | rdfjs.NamedNode | rdfjs.Literal)> | string, readonly qudt_QuantityKind$j$baseUSCustomaryUnitDimensions?: (rdfjs.BlankNode | rdfjs.NamedNode | rdfjs.Literal) | Date | boolean | number | purify.Maybe<(rdfjs.BlankNode | rdfjs.NamedNode | rdfjs.Literal)> | string, readonly qudt_QuantityKind$j$belongsToSystemOfQuantities?: readonly (System_of$W$Quantity$W$Kinds)[], readonly qudt_QuantityKind$j$dimensionVectorForSI?: Quantity_Kind$W$Dimension$W$vector$W$$e$SI$f$ | purify.Maybe<Quantity_Kind$W$Dimension$W$vector$W$$e$SI$f$>, readonly qudt_QuantityKind$j$expression?: readonly ((rdfjs.BlankNode | rdfjs.NamedNode | rdfjs.Literal))[], readonly qudt_QuantityKind$j$hasDimensionVector: Quantity_Kind$W$Dimension$W$Vector, readonly qudt_QuantityKind$j$iec61360Code?: readonly (string)[], readonly qudt_QuantityKind$j$latexDefinition?: purify.Maybe<string> | string, readonly qudt_QuantityKind$j$mathMLdefinition?: purify.Maybe<string> | string, readonly qudt_QuantityKind$j$qkdvDenominator?: Quantity_Kind$W$Dimension$W$Vector | purify.Maybe<Quantity_Kind$W$Dimension$W$Vector>, readonly qudt_QuantityKind$j$qkdvNumerator?: Quantity_Kind$W$Dimension$W$Vector | purify.Maybe<Quantity_Kind$W$Dimension$W$Vector>, readonly qudt_QuantityKind$j$siExactMatch?: (rdfjs.BlankNode | rdfjs.NamedNode | rdfjs.Literal) | Date | boolean | number | purify.Maybe<(rdfjs.BlankNode | rdfjs.NamedNode | rdfjs.Literal)> | string } & ConstructorParameters<typeof Quantity_Kind$W$$e$abstract$f$>[0]) {
        super(parameters);
        if (typeof parameters.qudt_QuantityKind$j$applicableCGSUnit === "undefined") { this.qudt_QuantityKind$j$applicableCGSUnit = []; } else if (Array.isArray(parameters.qudt_QuantityKind$j$applicableCGSUnit)) { this.qudt_QuantityKind$j$applicableCGSUnit = parameters.qudt_QuantityKind$j$applicableCGSUnit; } else { this.qudt_QuantityKind$j$applicableCGSUnit =( parameters.qudt_QuantityKind$j$applicableCGSUnit) as never;
         }

        if (typeof parameters.qudt_QuantityKind$j$applicableImperialUnit === "undefined") { this.qudt_QuantityKind$j$applicableImperialUnit = []; } else if (Array.isArray(parameters.qudt_QuantityKind$j$applicableImperialUnit)) { this.qudt_QuantityKind$j$applicableImperialUnit = parameters.qudt_QuantityKind$j$applicableImperialUnit; } else { this.qudt_QuantityKind$j$applicableImperialUnit =( parameters.qudt_QuantityKind$j$applicableImperialUnit) as never;
         }

        if (typeof parameters.qudt_QuantityKind$j$applicableISOUnit === "undefined") { this.qudt_QuantityKind$j$applicableISOUnit = []; } else if (Array.isArray(parameters.qudt_QuantityKind$j$applicableISOUnit)) { this.qudt_QuantityKind$j$applicableISOUnit = parameters.qudt_QuantityKind$j$applicableISOUnit; } else { this.qudt_QuantityKind$j$applicableISOUnit =( parameters.qudt_QuantityKind$j$applicableISOUnit) as never;
         }

        if (typeof parameters.qudt_QuantityKind$j$applicableSIUnit === "undefined") { this.qudt_QuantityKind$j$applicableSIUnit = []; } else if (Array.isArray(parameters.qudt_QuantityKind$j$applicableSIUnit)) { this.qudt_QuantityKind$j$applicableSIUnit = parameters.qudt_QuantityKind$j$applicableSIUnit; } else { this.qudt_QuantityKind$j$applicableSIUnit =( parameters.qudt_QuantityKind$j$applicableSIUnit) as never;
         }

        if (typeof parameters.qudt_QuantityKind$j$applicableUnit === "undefined") { this.qudt_QuantityKind$j$applicableUnit = []; } else if (Array.isArray(parameters.qudt_QuantityKind$j$applicableUnit)) { this.qudt_QuantityKind$j$applicableUnit = parameters.qudt_QuantityKind$j$applicableUnit; } else { this.qudt_QuantityKind$j$applicableUnit =( parameters.qudt_QuantityKind$j$applicableUnit) as never;
         }

        if (typeof parameters.qudt_QuantityKind$j$applicableUSCustomaryUnit === "undefined") { this.qudt_QuantityKind$j$applicableUSCustomaryUnit = []; } else if (Array.isArray(parameters.qudt_QuantityKind$j$applicableUSCustomaryUnit)) { this.qudt_QuantityKind$j$applicableUSCustomaryUnit = parameters.qudt_QuantityKind$j$applicableUSCustomaryUnit; } else { this.qudt_QuantityKind$j$applicableUSCustomaryUnit =( parameters.qudt_QuantityKind$j$applicableUSCustomaryUnit) as never;
         }

        if (purify.Maybe.isMaybe(parameters.qudt_QuantityKind$j$baseCGSUnitDimensions)) { this.qudt_QuantityKind$j$baseCGSUnitDimensions = parameters.qudt_QuantityKind$j$baseCGSUnitDimensions; } else if (typeof parameters.qudt_QuantityKind$j$baseCGSUnitDimensions === "boolean") { this.qudt_QuantityKind$j$baseCGSUnitDimensions = purify.Maybe.of(rdfLiteral.toRdf(parameters.qudt_QuantityKind$j$baseCGSUnitDimensions, { dataFactory })); } else if (typeof parameters.qudt_QuantityKind$j$baseCGSUnitDimensions === "object" && parameters.qudt_QuantityKind$j$baseCGSUnitDimensions instanceof Date) { this.qudt_QuantityKind$j$baseCGSUnitDimensions = purify.Maybe.of(rdfLiteral.toRdf(parameters.qudt_QuantityKind$j$baseCGSUnitDimensions, { dataFactory })); } else if (typeof parameters.qudt_QuantityKind$j$baseCGSUnitDimensions === "number") { this.qudt_QuantityKind$j$baseCGSUnitDimensions = purify.Maybe.of(rdfLiteral.toRdf(parameters.qudt_QuantityKind$j$baseCGSUnitDimensions, { dataFactory })); } else if (typeof parameters.qudt_QuantityKind$j$baseCGSUnitDimensions === "string") { this.qudt_QuantityKind$j$baseCGSUnitDimensions = purify.Maybe.of(dataFactory.literal(parameters.qudt_QuantityKind$j$baseCGSUnitDimensions)); } else if (typeof parameters.qudt_QuantityKind$j$baseCGSUnitDimensions === "object") { this.qudt_QuantityKind$j$baseCGSUnitDimensions = purify.Maybe.of(parameters.qudt_QuantityKind$j$baseCGSUnitDimensions); } else if (typeof parameters.qudt_QuantityKind$j$baseCGSUnitDimensions === "undefined") { this.qudt_QuantityKind$j$baseCGSUnitDimensions = purify.Maybe.empty(); } else { this.qudt_QuantityKind$j$baseCGSUnitDimensions =( parameters.qudt_QuantityKind$j$baseCGSUnitDimensions) as never;
         }

        if (purify.Maybe.isMaybe(parameters.qudt_QuantityKind$j$baseImperialUnitDimensions)) { this.qudt_QuantityKind$j$baseImperialUnitDimensions = parameters.qudt_QuantityKind$j$baseImperialUnitDimensions; } else if (typeof parameters.qudt_QuantityKind$j$baseImperialUnitDimensions === "boolean") { this.qudt_QuantityKind$j$baseImperialUnitDimensions = purify.Maybe.of(rdfLiteral.toRdf(parameters.qudt_QuantityKind$j$baseImperialUnitDimensions, { dataFactory })); } else if (typeof parameters.qudt_QuantityKind$j$baseImperialUnitDimensions === "object" && parameters.qudt_QuantityKind$j$baseImperialUnitDimensions instanceof Date) { this.qudt_QuantityKind$j$baseImperialUnitDimensions = purify.Maybe.of(rdfLiteral.toRdf(parameters.qudt_QuantityKind$j$baseImperialUnitDimensions, { dataFactory })); } else if (typeof parameters.qudt_QuantityKind$j$baseImperialUnitDimensions === "number") { this.qudt_QuantityKind$j$baseImperialUnitDimensions = purify.Maybe.of(rdfLiteral.toRdf(parameters.qudt_QuantityKind$j$baseImperialUnitDimensions, { dataFactory })); } else if (typeof parameters.qudt_QuantityKind$j$baseImperialUnitDimensions === "string") { this.qudt_QuantityKind$j$baseImperialUnitDimensions = purify.Maybe.of(dataFactory.literal(parameters.qudt_QuantityKind$j$baseImperialUnitDimensions)); } else if (typeof parameters.qudt_QuantityKind$j$baseImperialUnitDimensions === "object") { this.qudt_QuantityKind$j$baseImperialUnitDimensions = purify.Maybe.of(parameters.qudt_QuantityKind$j$baseImperialUnitDimensions); } else if (typeof parameters.qudt_QuantityKind$j$baseImperialUnitDimensions === "undefined") { this.qudt_QuantityKind$j$baseImperialUnitDimensions = purify.Maybe.empty(); } else { this.qudt_QuantityKind$j$baseImperialUnitDimensions =( parameters.qudt_QuantityKind$j$baseImperialUnitDimensions) as never;
         }

        if (purify.Maybe.isMaybe(parameters.qudt_QuantityKind$j$baseISOUnitDimensions)) { this.qudt_QuantityKind$j$baseISOUnitDimensions = parameters.qudt_QuantityKind$j$baseISOUnitDimensions; } else if (typeof parameters.qudt_QuantityKind$j$baseISOUnitDimensions === "boolean") { this.qudt_QuantityKind$j$baseISOUnitDimensions = purify.Maybe.of(rdfLiteral.toRdf(parameters.qudt_QuantityKind$j$baseISOUnitDimensions, { dataFactory })); } else if (typeof parameters.qudt_QuantityKind$j$baseISOUnitDimensions === "object" && parameters.qudt_QuantityKind$j$baseISOUnitDimensions instanceof Date) { this.qudt_QuantityKind$j$baseISOUnitDimensions = purify.Maybe.of(rdfLiteral.toRdf(parameters.qudt_QuantityKind$j$baseISOUnitDimensions, { dataFactory })); } else if (typeof parameters.qudt_QuantityKind$j$baseISOUnitDimensions === "number") { this.qudt_QuantityKind$j$baseISOUnitDimensions = purify.Maybe.of(rdfLiteral.toRdf(parameters.qudt_QuantityKind$j$baseISOUnitDimensions, { dataFactory })); } else if (typeof parameters.qudt_QuantityKind$j$baseISOUnitDimensions === "string") { this.qudt_QuantityKind$j$baseISOUnitDimensions = purify.Maybe.of(dataFactory.literal(parameters.qudt_QuantityKind$j$baseISOUnitDimensions)); } else if (typeof parameters.qudt_QuantityKind$j$baseISOUnitDimensions === "object") { this.qudt_QuantityKind$j$baseISOUnitDimensions = purify.Maybe.of(parameters.qudt_QuantityKind$j$baseISOUnitDimensions); } else if (typeof parameters.qudt_QuantityKind$j$baseISOUnitDimensions === "undefined") { this.qudt_QuantityKind$j$baseISOUnitDimensions = purify.Maybe.empty(); } else { this.qudt_QuantityKind$j$baseISOUnitDimensions =( parameters.qudt_QuantityKind$j$baseISOUnitDimensions) as never;
         }

        if (purify.Maybe.isMaybe(parameters.qudt_QuantityKind$j$baseSIUnitDimensions)) { this.qudt_QuantityKind$j$baseSIUnitDimensions = parameters.qudt_QuantityKind$j$baseSIUnitDimensions; } else if (typeof parameters.qudt_QuantityKind$j$baseSIUnitDimensions === "boolean") { this.qudt_QuantityKind$j$baseSIUnitDimensions = purify.Maybe.of(rdfLiteral.toRdf(parameters.qudt_QuantityKind$j$baseSIUnitDimensions, { dataFactory })); } else if (typeof parameters.qudt_QuantityKind$j$baseSIUnitDimensions === "object" && parameters.qudt_QuantityKind$j$baseSIUnitDimensions instanceof Date) { this.qudt_QuantityKind$j$baseSIUnitDimensions = purify.Maybe.of(rdfLiteral.toRdf(parameters.qudt_QuantityKind$j$baseSIUnitDimensions, { dataFactory })); } else if (typeof parameters.qudt_QuantityKind$j$baseSIUnitDimensions === "number") { this.qudt_QuantityKind$j$baseSIUnitDimensions = purify.Maybe.of(rdfLiteral.toRdf(parameters.qudt_QuantityKind$j$baseSIUnitDimensions, { dataFactory })); } else if (typeof parameters.qudt_QuantityKind$j$baseSIUnitDimensions === "string") { this.qudt_QuantityKind$j$baseSIUnitDimensions = purify.Maybe.of(dataFactory.literal(parameters.qudt_QuantityKind$j$baseSIUnitDimensions)); } else if (typeof parameters.qudt_QuantityKind$j$baseSIUnitDimensions === "object") { this.qudt_QuantityKind$j$baseSIUnitDimensions = purify.Maybe.of(parameters.qudt_QuantityKind$j$baseSIUnitDimensions); } else if (typeof parameters.qudt_QuantityKind$j$baseSIUnitDimensions === "undefined") { this.qudt_QuantityKind$j$baseSIUnitDimensions = purify.Maybe.empty(); } else { this.qudt_QuantityKind$j$baseSIUnitDimensions =( parameters.qudt_QuantityKind$j$baseSIUnitDimensions) as never;
         }

        if (purify.Maybe.isMaybe(parameters.qudt_QuantityKind$j$baseUSCustomaryUnitDimensions)) { this.qudt_QuantityKind$j$baseUSCustomaryUnitDimensions = parameters.qudt_QuantityKind$j$baseUSCustomaryUnitDimensions; } else if (typeof parameters.qudt_QuantityKind$j$baseUSCustomaryUnitDimensions === "boolean") { this.qudt_QuantityKind$j$baseUSCustomaryUnitDimensions = purify.Maybe.of(rdfLiteral.toRdf(parameters.qudt_QuantityKind$j$baseUSCustomaryUnitDimensions, { dataFactory })); } else if (typeof parameters.qudt_QuantityKind$j$baseUSCustomaryUnitDimensions === "object" && parameters.qudt_QuantityKind$j$baseUSCustomaryUnitDimensions instanceof Date) { this.qudt_QuantityKind$j$baseUSCustomaryUnitDimensions = purify.Maybe.of(rdfLiteral.toRdf(parameters.qudt_QuantityKind$j$baseUSCustomaryUnitDimensions, { dataFactory })); } else if (typeof parameters.qudt_QuantityKind$j$baseUSCustomaryUnitDimensions === "number") { this.qudt_QuantityKind$j$baseUSCustomaryUnitDimensions = purify.Maybe.of(rdfLiteral.toRdf(parameters.qudt_QuantityKind$j$baseUSCustomaryUnitDimensions, { dataFactory })); } else if (typeof parameters.qudt_QuantityKind$j$baseUSCustomaryUnitDimensions === "string") { this.qudt_QuantityKind$j$baseUSCustomaryUnitDimensions = purify.Maybe.of(dataFactory.literal(parameters.qudt_QuantityKind$j$baseUSCustomaryUnitDimensions)); } else if (typeof parameters.qudt_QuantityKind$j$baseUSCustomaryUnitDimensions === "object") { this.qudt_QuantityKind$j$baseUSCustomaryUnitDimensions = purify.Maybe.of(parameters.qudt_QuantityKind$j$baseUSCustomaryUnitDimensions); } else if (typeof parameters.qudt_QuantityKind$j$baseUSCustomaryUnitDimensions === "undefined") { this.qudt_QuantityKind$j$baseUSCustomaryUnitDimensions = purify.Maybe.empty(); } else { this.qudt_QuantityKind$j$baseUSCustomaryUnitDimensions =( parameters.qudt_QuantityKind$j$baseUSCustomaryUnitDimensions) as never;
         }

        if (typeof parameters.qudt_QuantityKind$j$belongsToSystemOfQuantities === "undefined") { this.qudt_QuantityKind$j$belongsToSystemOfQuantities = []; } else if (Array.isArray(parameters.qudt_QuantityKind$j$belongsToSystemOfQuantities)) { this.qudt_QuantityKind$j$belongsToSystemOfQuantities = parameters.qudt_QuantityKind$j$belongsToSystemOfQuantities; } else { this.qudt_QuantityKind$j$belongsToSystemOfQuantities =( parameters.qudt_QuantityKind$j$belongsToSystemOfQuantities) as never;
         }

        if (purify.Maybe.isMaybe(parameters.qudt_QuantityKind$j$dimensionVectorForSI)) { this.qudt_QuantityKind$j$dimensionVectorForSI = parameters.qudt_QuantityKind$j$dimensionVectorForSI; } else if (typeof parameters.qudt_QuantityKind$j$dimensionVectorForSI === "object" && parameters.qudt_QuantityKind$j$dimensionVectorForSI instanceof Quantity_Kind$W$Dimension$W$vector$W$$e$SI$f$) { this.qudt_QuantityKind$j$dimensionVectorForSI = purify.Maybe.of(parameters.qudt_QuantityKind$j$dimensionVectorForSI); } else if (typeof parameters.qudt_QuantityKind$j$dimensionVectorForSI === "undefined") { this.qudt_QuantityKind$j$dimensionVectorForSI = purify.Maybe.empty(); } else { this.qudt_QuantityKind$j$dimensionVectorForSI =( parameters.qudt_QuantityKind$j$dimensionVectorForSI) as never;
         }

        if (typeof parameters.qudt_QuantityKind$j$expression === "undefined") { this.qudt_QuantityKind$j$expression = []; } else if (Array.isArray(parameters.qudt_QuantityKind$j$expression)) { this.qudt_QuantityKind$j$expression = parameters.qudt_QuantityKind$j$expression; } else { this.qudt_QuantityKind$j$expression =( parameters.qudt_QuantityKind$j$expression) as never;
         }

        this.qudt_QuantityKind$j$hasDimensionVector = parameters.qudt_QuantityKind$j$hasDimensionVector;
        if (typeof parameters.qudt_QuantityKind$j$iec61360Code === "undefined") { this.qudt_QuantityKind$j$iec61360Code = []; } else if (Array.isArray(parameters.qudt_QuantityKind$j$iec61360Code)) { this.qudt_QuantityKind$j$iec61360Code = parameters.qudt_QuantityKind$j$iec61360Code; } else { this.qudt_QuantityKind$j$iec61360Code =( parameters.qudt_QuantityKind$j$iec61360Code) as never;
         }

        if (purify.Maybe.isMaybe(parameters.qudt_QuantityKind$j$latexDefinition)) { this.qudt_QuantityKind$j$latexDefinition = parameters.qudt_QuantityKind$j$latexDefinition; } else if (typeof parameters.qudt_QuantityKind$j$latexDefinition === "string") { this.qudt_QuantityKind$j$latexDefinition = purify.Maybe.of(parameters.qudt_QuantityKind$j$latexDefinition); } else if (typeof parameters.qudt_QuantityKind$j$latexDefinition === "undefined") { this.qudt_QuantityKind$j$latexDefinition = purify.Maybe.empty(); } else { this.qudt_QuantityKind$j$latexDefinition =( parameters.qudt_QuantityKind$j$latexDefinition) as never;
         }

        if (purify.Maybe.isMaybe(parameters.qudt_QuantityKind$j$mathMLdefinition)) { this.qudt_QuantityKind$j$mathMLdefinition = parameters.qudt_QuantityKind$j$mathMLdefinition; } else if (typeof parameters.qudt_QuantityKind$j$mathMLdefinition === "string") { this.qudt_QuantityKind$j$mathMLdefinition = purify.Maybe.of(parameters.qudt_QuantityKind$j$mathMLdefinition); } else if (typeof parameters.qudt_QuantityKind$j$mathMLdefinition === "undefined") { this.qudt_QuantityKind$j$mathMLdefinition = purify.Maybe.empty(); } else { this.qudt_QuantityKind$j$mathMLdefinition =( parameters.qudt_QuantityKind$j$mathMLdefinition) as never;
         }

        if (purify.Maybe.isMaybe(parameters.qudt_QuantityKind$j$qkdvDenominator)) { this.qudt_QuantityKind$j$qkdvDenominator = parameters.qudt_QuantityKind$j$qkdvDenominator; } else if (typeof parameters.qudt_QuantityKind$j$qkdvDenominator === "object" && parameters.qudt_QuantityKind$j$qkdvDenominator instanceof Quantity_Kind$W$Dimension$W$Vector) { this.qudt_QuantityKind$j$qkdvDenominator = purify.Maybe.of(parameters.qudt_QuantityKind$j$qkdvDenominator); } else if (typeof parameters.qudt_QuantityKind$j$qkdvDenominator === "undefined") { this.qudt_QuantityKind$j$qkdvDenominator = purify.Maybe.empty(); } else { this.qudt_QuantityKind$j$qkdvDenominator =( parameters.qudt_QuantityKind$j$qkdvDenominator) as never;
         }

        if (purify.Maybe.isMaybe(parameters.qudt_QuantityKind$j$qkdvNumerator)) { this.qudt_QuantityKind$j$qkdvNumerator = parameters.qudt_QuantityKind$j$qkdvNumerator; } else if (typeof parameters.qudt_QuantityKind$j$qkdvNumerator === "object" && parameters.qudt_QuantityKind$j$qkdvNumerator instanceof Quantity_Kind$W$Dimension$W$Vector) { this.qudt_QuantityKind$j$qkdvNumerator = purify.Maybe.of(parameters.qudt_QuantityKind$j$qkdvNumerator); } else if (typeof parameters.qudt_QuantityKind$j$qkdvNumerator === "undefined") { this.qudt_QuantityKind$j$qkdvNumerator = purify.Maybe.empty(); } else { this.qudt_QuantityKind$j$qkdvNumerator =( parameters.qudt_QuantityKind$j$qkdvNumerator) as never;
         }

        if (purify.Maybe.isMaybe(parameters.qudt_QuantityKind$j$siExactMatch)) { this.qudt_QuantityKind$j$siExactMatch = parameters.qudt_QuantityKind$j$siExactMatch; } else if (typeof parameters.qudt_QuantityKind$j$siExactMatch === "boolean") { this.qudt_QuantityKind$j$siExactMatch = purify.Maybe.of(rdfLiteral.toRdf(parameters.qudt_QuantityKind$j$siExactMatch, { dataFactory })); } else if (typeof parameters.qudt_QuantityKind$j$siExactMatch === "object" && parameters.qudt_QuantityKind$j$siExactMatch instanceof Date) { this.qudt_QuantityKind$j$siExactMatch = purify.Maybe.of(rdfLiteral.toRdf(parameters.qudt_QuantityKind$j$siExactMatch, { dataFactory })); } else if (typeof parameters.qudt_QuantityKind$j$siExactMatch === "number") { this.qudt_QuantityKind$j$siExactMatch = purify.Maybe.of(rdfLiteral.toRdf(parameters.qudt_QuantityKind$j$siExactMatch, { dataFactory })); } else if (typeof parameters.qudt_QuantityKind$j$siExactMatch === "string") { this.qudt_QuantityKind$j$siExactMatch = purify.Maybe.of(dataFactory.literal(parameters.qudt_QuantityKind$j$siExactMatch)); } else if (typeof parameters.qudt_QuantityKind$j$siExactMatch === "object") { this.qudt_QuantityKind$j$siExactMatch = purify.Maybe.of(parameters.qudt_QuantityKind$j$siExactMatch); } else if (typeof parameters.qudt_QuantityKind$j$siExactMatch === "undefined") { this.qudt_QuantityKind$j$siExactMatch = purify.Maybe.empty(); } else { this.qudt_QuantityKind$j$siExactMatch =( parameters.qudt_QuantityKind$j$siExactMatch) as never;
         }
    }

    override get identifier(): (rdfjs.BlankNode | rdfjs.NamedNode) {
        if (typeof this._identifier === "undefined") { this._identifier = dataFactory.blankNode(); } return this._identifier;
    }

    override equals(other: Quantity_Kind): EqualsResult {
        return super.equals(other).chain(() => (((left, right) => arrayEquals(left, right, ((left, right) => left.equals(right)))))(this.qudt_QuantityKind$j$applicableCGSUnit, other.qudt_QuantityKind$j$applicableCGSUnit).mapLeft(propertyValuesUnequal => ({ left: this, right: other, propertyName: "qudt_QuantityKind$j$applicableCGSUnit", propertyValuesUnequal, type: "Property" as const }))).chain(() => (((left, right) => arrayEquals(left, right, ((left, right) => left.equals(right)))))(this.qudt_QuantityKind$j$applicableImperialUnit, other.qudt_QuantityKind$j$applicableImperialUnit).mapLeft(propertyValuesUnequal => ({ left: this, right: other, propertyName: "qudt_QuantityKind$j$applicableImperialUnit", propertyValuesUnequal, type: "Property" as const }))).chain(() => (((left, right) => arrayEquals(left, right, ((left, right) => left.equals(right)))))(this.qudt_QuantityKind$j$applicableISOUnit, other.qudt_QuantityKind$j$applicableISOUnit).mapLeft(propertyValuesUnequal => ({ left: this, right: other, propertyName: "qudt_QuantityKind$j$applicableISOUnit", propertyValuesUnequal, type: "Property" as const }))).chain(() => (((left, right) => arrayEquals(left, right, ((left, right) => left.equals(right)))))(this.qudt_QuantityKind$j$applicableSIUnit, other.qudt_QuantityKind$j$applicableSIUnit).mapLeft(propertyValuesUnequal => ({ left: this, right: other, propertyName: "qudt_QuantityKind$j$applicableSIUnit", propertyValuesUnequal, type: "Property" as const }))).chain(() => (((left, right) => arrayEquals(left, right, ((left, right) => left.equals(right)))))(this.qudt_QuantityKind$j$applicableUnit, other.qudt_QuantityKind$j$applicableUnit).mapLeft(propertyValuesUnequal => ({ left: this, right: other, propertyName: "qudt_QuantityKind$j$applicableUnit", propertyValuesUnequal, type: "Property" as const }))).chain(() => (((left, right) => arrayEquals(left, right, ((left, right) => left.equals(right)))))(this.qudt_QuantityKind$j$applicableUSCustomaryUnit, other.qudt_QuantityKind$j$applicableUSCustomaryUnit).mapLeft(propertyValuesUnequal => ({ left: this, right: other, propertyName: "qudt_QuantityKind$j$applicableUSCustomaryUnit", propertyValuesUnequal, type: "Property" as const }))).chain(() => (((left, right) => maybeEquals(left, right, booleanEquals)))(this.qudt_QuantityKind$j$baseCGSUnitDimensions, other.qudt_QuantityKind$j$baseCGSUnitDimensions).mapLeft(propertyValuesUnequal => ({ left: this, right: other, propertyName: "qudt_QuantityKind$j$baseCGSUnitDimensions", propertyValuesUnequal, type: "Property" as const }))).chain(() => (((left, right) => maybeEquals(left, right, booleanEquals)))(this.qudt_QuantityKind$j$baseImperialUnitDimensions, other.qudt_QuantityKind$j$baseImperialUnitDimensions).mapLeft(propertyValuesUnequal => ({ left: this, right: other, propertyName: "qudt_QuantityKind$j$baseImperialUnitDimensions", propertyValuesUnequal, type: "Property" as const }))).chain(() => (((left, right) => maybeEquals(left, right, booleanEquals)))(this.qudt_QuantityKind$j$baseISOUnitDimensions, other.qudt_QuantityKind$j$baseISOUnitDimensions).mapLeft(propertyValuesUnequal => ({ left: this, right: other, propertyName: "qudt_QuantityKind$j$baseISOUnitDimensions", propertyValuesUnequal, type: "Property" as const }))).chain(() => (((left, right) => maybeEquals(left, right, booleanEquals)))(this.qudt_QuantityKind$j$baseSIUnitDimensions, other.qudt_QuantityKind$j$baseSIUnitDimensions).mapLeft(propertyValuesUnequal => ({ left: this, right: other, propertyName: "qudt_QuantityKind$j$baseSIUnitDimensions", propertyValuesUnequal, type: "Property" as const }))).chain(() => (((left, right) => maybeEquals(left, right, booleanEquals)))(this.qudt_QuantityKind$j$baseUSCustomaryUnitDimensions, other.qudt_QuantityKind$j$baseUSCustomaryUnitDimensions).mapLeft(propertyValuesUnequal => ({ left: this, right: other, propertyName: "qudt_QuantityKind$j$baseUSCustomaryUnitDimensions", propertyValuesUnequal, type: "Property" as const }))).chain(() => (((left, right) => arrayEquals(left, right, ((left, right) => left.equals(right)))))(this.qudt_QuantityKind$j$belongsToSystemOfQuantities, other.qudt_QuantityKind$j$belongsToSystemOfQuantities).mapLeft(propertyValuesUnequal => ({ left: this, right: other, propertyName: "qudt_QuantityKind$j$belongsToSystemOfQuantities", propertyValuesUnequal, type: "Property" as const }))).chain(() => (((left, right) => maybeEquals(left, right, ((left, right) => left.equals(right)))))(this.qudt_QuantityKind$j$dimensionVectorForSI, other.qudt_QuantityKind$j$dimensionVectorForSI).mapLeft(propertyValuesUnequal => ({ left: this, right: other, propertyName: "qudt_QuantityKind$j$dimensionVectorForSI", propertyValuesUnequal, type: "Property" as const }))).chain(() => (((left, right) => arrayEquals(left, right, booleanEquals)))(this.qudt_QuantityKind$j$expression, other.qudt_QuantityKind$j$expression).mapLeft(propertyValuesUnequal => ({ left: this, right: other, propertyName: "qudt_QuantityKind$j$expression", propertyValuesUnequal, type: "Property" as const }))).chain(() => (((left, right) => left.equals(right)))(this.qudt_QuantityKind$j$hasDimensionVector, other.qudt_QuantityKind$j$hasDimensionVector).mapLeft(propertyValuesUnequal => ({ left: this, right: other, propertyName: "qudt_QuantityKind$j$hasDimensionVector", propertyValuesUnequal, type: "Property" as const }))).chain(() => (((left, right) => arrayEquals(left, right, strictEquals)))(this.qudt_QuantityKind$j$iec61360Code, other.qudt_QuantityKind$j$iec61360Code).mapLeft(propertyValuesUnequal => ({ left: this, right: other, propertyName: "qudt_QuantityKind$j$iec61360Code", propertyValuesUnequal, type: "Property" as const }))).chain(() => (((left, right) => maybeEquals(left, right, strictEquals)))(this.qudt_QuantityKind$j$latexDefinition, other.qudt_QuantityKind$j$latexDefinition).mapLeft(propertyValuesUnequal => ({ left: this, right: other, propertyName: "qudt_QuantityKind$j$latexDefinition", propertyValuesUnequal, type: "Property" as const }))).chain(() => (((left, right) => maybeEquals(left, right, strictEquals)))(this.qudt_QuantityKind$j$mathMLdefinition, other.qudt_QuantityKind$j$mathMLdefinition).mapLeft(propertyValuesUnequal => ({ left: this, right: other, propertyName: "qudt_QuantityKind$j$mathMLdefinition", propertyValuesUnequal, type: "Property" as const }))).chain(() => (((left, right) => maybeEquals(left, right, ((left, right) => left.equals(right)))))(this.qudt_QuantityKind$j$qkdvDenominator, other.qudt_QuantityKind$j$qkdvDenominator).mapLeft(propertyValuesUnequal => ({ left: this, right: other, propertyName: "qudt_QuantityKind$j$qkdvDenominator", propertyValuesUnequal, type: "Property" as const }))).chain(() => (((left, right) => maybeEquals(left, right, ((left, right) => left.equals(right)))))(this.qudt_QuantityKind$j$qkdvNumerator, other.qudt_QuantityKind$j$qkdvNumerator).mapLeft(propertyValuesUnequal => ({ left: this, right: other, propertyName: "qudt_QuantityKind$j$qkdvNumerator", propertyValuesUnequal, type: "Property" as const }))).chain(() => (((left, right) => maybeEquals(left, right, booleanEquals)))(this.qudt_QuantityKind$j$siExactMatch, other.qudt_QuantityKind$j$siExactMatch).mapLeft(propertyValuesUnequal => ({ left: this, right: other, propertyName: "qudt_QuantityKind$j$siExactMatch", propertyValuesUnequal, type: "Property" as const })));
    }

    override hash<HasherT extends { update: (message: string | number[] | ArrayBuffer | Uint8Array) => void; }>(_hasher: HasherT): HasherT {
        this.hashShaclProperties(_hasher);
        return _hasher;
    }

    protected override hashShaclProperties<HasherT extends { update: (message: string | number[] | ArrayBuffer | Uint8Array) => void; }>(_hasher: HasherT): HasherT {
        super.hashShaclProperties(_hasher);
        for (const _item0 of this.qudt_QuantityKind$j$applicableCGSUnit) { _item0.hash(_hasher); }

        for (const _item0 of this.qudt_QuantityKind$j$applicableImperialUnit) { _item0.hash(_hasher); }

        for (const _item0 of this.qudt_QuantityKind$j$applicableISOUnit) { _item0.hash(_hasher); }

        for (const _item0 of this.qudt_QuantityKind$j$applicableSIUnit) { _item0.hash(_hasher); }

        for (const _item0 of this.qudt_QuantityKind$j$applicableUnit) { _item0.hash(_hasher); }

        for (const _item0 of this.qudt_QuantityKind$j$applicableUSCustomaryUnit) { _item0.hash(_hasher); }

        this.qudt_QuantityKind$j$baseCGSUnitDimensions.ifJust((_value0) => { _hasher.update(_value0.termType);
        _hasher.update(_value0.value); })
        this.qudt_QuantityKind$j$baseImperialUnitDimensions.ifJust((_value0) => { _hasher.update(_value0.termType);
        _hasher.update(_value0.value); })
        this.qudt_QuantityKind$j$baseISOUnitDimensions.ifJust((_value0) => { _hasher.update(_value0.termType);
        _hasher.update(_value0.value); })
        this.qudt_QuantityKind$j$baseSIUnitDimensions.ifJust((_value0) => { _hasher.update(_value0.termType);
        _hasher.update(_value0.value); })
        this.qudt_QuantityKind$j$baseUSCustomaryUnitDimensions.ifJust((_value0) => { _hasher.update(_value0.termType);
        _hasher.update(_value0.value); })
        for (const _item0 of this.qudt_QuantityKind$j$belongsToSystemOfQuantities) { _item0.hash(_hasher); }

        this.qudt_QuantityKind$j$dimensionVectorForSI.ifJust((_value0) => { _value0.hash(_hasher); })
        for (const _item0 of this.qudt_QuantityKind$j$expression) { _hasher.update(_item0.termType);
        _hasher.update(_item0.value); }

        this.qudt_QuantityKind$j$hasDimensionVector.hash(_hasher);
        for (const _item0 of this.qudt_QuantityKind$j$iec61360Code) { _hasher.update(_item0); }

        this.qudt_QuantityKind$j$latexDefinition.ifJust((_value0) => { _hasher.update(_value0); })
        this.qudt_QuantityKind$j$mathMLdefinition.ifJust((_value0) => { _hasher.update(_value0); })
        this.qudt_QuantityKind$j$qkdvDenominator.ifJust((_value0) => { _value0.hash(_hasher); })
        this.qudt_QuantityKind$j$qkdvNumerator.ifJust((_value0) => { _value0.hash(_hasher); })
        this.qudt_QuantityKind$j$siExactMatch.ifJust((_value0) => { _hasher.update(_value0.termType);
        _hasher.update(_value0.value); })
        return _hasher;
    }

    override toJson(): { readonly "qudt_QuantityKind$j$applicableCGSUnit": readonly (ReturnType<Abstract_Unit["toJson"]>)[]; readonly "qudt_QuantityKind$j$applicableImperialUnit": readonly (ReturnType<Abstract_Unit["toJson"]>)[]; readonly "qudt_QuantityKind$j$applicableISOUnit": readonly (ReturnType<Abstract_Unit["toJson"]>)[]; readonly "qudt_QuantityKind$j$applicableSIUnit": readonly (ReturnType<Abstract_Unit["toJson"]>)[]; readonly "qudt_QuantityKind$j$applicableUnit": readonly (ReturnType<Abstract_Unit["toJson"]>)[]; readonly "qudt_QuantityKind$j$applicableUSCustomaryUnit": readonly (ReturnType<Abstract_Unit["toJson"]>)[]; readonly "qudt_QuantityKind$j$baseCGSUnitDimensions": ({ readonly "@id": string, readonly termType: "BlankNode" | "NamedNode" } | { readonly "@language": string | undefined, readonly "@type": string | undefined, readonly "@value": string, readonly termType: "Literal" }) | undefined; readonly "qudt_QuantityKind$j$baseImperialUnitDimensions": ({ readonly "@id": string, readonly termType: "BlankNode" | "NamedNode" } | { readonly "@language": string | undefined, readonly "@type": string | undefined, readonly "@value": string, readonly termType: "Literal" }) | undefined; readonly "qudt_QuantityKind$j$baseISOUnitDimensions": ({ readonly "@id": string, readonly termType: "BlankNode" | "NamedNode" } | { readonly "@language": string | undefined, readonly "@type": string | undefined, readonly "@value": string, readonly termType: "Literal" }) | undefined; readonly "qudt_QuantityKind$j$baseSIUnitDimensions": ({ readonly "@id": string, readonly termType: "BlankNode" | "NamedNode" } | { readonly "@language": string | undefined, readonly "@type": string | undefined, readonly "@value": string, readonly termType: "Literal" }) | undefined; readonly "qudt_QuantityKind$j$baseUSCustomaryUnitDimensions": ({ readonly "@id": string, readonly termType: "BlankNode" | "NamedNode" } | { readonly "@language": string | undefined, readonly "@type": string | undefined, readonly "@value": string, readonly termType: "Literal" }) | undefined; readonly "qudt_QuantityKind$j$belongsToSystemOfQuantities": readonly (ReturnType<System_of$W$Quantity$W$Kinds["toJson"]>)[]; readonly "qudt_QuantityKind$j$dimensionVectorForSI": (ReturnType<Quantity_Kind$W$Dimension$W$vector$W$$e$SI$f$["toJson"]>) | undefined; readonly "qudt_QuantityKind$j$expression": readonly ({ readonly "@id": string, readonly termType: "BlankNode" | "NamedNode" } | { readonly "@language": string | undefined, readonly "@type": string | undefined, readonly "@value": string, readonly termType: "Literal" })[]; readonly "qudt_QuantityKind$j$hasDimensionVector": ReturnType<Quantity_Kind$W$Dimension$W$Vector["toJson"]>; readonly "qudt_QuantityKind$j$iec61360Code": readonly (string)[]; readonly "qudt_QuantityKind$j$latexDefinition": (string) | undefined; readonly "qudt_QuantityKind$j$mathMLdefinition": (string) | undefined; readonly "qudt_QuantityKind$j$qkdvDenominator": (ReturnType<Quantity_Kind$W$Dimension$W$Vector["toJson"]>) | undefined; readonly "qudt_QuantityKind$j$qkdvNumerator": (ReturnType<Quantity_Kind$W$Dimension$W$Vector["toJson"]>) | undefined; readonly "qudt_QuantityKind$j$siExactMatch": ({ readonly "@id": string, readonly termType: "BlankNode" | "NamedNode" } | { readonly "@language": string | undefined, readonly "@type": string | undefined, readonly "@value": string, readonly termType: "Literal" }) | undefined } & ReturnType<Quantity_Kind$W$$e$abstract$f$["toJson"]> {
        return JSON.parse(JSON.stringify({ ...super.toJson(),qudt_QuantityKind$j$applicableCGSUnit: this.qudt_QuantityKind$j$applicableCGSUnit.map(_item => (_item.toJson())),qudt_QuantityKind$j$applicableImperialUnit: this.qudt_QuantityKind$j$applicableImperialUnit.map(_item => (_item.toJson())),qudt_QuantityKind$j$applicableISOUnit: this.qudt_QuantityKind$j$applicableISOUnit.map(_item => (_item.toJson())),qudt_QuantityKind$j$applicableSIUnit: this.qudt_QuantityKind$j$applicableSIUnit.map(_item => (_item.toJson())),qudt_QuantityKind$j$applicableUnit: this.qudt_QuantityKind$j$applicableUnit.map(_item => (_item.toJson())),qudt_QuantityKind$j$applicableUSCustomaryUnit: this.qudt_QuantityKind$j$applicableUSCustomaryUnit.map(_item => (_item.toJson())),qudt_QuantityKind$j$baseCGSUnitDimensions: this.qudt_QuantityKind$j$baseCGSUnitDimensions.map(_item => ((_item.termType === "Literal") ? { "@language": _item.language.length > 0 ? _item.language : undefined, "@type": _item.datatype.value !== "http://www.w3.org/2001/XMLSchema#string" ? _item.datatype.value : undefined, "@value": _item.value, termType: "Literal" as const } : (_item.termType === "NamedNode") ? { "@id": _item.value, termType: "NamedNode" as const } : { "@id": `_:${_item.value}`, termType: "BlankNode" as const })).extract(),qudt_QuantityKind$j$baseImperialUnitDimensions: this.qudt_QuantityKind$j$baseImperialUnitDimensions.map(_item => ((_item.termType === "Literal") ? { "@language": _item.language.length > 0 ? _item.language : undefined, "@type": _item.datatype.value !== "http://www.w3.org/2001/XMLSchema#string" ? _item.datatype.value : undefined, "@value": _item.value, termType: "Literal" as const } : (_item.termType === "NamedNode") ? { "@id": _item.value, termType: "NamedNode" as const } : { "@id": `_:${_item.value}`, termType: "BlankNode" as const })).extract(),qudt_QuantityKind$j$baseISOUnitDimensions: this.qudt_QuantityKind$j$baseISOUnitDimensions.map(_item => ((_item.termType === "Literal") ? { "@language": _item.language.length > 0 ? _item.language : undefined, "@type": _item.datatype.value !== "http://www.w3.org/2001/XMLSchema#string" ? _item.datatype.value : undefined, "@value": _item.value, termType: "Literal" as const } : (_item.termType === "NamedNode") ? { "@id": _item.value, termType: "NamedNode" as const } : { "@id": `_:${_item.value}`, termType: "BlankNode" as const })).extract(),qudt_QuantityKind$j$baseSIUnitDimensions: this.qudt_QuantityKind$j$baseSIUnitDimensions.map(_item => ((_item.termType === "Literal") ? { "@language": _item.language.length > 0 ? _item.language : undefined, "@type": _item.datatype.value !== "http://www.w3.org/2001/XMLSchema#string" ? _item.datatype.value : undefined, "@value": _item.value, termType: "Literal" as const } : (_item.termType === "NamedNode") ? { "@id": _item.value, termType: "NamedNode" as const } : { "@id": `_:${_item.value}`, termType: "BlankNode" as const })).extract(),qudt_QuantityKind$j$baseUSCustomaryUnitDimensions: this.qudt_QuantityKind$j$baseUSCustomaryUnitDimensions.map(_item => ((_item.termType === "Literal") ? { "@language": _item.language.length > 0 ? _item.language : undefined, "@type": _item.datatype.value !== "http://www.w3.org/2001/XMLSchema#string" ? _item.datatype.value : undefined, "@value": _item.value, termType: "Literal" as const } : (_item.termType === "NamedNode") ? { "@id": _item.value, termType: "NamedNode" as const } : { "@id": `_:${_item.value}`, termType: "BlankNode" as const })).extract(),qudt_QuantityKind$j$belongsToSystemOfQuantities: this.qudt_QuantityKind$j$belongsToSystemOfQuantities.map(_item => (_item.toJson())),qudt_QuantityKind$j$dimensionVectorForSI: this.qudt_QuantityKind$j$dimensionVectorForSI.map(_item => (_item.toJson())).extract(),qudt_QuantityKind$j$expression: this.qudt_QuantityKind$j$expression.map(_item => ((_item.termType === "Literal") ? { "@language": _item.language.length > 0 ? _item.language : undefined, "@type": _item.datatype.value !== "http://www.w3.org/2001/XMLSchema#string" ? _item.datatype.value : undefined, "@value": _item.value, termType: "Literal" as const } : (_item.termType === "NamedNode") ? { "@id": _item.value, termType: "NamedNode" as const } : { "@id": `_:${_item.value}`, termType: "BlankNode" as const })),qudt_QuantityKind$j$hasDimensionVector: this.qudt_QuantityKind$j$hasDimensionVector.toJson(),qudt_QuantityKind$j$iec61360Code: this.qudt_QuantityKind$j$iec61360Code.map(_item => (_item)),qudt_QuantityKind$j$latexDefinition: this.qudt_QuantityKind$j$latexDefinition.map(_item => (_item)).extract(),qudt_QuantityKind$j$mathMLdefinition: this.qudt_QuantityKind$j$mathMLdefinition.map(_item => (_item)).extract(),qudt_QuantityKind$j$qkdvDenominator: this.qudt_QuantityKind$j$qkdvDenominator.map(_item => (_item.toJson())).extract(),qudt_QuantityKind$j$qkdvNumerator: this.qudt_QuantityKind$j$qkdvNumerator.map(_item => (_item.toJson())).extract(),qudt_QuantityKind$j$siExactMatch: this.qudt_QuantityKind$j$siExactMatch.map(_item => ((_item.termType === "Literal") ? { "@language": _item.language.length > 0 ? _item.language : undefined, "@type": _item.datatype.value !== "http://www.w3.org/2001/XMLSchema#string" ? _item.datatype.value : undefined, "@value": _item.value, termType: "Literal" as const } : (_item.termType === "NamedNode") ? { "@id": _item.value, termType: "NamedNode" as const } : { "@id": `_:${_item.value}`, termType: "BlankNode" as const })).extract() } satisfies ReturnType<Quantity_Kind["toJson"]>));
    }

    override toRdf({ ignoreRdfType, mutateGraph, resourceSet }: { ignoreRdfType?: boolean; mutateGraph?: rdfjsResource.MutableResource.MutateGraph, resourceSet: rdfjsResource.MutableResourceSet }): rdfjsResource.MutableResource {
        const _resource = super.toRdf({ ignoreRdfType: true, mutateGraph, resourceSet });
        if (!ignoreRdfType) { _resource.add(_resource.dataFactory.namedNode("http://www.w3.org/1999/02/22-rdf-syntax-ns#type"), _resource.dataFactory.namedNode("http://qudt.org/schema/qudt/QuantityKind")); }

        _resource.add(dataFactory.namedNode("http://qudt.org/schema/qudt/applicableCGSUnit"), this.qudt_QuantityKind$j$applicableCGSUnit.map((_item) => _item.toRdf({ mutateGraph: mutateGraph, resourceSet: resourceSet })));
        _resource.add(dataFactory.namedNode("http://qudt.org/schema/qudt/applicableImperialUnit"), this.qudt_QuantityKind$j$applicableImperialUnit.map((_item) => _item.toRdf({ mutateGraph: mutateGraph, resourceSet: resourceSet })));
        _resource.add(dataFactory.namedNode("http://qudt.org/schema/qudt/applicableISOUnit"), this.qudt_QuantityKind$j$applicableISOUnit.map((_item) => _item.toRdf({ mutateGraph: mutateGraph, resourceSet: resourceSet })));
        _resource.add(dataFactory.namedNode("http://qudt.org/schema/qudt/applicableSIUnit"), this.qudt_QuantityKind$j$applicableSIUnit.map((_item) => _item.toRdf({ mutateGraph: mutateGraph, resourceSet: resourceSet })));
        _resource.add(dataFactory.namedNode("http://qudt.org/schema/qudt/applicableUnit"), this.qudt_QuantityKind$j$applicableUnit.map((_item) => _item.toRdf({ mutateGraph: mutateGraph, resourceSet: resourceSet })));
        _resource.add(dataFactory.namedNode("http://qudt.org/schema/qudt/applicableUSCustomaryUnit"), this.qudt_QuantityKind$j$applicableUSCustomaryUnit.map((_item) => _item.toRdf({ mutateGraph: mutateGraph, resourceSet: resourceSet })));
        _resource.add(dataFactory.namedNode("http://qudt.org/schema/qudt/baseCGSUnitDimensions"), this.qudt_QuantityKind$j$baseCGSUnitDimensions);
        _resource.add(dataFactory.namedNode("http://qudt.org/schema/qudt/baseImperialUnitDimensions"), this.qudt_QuantityKind$j$baseImperialUnitDimensions);
        _resource.add(dataFactory.namedNode("http://qudt.org/schema/qudt/baseISOUnitDimensions"), this.qudt_QuantityKind$j$baseISOUnitDimensions);
        _resource.add(dataFactory.namedNode("http://qudt.org/schema/qudt/baseSIUnitDimensions"), this.qudt_QuantityKind$j$baseSIUnitDimensions);
        _resource.add(dataFactory.namedNode("http://qudt.org/schema/qudt/baseUSCustomaryUnitDimensions"), this.qudt_QuantityKind$j$baseUSCustomaryUnitDimensions);
        _resource.add(dataFactory.namedNode("http://qudt.org/schema/qudt/belongsToSystemOfQuantities"), this.qudt_QuantityKind$j$belongsToSystemOfQuantities.map((_item) => _item.toRdf({ mutateGraph: mutateGraph, resourceSet: resourceSet })));
        _resource.add(dataFactory.namedNode("http://qudt.org/schema/qudt/dimensionVectorForSI"), this.qudt_QuantityKind$j$dimensionVectorForSI.map((_value) => _value.toRdf({ mutateGraph: mutateGraph, resourceSet: resourceSet })));
        _resource.add(dataFactory.namedNode("http://qudt.org/schema/qudt/expression"), this.qudt_QuantityKind$j$expression.map((_item) => _item));
        _resource.add(dataFactory.namedNode("http://qudt.org/schema/qudt/hasDimensionVector"), this.qudt_QuantityKind$j$hasDimensionVector.toRdf({ mutateGraph: mutateGraph, resourceSet: resourceSet }));
        _resource.add(dataFactory.namedNode("http://qudt.org/schema/qudt/iec61360Code"), this.qudt_QuantityKind$j$iec61360Code.map((_item) => _item));
        _resource.add(dataFactory.namedNode("http://qudt.org/schema/qudt/latexDefinition"), this.qudt_QuantityKind$j$latexDefinition);
        _resource.add(dataFactory.namedNode("http://qudt.org/schema/qudt/mathMLdefinition"), this.qudt_QuantityKind$j$mathMLdefinition);
        _resource.add(dataFactory.namedNode("http://qudt.org/schema/qudt/qkdvDenominator"), this.qudt_QuantityKind$j$qkdvDenominator.map((_value) => _value.toRdf({ mutateGraph: mutateGraph, resourceSet: resourceSet })));
        _resource.add(dataFactory.namedNode("http://qudt.org/schema/qudt/qkdvNumerator"), this.qudt_QuantityKind$j$qkdvNumerator.map((_value) => _value.toRdf({ mutateGraph: mutateGraph, resourceSet: resourceSet })));
        _resource.add(dataFactory.namedNode("http://qudt.org/schema/qudt/siExactMatch"), this.qudt_QuantityKind$j$siExactMatch);
        return _resource;
    }

    override toString(): string {
        return JSON.stringify(this.toJson());
    }
}

export namespace Quantity_Kind {
    export function _propertiesFromJson(_json: unknown): purify.Either<zod.ZodError, { identifier: (rdfjs.BlankNode | rdfjs.NamedNode); qudt_QuantityKind$j$applicableCGSUnit: readonly (Abstract_Unit)[]; qudt_QuantityKind$j$applicableImperialUnit: readonly (Abstract_Unit)[]; qudt_QuantityKind$j$applicableISOUnit: readonly (Abstract_Unit)[]; qudt_QuantityKind$j$applicableSIUnit: readonly (Abstract_Unit)[]; qudt_QuantityKind$j$applicableUnit: readonly (Abstract_Unit)[]; qudt_QuantityKind$j$applicableUSCustomaryUnit: readonly (Abstract_Unit)[]; qudt_QuantityKind$j$baseCGSUnitDimensions: purify.Maybe<(rdfjs.BlankNode | rdfjs.NamedNode | rdfjs.Literal)>; qudt_QuantityKind$j$baseImperialUnitDimensions: purify.Maybe<(rdfjs.BlankNode | rdfjs.NamedNode | rdfjs.Literal)>; qudt_QuantityKind$j$baseISOUnitDimensions: purify.Maybe<(rdfjs.BlankNode | rdfjs.NamedNode | rdfjs.Literal)>; qudt_QuantityKind$j$baseSIUnitDimensions: purify.Maybe<(rdfjs.BlankNode | rdfjs.NamedNode | rdfjs.Literal)>; qudt_QuantityKind$j$baseUSCustomaryUnitDimensions: purify.Maybe<(rdfjs.BlankNode | rdfjs.NamedNode | rdfjs.Literal)>; qudt_QuantityKind$j$belongsToSystemOfQuantities: readonly (System_of$W$Quantity$W$Kinds)[]; qudt_QuantityKind$j$dimensionVectorForSI: purify.Maybe<Quantity_Kind$W$Dimension$W$vector$W$$e$SI$f$>; qudt_QuantityKind$j$expression: readonly ((rdfjs.BlankNode | rdfjs.NamedNode | rdfjs.Literal))[]; qudt_QuantityKind$j$hasDimensionVector: Quantity_Kind$W$Dimension$W$Vector; qudt_QuantityKind$j$iec61360Code: readonly (string)[]; qudt_QuantityKind$j$latexDefinition: purify.Maybe<string>; qudt_QuantityKind$j$mathMLdefinition: purify.Maybe<string>; qudt_QuantityKind$j$qkdvDenominator: purify.Maybe<Quantity_Kind$W$Dimension$W$Vector>; qudt_QuantityKind$j$qkdvNumerator: purify.Maybe<Quantity_Kind$W$Dimension$W$Vector>; qudt_QuantityKind$j$siExactMatch: purify.Maybe<(rdfjs.BlankNode | rdfjs.NamedNode | rdfjs.Literal)>; } & UnwrapR<ReturnType<typeof Quantity_Kind$W$$e$abstract$f$._propertiesFromJson>>> {
        const _jsonSafeParseResult = quantityKindJsonZodSchema().safeParse(_json);
        if (!_jsonSafeParseResult.success) { return purify.Left(_jsonSafeParseResult.error); }

        const _jsonObject = _jsonSafeParseResult.data;
        const _super0Either = Quantity_Kind$W$$e$abstract$f$._propertiesFromJson(_jsonObject);
        if (_super0Either.isLeft()) { return _super0Either; }

        const _super0 = _super0Either.unsafeCoerce()
        const identifier = (_jsonObject["@id"].startsWith("_:") ? dataFactory.blankNode(_jsonObject["@id"].substring(2)) : dataFactory.namedNode(_jsonObject["@id"]));
        const qudt_QuantityKind$j$applicableCGSUnit = _jsonObject["qudt_QuantityKind$j$applicableCGSUnit"].map(_item => (Abstract_Unit.fromJson(_item).unsafeCoerce()));
        const qudt_QuantityKind$j$applicableImperialUnit = _jsonObject["qudt_QuantityKind$j$applicableImperialUnit"].map(_item => (Abstract_Unit.fromJson(_item).unsafeCoerce()));
        const qudt_QuantityKind$j$applicableISOUnit = _jsonObject["qudt_QuantityKind$j$applicableISOUnit"].map(_item => (Abstract_Unit.fromJson(_item).unsafeCoerce()));
        const qudt_QuantityKind$j$applicableSIUnit = _jsonObject["qudt_QuantityKind$j$applicableSIUnit"].map(_item => (Abstract_Unit.fromJson(_item).unsafeCoerce()));
        const qudt_QuantityKind$j$applicableUnit = _jsonObject["qudt_QuantityKind$j$applicableUnit"].map(_item => (Abstract_Unit.fromJson(_item).unsafeCoerce()));
        const qudt_QuantityKind$j$applicableUSCustomaryUnit = _jsonObject["qudt_QuantityKind$j$applicableUSCustomaryUnit"].map(_item => (Abstract_Unit.fromJson(_item).unsafeCoerce()));
        const qudt_QuantityKind$j$baseCGSUnitDimensions = purify.Maybe.fromNullable(_jsonObject["qudt_QuantityKind$j$baseCGSUnitDimensions"]).map(_item => (((_item.termType === "Literal") ? (dataFactory.literal(_item["@value"], typeof _item["@language"] !== "undefined" ? _item["@language"] : (typeof _item["@type"] !== "undefined" ? dataFactory.namedNode(_item["@type"]) : undefined))) : (((_item.termType === "NamedNode") ? (dataFactory.namedNode(_item["@id"])) : (dataFactory.blankNode(_item["@id"].substring(2))))))));
        const qudt_QuantityKind$j$baseImperialUnitDimensions = purify.Maybe.fromNullable(_jsonObject["qudt_QuantityKind$j$baseImperialUnitDimensions"]).map(_item => (((_item.termType === "Literal") ? (dataFactory.literal(_item["@value"], typeof _item["@language"] !== "undefined" ? _item["@language"] : (typeof _item["@type"] !== "undefined" ? dataFactory.namedNode(_item["@type"]) : undefined))) : (((_item.termType === "NamedNode") ? (dataFactory.namedNode(_item["@id"])) : (dataFactory.blankNode(_item["@id"].substring(2))))))));
        const qudt_QuantityKind$j$baseISOUnitDimensions = purify.Maybe.fromNullable(_jsonObject["qudt_QuantityKind$j$baseISOUnitDimensions"]).map(_item => (((_item.termType === "Literal") ? (dataFactory.literal(_item["@value"], typeof _item["@language"] !== "undefined" ? _item["@language"] : (typeof _item["@type"] !== "undefined" ? dataFactory.namedNode(_item["@type"]) : undefined))) : (((_item.termType === "NamedNode") ? (dataFactory.namedNode(_item["@id"])) : (dataFactory.blankNode(_item["@id"].substring(2))))))));
        const qudt_QuantityKind$j$baseSIUnitDimensions = purify.Maybe.fromNullable(_jsonObject["qudt_QuantityKind$j$baseSIUnitDimensions"]).map(_item => (((_item.termType === "Literal") ? (dataFactory.literal(_item["@value"], typeof _item["@language"] !== "undefined" ? _item["@language"] : (typeof _item["@type"] !== "undefined" ? dataFactory.namedNode(_item["@type"]) : undefined))) : (((_item.termType === "NamedNode") ? (dataFactory.namedNode(_item["@id"])) : (dataFactory.blankNode(_item["@id"].substring(2))))))));
        const qudt_QuantityKind$j$baseUSCustomaryUnitDimensions = purify.Maybe.fromNullable(_jsonObject["qudt_QuantityKind$j$baseUSCustomaryUnitDimensions"]).map(_item => (((_item.termType === "Literal") ? (dataFactory.literal(_item["@value"], typeof _item["@language"] !== "undefined" ? _item["@language"] : (typeof _item["@type"] !== "undefined" ? dataFactory.namedNode(_item["@type"]) : undefined))) : (((_item.termType === "NamedNode") ? (dataFactory.namedNode(_item["@id"])) : (dataFactory.blankNode(_item["@id"].substring(2))))))));
        const qudt_QuantityKind$j$belongsToSystemOfQuantities = _jsonObject["qudt_QuantityKind$j$belongsToSystemOfQuantities"].map(_item => (System_of$W$Quantity$W$Kinds.fromJson(_item).unsafeCoerce()));
        const qudt_QuantityKind$j$dimensionVectorForSI = purify.Maybe.fromNullable(_jsonObject["qudt_QuantityKind$j$dimensionVectorForSI"]).map(_item => (Quantity_Kind$W$Dimension$W$vector$W$$e$SI$f$.fromJson(_item).unsafeCoerce()));
        const qudt_QuantityKind$j$expression = _jsonObject["qudt_QuantityKind$j$expression"].map(_item => (((_item.termType === "Literal") ? (dataFactory.literal(_item["@value"], typeof _item["@language"] !== "undefined" ? _item["@language"] : (typeof _item["@type"] !== "undefined" ? dataFactory.namedNode(_item["@type"]) : undefined))) : (((_item.termType === "NamedNode") ? (dataFactory.namedNode(_item["@id"])) : (dataFactory.blankNode(_item["@id"].substring(2))))))));
        const qudt_QuantityKind$j$hasDimensionVector = Quantity_Kind$W$Dimension$W$Vector.fromJson(_jsonObject["qudt_QuantityKind$j$hasDimensionVector"]).unsafeCoerce();
        const qudt_QuantityKind$j$iec61360Code = _jsonObject["qudt_QuantityKind$j$iec61360Code"];
        const qudt_QuantityKind$j$latexDefinition = purify.Maybe.fromNullable(_jsonObject["qudt_QuantityKind$j$latexDefinition"]);
        const qudt_QuantityKind$j$mathMLdefinition = purify.Maybe.fromNullable(_jsonObject["qudt_QuantityKind$j$mathMLdefinition"]);
        const qudt_QuantityKind$j$qkdvDenominator = purify.Maybe.fromNullable(_jsonObject["qudt_QuantityKind$j$qkdvDenominator"]).map(_item => (Quantity_Kind$W$Dimension$W$Vector.fromJson(_item).unsafeCoerce()));
        const qudt_QuantityKind$j$qkdvNumerator = purify.Maybe.fromNullable(_jsonObject["qudt_QuantityKind$j$qkdvNumerator"]).map(_item => (Quantity_Kind$W$Dimension$W$Vector.fromJson(_item).unsafeCoerce()));
        const qudt_QuantityKind$j$siExactMatch = purify.Maybe.fromNullable(_jsonObject["qudt_QuantityKind$j$siExactMatch"]).map(_item => (((_item.termType === "Literal") ? (dataFactory.literal(_item["@value"], typeof _item["@language"] !== "undefined" ? _item["@language"] : (typeof _item["@type"] !== "undefined" ? dataFactory.namedNode(_item["@type"]) : undefined))) : (((_item.termType === "NamedNode") ? (dataFactory.namedNode(_item["@id"])) : (dataFactory.blankNode(_item["@id"].substring(2))))))));
        return purify.Either.of({ ..._super0, identifier, qudt_QuantityKind$j$applicableCGSUnit, qudt_QuantityKind$j$applicableImperialUnit, qudt_QuantityKind$j$applicableISOUnit, qudt_QuantityKind$j$applicableSIUnit, qudt_QuantityKind$j$applicableUnit, qudt_QuantityKind$j$applicableUSCustomaryUnit, qudt_QuantityKind$j$baseCGSUnitDimensions, qudt_QuantityKind$j$baseImperialUnitDimensions, qudt_QuantityKind$j$baseISOUnitDimensions, qudt_QuantityKind$j$baseSIUnitDimensions, qudt_QuantityKind$j$baseUSCustomaryUnitDimensions, qudt_QuantityKind$j$belongsToSystemOfQuantities, qudt_QuantityKind$j$dimensionVectorForSI, qudt_QuantityKind$j$expression, qudt_QuantityKind$j$hasDimensionVector, qudt_QuantityKind$j$iec61360Code, qudt_QuantityKind$j$latexDefinition, qudt_QuantityKind$j$mathMLdefinition, qudt_QuantityKind$j$qkdvDenominator, qudt_QuantityKind$j$qkdvNumerator, qudt_QuantityKind$j$siExactMatch })
    }

    export function fromJson(json: unknown): purify.Either<zod.ZodError, Quantity_Kind> {
        return Quantity_Kind._propertiesFromJson(json).map(properties => new Quantity_Kind(properties));
    }

    export function _propertiesFromRdf({ ignoreRdfType: _ignoreRdfType, languageIn: _languageIn, resource: _resource,
        // @ts-ignore
        ..._context }: { [_index: string]: any; ignoreRdfType?: boolean; languageIn?: readonly string[]; resource: rdfjsResource.Resource; }): purify.Either<rdfjsResource.Resource.ValueError, { identifier: (rdfjs.BlankNode | rdfjs.NamedNode); qudt_QuantityKind$j$applicableCGSUnit: readonly (Abstract_Unit)[]; qudt_QuantityKind$j$applicableImperialUnit: readonly (Abstract_Unit)[]; qudt_QuantityKind$j$applicableISOUnit: readonly (Abstract_Unit)[]; qudt_QuantityKind$j$applicableSIUnit: readonly (Abstract_Unit)[]; qudt_QuantityKind$j$applicableUnit: readonly (Abstract_Unit)[]; qudt_QuantityKind$j$applicableUSCustomaryUnit: readonly (Abstract_Unit)[]; qudt_QuantityKind$j$baseCGSUnitDimensions: purify.Maybe<(rdfjs.BlankNode | rdfjs.NamedNode | rdfjs.Literal)>; qudt_QuantityKind$j$baseImperialUnitDimensions: purify.Maybe<(rdfjs.BlankNode | rdfjs.NamedNode | rdfjs.Literal)>; qudt_QuantityKind$j$baseISOUnitDimensions: purify.Maybe<(rdfjs.BlankNode | rdfjs.NamedNode | rdfjs.Literal)>; qudt_QuantityKind$j$baseSIUnitDimensions: purify.Maybe<(rdfjs.BlankNode | rdfjs.NamedNode | rdfjs.Literal)>; qudt_QuantityKind$j$baseUSCustomaryUnitDimensions: purify.Maybe<(rdfjs.BlankNode | rdfjs.NamedNode | rdfjs.Literal)>; qudt_QuantityKind$j$belongsToSystemOfQuantities: readonly (System_of$W$Quantity$W$Kinds)[]; qudt_QuantityKind$j$dimensionVectorForSI: purify.Maybe<Quantity_Kind$W$Dimension$W$vector$W$$e$SI$f$>; qudt_QuantityKind$j$expression: readonly ((rdfjs.BlankNode | rdfjs.NamedNode | rdfjs.Literal))[]; qudt_QuantityKind$j$hasDimensionVector: Quantity_Kind$W$Dimension$W$Vector; qudt_QuantityKind$j$iec61360Code: readonly (string)[]; qudt_QuantityKind$j$latexDefinition: purify.Maybe<string>; qudt_QuantityKind$j$mathMLdefinition: purify.Maybe<string>; qudt_QuantityKind$j$qkdvDenominator: purify.Maybe<Quantity_Kind$W$Dimension$W$Vector>; qudt_QuantityKind$j$qkdvNumerator: purify.Maybe<Quantity_Kind$W$Dimension$W$Vector>; qudt_QuantityKind$j$siExactMatch: purify.Maybe<(rdfjs.BlankNode | rdfjs.NamedNode | rdfjs.Literal)>; } & UnwrapR<ReturnType<typeof Quantity_Kind$W$$e$abstract$f$._propertiesFromRdf>>> {
        const _super0Either = Quantity_Kind$W$$e$abstract$f$._propertiesFromRdf({ ..._context, ignoreRdfType: true, languageIn: _languageIn, resource: _resource });
        if (_super0Either.isLeft()) { return _super0Either; }

        const _super0 = _super0Either.unsafeCoerce()
        if (!_ignoreRdfType && !_resource.isInstanceOf(dataFactory.namedNode("http://qudt.org/schema/qudt/QuantityKind"))) { return purify.Left(new rdfjsResource.Resource.ValueError({ focusResource: _resource, message: `${rdfjsResource.Resource.Identifier.toString(_resource.identifier)} has unexpected RDF type (expected http://qudt.org/schema/qudt/QuantityKind)`, predicate: dataFactory.namedNode("http://qudt.org/schema/qudt/QuantityKind") })); }

        const identifier = _resource.identifier
        const _qudt_QuantityKind$j$applicableCGSUnitEither: purify.Either<rdfjsResource.Resource.ValueError, readonly (Abstract_Unit)[]> = purify.Either.of([..._resource.values(dataFactory.namedNode("http://qudt.org/schema/qudt/applicableCGSUnit"), { unique: true }).flatMap(_item => _item.toValues().head().chain(value => value.toResource()).chain(_resource => Abstract_Unit.fromRdf({ ..._context, ignoreRdfType: true, languageIn: _languageIn, resource: _resource })).toMaybe().toList())]);
        if (_qudt_QuantityKind$j$applicableCGSUnitEither.isLeft()) { return _qudt_QuantityKind$j$applicableCGSUnitEither; }

        const qudt_QuantityKind$j$applicableCGSUnit = _qudt_QuantityKind$j$applicableCGSUnitEither.unsafeCoerce();
        const _qudt_QuantityKind$j$applicableImperialUnitEither: purify.Either<rdfjsResource.Resource.ValueError, readonly (Abstract_Unit)[]> = purify.Either.of([..._resource.values(dataFactory.namedNode("http://qudt.org/schema/qudt/applicableImperialUnit"), { unique: true }).flatMap(_item => _item.toValues().head().chain(value => value.toResource()).chain(_resource => Abstract_Unit.fromRdf({ ..._context, ignoreRdfType: true, languageIn: _languageIn, resource: _resource })).toMaybe().toList())]);
        if (_qudt_QuantityKind$j$applicableImperialUnitEither.isLeft()) { return _qudt_QuantityKind$j$applicableImperialUnitEither; }

        const qudt_QuantityKind$j$applicableImperialUnit = _qudt_QuantityKind$j$applicableImperialUnitEither.unsafeCoerce();
        const _qudt_QuantityKind$j$applicableISOUnitEither: purify.Either<rdfjsResource.Resource.ValueError, readonly (Abstract_Unit)[]> = purify.Either.of([..._resource.values(dataFactory.namedNode("http://qudt.org/schema/qudt/applicableISOUnit"), { unique: true }).flatMap(_item => _item.toValues().head().chain(value => value.toResource()).chain(_resource => Abstract_Unit.fromRdf({ ..._context, ignoreRdfType: true, languageIn: _languageIn, resource: _resource })).toMaybe().toList())]);
        if (_qudt_QuantityKind$j$applicableISOUnitEither.isLeft()) { return _qudt_QuantityKind$j$applicableISOUnitEither; }

        const qudt_QuantityKind$j$applicableISOUnit = _qudt_QuantityKind$j$applicableISOUnitEither.unsafeCoerce();
        const _qudt_QuantityKind$j$applicableSIUnitEither: purify.Either<rdfjsResource.Resource.ValueError, readonly (Abstract_Unit)[]> = purify.Either.of([..._resource.values(dataFactory.namedNode("http://qudt.org/schema/qudt/applicableSIUnit"), { unique: true }).flatMap(_item => _item.toValues().head().chain(value => value.toResource()).chain(_resource => Abstract_Unit.fromRdf({ ..._context, ignoreRdfType: true, languageIn: _languageIn, resource: _resource })).toMaybe().toList())]);
        if (_qudt_QuantityKind$j$applicableSIUnitEither.isLeft()) { return _qudt_QuantityKind$j$applicableSIUnitEither; }

        const qudt_QuantityKind$j$applicableSIUnit = _qudt_QuantityKind$j$applicableSIUnitEither.unsafeCoerce();
        const _qudt_QuantityKind$j$applicableUnitEither: purify.Either<rdfjsResource.Resource.ValueError, readonly (Abstract_Unit)[]> = purify.Either.of([..._resource.values(dataFactory.namedNode("http://qudt.org/schema/qudt/applicableUnit"), { unique: true }).flatMap(_item => _item.toValues().head().chain(value => value.toResource()).chain(_resource => Abstract_Unit.fromRdf({ ..._context, ignoreRdfType: true, languageIn: _languageIn, resource: _resource })).toMaybe().toList())]);
        if (_qudt_QuantityKind$j$applicableUnitEither.isLeft()) { return _qudt_QuantityKind$j$applicableUnitEither; }

        const qudt_QuantityKind$j$applicableUnit = _qudt_QuantityKind$j$applicableUnitEither.unsafeCoerce();
        const _qudt_QuantityKind$j$applicableUSCustomaryUnitEither: purify.Either<rdfjsResource.Resource.ValueError, readonly (Abstract_Unit)[]> = purify.Either.of([..._resource.values(dataFactory.namedNode("http://qudt.org/schema/qudt/applicableUSCustomaryUnit"), { unique: true }).flatMap(_item => _item.toValues().head().chain(value => value.toResource()).chain(_resource => Abstract_Unit.fromRdf({ ..._context, ignoreRdfType: true, languageIn: _languageIn, resource: _resource })).toMaybe().toList())]);
        if (_qudt_QuantityKind$j$applicableUSCustomaryUnitEither.isLeft()) { return _qudt_QuantityKind$j$applicableUSCustomaryUnitEither; }

        const qudt_QuantityKind$j$applicableUSCustomaryUnit = _qudt_QuantityKind$j$applicableUSCustomaryUnitEither.unsafeCoerce();
        const _qudt_QuantityKind$j$baseCGSUnitDimensionsEither: purify.Either<rdfjsResource.Resource.ValueError, purify.Maybe<(rdfjs.BlankNode | rdfjs.NamedNode | rdfjs.Literal)>> = purify.Either.of(_resource.values(dataFactory.namedNode("http://qudt.org/schema/qudt/baseCGSUnitDimensions"), { unique: true }).head().chain(_value => purify.Either.of(_value.toTerm())).toMaybe());
        if (_qudt_QuantityKind$j$baseCGSUnitDimensionsEither.isLeft()) { return _qudt_QuantityKind$j$baseCGSUnitDimensionsEither; }

        const qudt_QuantityKind$j$baseCGSUnitDimensions = _qudt_QuantityKind$j$baseCGSUnitDimensionsEither.unsafeCoerce();
        const _qudt_QuantityKind$j$baseImperialUnitDimensionsEither: purify.Either<rdfjsResource.Resource.ValueError, purify.Maybe<(rdfjs.BlankNode | rdfjs.NamedNode | rdfjs.Literal)>> = purify.Either.of(_resource.values(dataFactory.namedNode("http://qudt.org/schema/qudt/baseImperialUnitDimensions"), { unique: true }).head().chain(_value => purify.Either.of(_value.toTerm())).toMaybe());
        if (_qudt_QuantityKind$j$baseImperialUnitDimensionsEither.isLeft()) { return _qudt_QuantityKind$j$baseImperialUnitDimensionsEither; }

        const qudt_QuantityKind$j$baseImperialUnitDimensions = _qudt_QuantityKind$j$baseImperialUnitDimensionsEither.unsafeCoerce();
        const _qudt_QuantityKind$j$baseISOUnitDimensionsEither: purify.Either<rdfjsResource.Resource.ValueError, purify.Maybe<(rdfjs.BlankNode | rdfjs.NamedNode | rdfjs.Literal)>> = purify.Either.of(_resource.values(dataFactory.namedNode("http://qudt.org/schema/qudt/baseISOUnitDimensions"), { unique: true }).head().chain(_value => purify.Either.of(_value.toTerm())).toMaybe());
        if (_qudt_QuantityKind$j$baseISOUnitDimensionsEither.isLeft()) { return _qudt_QuantityKind$j$baseISOUnitDimensionsEither; }

        const qudt_QuantityKind$j$baseISOUnitDimensions = _qudt_QuantityKind$j$baseISOUnitDimensionsEither.unsafeCoerce();
        const _qudt_QuantityKind$j$baseSIUnitDimensionsEither: purify.Either<rdfjsResource.Resource.ValueError, purify.Maybe<(rdfjs.BlankNode | rdfjs.NamedNode | rdfjs.Literal)>> = purify.Either.of(_resource.values(dataFactory.namedNode("http://qudt.org/schema/qudt/baseSIUnitDimensions"), { unique: true }).head().chain(_value => purify.Either.of(_value.toTerm())).toMaybe());
        if (_qudt_QuantityKind$j$baseSIUnitDimensionsEither.isLeft()) { return _qudt_QuantityKind$j$baseSIUnitDimensionsEither; }

        const qudt_QuantityKind$j$baseSIUnitDimensions = _qudt_QuantityKind$j$baseSIUnitDimensionsEither.unsafeCoerce();
        const _qudt_QuantityKind$j$baseUSCustomaryUnitDimensionsEither: purify.Either<rdfjsResource.Resource.ValueError, purify.Maybe<(rdfjs.BlankNode | rdfjs.NamedNode | rdfjs.Literal)>> = purify.Either.of(_resource.values(dataFactory.namedNode("http://qudt.org/schema/qudt/baseUSCustomaryUnitDimensions"), { unique: true }).head().chain(_value => purify.Either.of(_value.toTerm())).toMaybe());
        if (_qudt_QuantityKind$j$baseUSCustomaryUnitDimensionsEither.isLeft()) { return _qudt_QuantityKind$j$baseUSCustomaryUnitDimensionsEither; }

        const qudt_QuantityKind$j$baseUSCustomaryUnitDimensions = _qudt_QuantityKind$j$baseUSCustomaryUnitDimensionsEither.unsafeCoerce();
        const _qudt_QuantityKind$j$belongsToSystemOfQuantitiesEither: purify.Either<rdfjsResource.Resource.ValueError, readonly (System_of$W$Quantity$W$Kinds)[]> = purify.Either.of([..._resource.values(dataFactory.namedNode("http://qudt.org/schema/qudt/belongsToSystemOfQuantities"), { unique: true }).flatMap(_item => _item.toValues().head().chain(value => value.toResource()).chain(_resource => System_of$W$Quantity$W$Kinds.fromRdf({ ..._context, ignoreRdfType: true, languageIn: _languageIn, resource: _resource })).toMaybe().toList())]);
        if (_qudt_QuantityKind$j$belongsToSystemOfQuantitiesEither.isLeft()) { return _qudt_QuantityKind$j$belongsToSystemOfQuantitiesEither; }

        const qudt_QuantityKind$j$belongsToSystemOfQuantities = _qudt_QuantityKind$j$belongsToSystemOfQuantitiesEither.unsafeCoerce();
        const _qudt_QuantityKind$j$dimensionVectorForSIEither: purify.Either<rdfjsResource.Resource.ValueError, purify.Maybe<Quantity_Kind$W$Dimension$W$vector$W$$e$SI$f$>> = purify.Either.of(_resource.values(dataFactory.namedNode("http://qudt.org/schema/qudt/dimensionVectorForSI"), { unique: true }).head().chain(value => value.toResource()).chain(_resource => Quantity_Kind$W$Dimension$W$vector$W$$e$SI$f$.fromRdf({ ..._context, ignoreRdfType: true, languageIn: _languageIn, resource: _resource })).toMaybe());
        if (_qudt_QuantityKind$j$dimensionVectorForSIEither.isLeft()) { return _qudt_QuantityKind$j$dimensionVectorForSIEither; }

        const qudt_QuantityKind$j$dimensionVectorForSI = _qudt_QuantityKind$j$dimensionVectorForSIEither.unsafeCoerce();
        const _qudt_QuantityKind$j$expressionEither: purify.Either<rdfjsResource.Resource.ValueError, readonly ((rdfjs.BlankNode | rdfjs.NamedNode | rdfjs.Literal))[]> = purify.Either.of([..._resource.values(dataFactory.namedNode("http://qudt.org/schema/qudt/expression"), { unique: true }).flatMap(_item => _item.toValues().head().chain(_value => purify.Either.of(_value.toTerm())).toMaybe().toList())]);
        if (_qudt_QuantityKind$j$expressionEither.isLeft()) { return _qudt_QuantityKind$j$expressionEither; }

        const qudt_QuantityKind$j$expression = _qudt_QuantityKind$j$expressionEither.unsafeCoerce();
        const _qudt_QuantityKind$j$hasDimensionVectorEither: purify.Either<rdfjsResource.Resource.ValueError, Quantity_Kind$W$Dimension$W$Vector> = _resource.values(dataFactory.namedNode("http://qudt.org/schema/qudt/hasDimensionVector"), { unique: true }).head().chain(value => value.toResource()).chain(_resource => Quantity_Kind$W$Dimension$W$Vector.fromRdf({ ..._context, ignoreRdfType: true, languageIn: _languageIn, resource: _resource }));
        if (_qudt_QuantityKind$j$hasDimensionVectorEither.isLeft()) { return _qudt_QuantityKind$j$hasDimensionVectorEither; }

        const qudt_QuantityKind$j$hasDimensionVector = _qudt_QuantityKind$j$hasDimensionVectorEither.unsafeCoerce();
        const _qudt_QuantityKind$j$iec61360CodeEither: purify.Either<rdfjsResource.Resource.ValueError, readonly (string)[]> = purify.Either.of([..._resource.values(dataFactory.namedNode("http://qudt.org/schema/qudt/iec61360Code"), { unique: true }).flatMap(_item => _item.toValues().head().chain(_value => _value.toString()).toMaybe().toList())]);
        if (_qudt_QuantityKind$j$iec61360CodeEither.isLeft()) { return _qudt_QuantityKind$j$iec61360CodeEither; }

        const qudt_QuantityKind$j$iec61360Code = _qudt_QuantityKind$j$iec61360CodeEither.unsafeCoerce();
        const _qudt_QuantityKind$j$latexDefinitionEither: purify.Either<rdfjsResource.Resource.ValueError, purify.Maybe<string>> = purify.Either.of(_resource.values(dataFactory.namedNode("http://qudt.org/schema/qudt/latexDefinition"), { unique: true }).head().chain(_value => _value.toString()).toMaybe());
        if (_qudt_QuantityKind$j$latexDefinitionEither.isLeft()) { return _qudt_QuantityKind$j$latexDefinitionEither; }

        const qudt_QuantityKind$j$latexDefinition = _qudt_QuantityKind$j$latexDefinitionEither.unsafeCoerce();
        const _qudt_QuantityKind$j$mathMLdefinitionEither: purify.Either<rdfjsResource.Resource.ValueError, purify.Maybe<string>> = purify.Either.of(_resource.values(dataFactory.namedNode("http://qudt.org/schema/qudt/mathMLdefinition"), { unique: true }).head().chain(_value => _value.toString()).toMaybe());
        if (_qudt_QuantityKind$j$mathMLdefinitionEither.isLeft()) { return _qudt_QuantityKind$j$mathMLdefinitionEither; }

        const qudt_QuantityKind$j$mathMLdefinition = _qudt_QuantityKind$j$mathMLdefinitionEither.unsafeCoerce();
        const _qudt_QuantityKind$j$qkdvDenominatorEither: purify.Either<rdfjsResource.Resource.ValueError, purify.Maybe<Quantity_Kind$W$Dimension$W$Vector>> = purify.Either.of(_resource.values(dataFactory.namedNode("http://qudt.org/schema/qudt/qkdvDenominator"), { unique: true }).head().chain(value => value.toResource()).chain(_resource => Quantity_Kind$W$Dimension$W$Vector.fromRdf({ ..._context, ignoreRdfType: true, languageIn: _languageIn, resource: _resource })).toMaybe());
        if (_qudt_QuantityKind$j$qkdvDenominatorEither.isLeft()) { return _qudt_QuantityKind$j$qkdvDenominatorEither; }

        const qudt_QuantityKind$j$qkdvDenominator = _qudt_QuantityKind$j$qkdvDenominatorEither.unsafeCoerce();
        const _qudt_QuantityKind$j$qkdvNumeratorEither: purify.Either<rdfjsResource.Resource.ValueError, purify.Maybe<Quantity_Kind$W$Dimension$W$Vector>> = purify.Either.of(_resource.values(dataFactory.namedNode("http://qudt.org/schema/qudt/qkdvNumerator"), { unique: true }).head().chain(value => value.toResource()).chain(_resource => Quantity_Kind$W$Dimension$W$Vector.fromRdf({ ..._context, ignoreRdfType: true, languageIn: _languageIn, resource: _resource })).toMaybe());
        if (_qudt_QuantityKind$j$qkdvNumeratorEither.isLeft()) { return _qudt_QuantityKind$j$qkdvNumeratorEither; }

        const qudt_QuantityKind$j$qkdvNumerator = _qudt_QuantityKind$j$qkdvNumeratorEither.unsafeCoerce();
        const _qudt_QuantityKind$j$siExactMatchEither: purify.Either<rdfjsResource.Resource.ValueError, purify.Maybe<(rdfjs.BlankNode | rdfjs.NamedNode | rdfjs.Literal)>> = purify.Either.of(_resource.values(dataFactory.namedNode("http://qudt.org/schema/qudt/siExactMatch"), { unique: true }).head().chain(_value => purify.Either.of(_value.toTerm())).toMaybe());
        if (_qudt_QuantityKind$j$siExactMatchEither.isLeft()) { return _qudt_QuantityKind$j$siExactMatchEither; }

        const qudt_QuantityKind$j$siExactMatch = _qudt_QuantityKind$j$siExactMatchEither.unsafeCoerce();
        return purify.Either.of({ ..._super0, identifier, qudt_QuantityKind$j$applicableCGSUnit, qudt_QuantityKind$j$applicableImperialUnit, qudt_QuantityKind$j$applicableISOUnit, qudt_QuantityKind$j$applicableSIUnit, qudt_QuantityKind$j$applicableUnit, qudt_QuantityKind$j$applicableUSCustomaryUnit, qudt_QuantityKind$j$baseCGSUnitDimensions, qudt_QuantityKind$j$baseImperialUnitDimensions, qudt_QuantityKind$j$baseISOUnitDimensions, qudt_QuantityKind$j$baseSIUnitDimensions, qudt_QuantityKind$j$baseUSCustomaryUnitDimensions, qudt_QuantityKind$j$belongsToSystemOfQuantities, qudt_QuantityKind$j$dimensionVectorForSI, qudt_QuantityKind$j$expression, qudt_QuantityKind$j$hasDimensionVector, qudt_QuantityKind$j$iec61360Code, qudt_QuantityKind$j$latexDefinition, qudt_QuantityKind$j$mathMLdefinition, qudt_QuantityKind$j$qkdvDenominator, qudt_QuantityKind$j$qkdvNumerator, qudt_QuantityKind$j$siExactMatch })
    }

    export function fromRdf(parameters: Parameters<typeof Quantity_Kind._propertiesFromRdf>[0]): purify.Either<rdfjsResource.Resource.ValueError, Quantity_Kind> {
        return Quantity_Kind._propertiesFromRdf(parameters).map(properties => new Quantity_Kind(properties));
    }

    export let fromRdfType: rdfjs.NamedNode<string> = dataFactory.namedNode("http://qudt.org/schema/qudt/QuantityKind");

    export function jsonSchema() {
        return zodToJsonSchema(quantityKindJsonZodSchema());
    }

    export function quantityKindJsonUiSchema(parameters?: { scopePrefix?: string }) {
        const scopePrefix = parameters?.scopePrefix ?? "#";
        return { "elements": [ Quantity_Kind$W$$e$abstract$f$.quantityKindWEAbstractFJsonUiSchema({ scopePrefix }), Abstract_Unit.abstractUnitJsonUiSchema({ scopePrefix: `${scopePrefix}/properties/qudt_QuantityKind$j$applicableCGSUnit` }), Abstract_Unit.abstractUnitJsonUiSchema({ scopePrefix: `${scopePrefix}/properties/qudt_QuantityKind$j$applicableImperialUnit` }), Abstract_Unit.abstractUnitJsonUiSchema({ scopePrefix: `${scopePrefix}/properties/qudt_QuantityKind$j$applicableISOUnit` }), Abstract_Unit.abstractUnitJsonUiSchema({ scopePrefix: `${scopePrefix}/properties/qudt_QuantityKind$j$applicableSIUnit` }), Abstract_Unit.abstractUnitJsonUiSchema({ scopePrefix: `${scopePrefix}/properties/qudt_QuantityKind$j$applicableUnit` }), Abstract_Unit.abstractUnitJsonUiSchema({ scopePrefix: `${scopePrefix}/properties/qudt_QuantityKind$j$applicableUSCustomaryUnit` }), { scope: `${scopePrefix}/properties/qudt_QuantityKind$j$baseCGSUnitDimensions`, type: "Control" }, { scope: `${scopePrefix}/properties/qudt_QuantityKind$j$baseImperialUnitDimensions`, type: "Control" }, { scope: `${scopePrefix}/properties/qudt_QuantityKind$j$baseISOUnitDimensions`, type: "Control" }, { scope: `${scopePrefix}/properties/qudt_QuantityKind$j$baseSIUnitDimensions`, type: "Control" }, { scope: `${scopePrefix}/properties/qudt_QuantityKind$j$baseUSCustomaryUnitDimensions`, type: "Control" }, System_of$W$Quantity$W$Kinds.systemOfWQuantityWKindsJsonUiSchema({ scopePrefix: `${scopePrefix}/properties/qudt_QuantityKind$j$belongsToSystemOfQuantities` }), Quantity_Kind$W$Dimension$W$vector$W$$e$SI$f$.quantityKindWDimensionWVectorWESiFJsonUiSchema({ scopePrefix: `${scopePrefix}/properties/qudt_QuantityKind$j$dimensionVectorForSI` }), { scope: `${scopePrefix}/properties/qudt_QuantityKind$j$expression`, type: "Control" }, Quantity_Kind$W$Dimension$W$Vector.quantityKindWDimensionWVectorJsonUiSchema({ scopePrefix: `${scopePrefix}/properties/qudt_QuantityKind$j$hasDimensionVector` }), { scope: `${scopePrefix}/properties/qudt_QuantityKind$j$iec61360Code`, type: "Control" }, { scope: `${scopePrefix}/properties/qudt_QuantityKind$j$latexDefinition`, type: "Control" }, { scope: `${scopePrefix}/properties/qudt_QuantityKind$j$mathMLdefinition`, type: "Control" }, Quantity_Kind$W$Dimension$W$Vector.quantityKindWDimensionWVectorJsonUiSchema({ scopePrefix: `${scopePrefix}/properties/qudt_QuantityKind$j$qkdvDenominator` }), Quantity_Kind$W$Dimension$W$Vector.quantityKindWDimensionWVectorJsonUiSchema({ scopePrefix: `${scopePrefix}/properties/qudt_QuantityKind$j$qkdvNumerator` }), { scope: `${scopePrefix}/properties/qudt_QuantityKind$j$siExactMatch`, type: "Control" } ], label: "Quantity Kind", type: "Group" }
    }

    export function quantityKindJsonZodSchema() {
        return Quantity_Kind$W$$e$abstract$f$.quantityKindWEAbstractFJsonZodSchema().merge(zod.object({ "@id": zod.string().min(1),"type": zod.literal("Quantity_Kind"),"qudt_QuantityKind$j$applicableCGSUnit": Abstract_Unit.abstractUnitJsonZodSchema().array(),"qudt_QuantityKind$j$applicableImperialUnit": Abstract_Unit.abstractUnitJsonZodSchema().array(),"qudt_QuantityKind$j$applicableISOUnit": Abstract_Unit.abstractUnitJsonZodSchema().array(),"qudt_QuantityKind$j$applicableSIUnit": Abstract_Unit.abstractUnitJsonZodSchema().array(),"qudt_QuantityKind$j$applicableUnit": Abstract_Unit.abstractUnitJsonZodSchema().array(),"qudt_QuantityKind$j$applicableUSCustomaryUnit": Abstract_Unit.abstractUnitJsonZodSchema().array(),"qudt_QuantityKind$j$baseCGSUnitDimensions": zod.discriminatedUnion("termType", [zod.object({ "@id": zod.string().min(1), termType: zod.literal("BlankNode") }), zod.object({ "@id": zod.string().min(1), termType: zod.literal("NamedNode") }), zod.object({ "@language": zod.string().optional(), "@type": zod.string().optional(), "@value": zod.string(), termType: zod.literal("Literal") })]).optional(),"qudt_QuantityKind$j$baseImperialUnitDimensions": zod.discriminatedUnion("termType", [zod.object({ "@id": zod.string().min(1), termType: zod.literal("BlankNode") }), zod.object({ "@id": zod.string().min(1), termType: zod.literal("NamedNode") }), zod.object({ "@language": zod.string().optional(), "@type": zod.string().optional(), "@value": zod.string(), termType: zod.literal("Literal") })]).optional(),"qudt_QuantityKind$j$baseISOUnitDimensions": zod.discriminatedUnion("termType", [zod.object({ "@id": zod.string().min(1), termType: zod.literal("BlankNode") }), zod.object({ "@id": zod.string().min(1), termType: zod.literal("NamedNode") }), zod.object({ "@language": zod.string().optional(), "@type": zod.string().optional(), "@value": zod.string(), termType: zod.literal("Literal") })]).optional(),"qudt_QuantityKind$j$baseSIUnitDimensions": zod.discriminatedUnion("termType", [zod.object({ "@id": zod.string().min(1), termType: zod.literal("BlankNode") }), zod.object({ "@id": zod.string().min(1), termType: zod.literal("NamedNode") }), zod.object({ "@language": zod.string().optional(), "@type": zod.string().optional(), "@value": zod.string(), termType: zod.literal("Literal") })]).optional(),"qudt_QuantityKind$j$baseUSCustomaryUnitDimensions": zod.discriminatedUnion("termType", [zod.object({ "@id": zod.string().min(1), termType: zod.literal("BlankNode") }), zod.object({ "@id": zod.string().min(1), termType: zod.literal("NamedNode") }), zod.object({ "@language": zod.string().optional(), "@type": zod.string().optional(), "@value": zod.string(), termType: zod.literal("Literal") })]).optional(),"qudt_QuantityKind$j$belongsToSystemOfQuantities": System_of$W$Quantity$W$Kinds.systemOfWQuantityWKindsJsonZodSchema().array(),"qudt_QuantityKind$j$dimensionVectorForSI": Quantity_Kind$W$Dimension$W$vector$W$$e$SI$f$.quantityKindWDimensionWVectorWESiFJsonZodSchema().optional(),"qudt_QuantityKind$j$expression": zod.discriminatedUnion("termType", [zod.object({ "@id": zod.string().min(1), termType: zod.literal("BlankNode") }), zod.object({ "@id": zod.string().min(1), termType: zod.literal("NamedNode") }), zod.object({ "@language": zod.string().optional(), "@type": zod.string().optional(), "@value": zod.string(), termType: zod.literal("Literal") })]).array(),"qudt_QuantityKind$j$hasDimensionVector": Quantity_Kind$W$Dimension$W$Vector.quantityKindWDimensionWVectorJsonZodSchema(),"qudt_QuantityKind$j$iec61360Code": zod.string().array(),"qudt_QuantityKind$j$latexDefinition": zod.string().optional(),"qudt_QuantityKind$j$mathMLdefinition": zod.string().optional(),"qudt_QuantityKind$j$qkdvDenominator": Quantity_Kind$W$Dimension$W$Vector.quantityKindWDimensionWVectorJsonZodSchema().optional(),"qudt_QuantityKind$j$qkdvNumerator": Quantity_Kind$W$Dimension$W$Vector.quantityKindWDimensionWVectorJsonZodSchema().optional(),"qudt_QuantityKind$j$siExactMatch": zod.discriminatedUnion("termType", [zod.object({ "@id": zod.string().min(1), termType: zod.literal("BlankNode") }), zod.object({ "@id": zod.string().min(1), termType: zod.literal("NamedNode") }), zod.object({ "@language": zod.string().optional(), "@type": zod.string().optional(), "@value": zod.string(), termType: zod.literal("Literal") })]).optional() }));
    }

    export function sparqlConstructQuery(parameters?: { ignoreRdfType?: boolean; prefixes?: { [prefix: string]: string }; subject?: sparqljs.Triple["subject"]; } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type">): sparqljs.ConstructQuery {
        const { ignoreRdfType, subject, ...queryParameters } = parameters ?? {}

        return { ...queryParameters, prefixes: parameters?.prefixes ?? {}, queryType: "CONSTRUCT", template: (queryParameters.template ?? []).concat(Quantity_Kind.sparqlConstructTemplateTriples({ ignoreRdfType, subject })), type: "query", where: (queryParameters.where ?? []).concat(Quantity_Kind.sparqlWherePatterns({ ignoreRdfType, subject })) };
    }

    export function sparqlConstructQueryString(parameters?: { ignoreRdfType?: boolean; subject?: sparqljs.Triple["subject"]; variablePrefix?: string; } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type"> & sparqljs.GeneratorOptions): string {
        return new sparqljs.Generator(parameters).stringify(Quantity_Kind.sparqlConstructQuery(parameters));
    }

    export function sparqlConstructTemplateTriples(parameters?: { ignoreRdfType?: boolean; subject?: sparqljs.Triple["subject"], variablePrefix?: string }): readonly sparqljs.Triple[] {
        const subject = parameters?.subject ?? dataFactory.variable!("quantityKind");
        const variablePrefix = parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "quantityKind");
        return [...Quantity_Kind$W$$e$abstract$f$.sparqlConstructTemplateTriples({ ignoreRdfType: true, subject, variablePrefix }), ...(parameters?.ignoreRdfType ? [] : [{ subject, predicate: dataFactory.namedNode("http://www.w3.org/1999/02/22-rdf-syntax-ns#type"), object: dataFactory.variable!(`${variablePrefix}RdfType`) }]), { object: dataFactory.variable!(`${variablePrefix}QudtQuantityKindJApplicableCgsUnit`), predicate: dataFactory.namedNode("http://qudt.org/schema/qudt/applicableCGSUnit"), subject }, ...Abstract_Unit.sparqlConstructTemplateTriples({ ignoreRdfType: true, subject: dataFactory.variable!(`${variablePrefix}QudtQuantityKindJApplicableCgsUnit`), variablePrefix: `${variablePrefix}QudtQuantityKindJApplicableCgsUnit` }), { object: dataFactory.variable!(`${variablePrefix}QudtQuantityKindJApplicableImperialUnit`), predicate: dataFactory.namedNode("http://qudt.org/schema/qudt/applicableImperialUnit"), subject }, ...Abstract_Unit.sparqlConstructTemplateTriples({ ignoreRdfType: true, subject: dataFactory.variable!(`${variablePrefix}QudtQuantityKindJApplicableImperialUnit`), variablePrefix: `${variablePrefix}QudtQuantityKindJApplicableImperialUnit` }), { object: dataFactory.variable!(`${variablePrefix}QudtQuantityKindJApplicableIsoUnit`), predicate: dataFactory.namedNode("http://qudt.org/schema/qudt/applicableISOUnit"), subject }, ...Abstract_Unit.sparqlConstructTemplateTriples({ ignoreRdfType: true, subject: dataFactory.variable!(`${variablePrefix}QudtQuantityKindJApplicableIsoUnit`), variablePrefix: `${variablePrefix}QudtQuantityKindJApplicableIsoUnit` }), { object: dataFactory.variable!(`${variablePrefix}QudtQuantityKindJApplicableSiUnit`), predicate: dataFactory.namedNode("http://qudt.org/schema/qudt/applicableSIUnit"), subject }, ...Abstract_Unit.sparqlConstructTemplateTriples({ ignoreRdfType: true, subject: dataFactory.variable!(`${variablePrefix}QudtQuantityKindJApplicableSiUnit`), variablePrefix: `${variablePrefix}QudtQuantityKindJApplicableSiUnit` }), { object: dataFactory.variable!(`${variablePrefix}QudtQuantityKindJApplicableUnit`), predicate: dataFactory.namedNode("http://qudt.org/schema/qudt/applicableUnit"), subject }, ...Abstract_Unit.sparqlConstructTemplateTriples({ ignoreRdfType: true, subject: dataFactory.variable!(`${variablePrefix}QudtQuantityKindJApplicableUnit`), variablePrefix: `${variablePrefix}QudtQuantityKindJApplicableUnit` }), { object: dataFactory.variable!(`${variablePrefix}QudtQuantityKindJApplicableUsCustomaryUnit`), predicate: dataFactory.namedNode("http://qudt.org/schema/qudt/applicableUSCustomaryUnit"), subject }, ...Abstract_Unit.sparqlConstructTemplateTriples({ ignoreRdfType: true, subject: dataFactory.variable!(`${variablePrefix}QudtQuantityKindJApplicableUsCustomaryUnit`), variablePrefix: `${variablePrefix}QudtQuantityKindJApplicableUsCustomaryUnit` }), { object: dataFactory.variable!(`${variablePrefix}QudtQuantityKindJBaseCgsUnitDimensions`), predicate: dataFactory.namedNode("http://qudt.org/schema/qudt/baseCGSUnitDimensions"), subject }, { object: dataFactory.variable!(`${variablePrefix}QudtQuantityKindJBaseImperialUnitDimensions`), predicate: dataFactory.namedNode("http://qudt.org/schema/qudt/baseImperialUnitDimensions"), subject }, { object: dataFactory.variable!(`${variablePrefix}QudtQuantityKindJBaseIsoUnitDimensions`), predicate: dataFactory.namedNode("http://qudt.org/schema/qudt/baseISOUnitDimensions"), subject }, { object: dataFactory.variable!(`${variablePrefix}QudtQuantityKindJBaseSiUnitDimensions`), predicate: dataFactory.namedNode("http://qudt.org/schema/qudt/baseSIUnitDimensions"), subject }, { object: dataFactory.variable!(`${variablePrefix}QudtQuantityKindJBaseUsCustomaryUnitDimensions`), predicate: dataFactory.namedNode("http://qudt.org/schema/qudt/baseUSCustomaryUnitDimensions"), subject }, { object: dataFactory.variable!(`${variablePrefix}QudtQuantityKindJBelongsToSystemOfQuantities`), predicate: dataFactory.namedNode("http://qudt.org/schema/qudt/belongsToSystemOfQuantities"), subject }, ...System_of$W$Quantity$W$Kinds.sparqlConstructTemplateTriples({ ignoreRdfType: true, subject: dataFactory.variable!(`${variablePrefix}QudtQuantityKindJBelongsToSystemOfQuantities`), variablePrefix: `${variablePrefix}QudtQuantityKindJBelongsToSystemOfQuantities` }), { object: dataFactory.variable!(`${variablePrefix}QudtQuantityKindJDimensionVectorForSi`), predicate: dataFactory.namedNode("http://qudt.org/schema/qudt/dimensionVectorForSI"), subject }, ...Quantity_Kind$W$Dimension$W$vector$W$$e$SI$f$.sparqlConstructTemplateTriples({ ignoreRdfType: true, subject: dataFactory.variable!(`${variablePrefix}QudtQuantityKindJDimensionVectorForSi`), variablePrefix: `${variablePrefix}QudtQuantityKindJDimensionVectorForSi` }), { object: dataFactory.variable!(`${variablePrefix}QudtQuantityKindJExpression`), predicate: dataFactory.namedNode("http://qudt.org/schema/qudt/expression"), subject }, { object: dataFactory.variable!(`${variablePrefix}QudtQuantityKindJHasDimensionVector`), predicate: dataFactory.namedNode("http://qudt.org/schema/qudt/hasDimensionVector"), subject }, ...Quantity_Kind$W$Dimension$W$Vector.sparqlConstructTemplateTriples({ ignoreRdfType: true, subject: dataFactory.variable!(`${variablePrefix}QudtQuantityKindJHasDimensionVector`), variablePrefix: `${variablePrefix}QudtQuantityKindJHasDimensionVector` }), { object: dataFactory.variable!(`${variablePrefix}QudtQuantityKindJIec61360Code`), predicate: dataFactory.namedNode("http://qudt.org/schema/qudt/iec61360Code"), subject }, { object: dataFactory.variable!(`${variablePrefix}QudtQuantityKindJLatexDefinition`), predicate: dataFactory.namedNode("http://qudt.org/schema/qudt/latexDefinition"), subject }, { object: dataFactory.variable!(`${variablePrefix}QudtQuantityKindJMathMLdefinition`), predicate: dataFactory.namedNode("http://qudt.org/schema/qudt/mathMLdefinition"), subject }, { object: dataFactory.variable!(`${variablePrefix}QudtQuantityKindJQkdvDenominator`), predicate: dataFactory.namedNode("http://qudt.org/schema/qudt/qkdvDenominator"), subject }, ...Quantity_Kind$W$Dimension$W$Vector.sparqlConstructTemplateTriples({ ignoreRdfType: true, subject: dataFactory.variable!(`${variablePrefix}QudtQuantityKindJQkdvDenominator`), variablePrefix: `${variablePrefix}QudtQuantityKindJQkdvDenominator` }), { object: dataFactory.variable!(`${variablePrefix}QudtQuantityKindJQkdvNumerator`), predicate: dataFactory.namedNode("http://qudt.org/schema/qudt/qkdvNumerator"), subject }, ...Quantity_Kind$W$Dimension$W$Vector.sparqlConstructTemplateTriples({ ignoreRdfType: true, subject: dataFactory.variable!(`${variablePrefix}QudtQuantityKindJQkdvNumerator`), variablePrefix: `${variablePrefix}QudtQuantityKindJQkdvNumerator` }), { object: dataFactory.variable!(`${variablePrefix}QudtQuantityKindJSiExactMatch`), predicate: dataFactory.namedNode("http://qudt.org/schema/qudt/siExactMatch"), subject }];
    }

    export function sparqlWherePatterns(parameters: { ignoreRdfType?: boolean; subject?: sparqljs.Triple["subject"], variablePrefix?: string }): readonly sparqljs.Pattern[] {
        const subject = parameters?.subject ?? dataFactory.variable!("quantityKind");
        const variablePrefix = parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "quantityKind");
        return [...Quantity_Kind$W$$e$abstract$f$.sparqlWherePatterns({ ignoreRdfType: true, subject, variablePrefix }), ...(parameters?.ignoreRdfType ? [] : [{ triples: [{ subject, predicate: dataFactory.namedNode("http://www.w3.org/1999/02/22-rdf-syntax-ns#type"), object: dataFactory.namedNode("http://qudt.org/schema/qudt/QuantityKind") }], type: "bgp" as const }, { triples: [{ subject, predicate: dataFactory.namedNode("http://www.w3.org/1999/02/22-rdf-syntax-ns#type"), object: dataFactory.variable!(`${variablePrefix}RdfType`) }], type: "bgp" as const }]), { patterns: [{ triples: [{ object: dataFactory.variable!(`${variablePrefix}QudtQuantityKindJApplicableCgsUnit`), predicate: dataFactory.namedNode("http://qudt.org/schema/qudt/applicableCGSUnit"), subject }], type: "bgp" }, ...Abstract_Unit.sparqlWherePatterns({ ignoreRdfType: true, subject: dataFactory.variable!(`${variablePrefix}QudtQuantityKindJApplicableCgsUnit`), variablePrefix: `${variablePrefix}QudtQuantityKindJApplicableCgsUnit` })], type: "optional" }, { patterns: [{ triples: [{ object: dataFactory.variable!(`${variablePrefix}QudtQuantityKindJApplicableImperialUnit`), predicate: dataFactory.namedNode("http://qudt.org/schema/qudt/applicableImperialUnit"), subject }], type: "bgp" }, ...Abstract_Unit.sparqlWherePatterns({ ignoreRdfType: true, subject: dataFactory.variable!(`${variablePrefix}QudtQuantityKindJApplicableImperialUnit`), variablePrefix: `${variablePrefix}QudtQuantityKindJApplicableImperialUnit` })], type: "optional" }, { patterns: [{ triples: [{ object: dataFactory.variable!(`${variablePrefix}QudtQuantityKindJApplicableIsoUnit`), predicate: dataFactory.namedNode("http://qudt.org/schema/qudt/applicableISOUnit"), subject }], type: "bgp" }, ...Abstract_Unit.sparqlWherePatterns({ ignoreRdfType: true, subject: dataFactory.variable!(`${variablePrefix}QudtQuantityKindJApplicableIsoUnit`), variablePrefix: `${variablePrefix}QudtQuantityKindJApplicableIsoUnit` })], type: "optional" }, { patterns: [{ triples: [{ object: dataFactory.variable!(`${variablePrefix}QudtQuantityKindJApplicableSiUnit`), predicate: dataFactory.namedNode("http://qudt.org/schema/qudt/applicableSIUnit"), subject }], type: "bgp" }, ...Abstract_Unit.sparqlWherePatterns({ ignoreRdfType: true, subject: dataFactory.variable!(`${variablePrefix}QudtQuantityKindJApplicableSiUnit`), variablePrefix: `${variablePrefix}QudtQuantityKindJApplicableSiUnit` })], type: "optional" }, { patterns: [{ triples: [{ object: dataFactory.variable!(`${variablePrefix}QudtQuantityKindJApplicableUnit`), predicate: dataFactory.namedNode("http://qudt.org/schema/qudt/applicableUnit"), subject }], type: "bgp" }, ...Abstract_Unit.sparqlWherePatterns({ ignoreRdfType: true, subject: dataFactory.variable!(`${variablePrefix}QudtQuantityKindJApplicableUnit`), variablePrefix: `${variablePrefix}QudtQuantityKindJApplicableUnit` })], type: "optional" }, { patterns: [{ triples: [{ object: dataFactory.variable!(`${variablePrefix}QudtQuantityKindJApplicableUsCustomaryUnit`), predicate: dataFactory.namedNode("http://qudt.org/schema/qudt/applicableUSCustomaryUnit"), subject }], type: "bgp" }, ...Abstract_Unit.sparqlWherePatterns({ ignoreRdfType: true, subject: dataFactory.variable!(`${variablePrefix}QudtQuantityKindJApplicableUsCustomaryUnit`), variablePrefix: `${variablePrefix}QudtQuantityKindJApplicableUsCustomaryUnit` })], type: "optional" }, { patterns: [{ triples: [{ object: dataFactory.variable!(`${variablePrefix}QudtQuantityKindJBaseCgsUnitDimensions`), predicate: dataFactory.namedNode("http://qudt.org/schema/qudt/baseCGSUnitDimensions"), subject }], type: "bgp" }], type: "optional" }, { patterns: [{ triples: [{ object: dataFactory.variable!(`${variablePrefix}QudtQuantityKindJBaseImperialUnitDimensions`), predicate: dataFactory.namedNode("http://qudt.org/schema/qudt/baseImperialUnitDimensions"), subject }], type: "bgp" }], type: "optional" }, { patterns: [{ triples: [{ object: dataFactory.variable!(`${variablePrefix}QudtQuantityKindJBaseIsoUnitDimensions`), predicate: dataFactory.namedNode("http://qudt.org/schema/qudt/baseISOUnitDimensions"), subject }], type: "bgp" }], type: "optional" }, { patterns: [{ triples: [{ object: dataFactory.variable!(`${variablePrefix}QudtQuantityKindJBaseSiUnitDimensions`), predicate: dataFactory.namedNode("http://qudt.org/schema/qudt/baseSIUnitDimensions"), subject }], type: "bgp" }], type: "optional" }, { patterns: [{ triples: [{ object: dataFactory.variable!(`${variablePrefix}QudtQuantityKindJBaseUsCustomaryUnitDimensions`), predicate: dataFactory.namedNode("http://qudt.org/schema/qudt/baseUSCustomaryUnitDimensions"), subject }], type: "bgp" }], type: "optional" }, { patterns: [{ triples: [{ object: dataFactory.variable!(`${variablePrefix}QudtQuantityKindJBelongsToSystemOfQuantities`), predicate: dataFactory.namedNode("http://qudt.org/schema/qudt/belongsToSystemOfQuantities"), subject }], type: "bgp" }, ...System_of$W$Quantity$W$Kinds.sparqlWherePatterns({ ignoreRdfType: true, subject: dataFactory.variable!(`${variablePrefix}QudtQuantityKindJBelongsToSystemOfQuantities`), variablePrefix: `${variablePrefix}QudtQuantityKindJBelongsToSystemOfQuantities` })], type: "optional" }, { patterns: [{ triples: [{ object: dataFactory.variable!(`${variablePrefix}QudtQuantityKindJDimensionVectorForSi`), predicate: dataFactory.namedNode("http://qudt.org/schema/qudt/dimensionVectorForSI"), subject }], type: "bgp" }, ...Quantity_Kind$W$Dimension$W$vector$W$$e$SI$f$.sparqlWherePatterns({ ignoreRdfType: true, subject: dataFactory.variable!(`${variablePrefix}QudtQuantityKindJDimensionVectorForSi`), variablePrefix: `${variablePrefix}QudtQuantityKindJDimensionVectorForSi` })], type: "optional" }, { patterns: [{ triples: [{ object: dataFactory.variable!(`${variablePrefix}QudtQuantityKindJExpression`), predicate: dataFactory.namedNode("http://qudt.org/schema/qudt/expression"), subject }], type: "bgp" }], type: "optional" }, { triples: [{ object: dataFactory.variable!(`${variablePrefix}QudtQuantityKindJHasDimensionVector`), predicate: dataFactory.namedNode("http://qudt.org/schema/qudt/hasDimensionVector"), subject }], type: "bgp" }, ...Quantity_Kind$W$Dimension$W$Vector.sparqlWherePatterns({ ignoreRdfType: true, subject: dataFactory.variable!(`${variablePrefix}QudtQuantityKindJHasDimensionVector`), variablePrefix: `${variablePrefix}QudtQuantityKindJHasDimensionVector` }), { patterns: [{ triples: [{ object: dataFactory.variable!(`${variablePrefix}QudtQuantityKindJIec61360Code`), predicate: dataFactory.namedNode("http://qudt.org/schema/qudt/iec61360Code"), subject }], type: "bgp" }], type: "optional" }, { patterns: [{ triples: [{ object: dataFactory.variable!(`${variablePrefix}QudtQuantityKindJLatexDefinition`), predicate: dataFactory.namedNode("http://qudt.org/schema/qudt/latexDefinition"), subject }], type: "bgp" }], type: "optional" }, { patterns: [{ triples: [{ object: dataFactory.variable!(`${variablePrefix}QudtQuantityKindJMathMLdefinition`), predicate: dataFactory.namedNode("http://qudt.org/schema/qudt/mathMLdefinition"), subject }], type: "bgp" }], type: "optional" }, { patterns: [{ triples: [{ object: dataFactory.variable!(`${variablePrefix}QudtQuantityKindJQkdvDenominator`), predicate: dataFactory.namedNode("http://qudt.org/schema/qudt/qkdvDenominator"), subject }], type: "bgp" }, ...Quantity_Kind$W$Dimension$W$Vector.sparqlWherePatterns({ ignoreRdfType: true, subject: dataFactory.variable!(`${variablePrefix}QudtQuantityKindJQkdvDenominator`), variablePrefix: `${variablePrefix}QudtQuantityKindJQkdvDenominator` })], type: "optional" }, { patterns: [{ triples: [{ object: dataFactory.variable!(`${variablePrefix}QudtQuantityKindJQkdvNumerator`), predicate: dataFactory.namedNode("http://qudt.org/schema/qudt/qkdvNumerator"), subject }], type: "bgp" }, ...Quantity_Kind$W$Dimension$W$Vector.sparqlWherePatterns({ ignoreRdfType: true, subject: dataFactory.variable!(`${variablePrefix}QudtQuantityKindJQkdvNumerator`), variablePrefix: `${variablePrefix}QudtQuantityKindJQkdvNumerator` })], type: "optional" }, { patterns: [{ triples: [{ object: dataFactory.variable!(`${variablePrefix}QudtQuantityKindJSiExactMatch`), predicate: dataFactory.namedNode("http://qudt.org/schema/qudt/siExactMatch"), subject }], type: "bgp" }], type: "optional" }];
    }
}
/**
 * Quantifiable
 */
export class Quantifiable extends QUDT_Aspect {
    override readonly type = "Quantifiable";
    readonly qudt_Quantifiable$j$datatype: purify.Maybe<(rdfjs.BlankNode | rdfjs.NamedNode | rdfjs.Literal)>;
    readonly qudt_Quantifiable$j$hasUnit: purify.Maybe<Abstract_Unit>;
    readonly qudt_Quantifiable$j$relativeStandardUncertainty: purify.Maybe<number>;
    readonly qudt_Quantifiable$j$standardUncertainty: purify.Maybe<number>;
    readonly qudt_Quantifiable$j$standardUncertaintySN: purify.Maybe<number>;
    readonly qudt_Quantifiable$j$value: purify.Maybe<_$w$n3$j$169>;
    readonly qudt_Quantifiable$j$valueSN: purify.Maybe<(rdfjs.BlankNode | rdfjs.NamedNode | rdfjs.Literal)>;

    constructor(parameters: { readonly identifier?: (rdfjs.BlankNode | rdfjs.NamedNode) | string, readonly qudt_Quantifiable$j$datatype?: (rdfjs.BlankNode | rdfjs.NamedNode | rdfjs.Literal) | Date | boolean | number | purify.Maybe<(rdfjs.BlankNode | rdfjs.NamedNode | rdfjs.Literal)> | string, readonly qudt_Quantifiable$j$hasUnit?: Abstract_Unit | purify.Maybe<Abstract_Unit>, readonly qudt_Quantifiable$j$relativeStandardUncertainty?: number | purify.Maybe<number>, readonly qudt_Quantifiable$j$standardUncertainty?: number | purify.Maybe<number>, readonly qudt_Quantifiable$j$standardUncertaintySN?: number | purify.Maybe<number>, readonly qudt_Quantifiable$j$value?: _$w$n3$j$169 | purify.Maybe<_$w$n3$j$169>, readonly qudt_Quantifiable$j$valueSN?: (rdfjs.BlankNode | rdfjs.NamedNode | rdfjs.Literal) | Date | boolean | number | purify.Maybe<(rdfjs.BlankNode | rdfjs.NamedNode | rdfjs.Literal)> | string } & ConstructorParameters<typeof QUDT_Aspect>[0]) {
        super(parameters);
        if (purify.Maybe.isMaybe(parameters.qudt_Quantifiable$j$datatype)) { this.qudt_Quantifiable$j$datatype = parameters.qudt_Quantifiable$j$datatype; } else if (typeof parameters.qudt_Quantifiable$j$datatype === "boolean") { this.qudt_Quantifiable$j$datatype = purify.Maybe.of(rdfLiteral.toRdf(parameters.qudt_Quantifiable$j$datatype, { dataFactory })); } else if (typeof parameters.qudt_Quantifiable$j$datatype === "object" && parameters.qudt_Quantifiable$j$datatype instanceof Date) { this.qudt_Quantifiable$j$datatype = purify.Maybe.of(rdfLiteral.toRdf(parameters.qudt_Quantifiable$j$datatype, { dataFactory })); } else if (typeof parameters.qudt_Quantifiable$j$datatype === "number") { this.qudt_Quantifiable$j$datatype = purify.Maybe.of(rdfLiteral.toRdf(parameters.qudt_Quantifiable$j$datatype, { dataFactory })); } else if (typeof parameters.qudt_Quantifiable$j$datatype === "string") { this.qudt_Quantifiable$j$datatype = purify.Maybe.of(dataFactory.literal(parameters.qudt_Quantifiable$j$datatype)); } else if (typeof parameters.qudt_Quantifiable$j$datatype === "object") { this.qudt_Quantifiable$j$datatype = purify.Maybe.of(parameters.qudt_Quantifiable$j$datatype); } else if (typeof parameters.qudt_Quantifiable$j$datatype === "undefined") { this.qudt_Quantifiable$j$datatype = purify.Maybe.empty(); } else { this.qudt_Quantifiable$j$datatype =( parameters.qudt_Quantifiable$j$datatype) as never;
         }

        if (purify.Maybe.isMaybe(parameters.qudt_Quantifiable$j$hasUnit)) { this.qudt_Quantifiable$j$hasUnit = parameters.qudt_Quantifiable$j$hasUnit; } else if (typeof parameters.qudt_Quantifiable$j$hasUnit === "object" && parameters.qudt_Quantifiable$j$hasUnit instanceof Abstract_Unit) { this.qudt_Quantifiable$j$hasUnit = purify.Maybe.of(parameters.qudt_Quantifiable$j$hasUnit); } else if (typeof parameters.qudt_Quantifiable$j$hasUnit === "undefined") { this.qudt_Quantifiable$j$hasUnit = purify.Maybe.empty(); } else { this.qudt_Quantifiable$j$hasUnit =( parameters.qudt_Quantifiable$j$hasUnit) as never;
         }

        if (purify.Maybe.isMaybe(parameters.qudt_Quantifiable$j$relativeStandardUncertainty)) { this.qudt_Quantifiable$j$relativeStandardUncertainty = parameters.qudt_Quantifiable$j$relativeStandardUncertainty; } else if (typeof parameters.qudt_Quantifiable$j$relativeStandardUncertainty === "number") { this.qudt_Quantifiable$j$relativeStandardUncertainty = purify.Maybe.of(parameters.qudt_Quantifiable$j$relativeStandardUncertainty); } else if (typeof parameters.qudt_Quantifiable$j$relativeStandardUncertainty === "undefined") { this.qudt_Quantifiable$j$relativeStandardUncertainty = purify.Maybe.empty(); } else { this.qudt_Quantifiable$j$relativeStandardUncertainty =( parameters.qudt_Quantifiable$j$relativeStandardUncertainty) as never;
         }

        if (purify.Maybe.isMaybe(parameters.qudt_Quantifiable$j$standardUncertainty)) { this.qudt_Quantifiable$j$standardUncertainty = parameters.qudt_Quantifiable$j$standardUncertainty; } else if (typeof parameters.qudt_Quantifiable$j$standardUncertainty === "number") { this.qudt_Quantifiable$j$standardUncertainty = purify.Maybe.of(parameters.qudt_Quantifiable$j$standardUncertainty); } else if (typeof parameters.qudt_Quantifiable$j$standardUncertainty === "undefined") { this.qudt_Quantifiable$j$standardUncertainty = purify.Maybe.empty(); } else { this.qudt_Quantifiable$j$standardUncertainty =( parameters.qudt_Quantifiable$j$standardUncertainty) as never;
         }

        if (purify.Maybe.isMaybe(parameters.qudt_Quantifiable$j$standardUncertaintySN)) { this.qudt_Quantifiable$j$standardUncertaintySN = parameters.qudt_Quantifiable$j$standardUncertaintySN; } else if (typeof parameters.qudt_Quantifiable$j$standardUncertaintySN === "number") { this.qudt_Quantifiable$j$standardUncertaintySN = purify.Maybe.of(parameters.qudt_Quantifiable$j$standardUncertaintySN); } else if (typeof parameters.qudt_Quantifiable$j$standardUncertaintySN === "undefined") { this.qudt_Quantifiable$j$standardUncertaintySN = purify.Maybe.empty(); } else { this.qudt_Quantifiable$j$standardUncertaintySN =( parameters.qudt_Quantifiable$j$standardUncertaintySN) as never;
         }

        if (purify.Maybe.isMaybe(parameters.qudt_Quantifiable$j$value)) { this.qudt_Quantifiable$j$value = parameters.qudt_Quantifiable$j$value; } else if (typeof parameters.qudt_Quantifiable$j$value === "object" && parameters.qudt_Quantifiable$j$value instanceof _$w$n3$j$169) { this.qudt_Quantifiable$j$value = purify.Maybe.of(parameters.qudt_Quantifiable$j$value); } else if (typeof parameters.qudt_Quantifiable$j$value === "undefined") { this.qudt_Quantifiable$j$value = purify.Maybe.empty(); } else { this.qudt_Quantifiable$j$value =( parameters.qudt_Quantifiable$j$value) as never;
         }

        if (purify.Maybe.isMaybe(parameters.qudt_Quantifiable$j$valueSN)) { this.qudt_Quantifiable$j$valueSN = parameters.qudt_Quantifiable$j$valueSN; } else if (typeof parameters.qudt_Quantifiable$j$valueSN === "boolean") { this.qudt_Quantifiable$j$valueSN = purify.Maybe.of(rdfLiteral.toRdf(parameters.qudt_Quantifiable$j$valueSN, { dataFactory })); } else if (typeof parameters.qudt_Quantifiable$j$valueSN === "object" && parameters.qudt_Quantifiable$j$valueSN instanceof Date) { this.qudt_Quantifiable$j$valueSN = purify.Maybe.of(rdfLiteral.toRdf(parameters.qudt_Quantifiable$j$valueSN, { dataFactory })); } else if (typeof parameters.qudt_Quantifiable$j$valueSN === "number") { this.qudt_Quantifiable$j$valueSN = purify.Maybe.of(rdfLiteral.toRdf(parameters.qudt_Quantifiable$j$valueSN, { dataFactory })); } else if (typeof parameters.qudt_Quantifiable$j$valueSN === "string") { this.qudt_Quantifiable$j$valueSN = purify.Maybe.of(dataFactory.literal(parameters.qudt_Quantifiable$j$valueSN)); } else if (typeof parameters.qudt_Quantifiable$j$valueSN === "object") { this.qudt_Quantifiable$j$valueSN = purify.Maybe.of(parameters.qudt_Quantifiable$j$valueSN); } else if (typeof parameters.qudt_Quantifiable$j$valueSN === "undefined") { this.qudt_Quantifiable$j$valueSN = purify.Maybe.empty(); } else { this.qudt_Quantifiable$j$valueSN =( parameters.qudt_Quantifiable$j$valueSN) as never;
         }
    }

    override get identifier(): (rdfjs.BlankNode | rdfjs.NamedNode) {
        if (typeof this._identifier === "undefined") { this._identifier = dataFactory.blankNode(); } return this._identifier;
    }

    override equals(other: Quantifiable): EqualsResult {
        return super.equals(other).chain(() => (((left, right) => maybeEquals(left, right, booleanEquals)))(this.qudt_Quantifiable$j$datatype, other.qudt_Quantifiable$j$datatype).mapLeft(propertyValuesUnequal => ({ left: this, right: other, propertyName: "qudt_Quantifiable$j$datatype", propertyValuesUnequal, type: "Property" as const }))).chain(() => (((left, right) => maybeEquals(left, right, ((left, right) => left.equals(right)))))(this.qudt_Quantifiable$j$hasUnit, other.qudt_Quantifiable$j$hasUnit).mapLeft(propertyValuesUnequal => ({ left: this, right: other, propertyName: "qudt_Quantifiable$j$hasUnit", propertyValuesUnequal, type: "Property" as const }))).chain(() => (((left, right) => maybeEquals(left, right, strictEquals)))(this.qudt_Quantifiable$j$relativeStandardUncertainty, other.qudt_Quantifiable$j$relativeStandardUncertainty).mapLeft(propertyValuesUnequal => ({ left: this, right: other, propertyName: "qudt_Quantifiable$j$relativeStandardUncertainty", propertyValuesUnequal, type: "Property" as const }))).chain(() => (((left, right) => maybeEquals(left, right, strictEquals)))(this.qudt_Quantifiable$j$standardUncertainty, other.qudt_Quantifiable$j$standardUncertainty).mapLeft(propertyValuesUnequal => ({ left: this, right: other, propertyName: "qudt_Quantifiable$j$standardUncertainty", propertyValuesUnequal, type: "Property" as const }))).chain(() => (((left, right) => maybeEquals(left, right, strictEquals)))(this.qudt_Quantifiable$j$standardUncertaintySN, other.qudt_Quantifiable$j$standardUncertaintySN).mapLeft(propertyValuesUnequal => ({ left: this, right: other, propertyName: "qudt_Quantifiable$j$standardUncertaintySN", propertyValuesUnequal, type: "Property" as const }))).chain(() => (((left, right) => maybeEquals(left, right, ((left, right) => left.equals(right)))))(this.qudt_Quantifiable$j$value, other.qudt_Quantifiable$j$value).mapLeft(propertyValuesUnequal => ({ left: this, right: other, propertyName: "qudt_Quantifiable$j$value", propertyValuesUnequal, type: "Property" as const }))).chain(() => (((left, right) => maybeEquals(left, right, booleanEquals)))(this.qudt_Quantifiable$j$valueSN, other.qudt_Quantifiable$j$valueSN).mapLeft(propertyValuesUnequal => ({ left: this, right: other, propertyName: "qudt_Quantifiable$j$valueSN", propertyValuesUnequal, type: "Property" as const })));
    }

    override hash<HasherT extends { update: (message: string | number[] | ArrayBuffer | Uint8Array) => void; }>(_hasher: HasherT): HasherT {
        this.hashShaclProperties(_hasher);
        return _hasher;
    }

    protected override hashShaclProperties<HasherT extends { update: (message: string | number[] | ArrayBuffer | Uint8Array) => void; }>(_hasher: HasherT): HasherT {
        super.hashShaclProperties(_hasher);
        this.qudt_Quantifiable$j$datatype.ifJust((_value0) => { _hasher.update(_value0.termType);
        _hasher.update(_value0.value); })
        this.qudt_Quantifiable$j$hasUnit.ifJust((_value0) => { _value0.hash(_hasher); })
        this.qudt_Quantifiable$j$relativeStandardUncertainty.ifJust((_value0) => { _hasher.update(_value0.toString()); })
        this.qudt_Quantifiable$j$standardUncertainty.ifJust((_value0) => { _hasher.update(_value0.toString()); })
        this.qudt_Quantifiable$j$standardUncertaintySN.ifJust((_value0) => { _hasher.update(_value0.toString()); })
        this.qudt_Quantifiable$j$value.ifJust((_value0) => { _value0.hash(_hasher); })
        this.qudt_Quantifiable$j$valueSN.ifJust((_value0) => { _hasher.update(_value0.termType);
        _hasher.update(_value0.value); })
        return _hasher;
    }

    override toJson(): { readonly "qudt_Quantifiable$j$datatype": ({ readonly "@id": string, readonly termType: "BlankNode" | "NamedNode" } | { readonly "@language": string | undefined, readonly "@type": string | undefined, readonly "@value": string, readonly termType: "Literal" }) | undefined; readonly "qudt_Quantifiable$j$hasUnit": (ReturnType<Abstract_Unit["toJson"]>) | undefined; readonly "qudt_Quantifiable$j$relativeStandardUncertainty": (number) | undefined; readonly "qudt_Quantifiable$j$standardUncertainty": (number) | undefined; readonly "qudt_Quantifiable$j$standardUncertaintySN": (number) | undefined; readonly "qudt_Quantifiable$j$value": (ReturnType<_$w$n3$j$169["toJson"]>) | undefined; readonly "qudt_Quantifiable$j$valueSN": ({ readonly "@id": string, readonly termType: "BlankNode" | "NamedNode" } | { readonly "@language": string | undefined, readonly "@type": string | undefined, readonly "@value": string, readonly termType: "Literal" }) | undefined } & ReturnType<QUDT_Aspect["toJson"]> {
        return JSON.parse(JSON.stringify({ ...super.toJson(),qudt_Quantifiable$j$datatype: this.qudt_Quantifiable$j$datatype.map(_item => ((_item.termType === "Literal") ? { "@language": _item.language.length > 0 ? _item.language : undefined, "@type": _item.datatype.value !== "http://www.w3.org/2001/XMLSchema#string" ? _item.datatype.value : undefined, "@value": _item.value, termType: "Literal" as const } : (_item.termType === "NamedNode") ? { "@id": _item.value, termType: "NamedNode" as const } : { "@id": `_:${_item.value}`, termType: "BlankNode" as const })).extract(),qudt_Quantifiable$j$hasUnit: this.qudt_Quantifiable$j$hasUnit.map(_item => (_item.toJson())).extract(),qudt_Quantifiable$j$relativeStandardUncertainty: this.qudt_Quantifiable$j$relativeStandardUncertainty.map(_item => (_item)).extract(),qudt_Quantifiable$j$standardUncertainty: this.qudt_Quantifiable$j$standardUncertainty.map(_item => (_item)).extract(),qudt_Quantifiable$j$standardUncertaintySN: this.qudt_Quantifiable$j$standardUncertaintySN.map(_item => (_item)).extract(),qudt_Quantifiable$j$value: this.qudt_Quantifiable$j$value.map(_item => (_item.toJson())).extract(),qudt_Quantifiable$j$valueSN: this.qudt_Quantifiable$j$valueSN.map(_item => ((_item.termType === "Literal") ? { "@language": _item.language.length > 0 ? _item.language : undefined, "@type": _item.datatype.value !== "http://www.w3.org/2001/XMLSchema#string" ? _item.datatype.value : undefined, "@value": _item.value, termType: "Literal" as const } : (_item.termType === "NamedNode") ? { "@id": _item.value, termType: "NamedNode" as const } : { "@id": `_:${_item.value}`, termType: "BlankNode" as const })).extract() } satisfies ReturnType<Quantifiable["toJson"]>));
    }

    override toRdf({ ignoreRdfType, mutateGraph, resourceSet }: { ignoreRdfType?: boolean; mutateGraph?: rdfjsResource.MutableResource.MutateGraph, resourceSet: rdfjsResource.MutableResourceSet }): rdfjsResource.MutableResource {
        const _resource = super.toRdf({ ignoreRdfType: true, mutateGraph, resourceSet });
        if (!ignoreRdfType) { _resource.add(_resource.dataFactory.namedNode("http://www.w3.org/1999/02/22-rdf-syntax-ns#type"), _resource.dataFactory.namedNode("http://qudt.org/schema/qudt/Quantifiable")); }

        _resource.add(dataFactory.namedNode("http://qudt.org/schema/qudt/datatype"), this.qudt_Quantifiable$j$datatype);
        _resource.add(dataFactory.namedNode("http://qudt.org/schema/qudt/hasUnit"), this.qudt_Quantifiable$j$hasUnit.map((_value) => _value.toRdf({ mutateGraph: mutateGraph, resourceSet: resourceSet })));
        _resource.add(dataFactory.namedNode("http://qudt.org/schema/qudt/relativeStandardUncertainty"), this.qudt_Quantifiable$j$relativeStandardUncertainty);
        _resource.add(dataFactory.namedNode("http://qudt.org/schema/qudt/standardUncertainty"), this.qudt_Quantifiable$j$standardUncertainty);
        _resource.add(dataFactory.namedNode("http://qudt.org/schema/qudt/standardUncertaintySN"), this.qudt_Quantifiable$j$standardUncertaintySN);
        _resource.add(dataFactory.namedNode("http://qudt.org/schema/qudt/value"), this.qudt_Quantifiable$j$value.map((_value) => _value.toRdf({ mutateGraph: mutateGraph, resourceSet: resourceSet })));
        _resource.add(dataFactory.namedNode("http://qudt.org/schema/qudt/valueSN"), this.qudt_Quantifiable$j$valueSN);
        return _resource;
    }

    override toString(): string {
        return JSON.stringify(this.toJson());
    }
}

export namespace Quantifiable {
    export function _propertiesFromJson(_json: unknown): purify.Either<zod.ZodError, { identifier: (rdfjs.BlankNode | rdfjs.NamedNode); qudt_Quantifiable$j$datatype: purify.Maybe<(rdfjs.BlankNode | rdfjs.NamedNode | rdfjs.Literal)>; qudt_Quantifiable$j$hasUnit: purify.Maybe<Abstract_Unit>; qudt_Quantifiable$j$relativeStandardUncertainty: purify.Maybe<number>; qudt_Quantifiable$j$standardUncertainty: purify.Maybe<number>; qudt_Quantifiable$j$standardUncertaintySN: purify.Maybe<number>; qudt_Quantifiable$j$value: purify.Maybe<_$w$n3$j$169>; qudt_Quantifiable$j$valueSN: purify.Maybe<(rdfjs.BlankNode | rdfjs.NamedNode | rdfjs.Literal)>; } & UnwrapR<ReturnType<typeof QUDT_Aspect._propertiesFromJson>>> {
        const _jsonSafeParseResult = quantifiableJsonZodSchema().safeParse(_json);
        if (!_jsonSafeParseResult.success) { return purify.Left(_jsonSafeParseResult.error); }

        const _jsonObject = _jsonSafeParseResult.data;
        const _super0Either = QUDT_Aspect._propertiesFromJson(_jsonObject);
        if (_super0Either.isLeft()) { return _super0Either; }

        const _super0 = _super0Either.unsafeCoerce()
        const identifier = (_jsonObject["@id"].startsWith("_:") ? dataFactory.blankNode(_jsonObject["@id"].substring(2)) : dataFactory.namedNode(_jsonObject["@id"]));
        const qudt_Quantifiable$j$datatype = purify.Maybe.fromNullable(_jsonObject["qudt_Quantifiable$j$datatype"]).map(_item => (((_item.termType === "Literal") ? (dataFactory.literal(_item["@value"], typeof _item["@language"] !== "undefined" ? _item["@language"] : (typeof _item["@type"] !== "undefined" ? dataFactory.namedNode(_item["@type"]) : undefined))) : (((_item.termType === "NamedNode") ? (dataFactory.namedNode(_item["@id"])) : (dataFactory.blankNode(_item["@id"].substring(2))))))));
        const qudt_Quantifiable$j$hasUnit = purify.Maybe.fromNullable(_jsonObject["qudt_Quantifiable$j$hasUnit"]).map(_item => (Abstract_Unit.fromJson(_item).unsafeCoerce()));
        const qudt_Quantifiable$j$relativeStandardUncertainty = purify.Maybe.fromNullable(_jsonObject["qudt_Quantifiable$j$relativeStandardUncertainty"]);
        const qudt_Quantifiable$j$standardUncertainty = purify.Maybe.fromNullable(_jsonObject["qudt_Quantifiable$j$standardUncertainty"]);
        const qudt_Quantifiable$j$standardUncertaintySN = purify.Maybe.fromNullable(_jsonObject["qudt_Quantifiable$j$standardUncertaintySN"]);
        const qudt_Quantifiable$j$value = purify.Maybe.fromNullable(_jsonObject["qudt_Quantifiable$j$value"]).map(_item => (_$w$n3$j$169.fromJson(_item).unsafeCoerce()));
        const qudt_Quantifiable$j$valueSN = purify.Maybe.fromNullable(_jsonObject["qudt_Quantifiable$j$valueSN"]).map(_item => (((_item.termType === "Literal") ? (dataFactory.literal(_item["@value"], typeof _item["@language"] !== "undefined" ? _item["@language"] : (typeof _item["@type"] !== "undefined" ? dataFactory.namedNode(_item["@type"]) : undefined))) : (((_item.termType === "NamedNode") ? (dataFactory.namedNode(_item["@id"])) : (dataFactory.blankNode(_item["@id"].substring(2))))))));
        return purify.Either.of({ ..._super0, identifier, qudt_Quantifiable$j$datatype, qudt_Quantifiable$j$hasUnit, qudt_Quantifiable$j$relativeStandardUncertainty, qudt_Quantifiable$j$standardUncertainty, qudt_Quantifiable$j$standardUncertaintySN, qudt_Quantifiable$j$value, qudt_Quantifiable$j$valueSN })
    }

    export function fromJson(json: unknown): purify.Either<zod.ZodError, Quantifiable> {
        return Quantifiable._propertiesFromJson(json).map(properties => new Quantifiable(properties));
    }

    export function _propertiesFromRdf({ ignoreRdfType: _ignoreRdfType, languageIn: _languageIn, resource: _resource,
        // @ts-ignore
        ..._context }: { [_index: string]: any; ignoreRdfType?: boolean; languageIn?: readonly string[]; resource: rdfjsResource.Resource; }): purify.Either<rdfjsResource.Resource.ValueError, { identifier: (rdfjs.BlankNode | rdfjs.NamedNode); qudt_Quantifiable$j$datatype: purify.Maybe<(rdfjs.BlankNode | rdfjs.NamedNode | rdfjs.Literal)>; qudt_Quantifiable$j$hasUnit: purify.Maybe<Abstract_Unit>; qudt_Quantifiable$j$relativeStandardUncertainty: purify.Maybe<number>; qudt_Quantifiable$j$standardUncertainty: purify.Maybe<number>; qudt_Quantifiable$j$standardUncertaintySN: purify.Maybe<number>; qudt_Quantifiable$j$value: purify.Maybe<_$w$n3$j$169>; qudt_Quantifiable$j$valueSN: purify.Maybe<(rdfjs.BlankNode | rdfjs.NamedNode | rdfjs.Literal)>; } & UnwrapR<ReturnType<typeof QUDT_Aspect._propertiesFromRdf>>> {
        const _super0Either = QUDT_Aspect._propertiesFromRdf({ ..._context, ignoreRdfType: true, languageIn: _languageIn, resource: _resource });
        if (_super0Either.isLeft()) { return _super0Either; }

        const _super0 = _super0Either.unsafeCoerce()
        if (!_ignoreRdfType && !_resource.isInstanceOf(dataFactory.namedNode("http://qudt.org/schema/qudt/Quantifiable"))) { return purify.Left(new rdfjsResource.Resource.ValueError({ focusResource: _resource, message: `${rdfjsResource.Resource.Identifier.toString(_resource.identifier)} has unexpected RDF type (expected http://qudt.org/schema/qudt/Quantifiable)`, predicate: dataFactory.namedNode("http://qudt.org/schema/qudt/Quantifiable") })); }

        const identifier = _resource.identifier
        const _qudt_Quantifiable$j$datatypeEither: purify.Either<rdfjsResource.Resource.ValueError, purify.Maybe<(rdfjs.BlankNode | rdfjs.NamedNode | rdfjs.Literal)>> = purify.Either.of(_resource.values(dataFactory.namedNode("http://qudt.org/schema/qudt/datatype"), { unique: true }).head().chain(_value => purify.Either.of(_value.toTerm())).toMaybe());
        if (_qudt_Quantifiable$j$datatypeEither.isLeft()) { return _qudt_Quantifiable$j$datatypeEither; }

        const qudt_Quantifiable$j$datatype = _qudt_Quantifiable$j$datatypeEither.unsafeCoerce();
        const _qudt_Quantifiable$j$hasUnitEither: purify.Either<rdfjsResource.Resource.ValueError, purify.Maybe<Abstract_Unit>> = purify.Either.of(_resource.values(dataFactory.namedNode("http://qudt.org/schema/qudt/hasUnit"), { unique: true }).head().chain(value => value.toResource()).chain(_resource => Abstract_Unit.fromRdf({ ..._context, ignoreRdfType: true, languageIn: _languageIn, resource: _resource })).toMaybe());
        if (_qudt_Quantifiable$j$hasUnitEither.isLeft()) { return _qudt_Quantifiable$j$hasUnitEither; }

        const qudt_Quantifiable$j$hasUnit = _qudt_Quantifiable$j$hasUnitEither.unsafeCoerce();
        const _qudt_Quantifiable$j$relativeStandardUncertaintyEither: purify.Either<rdfjsResource.Resource.ValueError, purify.Maybe<number>> = purify.Either.of(_resource.values(dataFactory.namedNode("http://qudt.org/schema/qudt/relativeStandardUncertainty"), { unique: true }).head().chain(_value => _value.toNumber()).toMaybe());
        if (_qudt_Quantifiable$j$relativeStandardUncertaintyEither.isLeft()) { return _qudt_Quantifiable$j$relativeStandardUncertaintyEither; }

        const qudt_Quantifiable$j$relativeStandardUncertainty = _qudt_Quantifiable$j$relativeStandardUncertaintyEither.unsafeCoerce();
        const _qudt_Quantifiable$j$standardUncertaintyEither: purify.Either<rdfjsResource.Resource.ValueError, purify.Maybe<number>> = purify.Either.of(_resource.values(dataFactory.namedNode("http://qudt.org/schema/qudt/standardUncertainty"), { unique: true }).head().chain(_value => _value.toNumber()).toMaybe());
        if (_qudt_Quantifiable$j$standardUncertaintyEither.isLeft()) { return _qudt_Quantifiable$j$standardUncertaintyEither; }

        const qudt_Quantifiable$j$standardUncertainty = _qudt_Quantifiable$j$standardUncertaintyEither.unsafeCoerce();
        const _qudt_Quantifiable$j$standardUncertaintySNEither: purify.Either<rdfjsResource.Resource.ValueError, purify.Maybe<number>> = purify.Either.of(_resource.values(dataFactory.namedNode("http://qudt.org/schema/qudt/standardUncertaintySN"), { unique: true }).head().chain(_value => _value.toNumber()).toMaybe());
        if (_qudt_Quantifiable$j$standardUncertaintySNEither.isLeft()) { return _qudt_Quantifiable$j$standardUncertaintySNEither; }

        const qudt_Quantifiable$j$standardUncertaintySN = _qudt_Quantifiable$j$standardUncertaintySNEither.unsafeCoerce();
        const _qudt_Quantifiable$j$valueEither: purify.Either<rdfjsResource.Resource.ValueError, purify.Maybe<_$w$n3$j$169>> = purify.Either.of(_resource.values(dataFactory.namedNode("http://qudt.org/schema/qudt/value"), { unique: true }).head().chain(value => value.toResource()).chain(_resource => _$w$n3$j$169.fromRdf({ ..._context, ignoreRdfType: true, languageIn: _languageIn, resource: _resource })).toMaybe());
        if (_qudt_Quantifiable$j$valueEither.isLeft()) { return _qudt_Quantifiable$j$valueEither; }

        const qudt_Quantifiable$j$value = _qudt_Quantifiable$j$valueEither.unsafeCoerce();
        const _qudt_Quantifiable$j$valueSNEither: purify.Either<rdfjsResource.Resource.ValueError, purify.Maybe<(rdfjs.BlankNode | rdfjs.NamedNode | rdfjs.Literal)>> = purify.Either.of(_resource.values(dataFactory.namedNode("http://qudt.org/schema/qudt/valueSN"), { unique: true }).head().chain(_value => purify.Either.of(_value.toTerm())).toMaybe());
        if (_qudt_Quantifiable$j$valueSNEither.isLeft()) { return _qudt_Quantifiable$j$valueSNEither; }

        const qudt_Quantifiable$j$valueSN = _qudt_Quantifiable$j$valueSNEither.unsafeCoerce();
        return purify.Either.of({ ..._super0, identifier, qudt_Quantifiable$j$datatype, qudt_Quantifiable$j$hasUnit, qudt_Quantifiable$j$relativeStandardUncertainty, qudt_Quantifiable$j$standardUncertainty, qudt_Quantifiable$j$standardUncertaintySN, qudt_Quantifiable$j$value, qudt_Quantifiable$j$valueSN })
    }

    export function fromRdf(parameters: Parameters<typeof Quantifiable._propertiesFromRdf>[0]): purify.Either<rdfjsResource.Resource.ValueError, Quantifiable> {
        return Quantifiable._propertiesFromRdf(parameters).map(properties => new Quantifiable(properties));
    }

    export let fromRdfType: rdfjs.NamedNode<string> = dataFactory.namedNode("http://qudt.org/schema/qudt/Quantifiable");

    export function jsonSchema() {
        return zodToJsonSchema(quantifiableJsonZodSchema());
    }

    export function quantifiableJsonUiSchema(parameters?: { scopePrefix?: string }) {
        const scopePrefix = parameters?.scopePrefix ?? "#";
        return { "elements": [ QUDT_Aspect.qudtAspectJsonUiSchema({ scopePrefix }), { scope: `${scopePrefix}/properties/qudt_Quantifiable$j$datatype`, type: "Control" }, Abstract_Unit.abstractUnitJsonUiSchema({ scopePrefix: `${scopePrefix}/properties/qudt_Quantifiable$j$hasUnit` }), { scope: `${scopePrefix}/properties/qudt_Quantifiable$j$relativeStandardUncertainty`, type: "Control" }, { scope: `${scopePrefix}/properties/qudt_Quantifiable$j$standardUncertainty`, type: "Control" }, { scope: `${scopePrefix}/properties/qudt_Quantifiable$j$standardUncertaintySN`, type: "Control" }, _$w$n3$j$169.jsonUiSchema({ scopePrefix: `${scopePrefix}/properties/qudt_Quantifiable$j$value` }), { scope: `${scopePrefix}/properties/qudt_Quantifiable$j$valueSN`, type: "Control" } ], label: "Quantifiable", type: "Group" }
    }

    export function quantifiableJsonZodSchema() {
        return QUDT_Aspect.qudtAspectJsonZodSchema().merge(zod.object({ "@id": zod.string().min(1),"type": zod.literal("Quantifiable"),"qudt_Quantifiable$j$datatype": zod.discriminatedUnion("termType", [zod.object({ "@id": zod.string().min(1), termType: zod.literal("BlankNode") }), zod.object({ "@id": zod.string().min(1), termType: zod.literal("NamedNode") }), zod.object({ "@language": zod.string().optional(), "@type": zod.string().optional(), "@value": zod.string(), termType: zod.literal("Literal") })]).optional(),"qudt_Quantifiable$j$hasUnit": Abstract_Unit.abstractUnitJsonZodSchema().optional(),"qudt_Quantifiable$j$relativeStandardUncertainty": zod.number().optional(),"qudt_Quantifiable$j$standardUncertainty": zod.number().optional(),"qudt_Quantifiable$j$standardUncertaintySN": zod.number().optional(),"qudt_Quantifiable$j$value": _$w$n3$j$169.jsonZodSchema().optional(),"qudt_Quantifiable$j$valueSN": zod.discriminatedUnion("termType", [zod.object({ "@id": zod.string().min(1), termType: zod.literal("BlankNode") }), zod.object({ "@id": zod.string().min(1), termType: zod.literal("NamedNode") }), zod.object({ "@language": zod.string().optional(), "@type": zod.string().optional(), "@value": zod.string(), termType: zod.literal("Literal") })]).optional() }));
    }

    export function sparqlConstructQuery(parameters?: { ignoreRdfType?: boolean; prefixes?: { [prefix: string]: string }; subject?: sparqljs.Triple["subject"]; } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type">): sparqljs.ConstructQuery {
        const { ignoreRdfType, subject, ...queryParameters } = parameters ?? {}

        return { ...queryParameters, prefixes: parameters?.prefixes ?? {}, queryType: "CONSTRUCT", template: (queryParameters.template ?? []).concat(Quantifiable.sparqlConstructTemplateTriples({ ignoreRdfType, subject })), type: "query", where: (queryParameters.where ?? []).concat(Quantifiable.sparqlWherePatterns({ ignoreRdfType, subject })) };
    }

    export function sparqlConstructQueryString(parameters?: { ignoreRdfType?: boolean; subject?: sparqljs.Triple["subject"]; variablePrefix?: string; } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type"> & sparqljs.GeneratorOptions): string {
        return new sparqljs.Generator(parameters).stringify(Quantifiable.sparqlConstructQuery(parameters));
    }

    export function sparqlConstructTemplateTriples(parameters?: { ignoreRdfType?: boolean; subject?: sparqljs.Triple["subject"], variablePrefix?: string }): readonly sparqljs.Triple[] {
        const subject = parameters?.subject ?? dataFactory.variable!("quantifiable");
        const variablePrefix = parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "quantifiable");
        return [...QUDT_Aspect.sparqlConstructTemplateTriples({ ignoreRdfType: true, subject, variablePrefix }), ...(parameters?.ignoreRdfType ? [] : [{ subject, predicate: dataFactory.namedNode("http://www.w3.org/1999/02/22-rdf-syntax-ns#type"), object: dataFactory.variable!(`${variablePrefix}RdfType`) }]), { object: dataFactory.variable!(`${variablePrefix}QudtQuantifiableJDatatype`), predicate: dataFactory.namedNode("http://qudt.org/schema/qudt/datatype"), subject }, { object: dataFactory.variable!(`${variablePrefix}QudtQuantifiableJHasUnit`), predicate: dataFactory.namedNode("http://qudt.org/schema/qudt/hasUnit"), subject }, ...Abstract_Unit.sparqlConstructTemplateTriples({ ignoreRdfType: true, subject: dataFactory.variable!(`${variablePrefix}QudtQuantifiableJHasUnit`), variablePrefix: `${variablePrefix}QudtQuantifiableJHasUnit` }), { object: dataFactory.variable!(`${variablePrefix}QudtQuantifiableJRelativeStandardUncertainty`), predicate: dataFactory.namedNode("http://qudt.org/schema/qudt/relativeStandardUncertainty"), subject }, { object: dataFactory.variable!(`${variablePrefix}QudtQuantifiableJStandardUncertainty`), predicate: dataFactory.namedNode("http://qudt.org/schema/qudt/standardUncertainty"), subject }, { object: dataFactory.variable!(`${variablePrefix}QudtQuantifiableJStandardUncertaintySn`), predicate: dataFactory.namedNode("http://qudt.org/schema/qudt/standardUncertaintySN"), subject }, { object: dataFactory.variable!(`${variablePrefix}QudtQuantifiableJValue`), predicate: dataFactory.namedNode("http://qudt.org/schema/qudt/value"), subject }, ..._$w$n3$j$169.sparqlConstructTemplateTriples({ ignoreRdfType: true, subject: dataFactory.variable!(`${variablePrefix}QudtQuantifiableJValue`), variablePrefix: `${variablePrefix}QudtQuantifiableJValue` }), { object: dataFactory.variable!(`${variablePrefix}QudtQuantifiableJValueSn`), predicate: dataFactory.namedNode("http://qudt.org/schema/qudt/valueSN"), subject }];
    }

    export function sparqlWherePatterns(parameters: { ignoreRdfType?: boolean; subject?: sparqljs.Triple["subject"], variablePrefix?: string }): readonly sparqljs.Pattern[] {
        const subject = parameters?.subject ?? dataFactory.variable!("quantifiable");
        const variablePrefix = parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "quantifiable");
        return [...QUDT_Aspect.sparqlWherePatterns({ ignoreRdfType: true, subject, variablePrefix }), ...(parameters?.ignoreRdfType ? [] : [{ triples: [{ subject, predicate: dataFactory.namedNode("http://www.w3.org/1999/02/22-rdf-syntax-ns#type"), object: dataFactory.namedNode("http://qudt.org/schema/qudt/Quantifiable") }], type: "bgp" as const }, { triples: [{ subject, predicate: dataFactory.namedNode("http://www.w3.org/1999/02/22-rdf-syntax-ns#type"), object: dataFactory.variable!(`${variablePrefix}RdfType`) }], type: "bgp" as const }]), { patterns: [{ triples: [{ object: dataFactory.variable!(`${variablePrefix}QudtQuantifiableJDatatype`), predicate: dataFactory.namedNode("http://qudt.org/schema/qudt/datatype"), subject }], type: "bgp" }], type: "optional" }, { patterns: [{ triples: [{ object: dataFactory.variable!(`${variablePrefix}QudtQuantifiableJHasUnit`), predicate: dataFactory.namedNode("http://qudt.org/schema/qudt/hasUnit"), subject }], type: "bgp" }, ...Abstract_Unit.sparqlWherePatterns({ ignoreRdfType: true, subject: dataFactory.variable!(`${variablePrefix}QudtQuantifiableJHasUnit`), variablePrefix: `${variablePrefix}QudtQuantifiableJHasUnit` })], type: "optional" }, { patterns: [{ triples: [{ object: dataFactory.variable!(`${variablePrefix}QudtQuantifiableJRelativeStandardUncertainty`), predicate: dataFactory.namedNode("http://qudt.org/schema/qudt/relativeStandardUncertainty"), subject }], type: "bgp" }], type: "optional" }, { patterns: [{ triples: [{ object: dataFactory.variable!(`${variablePrefix}QudtQuantifiableJStandardUncertainty`), predicate: dataFactory.namedNode("http://qudt.org/schema/qudt/standardUncertainty"), subject }], type: "bgp" }], type: "optional" }, { patterns: [{ triples: [{ object: dataFactory.variable!(`${variablePrefix}QudtQuantifiableJStandardUncertaintySn`), predicate: dataFactory.namedNode("http://qudt.org/schema/qudt/standardUncertaintySN"), subject }], type: "bgp" }], type: "optional" }, { patterns: [{ triples: [{ object: dataFactory.variable!(`${variablePrefix}QudtQuantifiableJValue`), predicate: dataFactory.namedNode("http://qudt.org/schema/qudt/value"), subject }], type: "bgp" }, ..._$w$n3$j$169.sparqlWherePatterns({ ignoreRdfType: true, subject: dataFactory.variable!(`${variablePrefix}QudtQuantifiableJValue`), variablePrefix: `${variablePrefix}QudtQuantifiableJValue` })], type: "optional" }, { patterns: [{ triples: [{ object: dataFactory.variable!(`${variablePrefix}QudtQuantifiableJValueSn`), predicate: dataFactory.namedNode("http://qudt.org/schema/qudt/valueSN"), subject }], type: "bgp" }], type: "optional" }];
    }
}
/**
 * Plane Angle Unit
 */
export class Plane_Angle$W$Unit extends Angle_unit {
    override readonly type = "Plane_Angle$W$Unit";

    // biome-ignore lint/complexity/noUselessConstructor: Always have a constructor
    constructor(parameters: { readonly identifier?: (rdfjs.BlankNode | rdfjs.NamedNode) | string } & ConstructorParameters<typeof Angle_unit>[0]) {
        super(parameters);
    }

    override get identifier(): (rdfjs.BlankNode | rdfjs.NamedNode) {
        if (typeof this._identifier === "undefined") { this._identifier = dataFactory.blankNode(); } return this._identifier;
    }

    override toRdf({ ignoreRdfType, mutateGraph, resourceSet }: { ignoreRdfType?: boolean; mutateGraph?: rdfjsResource.MutableResource.MutateGraph, resourceSet: rdfjsResource.MutableResourceSet }): rdfjsResource.MutableResource {
        const _resource = super.toRdf({ ignoreRdfType: true, mutateGraph, resourceSet });
        if (!ignoreRdfType) { _resource.add(_resource.dataFactory.namedNode("http://www.w3.org/1999/02/22-rdf-syntax-ns#type"), _resource.dataFactory.namedNode("http://qudt.org/schema/qudt/PlaneAngleUnit")); }

        return _resource;
    }

    override toString(): string {
        return JSON.stringify(this.toJson());
    }
}

export namespace Plane_Angle$W$Unit {
    export function _propertiesFromJson(_json: unknown): purify.Either<zod.ZodError, { identifier: (rdfjs.BlankNode | rdfjs.NamedNode); } & UnwrapR<ReturnType<typeof Angle_unit._propertiesFromJson>>> {
        const _jsonSafeParseResult = planeAngleWUnitJsonZodSchema().safeParse(_json);
        if (!_jsonSafeParseResult.success) { return purify.Left(_jsonSafeParseResult.error); }

        const _jsonObject = _jsonSafeParseResult.data;
        const _super0Either = Angle_unit._propertiesFromJson(_jsonObject);
        if (_super0Either.isLeft()) { return _super0Either; }

        const _super0 = _super0Either.unsafeCoerce()
        const identifier = (_jsonObject["@id"].startsWith("_:") ? dataFactory.blankNode(_jsonObject["@id"].substring(2)) : dataFactory.namedNode(_jsonObject["@id"]));
        return purify.Either.of({ ..._super0, identifier })
    }

    export function fromJson(json: unknown): purify.Either<zod.ZodError, Plane_Angle$W$Unit> {
        return Plane_Angle$W$Unit._propertiesFromJson(json).map(properties => new Plane_Angle$W$Unit(properties));
    }

    export function _propertiesFromRdf({ ignoreRdfType: _ignoreRdfType, languageIn: _languageIn, resource: _resource,
        // @ts-ignore
        ..._context }: { [_index: string]: any; ignoreRdfType?: boolean; languageIn?: readonly string[]; resource: rdfjsResource.Resource; }): purify.Either<rdfjsResource.Resource.ValueError, { identifier: (rdfjs.BlankNode | rdfjs.NamedNode); } & UnwrapR<ReturnType<typeof Angle_unit._propertiesFromRdf>>> {
        const _super0Either = Angle_unit._propertiesFromRdf({ ..._context, ignoreRdfType: true, languageIn: _languageIn, resource: _resource });
        if (_super0Either.isLeft()) { return _super0Either; }

        const _super0 = _super0Either.unsafeCoerce()
        if (!_ignoreRdfType && !_resource.isInstanceOf(dataFactory.namedNode("http://qudt.org/schema/qudt/PlaneAngleUnit"))) { return purify.Left(new rdfjsResource.Resource.ValueError({ focusResource: _resource, message: `${rdfjsResource.Resource.Identifier.toString(_resource.identifier)} has unexpected RDF type (expected http://qudt.org/schema/qudt/PlaneAngleUnit)`, predicate: dataFactory.namedNode("http://qudt.org/schema/qudt/PlaneAngleUnit") })); }

        const identifier = _resource.identifier
        return purify.Either.of({ ..._super0, identifier })
    }

    export function fromRdf(parameters: Parameters<typeof Plane_Angle$W$Unit._propertiesFromRdf>[0]): purify.Either<rdfjsResource.Resource.ValueError, Plane_Angle$W$Unit> {
        return Plane_Angle$W$Unit._propertiesFromRdf(parameters).map(properties => new Plane_Angle$W$Unit(properties));
    }

    export let fromRdfType: rdfjs.NamedNode<string> = dataFactory.namedNode("http://qudt.org/schema/qudt/PlaneAngleUnit");

    export function jsonSchema() {
        return zodToJsonSchema(planeAngleWUnitJsonZodSchema());
    }

    export function planeAngleWUnitJsonUiSchema(parameters?: { scopePrefix?: string }) {
        const scopePrefix = parameters?.scopePrefix ?? "#";
        return { "elements": [ Angle_unit.angleUnitJsonUiSchema({ scopePrefix }) ], label: "Plane Angle Unit", type: "Group" }
    }

    export function planeAngleWUnitJsonZodSchema() {
        return Angle_unit.angleUnitJsonZodSchema().merge(zod.object({ "@id": zod.string().min(1),"type": zod.literal("Plane_Angle$W$Unit") }));
    }

    export function sparqlConstructQuery(parameters?: { ignoreRdfType?: boolean; prefixes?: { [prefix: string]: string }; subject?: sparqljs.Triple["subject"]; } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type">): sparqljs.ConstructQuery {
        const { ignoreRdfType, subject, ...queryParameters } = parameters ?? {}

        return { ...queryParameters, prefixes: parameters?.prefixes ?? {}, queryType: "CONSTRUCT", template: (queryParameters.template ?? []).concat(Plane_Angle$W$Unit.sparqlConstructTemplateTriples({ ignoreRdfType, subject })), type: "query", where: (queryParameters.where ?? []).concat(Plane_Angle$W$Unit.sparqlWherePatterns({ ignoreRdfType, subject })) };
    }

    export function sparqlConstructQueryString(parameters?: { ignoreRdfType?: boolean; subject?: sparqljs.Triple["subject"]; variablePrefix?: string; } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type"> & sparqljs.GeneratorOptions): string {
        return new sparqljs.Generator(parameters).stringify(Plane_Angle$W$Unit.sparqlConstructQuery(parameters));
    }

    export function sparqlConstructTemplateTriples(parameters?: { ignoreRdfType?: boolean; subject?: sparqljs.Triple["subject"], variablePrefix?: string }): readonly sparqljs.Triple[] {
        const subject = parameters?.subject ?? dataFactory.variable!("planeAngleWUnit");
        const variablePrefix = parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "planeAngleWUnit");
        return [...Angle_unit.sparqlConstructTemplateTriples({ ignoreRdfType: true, subject, variablePrefix }), ...(parameters?.ignoreRdfType ? [] : [{ subject, predicate: dataFactory.namedNode("http://www.w3.org/1999/02/22-rdf-syntax-ns#type"), object: dataFactory.variable!(`${variablePrefix}RdfType`) }])];
    }

    export function sparqlWherePatterns(parameters: { ignoreRdfType?: boolean; subject?: sparqljs.Triple["subject"], variablePrefix?: string }): readonly sparqljs.Pattern[] {
        const subject = parameters?.subject ?? dataFactory.variable!("planeAngleWUnit");
        const variablePrefix = parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "planeAngleWUnit");
        return [...Angle_unit.sparqlWherePatterns({ ignoreRdfType: true, subject, variablePrefix }), ...(parameters?.ignoreRdfType ? [] : [{ triples: [{ subject, predicate: dataFactory.namedNode("http://www.w3.org/1999/02/22-rdf-syntax-ns#type"), object: dataFactory.namedNode("http://qudt.org/schema/qudt/PlaneAngleUnit") }], type: "bgp" as const }, { triples: [{ subject, predicate: dataFactory.namedNode("http://www.w3.org/1999/02/22-rdf-syntax-ns#type"), object: dataFactory.variable!(`${variablePrefix}RdfType`) }], type: "bgp" as const }])];
    }
}
/**
 * Quantity
 */
export class Quantity extends QUDT_Concept {
    override readonly type: "Physical_Constant" | "Quantity" = "Quantity";
    readonly qudt_Quantity$j$hasQuantityKind: readonly (Quantity_Kind)[];
    readonly qudt_Quantity$j$isDeltaQuantity: readonly (boolean)[];
    readonly qudt_Quantity$j$quantityValue: readonly (Quantity_value)[];

    constructor(parameters: { readonly identifier?: (rdfjs.BlankNode | rdfjs.NamedNode) | string, readonly qudt_Quantity$j$hasQuantityKind?: readonly (Quantity_Kind)[], readonly qudt_Quantity$j$isDeltaQuantity?: readonly (boolean)[], readonly qudt_Quantity$j$quantityValue?: readonly (Quantity_value)[] } & ConstructorParameters<typeof QUDT_Concept>[0]) {
        super(parameters);
        if (typeof parameters.qudt_Quantity$j$hasQuantityKind === "undefined") { this.qudt_Quantity$j$hasQuantityKind = []; } else if (Array.isArray(parameters.qudt_Quantity$j$hasQuantityKind)) { this.qudt_Quantity$j$hasQuantityKind = parameters.qudt_Quantity$j$hasQuantityKind; } else { this.qudt_Quantity$j$hasQuantityKind =( parameters.qudt_Quantity$j$hasQuantityKind) as never;
         }

        if (typeof parameters.qudt_Quantity$j$isDeltaQuantity === "undefined") { this.qudt_Quantity$j$isDeltaQuantity = []; } else if (Array.isArray(parameters.qudt_Quantity$j$isDeltaQuantity)) { this.qudt_Quantity$j$isDeltaQuantity = parameters.qudt_Quantity$j$isDeltaQuantity; } else { this.qudt_Quantity$j$isDeltaQuantity =( parameters.qudt_Quantity$j$isDeltaQuantity) as never;
         }

        if (typeof parameters.qudt_Quantity$j$quantityValue === "undefined") { this.qudt_Quantity$j$quantityValue = []; } else if (Array.isArray(parameters.qudt_Quantity$j$quantityValue)) { this.qudt_Quantity$j$quantityValue = parameters.qudt_Quantity$j$quantityValue; } else { this.qudt_Quantity$j$quantityValue =( parameters.qudt_Quantity$j$quantityValue) as never;
         }
    }

    override get identifier(): (rdfjs.BlankNode | rdfjs.NamedNode) {
        if (typeof this._identifier === "undefined") { this._identifier = dataFactory.blankNode(); } return this._identifier;
    }

    override equals(other: Quantity): EqualsResult {
        return super.equals(other).chain(() => (((left, right) => arrayEquals(left, right, ((left, right) => left.equals(right)))))(this.qudt_Quantity$j$hasQuantityKind, other.qudt_Quantity$j$hasQuantityKind).mapLeft(propertyValuesUnequal => ({ left: this, right: other, propertyName: "qudt_Quantity$j$hasQuantityKind", propertyValuesUnequal, type: "Property" as const }))).chain(() => (((left, right) => arrayEquals(left, right, strictEquals)))(this.qudt_Quantity$j$isDeltaQuantity, other.qudt_Quantity$j$isDeltaQuantity).mapLeft(propertyValuesUnequal => ({ left: this, right: other, propertyName: "qudt_Quantity$j$isDeltaQuantity", propertyValuesUnequal, type: "Property" as const }))).chain(() => (((left, right) => arrayEquals(left, right, ((left, right) => left.equals(right)))))(this.qudt_Quantity$j$quantityValue, other.qudt_Quantity$j$quantityValue).mapLeft(propertyValuesUnequal => ({ left: this, right: other, propertyName: "qudt_Quantity$j$quantityValue", propertyValuesUnequal, type: "Property" as const })));
    }

    override hash<HasherT extends { update: (message: string | number[] | ArrayBuffer | Uint8Array) => void; }>(_hasher: HasherT): HasherT {
        this.hashShaclProperties(_hasher);
        return _hasher;
    }

    protected override hashShaclProperties<HasherT extends { update: (message: string | number[] | ArrayBuffer | Uint8Array) => void; }>(_hasher: HasherT): HasherT {
        super.hashShaclProperties(_hasher);
        for (const _item0 of this.qudt_Quantity$j$hasQuantityKind) { _item0.hash(_hasher); }

        for (const _item0 of this.qudt_Quantity$j$isDeltaQuantity) { _hasher.update(_item0.toString()); }

        for (const _item0 of this.qudt_Quantity$j$quantityValue) { _item0.hash(_hasher); }

        return _hasher;
    }

    override toJson(): { readonly "qudt_Quantity$j$hasQuantityKind": readonly (ReturnType<Quantity_Kind["toJson"]>)[]; readonly "qudt_Quantity$j$isDeltaQuantity": readonly (boolean)[]; readonly "qudt_Quantity$j$quantityValue": readonly (ReturnType<Quantity_value["toJson"]>)[] } & ReturnType<QUDT_Concept["toJson"]> {
        return JSON.parse(JSON.stringify({ ...super.toJson(),qudt_Quantity$j$hasQuantityKind: this.qudt_Quantity$j$hasQuantityKind.map(_item => (_item.toJson())),qudt_Quantity$j$isDeltaQuantity: this.qudt_Quantity$j$isDeltaQuantity.map(_item => (_item)),qudt_Quantity$j$quantityValue: this.qudt_Quantity$j$quantityValue.map(_item => (_item.toJson())) } satisfies ReturnType<Quantity["toJson"]>));
    }

    override toRdf({ ignoreRdfType, mutateGraph, resourceSet }: { ignoreRdfType?: boolean; mutateGraph?: rdfjsResource.MutableResource.MutateGraph, resourceSet: rdfjsResource.MutableResourceSet }): rdfjsResource.MutableResource {
        const _resource = super.toRdf({ ignoreRdfType: true, mutateGraph, resourceSet });
        if (!ignoreRdfType) { _resource.add(_resource.dataFactory.namedNode("http://www.w3.org/1999/02/22-rdf-syntax-ns#type"), _resource.dataFactory.namedNode("http://qudt.org/schema/qudt/Quantity")); }

        _resource.add(dataFactory.namedNode("http://qudt.org/schema/qudt/hasQuantityKind"), this.qudt_Quantity$j$hasQuantityKind.map((_item) => _item.toRdf({ mutateGraph: mutateGraph, resourceSet: resourceSet })));
        _resource.add(dataFactory.namedNode("http://qudt.org/schema/qudt/isDeltaQuantity"), this.qudt_Quantity$j$isDeltaQuantity.map((_item) => _item));
        _resource.add(dataFactory.namedNode("http://qudt.org/schema/qudt/quantityValue"), this.qudt_Quantity$j$quantityValue.map((_item) => _item.toRdf({ mutateGraph: mutateGraph, resourceSet: resourceSet })));
        return _resource;
    }

    override toString(): string {
        return JSON.stringify(this.toJson());
    }
}

export namespace Quantity {
    export function _propertiesFromJson(_json: unknown): purify.Either<zod.ZodError, { identifier: (rdfjs.BlankNode | rdfjs.NamedNode); qudt_Quantity$j$hasQuantityKind: readonly (Quantity_Kind)[]; qudt_Quantity$j$isDeltaQuantity: readonly (boolean)[]; qudt_Quantity$j$quantityValue: readonly (Quantity_value)[]; } & UnwrapR<ReturnType<typeof QUDT_Concept._propertiesFromJson>>> {
        const _jsonSafeParseResult = quantityJsonZodSchema().safeParse(_json);
        if (!_jsonSafeParseResult.success) { return purify.Left(_jsonSafeParseResult.error); }

        const _jsonObject = _jsonSafeParseResult.data;
        const _super0Either = QUDT_Concept._propertiesFromJson(_jsonObject);
        if (_super0Either.isLeft()) { return _super0Either; }

        const _super0 = _super0Either.unsafeCoerce()
        const identifier = (_jsonObject["@id"].startsWith("_:") ? dataFactory.blankNode(_jsonObject["@id"].substring(2)) : dataFactory.namedNode(_jsonObject["@id"]));
        const qudt_Quantity$j$hasQuantityKind = _jsonObject["qudt_Quantity$j$hasQuantityKind"].map(_item => (Quantity_Kind.fromJson(_item).unsafeCoerce()));
        const qudt_Quantity$j$isDeltaQuantity = _jsonObject["qudt_Quantity$j$isDeltaQuantity"];
        const qudt_Quantity$j$quantityValue = _jsonObject["qudt_Quantity$j$quantityValue"].map(_item => (Quantity_value.fromJson(_item).unsafeCoerce()));
        return purify.Either.of({ ..._super0, identifier, qudt_Quantity$j$hasQuantityKind, qudt_Quantity$j$isDeltaQuantity, qudt_Quantity$j$quantityValue })
    }

    export function fromJson(json: unknown): purify.Either<zod.ZodError, Quantity> {
        return (Physical_Constant.fromJson(json) as purify.Either<zod.ZodError, Quantity>).altLazy(() => Quantity._propertiesFromJson(json).map(properties => new Quantity(properties)));
    }

    export function _propertiesFromRdf({ ignoreRdfType: _ignoreRdfType, languageIn: _languageIn, resource: _resource,
        // @ts-ignore
        ..._context }: { [_index: string]: any; ignoreRdfType?: boolean; languageIn?: readonly string[]; resource: rdfjsResource.Resource; }): purify.Either<rdfjsResource.Resource.ValueError, { identifier: (rdfjs.BlankNode | rdfjs.NamedNode); qudt_Quantity$j$hasQuantityKind: readonly (Quantity_Kind)[]; qudt_Quantity$j$isDeltaQuantity: readonly (boolean)[]; qudt_Quantity$j$quantityValue: readonly (Quantity_value)[]; } & UnwrapR<ReturnType<typeof QUDT_Concept._propertiesFromRdf>>> {
        const _super0Either = QUDT_Concept._propertiesFromRdf({ ..._context, ignoreRdfType: true, languageIn: _languageIn, resource: _resource });
        if (_super0Either.isLeft()) { return _super0Either; }

        const _super0 = _super0Either.unsafeCoerce()
        if (!_ignoreRdfType && !_resource.isInstanceOf(dataFactory.namedNode("http://qudt.org/schema/qudt/Quantity"))) { return purify.Left(new rdfjsResource.Resource.ValueError({ focusResource: _resource, message: `${rdfjsResource.Resource.Identifier.toString(_resource.identifier)} has unexpected RDF type (expected http://qudt.org/schema/qudt/Quantity)`, predicate: dataFactory.namedNode("http://qudt.org/schema/qudt/Quantity") })); }

        const identifier = _resource.identifier
        const _qudt_Quantity$j$hasQuantityKindEither: purify.Either<rdfjsResource.Resource.ValueError, readonly (Quantity_Kind)[]> = purify.Either.of([..._resource.values(dataFactory.namedNode("http://qudt.org/schema/qudt/hasQuantityKind"), { unique: true }).flatMap(_item => _item.toValues().head().chain(value => value.toResource()).chain(_resource => Quantity_Kind.fromRdf({ ..._context, ignoreRdfType: true, languageIn: _languageIn, resource: _resource })).toMaybe().toList())]);
        if (_qudt_Quantity$j$hasQuantityKindEither.isLeft()) { return _qudt_Quantity$j$hasQuantityKindEither; }

        const qudt_Quantity$j$hasQuantityKind = _qudt_Quantity$j$hasQuantityKindEither.unsafeCoerce();
        const _qudt_Quantity$j$isDeltaQuantityEither: purify.Either<rdfjsResource.Resource.ValueError, readonly (boolean)[]> = purify.Either.of([..._resource.values(dataFactory.namedNode("http://qudt.org/schema/qudt/isDeltaQuantity"), { unique: true }).flatMap(_item => _item.toValues().head().chain(_value => _value.toBoolean()).toMaybe().toList())]);
        if (_qudt_Quantity$j$isDeltaQuantityEither.isLeft()) { return _qudt_Quantity$j$isDeltaQuantityEither; }

        const qudt_Quantity$j$isDeltaQuantity = _qudt_Quantity$j$isDeltaQuantityEither.unsafeCoerce();
        const _qudt_Quantity$j$quantityValueEither: purify.Either<rdfjsResource.Resource.ValueError, readonly (Quantity_value)[]> = purify.Either.of([..._resource.values(dataFactory.namedNode("http://qudt.org/schema/qudt/quantityValue"), { unique: true }).flatMap(_item => _item.toValues().head().chain(value => value.toResource()).chain(_resource => Quantity_value.fromRdf({ ..._context, ignoreRdfType: true, languageIn: _languageIn, resource: _resource })).toMaybe().toList())]);
        if (_qudt_Quantity$j$quantityValueEither.isLeft()) { return _qudt_Quantity$j$quantityValueEither; }

        const qudt_Quantity$j$quantityValue = _qudt_Quantity$j$quantityValueEither.unsafeCoerce();
        return purify.Either.of({ ..._super0, identifier, qudt_Quantity$j$hasQuantityKind, qudt_Quantity$j$isDeltaQuantity, qudt_Quantity$j$quantityValue })
    }

    export function fromRdf(parameters: Parameters<typeof Quantity._propertiesFromRdf>[0]): purify.Either<rdfjsResource.Resource.ValueError, Quantity> {
        const { ignoreRdfType: _ignoreRdfType, ...otherParameters } = parameters
        return (Physical_Constant.fromRdf(otherParameters) as purify.Either<rdfjsResource.Resource.ValueError, Quantity>).altLazy(() => Quantity._propertiesFromRdf(parameters).map(properties => new Quantity(properties)));
    }

    export let fromRdfType: rdfjs.NamedNode<string> = dataFactory.namedNode("http://qudt.org/schema/qudt/Quantity");

    export function jsonSchema() {
        return zodToJsonSchema(quantityJsonZodSchema());
    }

    export function quantityJsonUiSchema(parameters?: { scopePrefix?: string }) {
        const scopePrefix = parameters?.scopePrefix ?? "#";
        return { "elements": [ QUDT_Concept.qudtConceptJsonUiSchema({ scopePrefix }), Quantity_Kind.quantityKindJsonUiSchema({ scopePrefix: `${scopePrefix}/properties/qudt_Quantity$j$hasQuantityKind` }), { scope: `${scopePrefix}/properties/qudt_Quantity$j$isDeltaQuantity`, type: "Control" }, Quantity_value.quantityValueJsonUiSchema({ scopePrefix: `${scopePrefix}/properties/qudt_Quantity$j$quantityValue` }) ], label: "Quantity", type: "Group" }
    }

    export function quantityJsonZodSchema() {
        return QUDT_Concept.qudtConceptJsonZodSchema().merge(zod.object({ "@id": zod.string().min(1),"type": zod.enum(["Physical_Constant","Quantity"]),"qudt_Quantity$j$hasQuantityKind": Quantity_Kind.quantityKindJsonZodSchema().array(),"qudt_Quantity$j$isDeltaQuantity": zod.boolean().array(),"qudt_Quantity$j$quantityValue": Quantity_value.quantityValueJsonZodSchema().array() }));
    }

    export function sparqlConstructQuery(parameters?: { ignoreRdfType?: boolean; prefixes?: { [prefix: string]: string }; subject?: sparqljs.Triple["subject"]; } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type">): sparqljs.ConstructQuery {
        const { ignoreRdfType, subject, ...queryParameters } = parameters ?? {}

        return { ...queryParameters, prefixes: parameters?.prefixes ?? {}, queryType: "CONSTRUCT", template: (queryParameters.template ?? []).concat(Quantity.sparqlConstructTemplateTriples({ ignoreRdfType, subject })), type: "query", where: (queryParameters.where ?? []).concat(Quantity.sparqlWherePatterns({ ignoreRdfType, subject })) };
    }

    export function sparqlConstructQueryString(parameters?: { ignoreRdfType?: boolean; subject?: sparqljs.Triple["subject"]; variablePrefix?: string; } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type"> & sparqljs.GeneratorOptions): string {
        return new sparqljs.Generator(parameters).stringify(Quantity.sparqlConstructQuery(parameters));
    }

    export function sparqlConstructTemplateTriples(parameters?: { ignoreRdfType?: boolean; subject?: sparqljs.Triple["subject"], variablePrefix?: string }): readonly sparqljs.Triple[] {
        const subject = parameters?.subject ?? dataFactory.variable!("quantity");
        const variablePrefix = parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "quantity");
        return [...QUDT_Concept.sparqlConstructTemplateTriples({ ignoreRdfType: true, subject, variablePrefix }), ...(parameters?.ignoreRdfType ? [] : [{ subject, predicate: dataFactory.namedNode("http://www.w3.org/1999/02/22-rdf-syntax-ns#type"), object: dataFactory.variable!(`${variablePrefix}RdfType`) }]), { object: dataFactory.variable!(`${variablePrefix}QudtQuantityJHasQuantityKind`), predicate: dataFactory.namedNode("http://qudt.org/schema/qudt/hasQuantityKind"), subject }, ...Quantity_Kind.sparqlConstructTemplateTriples({ ignoreRdfType: true, subject: dataFactory.variable!(`${variablePrefix}QudtQuantityJHasQuantityKind`), variablePrefix: `${variablePrefix}QudtQuantityJHasQuantityKind` }), { object: dataFactory.variable!(`${variablePrefix}QudtQuantityJIsDeltaQuantity`), predicate: dataFactory.namedNode("http://qudt.org/schema/qudt/isDeltaQuantity"), subject }, { object: dataFactory.variable!(`${variablePrefix}QudtQuantityJQuantityValue`), predicate: dataFactory.namedNode("http://qudt.org/schema/qudt/quantityValue"), subject }, ...Quantity_value.sparqlConstructTemplateTriples({ ignoreRdfType: true, subject: dataFactory.variable!(`${variablePrefix}QudtQuantityJQuantityValue`), variablePrefix: `${variablePrefix}QudtQuantityJQuantityValue` })];
    }

    export function sparqlWherePatterns(parameters: { ignoreRdfType?: boolean; subject?: sparqljs.Triple["subject"], variablePrefix?: string }): readonly sparqljs.Pattern[] {
        const subject = parameters?.subject ?? dataFactory.variable!("quantity");
        const variablePrefix = parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "quantity");
        return [...QUDT_Concept.sparqlWherePatterns({ ignoreRdfType: true, subject, variablePrefix }), ...(parameters?.ignoreRdfType ? [] : [{ triples: [{ subject, predicate: dataFactory.namedNode("http://www.w3.org/1999/02/22-rdf-syntax-ns#type"), object: dataFactory.namedNode("http://qudt.org/schema/qudt/Quantity") }], type: "bgp" as const }, { triples: [{ subject, predicate: dataFactory.namedNode("http://www.w3.org/1999/02/22-rdf-syntax-ns#type"), object: dataFactory.variable!(`${variablePrefix}RdfType`) }], type: "bgp" as const }]), { patterns: [{ triples: [{ object: dataFactory.variable!(`${variablePrefix}QudtQuantityJHasQuantityKind`), predicate: dataFactory.namedNode("http://qudt.org/schema/qudt/hasQuantityKind"), subject }], type: "bgp" }, ...Quantity_Kind.sparqlWherePatterns({ ignoreRdfType: true, subject: dataFactory.variable!(`${variablePrefix}QudtQuantityJHasQuantityKind`), variablePrefix: `${variablePrefix}QudtQuantityJHasQuantityKind` })], type: "optional" }, { patterns: [{ triples: [{ object: dataFactory.variable!(`${variablePrefix}QudtQuantityJIsDeltaQuantity`), predicate: dataFactory.namedNode("http://qudt.org/schema/qudt/isDeltaQuantity"), subject }], type: "bgp" }], type: "optional" }, { patterns: [{ triples: [{ object: dataFactory.variable!(`${variablePrefix}QudtQuantityJQuantityValue`), predicate: dataFactory.namedNode("http://qudt.org/schema/qudt/quantityValue"), subject }], type: "bgp" }, ...Quantity_value.sparqlWherePatterns({ ignoreRdfType: true, subject: dataFactory.variable!(`${variablePrefix}QudtQuantityJQuantityValue`), variablePrefix: `${variablePrefix}QudtQuantityJQuantityValue` })], type: "optional" }];
    }
}
/**
 * Physical Constant
 */
export class Physical_Constant extends Quantity {
    override readonly type = "Physical_Constant";
    readonly qudt_PhysicalConstant$j$altSymbol: readonly ((rdfjs.BlankNode | rdfjs.NamedNode | rdfjs.Literal))[];
    readonly qudt_PhysicalConstant$j$applicableSystem: readonly (System_of$W$Units)[];
    readonly qudt_PhysicalConstant$j$applicableUnit: readonly (Abstract_Unit)[];
    readonly qudt_PhysicalConstant$j$dbpediaMatch: readonly (string)[];
    readonly qudt_PhysicalConstant$j$exactConstant: readonly (boolean)[];
    readonly qudt_PhysicalConstant$j$hasDimensionVector: readonly (Quantity_Kind$W$Dimension$W$Vector)[];
    readonly qudt_PhysicalConstant$j$iec61360Code: readonly (string)[];
    readonly qudt_PhysicalConstant$j$isoNormativeReference: readonly (string)[];
    readonly qudt_PhysicalConstant$j$latexDefinition: purify.Maybe<string>;
    readonly qudt_PhysicalConstant$j$latexSymbol: readonly (string)[];
    readonly qudt_PhysicalConstant$j$mathMLdefinition: purify.Maybe<string>;
    readonly qudt_PhysicalConstant$j$normativeReference: readonly (string)[];
    readonly qudt_PhysicalConstant$j$siExactMatch: purify.Maybe<(rdfjs.BlankNode | rdfjs.NamedNode | rdfjs.Literal)>;
    readonly qudt_PhysicalConstant$j$symbol: purify.Maybe<(rdfjs.BlankNode | rdfjs.NamedNode | rdfjs.Literal)>;
    readonly qudt_PhysicalConstant$j$ucumCode: readonly (string)[];

    constructor(parameters: { readonly identifier?: (rdfjs.BlankNode | rdfjs.NamedNode) | string, readonly qudt_PhysicalConstant$j$altSymbol?: readonly ((rdfjs.BlankNode | rdfjs.NamedNode | rdfjs.Literal))[], readonly qudt_PhysicalConstant$j$applicableSystem?: readonly (System_of$W$Units)[], readonly qudt_PhysicalConstant$j$applicableUnit?: readonly (Abstract_Unit)[], readonly qudt_PhysicalConstant$j$dbpediaMatch?: readonly (string)[], readonly qudt_PhysicalConstant$j$exactConstant?: readonly (boolean)[], readonly qudt_PhysicalConstant$j$hasDimensionVector?: readonly (Quantity_Kind$W$Dimension$W$Vector)[], readonly qudt_PhysicalConstant$j$iec61360Code?: readonly (string)[], readonly qudt_PhysicalConstant$j$isoNormativeReference?: readonly (string)[], readonly qudt_PhysicalConstant$j$latexDefinition?: purify.Maybe<string> | string, readonly qudt_PhysicalConstant$j$latexSymbol?: readonly (string)[], readonly qudt_PhysicalConstant$j$mathMLdefinition?: purify.Maybe<string> | string, readonly qudt_PhysicalConstant$j$normativeReference?: readonly (string)[], readonly qudt_PhysicalConstant$j$siExactMatch?: (rdfjs.BlankNode | rdfjs.NamedNode | rdfjs.Literal) | Date | boolean | number | purify.Maybe<(rdfjs.BlankNode | rdfjs.NamedNode | rdfjs.Literal)> | string, readonly qudt_PhysicalConstant$j$symbol?: (rdfjs.BlankNode | rdfjs.NamedNode | rdfjs.Literal) | Date | boolean | number | purify.Maybe<(rdfjs.BlankNode | rdfjs.NamedNode | rdfjs.Literal)> | string, readonly qudt_PhysicalConstant$j$ucumCode?: readonly (string)[] } & ConstructorParameters<typeof Quantity>[0]) {
        super(parameters);
        if (typeof parameters.qudt_PhysicalConstant$j$altSymbol === "undefined") { this.qudt_PhysicalConstant$j$altSymbol = []; } else if (Array.isArray(parameters.qudt_PhysicalConstant$j$altSymbol)) { this.qudt_PhysicalConstant$j$altSymbol = parameters.qudt_PhysicalConstant$j$altSymbol; } else { this.qudt_PhysicalConstant$j$altSymbol =( parameters.qudt_PhysicalConstant$j$altSymbol) as never;
         }

        if (typeof parameters.qudt_PhysicalConstant$j$applicableSystem === "undefined") { this.qudt_PhysicalConstant$j$applicableSystem = []; } else if (Array.isArray(parameters.qudt_PhysicalConstant$j$applicableSystem)) { this.qudt_PhysicalConstant$j$applicableSystem = parameters.qudt_PhysicalConstant$j$applicableSystem; } else { this.qudt_PhysicalConstant$j$applicableSystem =( parameters.qudt_PhysicalConstant$j$applicableSystem) as never;
         }

        if (typeof parameters.qudt_PhysicalConstant$j$applicableUnit === "undefined") { this.qudt_PhysicalConstant$j$applicableUnit = []; } else if (Array.isArray(parameters.qudt_PhysicalConstant$j$applicableUnit)) { this.qudt_PhysicalConstant$j$applicableUnit = parameters.qudt_PhysicalConstant$j$applicableUnit; } else { this.qudt_PhysicalConstant$j$applicableUnit =( parameters.qudt_PhysicalConstant$j$applicableUnit) as never;
         }

        if (typeof parameters.qudt_PhysicalConstant$j$dbpediaMatch === "undefined") { this.qudt_PhysicalConstant$j$dbpediaMatch = []; } else if (Array.isArray(parameters.qudt_PhysicalConstant$j$dbpediaMatch)) { this.qudt_PhysicalConstant$j$dbpediaMatch = parameters.qudt_PhysicalConstant$j$dbpediaMatch; } else { this.qudt_PhysicalConstant$j$dbpediaMatch =( parameters.qudt_PhysicalConstant$j$dbpediaMatch) as never;
         }

        if (typeof parameters.qudt_PhysicalConstant$j$exactConstant === "undefined") { this.qudt_PhysicalConstant$j$exactConstant = []; } else if (Array.isArray(parameters.qudt_PhysicalConstant$j$exactConstant)) { this.qudt_PhysicalConstant$j$exactConstant = parameters.qudt_PhysicalConstant$j$exactConstant; } else { this.qudt_PhysicalConstant$j$exactConstant =( parameters.qudt_PhysicalConstant$j$exactConstant) as never;
         }

        if (typeof parameters.qudt_PhysicalConstant$j$hasDimensionVector === "undefined") { this.qudt_PhysicalConstant$j$hasDimensionVector = []; } else if (Array.isArray(parameters.qudt_PhysicalConstant$j$hasDimensionVector)) { this.qudt_PhysicalConstant$j$hasDimensionVector = parameters.qudt_PhysicalConstant$j$hasDimensionVector; } else { this.qudt_PhysicalConstant$j$hasDimensionVector =( parameters.qudt_PhysicalConstant$j$hasDimensionVector) as never;
         }

        if (typeof parameters.qudt_PhysicalConstant$j$iec61360Code === "undefined") { this.qudt_PhysicalConstant$j$iec61360Code = []; } else if (Array.isArray(parameters.qudt_PhysicalConstant$j$iec61360Code)) { this.qudt_PhysicalConstant$j$iec61360Code = parameters.qudt_PhysicalConstant$j$iec61360Code; } else { this.qudt_PhysicalConstant$j$iec61360Code =( parameters.qudt_PhysicalConstant$j$iec61360Code) as never;
         }

        if (typeof parameters.qudt_PhysicalConstant$j$isoNormativeReference === "undefined") { this.qudt_PhysicalConstant$j$isoNormativeReference = []; } else if (Array.isArray(parameters.qudt_PhysicalConstant$j$isoNormativeReference)) { this.qudt_PhysicalConstant$j$isoNormativeReference = parameters.qudt_PhysicalConstant$j$isoNormativeReference; } else { this.qudt_PhysicalConstant$j$isoNormativeReference =( parameters.qudt_PhysicalConstant$j$isoNormativeReference) as never;
         }

        if (purify.Maybe.isMaybe(parameters.qudt_PhysicalConstant$j$latexDefinition)) { this.qudt_PhysicalConstant$j$latexDefinition = parameters.qudt_PhysicalConstant$j$latexDefinition; } else if (typeof parameters.qudt_PhysicalConstant$j$latexDefinition === "string") { this.qudt_PhysicalConstant$j$latexDefinition = purify.Maybe.of(parameters.qudt_PhysicalConstant$j$latexDefinition); } else if (typeof parameters.qudt_PhysicalConstant$j$latexDefinition === "undefined") { this.qudt_PhysicalConstant$j$latexDefinition = purify.Maybe.empty(); } else { this.qudt_PhysicalConstant$j$latexDefinition =( parameters.qudt_PhysicalConstant$j$latexDefinition) as never;
         }

        if (typeof parameters.qudt_PhysicalConstant$j$latexSymbol === "undefined") { this.qudt_PhysicalConstant$j$latexSymbol = []; } else if (Array.isArray(parameters.qudt_PhysicalConstant$j$latexSymbol)) { this.qudt_PhysicalConstant$j$latexSymbol = parameters.qudt_PhysicalConstant$j$latexSymbol; } else { this.qudt_PhysicalConstant$j$latexSymbol =( parameters.qudt_PhysicalConstant$j$latexSymbol) as never;
         }

        if (purify.Maybe.isMaybe(parameters.qudt_PhysicalConstant$j$mathMLdefinition)) { this.qudt_PhysicalConstant$j$mathMLdefinition = parameters.qudt_PhysicalConstant$j$mathMLdefinition; } else if (typeof parameters.qudt_PhysicalConstant$j$mathMLdefinition === "string") { this.qudt_PhysicalConstant$j$mathMLdefinition = purify.Maybe.of(parameters.qudt_PhysicalConstant$j$mathMLdefinition); } else if (typeof parameters.qudt_PhysicalConstant$j$mathMLdefinition === "undefined") { this.qudt_PhysicalConstant$j$mathMLdefinition = purify.Maybe.empty(); } else { this.qudt_PhysicalConstant$j$mathMLdefinition =( parameters.qudt_PhysicalConstant$j$mathMLdefinition) as never;
         }

        if (typeof parameters.qudt_PhysicalConstant$j$normativeReference === "undefined") { this.qudt_PhysicalConstant$j$normativeReference = []; } else if (Array.isArray(parameters.qudt_PhysicalConstant$j$normativeReference)) { this.qudt_PhysicalConstant$j$normativeReference = parameters.qudt_PhysicalConstant$j$normativeReference; } else { this.qudt_PhysicalConstant$j$normativeReference =( parameters.qudt_PhysicalConstant$j$normativeReference) as never;
         }

        if (purify.Maybe.isMaybe(parameters.qudt_PhysicalConstant$j$siExactMatch)) { this.qudt_PhysicalConstant$j$siExactMatch = parameters.qudt_PhysicalConstant$j$siExactMatch; } else if (typeof parameters.qudt_PhysicalConstant$j$siExactMatch === "boolean") { this.qudt_PhysicalConstant$j$siExactMatch = purify.Maybe.of(rdfLiteral.toRdf(parameters.qudt_PhysicalConstant$j$siExactMatch, { dataFactory })); } else if (typeof parameters.qudt_PhysicalConstant$j$siExactMatch === "object" && parameters.qudt_PhysicalConstant$j$siExactMatch instanceof Date) { this.qudt_PhysicalConstant$j$siExactMatch = purify.Maybe.of(rdfLiteral.toRdf(parameters.qudt_PhysicalConstant$j$siExactMatch, { dataFactory })); } else if (typeof parameters.qudt_PhysicalConstant$j$siExactMatch === "number") { this.qudt_PhysicalConstant$j$siExactMatch = purify.Maybe.of(rdfLiteral.toRdf(parameters.qudt_PhysicalConstant$j$siExactMatch, { dataFactory })); } else if (typeof parameters.qudt_PhysicalConstant$j$siExactMatch === "string") { this.qudt_PhysicalConstant$j$siExactMatch = purify.Maybe.of(dataFactory.literal(parameters.qudt_PhysicalConstant$j$siExactMatch)); } else if (typeof parameters.qudt_PhysicalConstant$j$siExactMatch === "object") { this.qudt_PhysicalConstant$j$siExactMatch = purify.Maybe.of(parameters.qudt_PhysicalConstant$j$siExactMatch); } else if (typeof parameters.qudt_PhysicalConstant$j$siExactMatch === "undefined") { this.qudt_PhysicalConstant$j$siExactMatch = purify.Maybe.empty(); } else { this.qudt_PhysicalConstant$j$siExactMatch =( parameters.qudt_PhysicalConstant$j$siExactMatch) as never;
         }

        if (purify.Maybe.isMaybe(parameters.qudt_PhysicalConstant$j$symbol)) { this.qudt_PhysicalConstant$j$symbol = parameters.qudt_PhysicalConstant$j$symbol; } else if (typeof parameters.qudt_PhysicalConstant$j$symbol === "boolean") { this.qudt_PhysicalConstant$j$symbol = purify.Maybe.of(rdfLiteral.toRdf(parameters.qudt_PhysicalConstant$j$symbol, { dataFactory })); } else if (typeof parameters.qudt_PhysicalConstant$j$symbol === "object" && parameters.qudt_PhysicalConstant$j$symbol instanceof Date) { this.qudt_PhysicalConstant$j$symbol = purify.Maybe.of(rdfLiteral.toRdf(parameters.qudt_PhysicalConstant$j$symbol, { dataFactory })); } else if (typeof parameters.qudt_PhysicalConstant$j$symbol === "number") { this.qudt_PhysicalConstant$j$symbol = purify.Maybe.of(rdfLiteral.toRdf(parameters.qudt_PhysicalConstant$j$symbol, { dataFactory })); } else if (typeof parameters.qudt_PhysicalConstant$j$symbol === "string") { this.qudt_PhysicalConstant$j$symbol = purify.Maybe.of(dataFactory.literal(parameters.qudt_PhysicalConstant$j$symbol)); } else if (typeof parameters.qudt_PhysicalConstant$j$symbol === "object") { this.qudt_PhysicalConstant$j$symbol = purify.Maybe.of(parameters.qudt_PhysicalConstant$j$symbol); } else if (typeof parameters.qudt_PhysicalConstant$j$symbol === "undefined") { this.qudt_PhysicalConstant$j$symbol = purify.Maybe.empty(); } else { this.qudt_PhysicalConstant$j$symbol =( parameters.qudt_PhysicalConstant$j$symbol) as never;
         }

        if (typeof parameters.qudt_PhysicalConstant$j$ucumCode === "undefined") { this.qudt_PhysicalConstant$j$ucumCode = []; } else if (Array.isArray(parameters.qudt_PhysicalConstant$j$ucumCode)) { this.qudt_PhysicalConstant$j$ucumCode = parameters.qudt_PhysicalConstant$j$ucumCode; } else { this.qudt_PhysicalConstant$j$ucumCode =( parameters.qudt_PhysicalConstant$j$ucumCode) as never;
         }
    }

    override get identifier(): (rdfjs.BlankNode | rdfjs.NamedNode) {
        if (typeof this._identifier === "undefined") { this._identifier = dataFactory.blankNode(); } return this._identifier;
    }

    override equals(other: Physical_Constant): EqualsResult {
        return super.equals(other).chain(() => (((left, right) => arrayEquals(left, right, booleanEquals)))(this.qudt_PhysicalConstant$j$altSymbol, other.qudt_PhysicalConstant$j$altSymbol).mapLeft(propertyValuesUnequal => ({ left: this, right: other, propertyName: "qudt_PhysicalConstant$j$altSymbol", propertyValuesUnequal, type: "Property" as const }))).chain(() => (((left, right) => arrayEquals(left, right, ((left, right) => left.equals(right)))))(this.qudt_PhysicalConstant$j$applicableSystem, other.qudt_PhysicalConstant$j$applicableSystem).mapLeft(propertyValuesUnequal => ({ left: this, right: other, propertyName: "qudt_PhysicalConstant$j$applicableSystem", propertyValuesUnequal, type: "Property" as const }))).chain(() => (((left, right) => arrayEquals(left, right, ((left, right) => left.equals(right)))))(this.qudt_PhysicalConstant$j$applicableUnit, other.qudt_PhysicalConstant$j$applicableUnit).mapLeft(propertyValuesUnequal => ({ left: this, right: other, propertyName: "qudt_PhysicalConstant$j$applicableUnit", propertyValuesUnequal, type: "Property" as const }))).chain(() => (((left, right) => arrayEquals(left, right, strictEquals)))(this.qudt_PhysicalConstant$j$dbpediaMatch, other.qudt_PhysicalConstant$j$dbpediaMatch).mapLeft(propertyValuesUnequal => ({ left: this, right: other, propertyName: "qudt_PhysicalConstant$j$dbpediaMatch", propertyValuesUnequal, type: "Property" as const }))).chain(() => (((left, right) => arrayEquals(left, right, strictEquals)))(this.qudt_PhysicalConstant$j$exactConstant, other.qudt_PhysicalConstant$j$exactConstant).mapLeft(propertyValuesUnequal => ({ left: this, right: other, propertyName: "qudt_PhysicalConstant$j$exactConstant", propertyValuesUnequal, type: "Property" as const }))).chain(() => (((left, right) => arrayEquals(left, right, ((left, right) => left.equals(right)))))(this.qudt_PhysicalConstant$j$hasDimensionVector, other.qudt_PhysicalConstant$j$hasDimensionVector).mapLeft(propertyValuesUnequal => ({ left: this, right: other, propertyName: "qudt_PhysicalConstant$j$hasDimensionVector", propertyValuesUnequal, type: "Property" as const }))).chain(() => (((left, right) => arrayEquals(left, right, strictEquals)))(this.qudt_PhysicalConstant$j$iec61360Code, other.qudt_PhysicalConstant$j$iec61360Code).mapLeft(propertyValuesUnequal => ({ left: this, right: other, propertyName: "qudt_PhysicalConstant$j$iec61360Code", propertyValuesUnequal, type: "Property" as const }))).chain(() => (((left, right) => arrayEquals(left, right, strictEquals)))(this.qudt_PhysicalConstant$j$isoNormativeReference, other.qudt_PhysicalConstant$j$isoNormativeReference).mapLeft(propertyValuesUnequal => ({ left: this, right: other, propertyName: "qudt_PhysicalConstant$j$isoNormativeReference", propertyValuesUnequal, type: "Property" as const }))).chain(() => (((left, right) => maybeEquals(left, right, strictEquals)))(this.qudt_PhysicalConstant$j$latexDefinition, other.qudt_PhysicalConstant$j$latexDefinition).mapLeft(propertyValuesUnequal => ({ left: this, right: other, propertyName: "qudt_PhysicalConstant$j$latexDefinition", propertyValuesUnequal, type: "Property" as const }))).chain(() => (((left, right) => arrayEquals(left, right, strictEquals)))(this.qudt_PhysicalConstant$j$latexSymbol, other.qudt_PhysicalConstant$j$latexSymbol).mapLeft(propertyValuesUnequal => ({ left: this, right: other, propertyName: "qudt_PhysicalConstant$j$latexSymbol", propertyValuesUnequal, type: "Property" as const }))).chain(() => (((left, right) => maybeEquals(left, right, strictEquals)))(this.qudt_PhysicalConstant$j$mathMLdefinition, other.qudt_PhysicalConstant$j$mathMLdefinition).mapLeft(propertyValuesUnequal => ({ left: this, right: other, propertyName: "qudt_PhysicalConstant$j$mathMLdefinition", propertyValuesUnequal, type: "Property" as const }))).chain(() => (((left, right) => arrayEquals(left, right, strictEquals)))(this.qudt_PhysicalConstant$j$normativeReference, other.qudt_PhysicalConstant$j$normativeReference).mapLeft(propertyValuesUnequal => ({ left: this, right: other, propertyName: "qudt_PhysicalConstant$j$normativeReference", propertyValuesUnequal, type: "Property" as const }))).chain(() => (((left, right) => maybeEquals(left, right, booleanEquals)))(this.qudt_PhysicalConstant$j$siExactMatch, other.qudt_PhysicalConstant$j$siExactMatch).mapLeft(propertyValuesUnequal => ({ left: this, right: other, propertyName: "qudt_PhysicalConstant$j$siExactMatch", propertyValuesUnequal, type: "Property" as const }))).chain(() => (((left, right) => maybeEquals(left, right, booleanEquals)))(this.qudt_PhysicalConstant$j$symbol, other.qudt_PhysicalConstant$j$symbol).mapLeft(propertyValuesUnequal => ({ left: this, right: other, propertyName: "qudt_PhysicalConstant$j$symbol", propertyValuesUnequal, type: "Property" as const }))).chain(() => (((left, right) => arrayEquals(left, right, strictEquals)))(this.qudt_PhysicalConstant$j$ucumCode, other.qudt_PhysicalConstant$j$ucumCode).mapLeft(propertyValuesUnequal => ({ left: this, right: other, propertyName: "qudt_PhysicalConstant$j$ucumCode", propertyValuesUnequal, type: "Property" as const })));
    }

    override hash<HasherT extends { update: (message: string | number[] | ArrayBuffer | Uint8Array) => void; }>(_hasher: HasherT): HasherT {
        this.hashShaclProperties(_hasher);
        return _hasher;
    }

    protected override hashShaclProperties<HasherT extends { update: (message: string | number[] | ArrayBuffer | Uint8Array) => void; }>(_hasher: HasherT): HasherT {
        super.hashShaclProperties(_hasher);
        for (const _item0 of this.qudt_PhysicalConstant$j$altSymbol) { _hasher.update(_item0.termType);
        _hasher.update(_item0.value); }

        for (const _item0 of this.qudt_PhysicalConstant$j$applicableSystem) { _item0.hash(_hasher); }

        for (const _item0 of this.qudt_PhysicalConstant$j$applicableUnit) { _item0.hash(_hasher); }

        for (const _item0 of this.qudt_PhysicalConstant$j$dbpediaMatch) { _hasher.update(_item0); }

        for (const _item0 of this.qudt_PhysicalConstant$j$exactConstant) { _hasher.update(_item0.toString()); }

        for (const _item0 of this.qudt_PhysicalConstant$j$hasDimensionVector) { _item0.hash(_hasher); }

        for (const _item0 of this.qudt_PhysicalConstant$j$iec61360Code) { _hasher.update(_item0); }

        for (const _item0 of this.qudt_PhysicalConstant$j$isoNormativeReference) { _hasher.update(_item0); }

        this.qudt_PhysicalConstant$j$latexDefinition.ifJust((_value0) => { _hasher.update(_value0); })
        for (const _item0 of this.qudt_PhysicalConstant$j$latexSymbol) { _hasher.update(_item0); }

        this.qudt_PhysicalConstant$j$mathMLdefinition.ifJust((_value0) => { _hasher.update(_value0); })
        for (const _item0 of this.qudt_PhysicalConstant$j$normativeReference) { _hasher.update(_item0); }

        this.qudt_PhysicalConstant$j$siExactMatch.ifJust((_value0) => { _hasher.update(_value0.termType);
        _hasher.update(_value0.value); })
        this.qudt_PhysicalConstant$j$symbol.ifJust((_value0) => { _hasher.update(_value0.termType);
        _hasher.update(_value0.value); })
        for (const _item0 of this.qudt_PhysicalConstant$j$ucumCode) { _hasher.update(_item0); }

        return _hasher;
    }

    override toJson(): { readonly "qudt_PhysicalConstant$j$altSymbol": readonly ({ readonly "@id": string, readonly termType: "BlankNode" | "NamedNode" } | { readonly "@language": string | undefined, readonly "@type": string | undefined, readonly "@value": string, readonly termType: "Literal" })[]; readonly "qudt_PhysicalConstant$j$applicableSystem": readonly (ReturnType<System_of$W$Units["toJson"]>)[]; readonly "qudt_PhysicalConstant$j$applicableUnit": readonly (ReturnType<Abstract_Unit["toJson"]>)[]; readonly "qudt_PhysicalConstant$j$dbpediaMatch": readonly (string)[]; readonly "qudt_PhysicalConstant$j$exactConstant": readonly (boolean)[]; readonly "qudt_PhysicalConstant$j$hasDimensionVector": readonly (ReturnType<Quantity_Kind$W$Dimension$W$Vector["toJson"]>)[]; readonly "qudt_PhysicalConstant$j$iec61360Code": readonly (string)[]; readonly "qudt_PhysicalConstant$j$isoNormativeReference": readonly (string)[]; readonly "qudt_PhysicalConstant$j$latexDefinition": (string) | undefined; readonly "qudt_PhysicalConstant$j$latexSymbol": readonly (string)[]; readonly "qudt_PhysicalConstant$j$mathMLdefinition": (string) | undefined; readonly "qudt_PhysicalConstant$j$normativeReference": readonly (string)[]; readonly "qudt_PhysicalConstant$j$siExactMatch": ({ readonly "@id": string, readonly termType: "BlankNode" | "NamedNode" } | { readonly "@language": string | undefined, readonly "@type": string | undefined, readonly "@value": string, readonly termType: "Literal" }) | undefined; readonly "qudt_PhysicalConstant$j$symbol": ({ readonly "@id": string, readonly termType: "BlankNode" | "NamedNode" } | { readonly "@language": string | undefined, readonly "@type": string | undefined, readonly "@value": string, readonly termType: "Literal" }) | undefined; readonly "qudt_PhysicalConstant$j$ucumCode": readonly (string)[] } & ReturnType<Quantity["toJson"]> {
        return JSON.parse(JSON.stringify({ ...super.toJson(),qudt_PhysicalConstant$j$altSymbol: this.qudt_PhysicalConstant$j$altSymbol.map(_item => ((_item.termType === "Literal") ? { "@language": _item.language.length > 0 ? _item.language : undefined, "@type": _item.datatype.value !== "http://www.w3.org/2001/XMLSchema#string" ? _item.datatype.value : undefined, "@value": _item.value, termType: "Literal" as const } : (_item.termType === "NamedNode") ? { "@id": _item.value, termType: "NamedNode" as const } : { "@id": `_:${_item.value}`, termType: "BlankNode" as const })),qudt_PhysicalConstant$j$applicableSystem: this.qudt_PhysicalConstant$j$applicableSystem.map(_item => (_item.toJson())),qudt_PhysicalConstant$j$applicableUnit: this.qudt_PhysicalConstant$j$applicableUnit.map(_item => (_item.toJson())),qudt_PhysicalConstant$j$dbpediaMatch: this.qudt_PhysicalConstant$j$dbpediaMatch.map(_item => (_item)),qudt_PhysicalConstant$j$exactConstant: this.qudt_PhysicalConstant$j$exactConstant.map(_item => (_item)),qudt_PhysicalConstant$j$hasDimensionVector: this.qudt_PhysicalConstant$j$hasDimensionVector.map(_item => (_item.toJson())),qudt_PhysicalConstant$j$iec61360Code: this.qudt_PhysicalConstant$j$iec61360Code.map(_item => (_item)),qudt_PhysicalConstant$j$isoNormativeReference: this.qudt_PhysicalConstant$j$isoNormativeReference.map(_item => (_item)),qudt_PhysicalConstant$j$latexDefinition: this.qudt_PhysicalConstant$j$latexDefinition.map(_item => (_item)).extract(),qudt_PhysicalConstant$j$latexSymbol: this.qudt_PhysicalConstant$j$latexSymbol.map(_item => (_item)),qudt_PhysicalConstant$j$mathMLdefinition: this.qudt_PhysicalConstant$j$mathMLdefinition.map(_item => (_item)).extract(),qudt_PhysicalConstant$j$normativeReference: this.qudt_PhysicalConstant$j$normativeReference.map(_item => (_item)),qudt_PhysicalConstant$j$siExactMatch: this.qudt_PhysicalConstant$j$siExactMatch.map(_item => ((_item.termType === "Literal") ? { "@language": _item.language.length > 0 ? _item.language : undefined, "@type": _item.datatype.value !== "http://www.w3.org/2001/XMLSchema#string" ? _item.datatype.value : undefined, "@value": _item.value, termType: "Literal" as const } : (_item.termType === "NamedNode") ? { "@id": _item.value, termType: "NamedNode" as const } : { "@id": `_:${_item.value}`, termType: "BlankNode" as const })).extract(),qudt_PhysicalConstant$j$symbol: this.qudt_PhysicalConstant$j$symbol.map(_item => ((_item.termType === "Literal") ? { "@language": _item.language.length > 0 ? _item.language : undefined, "@type": _item.datatype.value !== "http://www.w3.org/2001/XMLSchema#string" ? _item.datatype.value : undefined, "@value": _item.value, termType: "Literal" as const } : (_item.termType === "NamedNode") ? { "@id": _item.value, termType: "NamedNode" as const } : { "@id": `_:${_item.value}`, termType: "BlankNode" as const })).extract(),qudt_PhysicalConstant$j$ucumCode: this.qudt_PhysicalConstant$j$ucumCode.map(_item => (_item)) } satisfies ReturnType<Physical_Constant["toJson"]>));
    }

    override toRdf({ ignoreRdfType, mutateGraph, resourceSet }: { ignoreRdfType?: boolean; mutateGraph?: rdfjsResource.MutableResource.MutateGraph, resourceSet: rdfjsResource.MutableResourceSet }): rdfjsResource.MutableResource {
        const _resource = super.toRdf({ ignoreRdfType: true, mutateGraph, resourceSet });
        if (!ignoreRdfType) { _resource.add(_resource.dataFactory.namedNode("http://www.w3.org/1999/02/22-rdf-syntax-ns#type"), _resource.dataFactory.namedNode("http://qudt.org/schema/qudt/PhysicalConstant")); }

        _resource.add(dataFactory.namedNode("http://qudt.org/schema/qudt/altSymbol"), this.qudt_PhysicalConstant$j$altSymbol.map((_item) => _item));
        _resource.add(dataFactory.namedNode("http://qudt.org/schema/qudt/applicableSystem"), this.qudt_PhysicalConstant$j$applicableSystem.map((_item) => _item.toRdf({ mutateGraph: mutateGraph, resourceSet: resourceSet })));
        _resource.add(dataFactory.namedNode("http://qudt.org/schema/qudt/applicableUnit"), this.qudt_PhysicalConstant$j$applicableUnit.map((_item) => _item.toRdf({ mutateGraph: mutateGraph, resourceSet: resourceSet })));
        _resource.add(dataFactory.namedNode("http://qudt.org/schema/qudt/dbpediaMatch"), this.qudt_PhysicalConstant$j$dbpediaMatch.map((_item) => _item));
        _resource.add(dataFactory.namedNode("http://qudt.org/schema/qudt/exactConstant"), this.qudt_PhysicalConstant$j$exactConstant.map((_item) => _item));
        _resource.add(dataFactory.namedNode("http://qudt.org/schema/qudt/hasDimensionVector"), this.qudt_PhysicalConstant$j$hasDimensionVector.map((_item) => _item.toRdf({ mutateGraph: mutateGraph, resourceSet: resourceSet })));
        _resource.add(dataFactory.namedNode("http://qudt.org/schema/qudt/iec61360Code"), this.qudt_PhysicalConstant$j$iec61360Code.map((_item) => _item));
        _resource.add(dataFactory.namedNode("http://qudt.org/schema/qudt/isoNormativeReference"), this.qudt_PhysicalConstant$j$isoNormativeReference.map((_item) => _item));
        _resource.add(dataFactory.namedNode("http://qudt.org/schema/qudt/latexDefinition"), this.qudt_PhysicalConstant$j$latexDefinition);
        _resource.add(dataFactory.namedNode("http://qudt.org/schema/qudt/latexSymbol"), this.qudt_PhysicalConstant$j$latexSymbol.map((_item) => _item));
        _resource.add(dataFactory.namedNode("http://qudt.org/schema/qudt/mathMLdefinition"), this.qudt_PhysicalConstant$j$mathMLdefinition);
        _resource.add(dataFactory.namedNode("http://qudt.org/schema/qudt/normativeReference"), this.qudt_PhysicalConstant$j$normativeReference.map((_item) => _item));
        _resource.add(dataFactory.namedNode("http://qudt.org/schema/qudt/siExactMatch"), this.qudt_PhysicalConstant$j$siExactMatch);
        _resource.add(dataFactory.namedNode("http://qudt.org/schema/qudt/symbol"), this.qudt_PhysicalConstant$j$symbol);
        _resource.add(dataFactory.namedNode("http://qudt.org/schema/qudt/ucumCode"), this.qudt_PhysicalConstant$j$ucumCode.map((_item) => _item));
        return _resource;
    }

    override toString(): string {
        return JSON.stringify(this.toJson());
    }
}

export namespace Physical_Constant {
    export function _propertiesFromJson(_json: unknown): purify.Either<zod.ZodError, { identifier: (rdfjs.BlankNode | rdfjs.NamedNode); qudt_PhysicalConstant$j$altSymbol: readonly ((rdfjs.BlankNode | rdfjs.NamedNode | rdfjs.Literal))[]; qudt_PhysicalConstant$j$applicableSystem: readonly (System_of$W$Units)[]; qudt_PhysicalConstant$j$applicableUnit: readonly (Abstract_Unit)[]; qudt_PhysicalConstant$j$dbpediaMatch: readonly (string)[]; qudt_PhysicalConstant$j$exactConstant: readonly (boolean)[]; qudt_PhysicalConstant$j$hasDimensionVector: readonly (Quantity_Kind$W$Dimension$W$Vector)[]; qudt_PhysicalConstant$j$iec61360Code: readonly (string)[]; qudt_PhysicalConstant$j$isoNormativeReference: readonly (string)[]; qudt_PhysicalConstant$j$latexDefinition: purify.Maybe<string>; qudt_PhysicalConstant$j$latexSymbol: readonly (string)[]; qudt_PhysicalConstant$j$mathMLdefinition: purify.Maybe<string>; qudt_PhysicalConstant$j$normativeReference: readonly (string)[]; qudt_PhysicalConstant$j$siExactMatch: purify.Maybe<(rdfjs.BlankNode | rdfjs.NamedNode | rdfjs.Literal)>; qudt_PhysicalConstant$j$symbol: purify.Maybe<(rdfjs.BlankNode | rdfjs.NamedNode | rdfjs.Literal)>; qudt_PhysicalConstant$j$ucumCode: readonly (string)[]; } & UnwrapR<ReturnType<typeof Quantity._propertiesFromJson>>> {
        const _jsonSafeParseResult = physicalConstantJsonZodSchema().safeParse(_json);
        if (!_jsonSafeParseResult.success) { return purify.Left(_jsonSafeParseResult.error); }

        const _jsonObject = _jsonSafeParseResult.data;
        const _super0Either = Quantity._propertiesFromJson(_jsonObject);
        if (_super0Either.isLeft()) { return _super0Either; }

        const _super0 = _super0Either.unsafeCoerce()
        const identifier = (_jsonObject["@id"].startsWith("_:") ? dataFactory.blankNode(_jsonObject["@id"].substring(2)) : dataFactory.namedNode(_jsonObject["@id"]));
        const qudt_PhysicalConstant$j$altSymbol = _jsonObject["qudt_PhysicalConstant$j$altSymbol"].map(_item => (((_item.termType === "Literal") ? (dataFactory.literal(_item["@value"], typeof _item["@language"] !== "undefined" ? _item["@language"] : (typeof _item["@type"] !== "undefined" ? dataFactory.namedNode(_item["@type"]) : undefined))) : (((_item.termType === "NamedNode") ? (dataFactory.namedNode(_item["@id"])) : (dataFactory.blankNode(_item["@id"].substring(2))))))));
        const qudt_PhysicalConstant$j$applicableSystem = _jsonObject["qudt_PhysicalConstant$j$applicableSystem"].map(_item => (System_of$W$Units.fromJson(_item).unsafeCoerce()));
        const qudt_PhysicalConstant$j$applicableUnit = _jsonObject["qudt_PhysicalConstant$j$applicableUnit"].map(_item => (Abstract_Unit.fromJson(_item).unsafeCoerce()));
        const qudt_PhysicalConstant$j$dbpediaMatch = _jsonObject["qudt_PhysicalConstant$j$dbpediaMatch"];
        const qudt_PhysicalConstant$j$exactConstant = _jsonObject["qudt_PhysicalConstant$j$exactConstant"];
        const qudt_PhysicalConstant$j$hasDimensionVector = _jsonObject["qudt_PhysicalConstant$j$hasDimensionVector"].map(_item => (Quantity_Kind$W$Dimension$W$Vector.fromJson(_item).unsafeCoerce()));
        const qudt_PhysicalConstant$j$iec61360Code = _jsonObject["qudt_PhysicalConstant$j$iec61360Code"];
        const qudt_PhysicalConstant$j$isoNormativeReference = _jsonObject["qudt_PhysicalConstant$j$isoNormativeReference"];
        const qudt_PhysicalConstant$j$latexDefinition = purify.Maybe.fromNullable(_jsonObject["qudt_PhysicalConstant$j$latexDefinition"]);
        const qudt_PhysicalConstant$j$latexSymbol = _jsonObject["qudt_PhysicalConstant$j$latexSymbol"];
        const qudt_PhysicalConstant$j$mathMLdefinition = purify.Maybe.fromNullable(_jsonObject["qudt_PhysicalConstant$j$mathMLdefinition"]);
        const qudt_PhysicalConstant$j$normativeReference = _jsonObject["qudt_PhysicalConstant$j$normativeReference"];
        const qudt_PhysicalConstant$j$siExactMatch = purify.Maybe.fromNullable(_jsonObject["qudt_PhysicalConstant$j$siExactMatch"]).map(_item => (((_item.termType === "Literal") ? (dataFactory.literal(_item["@value"], typeof _item["@language"] !== "undefined" ? _item["@language"] : (typeof _item["@type"] !== "undefined" ? dataFactory.namedNode(_item["@type"]) : undefined))) : (((_item.termType === "NamedNode") ? (dataFactory.namedNode(_item["@id"])) : (dataFactory.blankNode(_item["@id"].substring(2))))))));
        const qudt_PhysicalConstant$j$symbol = purify.Maybe.fromNullable(_jsonObject["qudt_PhysicalConstant$j$symbol"]).map(_item => (((_item.termType === "Literal") ? (dataFactory.literal(_item["@value"], typeof _item["@language"] !== "undefined" ? _item["@language"] : (typeof _item["@type"] !== "undefined" ? dataFactory.namedNode(_item["@type"]) : undefined))) : (((_item.termType === "NamedNode") ? (dataFactory.namedNode(_item["@id"])) : (dataFactory.blankNode(_item["@id"].substring(2))))))));
        const qudt_PhysicalConstant$j$ucumCode = _jsonObject["qudt_PhysicalConstant$j$ucumCode"];
        return purify.Either.of({ ..._super0, identifier, qudt_PhysicalConstant$j$altSymbol, qudt_PhysicalConstant$j$applicableSystem, qudt_PhysicalConstant$j$applicableUnit, qudt_PhysicalConstant$j$dbpediaMatch, qudt_PhysicalConstant$j$exactConstant, qudt_PhysicalConstant$j$hasDimensionVector, qudt_PhysicalConstant$j$iec61360Code, qudt_PhysicalConstant$j$isoNormativeReference, qudt_PhysicalConstant$j$latexDefinition, qudt_PhysicalConstant$j$latexSymbol, qudt_PhysicalConstant$j$mathMLdefinition, qudt_PhysicalConstant$j$normativeReference, qudt_PhysicalConstant$j$siExactMatch, qudt_PhysicalConstant$j$symbol, qudt_PhysicalConstant$j$ucumCode })
    }

    export function fromJson(json: unknown): purify.Either<zod.ZodError, Physical_Constant> {
        return Physical_Constant._propertiesFromJson(json).map(properties => new Physical_Constant(properties));
    }

    export function _propertiesFromRdf({ ignoreRdfType: _ignoreRdfType, languageIn: _languageIn, resource: _resource,
        // @ts-ignore
        ..._context }: { [_index: string]: any; ignoreRdfType?: boolean; languageIn?: readonly string[]; resource: rdfjsResource.Resource; }): purify.Either<rdfjsResource.Resource.ValueError, { identifier: (rdfjs.BlankNode | rdfjs.NamedNode); qudt_PhysicalConstant$j$altSymbol: readonly ((rdfjs.BlankNode | rdfjs.NamedNode | rdfjs.Literal))[]; qudt_PhysicalConstant$j$applicableSystem: readonly (System_of$W$Units)[]; qudt_PhysicalConstant$j$applicableUnit: readonly (Abstract_Unit)[]; qudt_PhysicalConstant$j$dbpediaMatch: readonly (string)[]; qudt_PhysicalConstant$j$exactConstant: readonly (boolean)[]; qudt_PhysicalConstant$j$hasDimensionVector: readonly (Quantity_Kind$W$Dimension$W$Vector)[]; qudt_PhysicalConstant$j$iec61360Code: readonly (string)[]; qudt_PhysicalConstant$j$isoNormativeReference: readonly (string)[]; qudt_PhysicalConstant$j$latexDefinition: purify.Maybe<string>; qudt_PhysicalConstant$j$latexSymbol: readonly (string)[]; qudt_PhysicalConstant$j$mathMLdefinition: purify.Maybe<string>; qudt_PhysicalConstant$j$normativeReference: readonly (string)[]; qudt_PhysicalConstant$j$siExactMatch: purify.Maybe<(rdfjs.BlankNode | rdfjs.NamedNode | rdfjs.Literal)>; qudt_PhysicalConstant$j$symbol: purify.Maybe<(rdfjs.BlankNode | rdfjs.NamedNode | rdfjs.Literal)>; qudt_PhysicalConstant$j$ucumCode: readonly (string)[]; } & UnwrapR<ReturnType<typeof Quantity._propertiesFromRdf>>> {
        const _super0Either = Quantity._propertiesFromRdf({ ..._context, ignoreRdfType: true, languageIn: _languageIn, resource: _resource });
        if (_super0Either.isLeft()) { return _super0Either; }

        const _super0 = _super0Either.unsafeCoerce()
        if (!_ignoreRdfType && !_resource.isInstanceOf(dataFactory.namedNode("http://qudt.org/schema/qudt/PhysicalConstant"))) { return purify.Left(new rdfjsResource.Resource.ValueError({ focusResource: _resource, message: `${rdfjsResource.Resource.Identifier.toString(_resource.identifier)} has unexpected RDF type (expected http://qudt.org/schema/qudt/PhysicalConstant)`, predicate: dataFactory.namedNode("http://qudt.org/schema/qudt/PhysicalConstant") })); }

        const identifier = _resource.identifier
        const _qudt_PhysicalConstant$j$altSymbolEither: purify.Either<rdfjsResource.Resource.ValueError, readonly ((rdfjs.BlankNode | rdfjs.NamedNode | rdfjs.Literal))[]> = purify.Either.of([..._resource.values(dataFactory.namedNode("http://qudt.org/schema/qudt/altSymbol"), { unique: true }).flatMap(_item => _item.toValues().head().chain(_value => purify.Either.of(_value.toTerm())).toMaybe().toList())]);
        if (_qudt_PhysicalConstant$j$altSymbolEither.isLeft()) { return _qudt_PhysicalConstant$j$altSymbolEither; }

        const qudt_PhysicalConstant$j$altSymbol = _qudt_PhysicalConstant$j$altSymbolEither.unsafeCoerce();
        const _qudt_PhysicalConstant$j$applicableSystemEither: purify.Either<rdfjsResource.Resource.ValueError, readonly (System_of$W$Units)[]> = purify.Either.of([..._resource.values(dataFactory.namedNode("http://qudt.org/schema/qudt/applicableSystem"), { unique: true }).flatMap(_item => _item.toValues().head().chain(value => value.toResource()).chain(_resource => System_of$W$Units.fromRdf({ ..._context, ignoreRdfType: true, languageIn: _languageIn, resource: _resource })).toMaybe().toList())]);
        if (_qudt_PhysicalConstant$j$applicableSystemEither.isLeft()) { return _qudt_PhysicalConstant$j$applicableSystemEither; }

        const qudt_PhysicalConstant$j$applicableSystem = _qudt_PhysicalConstant$j$applicableSystemEither.unsafeCoerce();
        const _qudt_PhysicalConstant$j$applicableUnitEither: purify.Either<rdfjsResource.Resource.ValueError, readonly (Abstract_Unit)[]> = purify.Either.of([..._resource.values(dataFactory.namedNode("http://qudt.org/schema/qudt/applicableUnit"), { unique: true }).flatMap(_item => _item.toValues().head().chain(value => value.toResource()).chain(_resource => Abstract_Unit.fromRdf({ ..._context, ignoreRdfType: true, languageIn: _languageIn, resource: _resource })).toMaybe().toList())]);
        if (_qudt_PhysicalConstant$j$applicableUnitEither.isLeft()) { return _qudt_PhysicalConstant$j$applicableUnitEither; }

        const qudt_PhysicalConstant$j$applicableUnit = _qudt_PhysicalConstant$j$applicableUnitEither.unsafeCoerce();
        const _qudt_PhysicalConstant$j$dbpediaMatchEither: purify.Either<rdfjsResource.Resource.ValueError, readonly (string)[]> = purify.Either.of([..._resource.values(dataFactory.namedNode("http://qudt.org/schema/qudt/dbpediaMatch"), { unique: true }).flatMap(_item => _item.toValues().head().chain(_value => _value.toString()).toMaybe().toList())]);
        if (_qudt_PhysicalConstant$j$dbpediaMatchEither.isLeft()) { return _qudt_PhysicalConstant$j$dbpediaMatchEither; }

        const qudt_PhysicalConstant$j$dbpediaMatch = _qudt_PhysicalConstant$j$dbpediaMatchEither.unsafeCoerce();
        const _qudt_PhysicalConstant$j$exactConstantEither: purify.Either<rdfjsResource.Resource.ValueError, readonly (boolean)[]> = purify.Either.of([..._resource.values(dataFactory.namedNode("http://qudt.org/schema/qudt/exactConstant"), { unique: true }).flatMap(_item => _item.toValues().head().chain(_value => _value.toBoolean()).toMaybe().toList())]);
        if (_qudt_PhysicalConstant$j$exactConstantEither.isLeft()) { return _qudt_PhysicalConstant$j$exactConstantEither; }

        const qudt_PhysicalConstant$j$exactConstant = _qudt_PhysicalConstant$j$exactConstantEither.unsafeCoerce();
        const _qudt_PhysicalConstant$j$hasDimensionVectorEither: purify.Either<rdfjsResource.Resource.ValueError, readonly (Quantity_Kind$W$Dimension$W$Vector)[]> = purify.Either.of([..._resource.values(dataFactory.namedNode("http://qudt.org/schema/qudt/hasDimensionVector"), { unique: true }).flatMap(_item => _item.toValues().head().chain(value => value.toResource()).chain(_resource => Quantity_Kind$W$Dimension$W$Vector.fromRdf({ ..._context, ignoreRdfType: true, languageIn: _languageIn, resource: _resource })).toMaybe().toList())]);
        if (_qudt_PhysicalConstant$j$hasDimensionVectorEither.isLeft()) { return _qudt_PhysicalConstant$j$hasDimensionVectorEither; }

        const qudt_PhysicalConstant$j$hasDimensionVector = _qudt_PhysicalConstant$j$hasDimensionVectorEither.unsafeCoerce();
        const _qudt_PhysicalConstant$j$iec61360CodeEither: purify.Either<rdfjsResource.Resource.ValueError, readonly (string)[]> = purify.Either.of([..._resource.values(dataFactory.namedNode("http://qudt.org/schema/qudt/iec61360Code"), { unique: true }).flatMap(_item => _item.toValues().head().chain(_value => _value.toString()).toMaybe().toList())]);
        if (_qudt_PhysicalConstant$j$iec61360CodeEither.isLeft()) { return _qudt_PhysicalConstant$j$iec61360CodeEither; }

        const qudt_PhysicalConstant$j$iec61360Code = _qudt_PhysicalConstant$j$iec61360CodeEither.unsafeCoerce();
        const _qudt_PhysicalConstant$j$isoNormativeReferenceEither: purify.Either<rdfjsResource.Resource.ValueError, readonly (string)[]> = purify.Either.of([..._resource.values(dataFactory.namedNode("http://qudt.org/schema/qudt/isoNormativeReference"), { unique: true }).flatMap(_item => _item.toValues().head().chain(_value => _value.toString()).toMaybe().toList())]);
        if (_qudt_PhysicalConstant$j$isoNormativeReferenceEither.isLeft()) { return _qudt_PhysicalConstant$j$isoNormativeReferenceEither; }

        const qudt_PhysicalConstant$j$isoNormativeReference = _qudt_PhysicalConstant$j$isoNormativeReferenceEither.unsafeCoerce();
        const _qudt_PhysicalConstant$j$latexDefinitionEither: purify.Either<rdfjsResource.Resource.ValueError, purify.Maybe<string>> = purify.Either.of(_resource.values(dataFactory.namedNode("http://qudt.org/schema/qudt/latexDefinition"), { unique: true }).head().chain(_value => _value.toString()).toMaybe());
        if (_qudt_PhysicalConstant$j$latexDefinitionEither.isLeft()) { return _qudt_PhysicalConstant$j$latexDefinitionEither; }

        const qudt_PhysicalConstant$j$latexDefinition = _qudt_PhysicalConstant$j$latexDefinitionEither.unsafeCoerce();
        const _qudt_PhysicalConstant$j$latexSymbolEither: purify.Either<rdfjsResource.Resource.ValueError, readonly (string)[]> = purify.Either.of([..._resource.values(dataFactory.namedNode("http://qudt.org/schema/qudt/latexSymbol"), { unique: true }).flatMap(_item => _item.toValues().head().chain(_value => _value.toString()).toMaybe().toList())]);
        if (_qudt_PhysicalConstant$j$latexSymbolEither.isLeft()) { return _qudt_PhysicalConstant$j$latexSymbolEither; }

        const qudt_PhysicalConstant$j$latexSymbol = _qudt_PhysicalConstant$j$latexSymbolEither.unsafeCoerce();
        const _qudt_PhysicalConstant$j$mathMLdefinitionEither: purify.Either<rdfjsResource.Resource.ValueError, purify.Maybe<string>> = purify.Either.of(_resource.values(dataFactory.namedNode("http://qudt.org/schema/qudt/mathMLdefinition"), { unique: true }).head().chain(_value => _value.toString()).toMaybe());
        if (_qudt_PhysicalConstant$j$mathMLdefinitionEither.isLeft()) { return _qudt_PhysicalConstant$j$mathMLdefinitionEither; }

        const qudt_PhysicalConstant$j$mathMLdefinition = _qudt_PhysicalConstant$j$mathMLdefinitionEither.unsafeCoerce();
        const _qudt_PhysicalConstant$j$normativeReferenceEither: purify.Either<rdfjsResource.Resource.ValueError, readonly (string)[]> = purify.Either.of([..._resource.values(dataFactory.namedNode("http://qudt.org/schema/qudt/normativeReference"), { unique: true }).flatMap(_item => _item.toValues().head().chain(_value => _value.toString()).toMaybe().toList())]);
        if (_qudt_PhysicalConstant$j$normativeReferenceEither.isLeft()) { return _qudt_PhysicalConstant$j$normativeReferenceEither; }

        const qudt_PhysicalConstant$j$normativeReference = _qudt_PhysicalConstant$j$normativeReferenceEither.unsafeCoerce();
        const _qudt_PhysicalConstant$j$siExactMatchEither: purify.Either<rdfjsResource.Resource.ValueError, purify.Maybe<(rdfjs.BlankNode | rdfjs.NamedNode | rdfjs.Literal)>> = purify.Either.of(_resource.values(dataFactory.namedNode("http://qudt.org/schema/qudt/siExactMatch"), { unique: true }).head().chain(_value => purify.Either.of(_value.toTerm())).toMaybe());
        if (_qudt_PhysicalConstant$j$siExactMatchEither.isLeft()) { return _qudt_PhysicalConstant$j$siExactMatchEither; }

        const qudt_PhysicalConstant$j$siExactMatch = _qudt_PhysicalConstant$j$siExactMatchEither.unsafeCoerce();
        const _qudt_PhysicalConstant$j$symbolEither: purify.Either<rdfjsResource.Resource.ValueError, purify.Maybe<(rdfjs.BlankNode | rdfjs.NamedNode | rdfjs.Literal)>> = purify.Either.of(_resource.values(dataFactory.namedNode("http://qudt.org/schema/qudt/symbol"), { unique: true }).head().chain(_value => purify.Either.of(_value.toTerm())).toMaybe());
        if (_qudt_PhysicalConstant$j$symbolEither.isLeft()) { return _qudt_PhysicalConstant$j$symbolEither; }

        const qudt_PhysicalConstant$j$symbol = _qudt_PhysicalConstant$j$symbolEither.unsafeCoerce();
        const _qudt_PhysicalConstant$j$ucumCodeEither: purify.Either<rdfjsResource.Resource.ValueError, readonly (string)[]> = purify.Either.of([..._resource.values(dataFactory.namedNode("http://qudt.org/schema/qudt/ucumCode"), { unique: true }).flatMap(_item => _item.toValues().head().chain(_value => _value.toString()).toMaybe().toList())]);
        if (_qudt_PhysicalConstant$j$ucumCodeEither.isLeft()) { return _qudt_PhysicalConstant$j$ucumCodeEither; }

        const qudt_PhysicalConstant$j$ucumCode = _qudt_PhysicalConstant$j$ucumCodeEither.unsafeCoerce();
        return purify.Either.of({ ..._super0, identifier, qudt_PhysicalConstant$j$altSymbol, qudt_PhysicalConstant$j$applicableSystem, qudt_PhysicalConstant$j$applicableUnit, qudt_PhysicalConstant$j$dbpediaMatch, qudt_PhysicalConstant$j$exactConstant, qudt_PhysicalConstant$j$hasDimensionVector, qudt_PhysicalConstant$j$iec61360Code, qudt_PhysicalConstant$j$isoNormativeReference, qudt_PhysicalConstant$j$latexDefinition, qudt_PhysicalConstant$j$latexSymbol, qudt_PhysicalConstant$j$mathMLdefinition, qudt_PhysicalConstant$j$normativeReference, qudt_PhysicalConstant$j$siExactMatch, qudt_PhysicalConstant$j$symbol, qudt_PhysicalConstant$j$ucumCode })
    }

    export function fromRdf(parameters: Parameters<typeof Physical_Constant._propertiesFromRdf>[0]): purify.Either<rdfjsResource.Resource.ValueError, Physical_Constant> {
        return Physical_Constant._propertiesFromRdf(parameters).map(properties => new Physical_Constant(properties));
    }

    export let fromRdfType: rdfjs.NamedNode<string> = dataFactory.namedNode("http://qudt.org/schema/qudt/PhysicalConstant");

    export function jsonSchema() {
        return zodToJsonSchema(physicalConstantJsonZodSchema());
    }

    export function physicalConstantJsonUiSchema(parameters?: { scopePrefix?: string }) {
        const scopePrefix = parameters?.scopePrefix ?? "#";
        return { "elements": [ Quantity.quantityJsonUiSchema({ scopePrefix }), { scope: `${scopePrefix}/properties/qudt_PhysicalConstant$j$altSymbol`, type: "Control" }, System_of$W$Units.systemOfWUnitsJsonUiSchema({ scopePrefix: `${scopePrefix}/properties/qudt_PhysicalConstant$j$applicableSystem` }), Abstract_Unit.abstractUnitJsonUiSchema({ scopePrefix: `${scopePrefix}/properties/qudt_PhysicalConstant$j$applicableUnit` }), { scope: `${scopePrefix}/properties/qudt_PhysicalConstant$j$dbpediaMatch`, type: "Control" }, { scope: `${scopePrefix}/properties/qudt_PhysicalConstant$j$exactConstant`, type: "Control" }, Quantity_Kind$W$Dimension$W$Vector.quantityKindWDimensionWVectorJsonUiSchema({ scopePrefix: `${scopePrefix}/properties/qudt_PhysicalConstant$j$hasDimensionVector` }), { scope: `${scopePrefix}/properties/qudt_PhysicalConstant$j$iec61360Code`, type: "Control" }, { scope: `${scopePrefix}/properties/qudt_PhysicalConstant$j$isoNormativeReference`, type: "Control" }, { scope: `${scopePrefix}/properties/qudt_PhysicalConstant$j$latexDefinition`, type: "Control" }, { scope: `${scopePrefix}/properties/qudt_PhysicalConstant$j$latexSymbol`, type: "Control" }, { scope: `${scopePrefix}/properties/qudt_PhysicalConstant$j$mathMLdefinition`, type: "Control" }, { scope: `${scopePrefix}/properties/qudt_PhysicalConstant$j$normativeReference`, type: "Control" }, { scope: `${scopePrefix}/properties/qudt_PhysicalConstant$j$siExactMatch`, type: "Control" }, { scope: `${scopePrefix}/properties/qudt_PhysicalConstant$j$symbol`, type: "Control" }, { scope: `${scopePrefix}/properties/qudt_PhysicalConstant$j$ucumCode`, type: "Control" } ], label: "Physical Constant", type: "Group" }
    }

    export function physicalConstantJsonZodSchema() {
        return Quantity.quantityJsonZodSchema().merge(zod.object({ "@id": zod.string().min(1),"type": zod.literal("Physical_Constant"),"qudt_PhysicalConstant$j$altSymbol": zod.discriminatedUnion("termType", [zod.object({ "@id": zod.string().min(1), termType: zod.literal("BlankNode") }), zod.object({ "@id": zod.string().min(1), termType: zod.literal("NamedNode") }), zod.object({ "@language": zod.string().optional(), "@type": zod.string().optional(), "@value": zod.string(), termType: zod.literal("Literal") })]).array(),"qudt_PhysicalConstant$j$applicableSystem": System_of$W$Units.systemOfWUnitsJsonZodSchema().array(),"qudt_PhysicalConstant$j$applicableUnit": Abstract_Unit.abstractUnitJsonZodSchema().array(),"qudt_PhysicalConstant$j$dbpediaMatch": zod.string().array(),"qudt_PhysicalConstant$j$exactConstant": zod.boolean().array(),"qudt_PhysicalConstant$j$hasDimensionVector": Quantity_Kind$W$Dimension$W$Vector.quantityKindWDimensionWVectorJsonZodSchema().array(),"qudt_PhysicalConstant$j$iec61360Code": zod.string().array(),"qudt_PhysicalConstant$j$isoNormativeReference": zod.string().array(),"qudt_PhysicalConstant$j$latexDefinition": zod.string().optional(),"qudt_PhysicalConstant$j$latexSymbol": zod.string().array(),"qudt_PhysicalConstant$j$mathMLdefinition": zod.string().optional(),"qudt_PhysicalConstant$j$normativeReference": zod.string().array(),"qudt_PhysicalConstant$j$siExactMatch": zod.discriminatedUnion("termType", [zod.object({ "@id": zod.string().min(1), termType: zod.literal("BlankNode") }), zod.object({ "@id": zod.string().min(1), termType: zod.literal("NamedNode") }), zod.object({ "@language": zod.string().optional(), "@type": zod.string().optional(), "@value": zod.string(), termType: zod.literal("Literal") })]).optional(),"qudt_PhysicalConstant$j$symbol": zod.discriminatedUnion("termType", [zod.object({ "@id": zod.string().min(1), termType: zod.literal("BlankNode") }), zod.object({ "@id": zod.string().min(1), termType: zod.literal("NamedNode") }), zod.object({ "@language": zod.string().optional(), "@type": zod.string().optional(), "@value": zod.string(), termType: zod.literal("Literal") })]).optional(),"qudt_PhysicalConstant$j$ucumCode": zod.string().array() }));
    }

    export function sparqlConstructQuery(parameters?: { ignoreRdfType?: boolean; prefixes?: { [prefix: string]: string }; subject?: sparqljs.Triple["subject"]; } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type">): sparqljs.ConstructQuery {
        const { ignoreRdfType, subject, ...queryParameters } = parameters ?? {}

        return { ...queryParameters, prefixes: parameters?.prefixes ?? {}, queryType: "CONSTRUCT", template: (queryParameters.template ?? []).concat(Physical_Constant.sparqlConstructTemplateTriples({ ignoreRdfType, subject })), type: "query", where: (queryParameters.where ?? []).concat(Physical_Constant.sparqlWherePatterns({ ignoreRdfType, subject })) };
    }

    export function sparqlConstructQueryString(parameters?: { ignoreRdfType?: boolean; subject?: sparqljs.Triple["subject"]; variablePrefix?: string; } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type"> & sparqljs.GeneratorOptions): string {
        return new sparqljs.Generator(parameters).stringify(Physical_Constant.sparqlConstructQuery(parameters));
    }

    export function sparqlConstructTemplateTriples(parameters?: { ignoreRdfType?: boolean; subject?: sparqljs.Triple["subject"], variablePrefix?: string }): readonly sparqljs.Triple[] {
        const subject = parameters?.subject ?? dataFactory.variable!("physicalConstant");
        const variablePrefix = parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "physicalConstant");
        return [...Quantity.sparqlConstructTemplateTriples({ ignoreRdfType: true, subject, variablePrefix }), ...(parameters?.ignoreRdfType ? [] : [{ subject, predicate: dataFactory.namedNode("http://www.w3.org/1999/02/22-rdf-syntax-ns#type"), object: dataFactory.variable!(`${variablePrefix}RdfType`) }]), { object: dataFactory.variable!(`${variablePrefix}QudtPhysicalConstantJAltSymbol`), predicate: dataFactory.namedNode("http://qudt.org/schema/qudt/altSymbol"), subject }, { object: dataFactory.variable!(`${variablePrefix}QudtPhysicalConstantJApplicableSystem`), predicate: dataFactory.namedNode("http://qudt.org/schema/qudt/applicableSystem"), subject }, ...System_of$W$Units.sparqlConstructTemplateTriples({ ignoreRdfType: true, subject: dataFactory.variable!(`${variablePrefix}QudtPhysicalConstantJApplicableSystem`), variablePrefix: `${variablePrefix}QudtPhysicalConstantJApplicableSystem` }), { object: dataFactory.variable!(`${variablePrefix}QudtPhysicalConstantJApplicableUnit`), predicate: dataFactory.namedNode("http://qudt.org/schema/qudt/applicableUnit"), subject }, ...Abstract_Unit.sparqlConstructTemplateTriples({ ignoreRdfType: true, subject: dataFactory.variable!(`${variablePrefix}QudtPhysicalConstantJApplicableUnit`), variablePrefix: `${variablePrefix}QudtPhysicalConstantJApplicableUnit` }), { object: dataFactory.variable!(`${variablePrefix}QudtPhysicalConstantJDbpediaMatch`), predicate: dataFactory.namedNode("http://qudt.org/schema/qudt/dbpediaMatch"), subject }, { object: dataFactory.variable!(`${variablePrefix}QudtPhysicalConstantJExactConstant`), predicate: dataFactory.namedNode("http://qudt.org/schema/qudt/exactConstant"), subject }, { object: dataFactory.variable!(`${variablePrefix}QudtPhysicalConstantJHasDimensionVector`), predicate: dataFactory.namedNode("http://qudt.org/schema/qudt/hasDimensionVector"), subject }, ...Quantity_Kind$W$Dimension$W$Vector.sparqlConstructTemplateTriples({ ignoreRdfType: true, subject: dataFactory.variable!(`${variablePrefix}QudtPhysicalConstantJHasDimensionVector`), variablePrefix: `${variablePrefix}QudtPhysicalConstantJHasDimensionVector` }), { object: dataFactory.variable!(`${variablePrefix}QudtPhysicalConstantJIec61360Code`), predicate: dataFactory.namedNode("http://qudt.org/schema/qudt/iec61360Code"), subject }, { object: dataFactory.variable!(`${variablePrefix}QudtPhysicalConstantJIsoNormativeReference`), predicate: dataFactory.namedNode("http://qudt.org/schema/qudt/isoNormativeReference"), subject }, { object: dataFactory.variable!(`${variablePrefix}QudtPhysicalConstantJLatexDefinition`), predicate: dataFactory.namedNode("http://qudt.org/schema/qudt/latexDefinition"), subject }, { object: dataFactory.variable!(`${variablePrefix}QudtPhysicalConstantJLatexSymbol`), predicate: dataFactory.namedNode("http://qudt.org/schema/qudt/latexSymbol"), subject }, { object: dataFactory.variable!(`${variablePrefix}QudtPhysicalConstantJMathMLdefinition`), predicate: dataFactory.namedNode("http://qudt.org/schema/qudt/mathMLdefinition"), subject }, { object: dataFactory.variable!(`${variablePrefix}QudtPhysicalConstantJNormativeReference`), predicate: dataFactory.namedNode("http://qudt.org/schema/qudt/normativeReference"), subject }, { object: dataFactory.variable!(`${variablePrefix}QudtPhysicalConstantJSiExactMatch`), predicate: dataFactory.namedNode("http://qudt.org/schema/qudt/siExactMatch"), subject }, { object: dataFactory.variable!(`${variablePrefix}QudtPhysicalConstantJSymbol`), predicate: dataFactory.namedNode("http://qudt.org/schema/qudt/symbol"), subject }, { object: dataFactory.variable!(`${variablePrefix}QudtPhysicalConstantJUcumCode`), predicate: dataFactory.namedNode("http://qudt.org/schema/qudt/ucumCode"), subject }];
    }

    export function sparqlWherePatterns(parameters: { ignoreRdfType?: boolean; subject?: sparqljs.Triple["subject"], variablePrefix?: string }): readonly sparqljs.Pattern[] {
        const subject = parameters?.subject ?? dataFactory.variable!("physicalConstant");
        const variablePrefix = parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "physicalConstant");
        return [...Quantity.sparqlWherePatterns({ ignoreRdfType: true, subject, variablePrefix }), ...(parameters?.ignoreRdfType ? [] : [{ triples: [{ subject, predicate: dataFactory.namedNode("http://www.w3.org/1999/02/22-rdf-syntax-ns#type"), object: dataFactory.namedNode("http://qudt.org/schema/qudt/PhysicalConstant") }], type: "bgp" as const }, { triples: [{ subject, predicate: dataFactory.namedNode("http://www.w3.org/1999/02/22-rdf-syntax-ns#type"), object: dataFactory.variable!(`${variablePrefix}RdfType`) }], type: "bgp" as const }]), { patterns: [{ triples: [{ object: dataFactory.variable!(`${variablePrefix}QudtPhysicalConstantJAltSymbol`), predicate: dataFactory.namedNode("http://qudt.org/schema/qudt/altSymbol"), subject }], type: "bgp" }], type: "optional" }, { patterns: [{ triples: [{ object: dataFactory.variable!(`${variablePrefix}QudtPhysicalConstantJApplicableSystem`), predicate: dataFactory.namedNode("http://qudt.org/schema/qudt/applicableSystem"), subject }], type: "bgp" }, ...System_of$W$Units.sparqlWherePatterns({ ignoreRdfType: true, subject: dataFactory.variable!(`${variablePrefix}QudtPhysicalConstantJApplicableSystem`), variablePrefix: `${variablePrefix}QudtPhysicalConstantJApplicableSystem` })], type: "optional" }, { patterns: [{ triples: [{ object: dataFactory.variable!(`${variablePrefix}QudtPhysicalConstantJApplicableUnit`), predicate: dataFactory.namedNode("http://qudt.org/schema/qudt/applicableUnit"), subject }], type: "bgp" }, ...Abstract_Unit.sparqlWherePatterns({ ignoreRdfType: true, subject: dataFactory.variable!(`${variablePrefix}QudtPhysicalConstantJApplicableUnit`), variablePrefix: `${variablePrefix}QudtPhysicalConstantJApplicableUnit` })], type: "optional" }, { patterns: [{ triples: [{ object: dataFactory.variable!(`${variablePrefix}QudtPhysicalConstantJDbpediaMatch`), predicate: dataFactory.namedNode("http://qudt.org/schema/qudt/dbpediaMatch"), subject }], type: "bgp" }], type: "optional" }, { patterns: [{ triples: [{ object: dataFactory.variable!(`${variablePrefix}QudtPhysicalConstantJExactConstant`), predicate: dataFactory.namedNode("http://qudt.org/schema/qudt/exactConstant"), subject }], type: "bgp" }], type: "optional" }, { patterns: [{ triples: [{ object: dataFactory.variable!(`${variablePrefix}QudtPhysicalConstantJHasDimensionVector`), predicate: dataFactory.namedNode("http://qudt.org/schema/qudt/hasDimensionVector"), subject }], type: "bgp" }, ...Quantity_Kind$W$Dimension$W$Vector.sparqlWherePatterns({ ignoreRdfType: true, subject: dataFactory.variable!(`${variablePrefix}QudtPhysicalConstantJHasDimensionVector`), variablePrefix: `${variablePrefix}QudtPhysicalConstantJHasDimensionVector` })], type: "optional" }, { patterns: [{ triples: [{ object: dataFactory.variable!(`${variablePrefix}QudtPhysicalConstantJIec61360Code`), predicate: dataFactory.namedNode("http://qudt.org/schema/qudt/iec61360Code"), subject }], type: "bgp" }], type: "optional" }, { patterns: [{ triples: [{ object: dataFactory.variable!(`${variablePrefix}QudtPhysicalConstantJIsoNormativeReference`), predicate: dataFactory.namedNode("http://qudt.org/schema/qudt/isoNormativeReference"), subject }], type: "bgp" }], type: "optional" }, { patterns: [{ triples: [{ object: dataFactory.variable!(`${variablePrefix}QudtPhysicalConstantJLatexDefinition`), predicate: dataFactory.namedNode("http://qudt.org/schema/qudt/latexDefinition"), subject }], type: "bgp" }], type: "optional" }, { patterns: [{ triples: [{ object: dataFactory.variable!(`${variablePrefix}QudtPhysicalConstantJLatexSymbol`), predicate: dataFactory.namedNode("http://qudt.org/schema/qudt/latexSymbol"), subject }], type: "bgp" }], type: "optional" }, { patterns: [{ triples: [{ object: dataFactory.variable!(`${variablePrefix}QudtPhysicalConstantJMathMLdefinition`), predicate: dataFactory.namedNode("http://qudt.org/schema/qudt/mathMLdefinition"), subject }], type: "bgp" }], type: "optional" }, { patterns: [{ triples: [{ object: dataFactory.variable!(`${variablePrefix}QudtPhysicalConstantJNormativeReference`), predicate: dataFactory.namedNode("http://qudt.org/schema/qudt/normativeReference"), subject }], type: "bgp" }], type: "optional" }, { patterns: [{ triples: [{ object: dataFactory.variable!(`${variablePrefix}QudtPhysicalConstantJSiExactMatch`), predicate: dataFactory.namedNode("http://qudt.org/schema/qudt/siExactMatch"), subject }], type: "bgp" }], type: "optional" }, { patterns: [{ triples: [{ object: dataFactory.variable!(`${variablePrefix}QudtPhysicalConstantJSymbol`), predicate: dataFactory.namedNode("http://qudt.org/schema/qudt/symbol"), subject }], type: "bgp" }], type: "optional" }, { patterns: [{ triples: [{ object: dataFactory.variable!(`${variablePrefix}QudtPhysicalConstantJUcumCode`), predicate: dataFactory.namedNode("http://qudt.org/schema/qudt/ucumCode"), subject }], type: "bgp" }], type: "optional" }];
    }
}
/**
 * Organization
 */
export class Organization extends QUDT_Concept {
    override readonly type = "Organization";
    readonly qudt_Organization$j$url: readonly (string)[];

    constructor(parameters: { readonly identifier?: (rdfjs.BlankNode | rdfjs.NamedNode) | string, readonly qudt_Organization$j$url?: readonly (string)[] } & ConstructorParameters<typeof QUDT_Concept>[0]) {
        super(parameters);
        if (typeof parameters.qudt_Organization$j$url === "undefined") { this.qudt_Organization$j$url = []; } else if (Array.isArray(parameters.qudt_Organization$j$url)) { this.qudt_Organization$j$url = parameters.qudt_Organization$j$url; } else { this.qudt_Organization$j$url =( parameters.qudt_Organization$j$url) as never;
         }
    }

    override get identifier(): (rdfjs.BlankNode | rdfjs.NamedNode) {
        if (typeof this._identifier === "undefined") { this._identifier = dataFactory.blankNode(); } return this._identifier;
    }

    override equals(other: Organization): EqualsResult {
        return super.equals(other).chain(() => (((left, right) => arrayEquals(left, right, strictEquals)))(this.qudt_Organization$j$url, other.qudt_Organization$j$url).mapLeft(propertyValuesUnequal => ({ left: this, right: other, propertyName: "qudt_Organization$j$url", propertyValuesUnequal, type: "Property" as const })));
    }

    override hash<HasherT extends { update: (message: string | number[] | ArrayBuffer | Uint8Array) => void; }>(_hasher: HasherT): HasherT {
        this.hashShaclProperties(_hasher);
        return _hasher;
    }

    protected override hashShaclProperties<HasherT extends { update: (message: string | number[] | ArrayBuffer | Uint8Array) => void; }>(_hasher: HasherT): HasherT {
        super.hashShaclProperties(_hasher);
        for (const _item0 of this.qudt_Organization$j$url) { _hasher.update(_item0); }

        return _hasher;
    }

    override toJson(): { readonly "qudt_Organization$j$url": readonly (string)[] } & ReturnType<QUDT_Concept["toJson"]> {
        return JSON.parse(JSON.stringify({ ...super.toJson(),qudt_Organization$j$url: this.qudt_Organization$j$url.map(_item => (_item)) } satisfies ReturnType<Organization["toJson"]>));
    }

    override toRdf({ ignoreRdfType, mutateGraph, resourceSet }: { ignoreRdfType?: boolean; mutateGraph?: rdfjsResource.MutableResource.MutateGraph, resourceSet: rdfjsResource.MutableResourceSet }): rdfjsResource.MutableResource {
        const _resource = super.toRdf({ ignoreRdfType: true, mutateGraph, resourceSet });
        if (!ignoreRdfType) { _resource.add(_resource.dataFactory.namedNode("http://www.w3.org/1999/02/22-rdf-syntax-ns#type"), _resource.dataFactory.namedNode("http://qudt.org/schema/qudt/Organization")); }

        _resource.add(dataFactory.namedNode("http://qudt.org/schema/qudt/url"), this.qudt_Organization$j$url.map((_item) => _item));
        return _resource;
    }

    override toString(): string {
        return JSON.stringify(this.toJson());
    }
}

export namespace Organization {
    export function _propertiesFromJson(_json: unknown): purify.Either<zod.ZodError, { identifier: (rdfjs.BlankNode | rdfjs.NamedNode); qudt_Organization$j$url: readonly (string)[]; } & UnwrapR<ReturnType<typeof QUDT_Concept._propertiesFromJson>>> {
        const _jsonSafeParseResult = organizationJsonZodSchema().safeParse(_json);
        if (!_jsonSafeParseResult.success) { return purify.Left(_jsonSafeParseResult.error); }

        const _jsonObject = _jsonSafeParseResult.data;
        const _super0Either = QUDT_Concept._propertiesFromJson(_jsonObject);
        if (_super0Either.isLeft()) { return _super0Either; }

        const _super0 = _super0Either.unsafeCoerce()
        const identifier = (_jsonObject["@id"].startsWith("_:") ? dataFactory.blankNode(_jsonObject["@id"].substring(2)) : dataFactory.namedNode(_jsonObject["@id"]));
        const qudt_Organization$j$url = _jsonObject["qudt_Organization$j$url"];
        return purify.Either.of({ ..._super0, identifier, qudt_Organization$j$url })
    }

    export function fromJson(json: unknown): purify.Either<zod.ZodError, Organization> {
        return Organization._propertiesFromJson(json).map(properties => new Organization(properties));
    }

    export function _propertiesFromRdf({ ignoreRdfType: _ignoreRdfType, languageIn: _languageIn, resource: _resource,
        // @ts-ignore
        ..._context }: { [_index: string]: any; ignoreRdfType?: boolean; languageIn?: readonly string[]; resource: rdfjsResource.Resource; }): purify.Either<rdfjsResource.Resource.ValueError, { identifier: (rdfjs.BlankNode | rdfjs.NamedNode); qudt_Organization$j$url: readonly (string)[]; } & UnwrapR<ReturnType<typeof QUDT_Concept._propertiesFromRdf>>> {
        const _super0Either = QUDT_Concept._propertiesFromRdf({ ..._context, ignoreRdfType: true, languageIn: _languageIn, resource: _resource });
        if (_super0Either.isLeft()) { return _super0Either; }

        const _super0 = _super0Either.unsafeCoerce()
        if (!_ignoreRdfType && !_resource.isInstanceOf(dataFactory.namedNode("http://qudt.org/schema/qudt/Organization"))) { return purify.Left(new rdfjsResource.Resource.ValueError({ focusResource: _resource, message: `${rdfjsResource.Resource.Identifier.toString(_resource.identifier)} has unexpected RDF type (expected http://qudt.org/schema/qudt/Organization)`, predicate: dataFactory.namedNode("http://qudt.org/schema/qudt/Organization") })); }

        const identifier = _resource.identifier
        const _qudt_Organization$j$urlEither: purify.Either<rdfjsResource.Resource.ValueError, readonly (string)[]> = purify.Either.of([..._resource.values(dataFactory.namedNode("http://qudt.org/schema/qudt/url"), { unique: true }).flatMap(_item => _item.toValues().head().chain(_value => _value.toString()).toMaybe().toList())]);
        if (_qudt_Organization$j$urlEither.isLeft()) { return _qudt_Organization$j$urlEither; }

        const qudt_Organization$j$url = _qudt_Organization$j$urlEither.unsafeCoerce();
        return purify.Either.of({ ..._super0, identifier, qudt_Organization$j$url })
    }

    export function fromRdf(parameters: Parameters<typeof Organization._propertiesFromRdf>[0]): purify.Either<rdfjsResource.Resource.ValueError, Organization> {
        return Organization._propertiesFromRdf(parameters).map(properties => new Organization(properties));
    }

    export let fromRdfType: rdfjs.NamedNode<string> = dataFactory.namedNode("http://qudt.org/schema/qudt/Organization");

    export function jsonSchema() {
        return zodToJsonSchema(organizationJsonZodSchema());
    }

    export function organizationJsonUiSchema(parameters?: { scopePrefix?: string }) {
        const scopePrefix = parameters?.scopePrefix ?? "#";
        return { "elements": [ QUDT_Concept.qudtConceptJsonUiSchema({ scopePrefix }), { scope: `${scopePrefix}/properties/qudt_Organization$j$url`, type: "Control" } ], label: "Organization", type: "Group" }
    }

    export function organizationJsonZodSchema() {
        return QUDT_Concept.qudtConceptJsonZodSchema().merge(zod.object({ "@id": zod.string().min(1),"type": zod.literal("Organization"),"qudt_Organization$j$url": zod.string().array() }));
    }

    export function sparqlConstructQuery(parameters?: { ignoreRdfType?: boolean; prefixes?: { [prefix: string]: string }; subject?: sparqljs.Triple["subject"]; } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type">): sparqljs.ConstructQuery {
        const { ignoreRdfType, subject, ...queryParameters } = parameters ?? {}

        return { ...queryParameters, prefixes: parameters?.prefixes ?? {}, queryType: "CONSTRUCT", template: (queryParameters.template ?? []).concat(Organization.sparqlConstructTemplateTriples({ ignoreRdfType, subject })), type: "query", where: (queryParameters.where ?? []).concat(Organization.sparqlWherePatterns({ ignoreRdfType, subject })) };
    }

    export function sparqlConstructQueryString(parameters?: { ignoreRdfType?: boolean; subject?: sparqljs.Triple["subject"]; variablePrefix?: string; } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type"> & sparqljs.GeneratorOptions): string {
        return new sparqljs.Generator(parameters).stringify(Organization.sparqlConstructQuery(parameters));
    }

    export function sparqlConstructTemplateTriples(parameters?: { ignoreRdfType?: boolean; subject?: sparqljs.Triple["subject"], variablePrefix?: string }): readonly sparqljs.Triple[] {
        const subject = parameters?.subject ?? dataFactory.variable!("organization");
        const variablePrefix = parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "organization");
        return [...QUDT_Concept.sparqlConstructTemplateTriples({ ignoreRdfType: true, subject, variablePrefix }), ...(parameters?.ignoreRdfType ? [] : [{ subject, predicate: dataFactory.namedNode("http://www.w3.org/1999/02/22-rdf-syntax-ns#type"), object: dataFactory.variable!(`${variablePrefix}RdfType`) }]), { object: dataFactory.variable!(`${variablePrefix}QudtOrganizationJUrl`), predicate: dataFactory.namedNode("http://qudt.org/schema/qudt/url"), subject }];
    }

    export function sparqlWherePatterns(parameters: { ignoreRdfType?: boolean; subject?: sparqljs.Triple["subject"], variablePrefix?: string }): readonly sparqljs.Pattern[] {
        const subject = parameters?.subject ?? dataFactory.variable!("organization");
        const variablePrefix = parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "organization");
        return [...QUDT_Concept.sparqlWherePatterns({ ignoreRdfType: true, subject, variablePrefix }), ...(parameters?.ignoreRdfType ? [] : [{ triples: [{ subject, predicate: dataFactory.namedNode("http://www.w3.org/1999/02/22-rdf-syntax-ns#type"), object: dataFactory.namedNode("http://qudt.org/schema/qudt/Organization") }], type: "bgp" as const }, { triples: [{ subject, predicate: dataFactory.namedNode("http://www.w3.org/1999/02/22-rdf-syntax-ns#type"), object: dataFactory.variable!(`${variablePrefix}RdfType`) }], type: "bgp" as const }]), { patterns: [{ triples: [{ object: dataFactory.variable!(`${variablePrefix}QudtOrganizationJUrl`), predicate: dataFactory.namedNode("http://qudt.org/schema/qudt/url"), subject }], type: "bgp" }], type: "optional" }];
    }
}
/**
 * Comment
 */
export class Comment extends QUDT_Concept {
    override readonly type: "Comment" | "NIST_SP$22$811$W$Comment" = "Comment";
    readonly qudt_Comment$j$description: purify.Maybe<(rdfjs.BlankNode | rdfjs.NamedNode | rdfjs.Literal)>;
    readonly qudt_Comment$j$rationale: readonly (string)[];

    constructor(parameters: { readonly identifier?: (rdfjs.BlankNode | rdfjs.NamedNode) | string, readonly qudt_Comment$j$description?: (rdfjs.BlankNode | rdfjs.NamedNode | rdfjs.Literal) | Date | boolean | number | purify.Maybe<(rdfjs.BlankNode | rdfjs.NamedNode | rdfjs.Literal)> | string, readonly qudt_Comment$j$rationale?: readonly (string)[] } & ConstructorParameters<typeof QUDT_Concept>[0]) {
        super(parameters);
        if (purify.Maybe.isMaybe(parameters.qudt_Comment$j$description)) { this.qudt_Comment$j$description = parameters.qudt_Comment$j$description; } else if (typeof parameters.qudt_Comment$j$description === "boolean") { this.qudt_Comment$j$description = purify.Maybe.of(rdfLiteral.toRdf(parameters.qudt_Comment$j$description, { dataFactory })); } else if (typeof parameters.qudt_Comment$j$description === "object" && parameters.qudt_Comment$j$description instanceof Date) { this.qudt_Comment$j$description = purify.Maybe.of(rdfLiteral.toRdf(parameters.qudt_Comment$j$description, { dataFactory })); } else if (typeof parameters.qudt_Comment$j$description === "number") { this.qudt_Comment$j$description = purify.Maybe.of(rdfLiteral.toRdf(parameters.qudt_Comment$j$description, { dataFactory })); } else if (typeof parameters.qudt_Comment$j$description === "string") { this.qudt_Comment$j$description = purify.Maybe.of(dataFactory.literal(parameters.qudt_Comment$j$description)); } else if (typeof parameters.qudt_Comment$j$description === "object") { this.qudt_Comment$j$description = purify.Maybe.of(parameters.qudt_Comment$j$description); } else if (typeof parameters.qudt_Comment$j$description === "undefined") { this.qudt_Comment$j$description = purify.Maybe.empty(); } else { this.qudt_Comment$j$description =( parameters.qudt_Comment$j$description) as never;
         }

        if (typeof parameters.qudt_Comment$j$rationale === "undefined") { this.qudt_Comment$j$rationale = []; } else if (Array.isArray(parameters.qudt_Comment$j$rationale)) { this.qudt_Comment$j$rationale = parameters.qudt_Comment$j$rationale; } else { this.qudt_Comment$j$rationale =( parameters.qudt_Comment$j$rationale) as never;
         }
    }

    override get identifier(): (rdfjs.BlankNode | rdfjs.NamedNode) {
        if (typeof this._identifier === "undefined") { this._identifier = dataFactory.blankNode(); } return this._identifier;
    }

    override equals(other: Comment): EqualsResult {
        return super.equals(other).chain(() => (((left, right) => maybeEquals(left, right, booleanEquals)))(this.qudt_Comment$j$description, other.qudt_Comment$j$description).mapLeft(propertyValuesUnequal => ({ left: this, right: other, propertyName: "qudt_Comment$j$description", propertyValuesUnequal, type: "Property" as const }))).chain(() => (((left, right) => arrayEquals(left, right, strictEquals)))(this.qudt_Comment$j$rationale, other.qudt_Comment$j$rationale).mapLeft(propertyValuesUnequal => ({ left: this, right: other, propertyName: "qudt_Comment$j$rationale", propertyValuesUnequal, type: "Property" as const })));
    }

    override hash<HasherT extends { update: (message: string | number[] | ArrayBuffer | Uint8Array) => void; }>(_hasher: HasherT): HasherT {
        this.hashShaclProperties(_hasher);
        return _hasher;
    }

    protected override hashShaclProperties<HasherT extends { update: (message: string | number[] | ArrayBuffer | Uint8Array) => void; }>(_hasher: HasherT): HasherT {
        super.hashShaclProperties(_hasher);
        this.qudt_Comment$j$description.ifJust((_value0) => { _hasher.update(_value0.termType);
        _hasher.update(_value0.value); })
        for (const _item0 of this.qudt_Comment$j$rationale) { _hasher.update(_item0); }

        return _hasher;
    }

    override toJson(): { readonly "qudt_Comment$j$description": ({ readonly "@id": string, readonly termType: "BlankNode" | "NamedNode" } | { readonly "@language": string | undefined, readonly "@type": string | undefined, readonly "@value": string, readonly termType: "Literal" }) | undefined; readonly "qudt_Comment$j$rationale": readonly (string)[] } & ReturnType<QUDT_Concept["toJson"]> {
        return JSON.parse(JSON.stringify({ ...super.toJson(),qudt_Comment$j$description: this.qudt_Comment$j$description.map(_item => ((_item.termType === "Literal") ? { "@language": _item.language.length > 0 ? _item.language : undefined, "@type": _item.datatype.value !== "http://www.w3.org/2001/XMLSchema#string" ? _item.datatype.value : undefined, "@value": _item.value, termType: "Literal" as const } : (_item.termType === "NamedNode") ? { "@id": _item.value, termType: "NamedNode" as const } : { "@id": `_:${_item.value}`, termType: "BlankNode" as const })).extract(),qudt_Comment$j$rationale: this.qudt_Comment$j$rationale.map(_item => (_item)) } satisfies ReturnType<Comment["toJson"]>));
    }

    override toRdf({ ignoreRdfType, mutateGraph, resourceSet }: { ignoreRdfType?: boolean; mutateGraph?: rdfjsResource.MutableResource.MutateGraph, resourceSet: rdfjsResource.MutableResourceSet }): rdfjsResource.MutableResource {
        const _resource = super.toRdf({ ignoreRdfType: true, mutateGraph, resourceSet });
        if (!ignoreRdfType) { _resource.add(_resource.dataFactory.namedNode("http://www.w3.org/1999/02/22-rdf-syntax-ns#type"), _resource.dataFactory.namedNode("http://qudt.org/schema/qudt/Comment")); }

        _resource.add(dataFactory.namedNode("http://purl.org/dc/terms/description"), this.qudt_Comment$j$description);
        _resource.add(dataFactory.namedNode("http://qudt.org/schema/qudt/rationale"), this.qudt_Comment$j$rationale.map((_item) => _item));
        return _resource;
    }

    override toString(): string {
        return JSON.stringify(this.toJson());
    }
}

export namespace Comment {
    export function _propertiesFromJson(_json: unknown): purify.Either<zod.ZodError, { identifier: (rdfjs.BlankNode | rdfjs.NamedNode); qudt_Comment$j$description: purify.Maybe<(rdfjs.BlankNode | rdfjs.NamedNode | rdfjs.Literal)>; qudt_Comment$j$rationale: readonly (string)[]; } & UnwrapR<ReturnType<typeof QUDT_Concept._propertiesFromJson>>> {
        const _jsonSafeParseResult = commentJsonZodSchema().safeParse(_json);
        if (!_jsonSafeParseResult.success) { return purify.Left(_jsonSafeParseResult.error); }

        const _jsonObject = _jsonSafeParseResult.data;
        const _super0Either = QUDT_Concept._propertiesFromJson(_jsonObject);
        if (_super0Either.isLeft()) { return _super0Either; }

        const _super0 = _super0Either.unsafeCoerce()
        const identifier = (_jsonObject["@id"].startsWith("_:") ? dataFactory.blankNode(_jsonObject["@id"].substring(2)) : dataFactory.namedNode(_jsonObject["@id"]));
        const qudt_Comment$j$description = purify.Maybe.fromNullable(_jsonObject["qudt_Comment$j$description"]).map(_item => (((_item.termType === "Literal") ? (dataFactory.literal(_item["@value"], typeof _item["@language"] !== "undefined" ? _item["@language"] : (typeof _item["@type"] !== "undefined" ? dataFactory.namedNode(_item["@type"]) : undefined))) : (((_item.termType === "NamedNode") ? (dataFactory.namedNode(_item["@id"])) : (dataFactory.blankNode(_item["@id"].substring(2))))))));
        const qudt_Comment$j$rationale = _jsonObject["qudt_Comment$j$rationale"];
        return purify.Either.of({ ..._super0, identifier, qudt_Comment$j$description, qudt_Comment$j$rationale })
    }

    export function fromJson(json: unknown): purify.Either<zod.ZodError, Comment> {
        return (NIST_SP$22$811$W$Comment.fromJson(json) as purify.Either<zod.ZodError, Comment>).altLazy(() => Comment._propertiesFromJson(json).map(properties => new Comment(properties)));
    }

    export function _propertiesFromRdf({ ignoreRdfType: _ignoreRdfType, languageIn: _languageIn, resource: _resource,
        // @ts-ignore
        ..._context }: { [_index: string]: any; ignoreRdfType?: boolean; languageIn?: readonly string[]; resource: rdfjsResource.Resource; }): purify.Either<rdfjsResource.Resource.ValueError, { identifier: (rdfjs.BlankNode | rdfjs.NamedNode); qudt_Comment$j$description: purify.Maybe<(rdfjs.BlankNode | rdfjs.NamedNode | rdfjs.Literal)>; qudt_Comment$j$rationale: readonly (string)[]; } & UnwrapR<ReturnType<typeof QUDT_Concept._propertiesFromRdf>>> {
        const _super0Either = QUDT_Concept._propertiesFromRdf({ ..._context, ignoreRdfType: true, languageIn: _languageIn, resource: _resource });
        if (_super0Either.isLeft()) { return _super0Either; }

        const _super0 = _super0Either.unsafeCoerce()
        if (!_ignoreRdfType && !_resource.isInstanceOf(dataFactory.namedNode("http://qudt.org/schema/qudt/Comment"))) { return purify.Left(new rdfjsResource.Resource.ValueError({ focusResource: _resource, message: `${rdfjsResource.Resource.Identifier.toString(_resource.identifier)} has unexpected RDF type (expected http://qudt.org/schema/qudt/Comment)`, predicate: dataFactory.namedNode("http://qudt.org/schema/qudt/Comment") })); }

        const identifier = _resource.identifier
        const _qudt_Comment$j$descriptionEither: purify.Either<rdfjsResource.Resource.ValueError, purify.Maybe<(rdfjs.BlankNode | rdfjs.NamedNode | rdfjs.Literal)>> = purify.Either.of(_resource.values(dataFactory.namedNode("http://purl.org/dc/terms/description"), { unique: true }).head().chain(_value => purify.Either.of(_value.toTerm())).toMaybe());
        if (_qudt_Comment$j$descriptionEither.isLeft()) { return _qudt_Comment$j$descriptionEither; }

        const qudt_Comment$j$description = _qudt_Comment$j$descriptionEither.unsafeCoerce();
        const _qudt_Comment$j$rationaleEither: purify.Either<rdfjsResource.Resource.ValueError, readonly (string)[]> = purify.Either.of([..._resource.values(dataFactory.namedNode("http://qudt.org/schema/qudt/rationale"), { unique: true }).flatMap(_item => _item.toValues().head().chain(_value => _value.toString()).toMaybe().toList())]);
        if (_qudt_Comment$j$rationaleEither.isLeft()) { return _qudt_Comment$j$rationaleEither; }

        const qudt_Comment$j$rationale = _qudt_Comment$j$rationaleEither.unsafeCoerce();
        return purify.Either.of({ ..._super0, identifier, qudt_Comment$j$description, qudt_Comment$j$rationale })
    }

    export function fromRdf(parameters: Parameters<typeof Comment._propertiesFromRdf>[0]): purify.Either<rdfjsResource.Resource.ValueError, Comment> {
        const { ignoreRdfType: _ignoreRdfType, ...otherParameters } = parameters
        return (NIST_SP$22$811$W$Comment.fromRdf(otherParameters) as purify.Either<rdfjsResource.Resource.ValueError, Comment>).altLazy(() => Comment._propertiesFromRdf(parameters).map(properties => new Comment(properties)));
    }

    export let fromRdfType: rdfjs.NamedNode<string> = dataFactory.namedNode("http://qudt.org/schema/qudt/Comment");

    export function jsonSchema() {
        return zodToJsonSchema(commentJsonZodSchema());
    }

    export function commentJsonUiSchema(parameters?: { scopePrefix?: string }) {
        const scopePrefix = parameters?.scopePrefix ?? "#";
        return { "elements": [ QUDT_Concept.qudtConceptJsonUiSchema({ scopePrefix }), { scope: `${scopePrefix}/properties/qudt_Comment$j$description`, type: "Control" }, { scope: `${scopePrefix}/properties/qudt_Comment$j$rationale`, type: "Control" } ], label: "Comment", type: "Group" }
    }

    export function commentJsonZodSchema() {
        return QUDT_Concept.qudtConceptJsonZodSchema().merge(zod.object({ "@id": zod.string().min(1),"type": zod.enum(["Comment","NIST_SP$22$811$W$Comment"]),"qudt_Comment$j$description": zod.discriminatedUnion("termType", [zod.object({ "@id": zod.string().min(1), termType: zod.literal("BlankNode") }), zod.object({ "@id": zod.string().min(1), termType: zod.literal("NamedNode") }), zod.object({ "@language": zod.string().optional(), "@type": zod.string().optional(), "@value": zod.string(), termType: zod.literal("Literal") })]).optional(),"qudt_Comment$j$rationale": zod.string().array() }));
    }

    export function sparqlConstructQuery(parameters?: { ignoreRdfType?: boolean; prefixes?: { [prefix: string]: string }; subject?: sparqljs.Triple["subject"]; } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type">): sparqljs.ConstructQuery {
        const { ignoreRdfType, subject, ...queryParameters } = parameters ?? {}

        return { ...queryParameters, prefixes: parameters?.prefixes ?? {}, queryType: "CONSTRUCT", template: (queryParameters.template ?? []).concat(Comment.sparqlConstructTemplateTriples({ ignoreRdfType, subject })), type: "query", where: (queryParameters.where ?? []).concat(Comment.sparqlWherePatterns({ ignoreRdfType, subject })) };
    }

    export function sparqlConstructQueryString(parameters?: { ignoreRdfType?: boolean; subject?: sparqljs.Triple["subject"]; variablePrefix?: string; } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type"> & sparqljs.GeneratorOptions): string {
        return new sparqljs.Generator(parameters).stringify(Comment.sparqlConstructQuery(parameters));
    }

    export function sparqlConstructTemplateTriples(parameters?: { ignoreRdfType?: boolean; subject?: sparqljs.Triple["subject"], variablePrefix?: string }): readonly sparqljs.Triple[] {
        const subject = parameters?.subject ?? dataFactory.variable!("comment");
        const variablePrefix = parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "comment");
        return [...QUDT_Concept.sparqlConstructTemplateTriples({ ignoreRdfType: true, subject, variablePrefix }), ...(parameters?.ignoreRdfType ? [] : [{ subject, predicate: dataFactory.namedNode("http://www.w3.org/1999/02/22-rdf-syntax-ns#type"), object: dataFactory.variable!(`${variablePrefix}RdfType`) }]), { object: dataFactory.variable!(`${variablePrefix}QudtCommentJDescription`), predicate: dataFactory.namedNode("http://purl.org/dc/terms/description"), subject }, { object: dataFactory.variable!(`${variablePrefix}QudtCommentJRationale`), predicate: dataFactory.namedNode("http://qudt.org/schema/qudt/rationale"), subject }];
    }

    export function sparqlWherePatterns(parameters: { ignoreRdfType?: boolean; subject?: sparqljs.Triple["subject"], variablePrefix?: string }): readonly sparqljs.Pattern[] {
        const subject = parameters?.subject ?? dataFactory.variable!("comment");
        const variablePrefix = parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "comment");
        return [...QUDT_Concept.sparqlWherePatterns({ ignoreRdfType: true, subject, variablePrefix }), ...(parameters?.ignoreRdfType ? [] : [{ triples: [{ subject, predicate: dataFactory.namedNode("http://www.w3.org/1999/02/22-rdf-syntax-ns#type"), object: dataFactory.namedNode("http://qudt.org/schema/qudt/Comment") }], type: "bgp" as const }, { triples: [{ subject, predicate: dataFactory.namedNode("http://www.w3.org/1999/02/22-rdf-syntax-ns#type"), object: dataFactory.variable!(`${variablePrefix}RdfType`) }], type: "bgp" as const }]), { patterns: [{ triples: [{ object: dataFactory.variable!(`${variablePrefix}QudtCommentJDescription`), predicate: dataFactory.namedNode("http://purl.org/dc/terms/description"), subject }], type: "bgp" }], type: "optional" }, { patterns: [{ triples: [{ object: dataFactory.variable!(`${variablePrefix}QudtCommentJRationale`), predicate: dataFactory.namedNode("http://qudt.org/schema/qudt/rationale"), subject }], type: "bgp" }], type: "optional" }];
    }
}
/**
 * NIST SP~811 Comment
 */
export class NIST_SP$22$811$W$Comment extends Comment {
    override readonly type = "NIST_SP$22$811$W$Comment";

    // biome-ignore lint/complexity/noUselessConstructor: Always have a constructor
    constructor(parameters: { readonly identifier?: (rdfjs.BlankNode | rdfjs.NamedNode) | string } & ConstructorParameters<typeof Comment>[0]) {
        super(parameters);
    }

    override get identifier(): (rdfjs.BlankNode | rdfjs.NamedNode) {
        if (typeof this._identifier === "undefined") { this._identifier = dataFactory.blankNode(); } return this._identifier;
    }

    override toRdf({ ignoreRdfType, mutateGraph, resourceSet }: { ignoreRdfType?: boolean; mutateGraph?: rdfjsResource.MutableResource.MutateGraph, resourceSet: rdfjsResource.MutableResourceSet }): rdfjsResource.MutableResource {
        const _resource = super.toRdf({ ignoreRdfType: true, mutateGraph, resourceSet });
        if (!ignoreRdfType) { _resource.add(_resource.dataFactory.namedNode("http://www.w3.org/1999/02/22-rdf-syntax-ns#type"), _resource.dataFactory.namedNode("http://qudt.org/schema/qudt/NIST_SP811_Comment")); }

        return _resource;
    }

    override toString(): string {
        return JSON.stringify(this.toJson());
    }
}

export namespace NIST_SP$22$811$W$Comment {
    export function _propertiesFromJson(_json: unknown): purify.Either<zod.ZodError, { identifier: (rdfjs.BlankNode | rdfjs.NamedNode); } & UnwrapR<ReturnType<typeof Comment._propertiesFromJson>>> {
        const _jsonSafeParseResult = nistSp_22_811WCommentJsonZodSchema().safeParse(_json);
        if (!_jsonSafeParseResult.success) { return purify.Left(_jsonSafeParseResult.error); }

        const _jsonObject = _jsonSafeParseResult.data;
        const _super0Either = Comment._propertiesFromJson(_jsonObject);
        if (_super0Either.isLeft()) { return _super0Either; }

        const _super0 = _super0Either.unsafeCoerce()
        const identifier = (_jsonObject["@id"].startsWith("_:") ? dataFactory.blankNode(_jsonObject["@id"].substring(2)) : dataFactory.namedNode(_jsonObject["@id"]));
        return purify.Either.of({ ..._super0, identifier })
    }

    export function fromJson(json: unknown): purify.Either<zod.ZodError, NIST_SP$22$811$W$Comment> {
        return NIST_SP$22$811$W$Comment._propertiesFromJson(json).map(properties => new NIST_SP$22$811$W$Comment(properties));
    }

    export function _propertiesFromRdf({ ignoreRdfType: _ignoreRdfType, languageIn: _languageIn, resource: _resource,
        // @ts-ignore
        ..._context }: { [_index: string]: any; ignoreRdfType?: boolean; languageIn?: readonly string[]; resource: rdfjsResource.Resource; }): purify.Either<rdfjsResource.Resource.ValueError, { identifier: (rdfjs.BlankNode | rdfjs.NamedNode); } & UnwrapR<ReturnType<typeof Comment._propertiesFromRdf>>> {
        const _super0Either = Comment._propertiesFromRdf({ ..._context, ignoreRdfType: true, languageIn: _languageIn, resource: _resource });
        if (_super0Either.isLeft()) { return _super0Either; }

        const _super0 = _super0Either.unsafeCoerce()
        if (!_ignoreRdfType && !_resource.isInstanceOf(dataFactory.namedNode("http://qudt.org/schema/qudt/NIST_SP811_Comment"))) { return purify.Left(new rdfjsResource.Resource.ValueError({ focusResource: _resource, message: `${rdfjsResource.Resource.Identifier.toString(_resource.identifier)} has unexpected RDF type (expected http://qudt.org/schema/qudt/NIST_SP811_Comment)`, predicate: dataFactory.namedNode("http://qudt.org/schema/qudt/NIST_SP811_Comment") })); }

        const identifier = _resource.identifier
        return purify.Either.of({ ..._super0, identifier })
    }

    export function fromRdf(parameters: Parameters<typeof NIST_SP$22$811$W$Comment._propertiesFromRdf>[0]): purify.Either<rdfjsResource.Resource.ValueError, NIST_SP$22$811$W$Comment> {
        return NIST_SP$22$811$W$Comment._propertiesFromRdf(parameters).map(properties => new NIST_SP$22$811$W$Comment(properties));
    }

    export let fromRdfType: rdfjs.NamedNode<string> = dataFactory.namedNode("http://qudt.org/schema/qudt/NIST_SP811_Comment");

    export function jsonSchema() {
        return zodToJsonSchema(nistSp_22_811WCommentJsonZodSchema());
    }

    export function nistSp_22_811WCommentJsonUiSchema(parameters?: { scopePrefix?: string }) {
        const scopePrefix = parameters?.scopePrefix ?? "#";
        return { "elements": [ Comment.commentJsonUiSchema({ scopePrefix }) ], label: "NIST SP~811 Comment", type: "Group" }
    }

    export function nistSp_22_811WCommentJsonZodSchema() {
        return Comment.commentJsonZodSchema().merge(zod.object({ "@id": zod.string().min(1),"type": zod.literal("NIST_SP$22$811$W$Comment") }));
    }

    export function sparqlConstructQuery(parameters?: { ignoreRdfType?: boolean; prefixes?: { [prefix: string]: string }; subject?: sparqljs.Triple["subject"]; } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type">): sparqljs.ConstructQuery {
        const { ignoreRdfType, subject, ...queryParameters } = parameters ?? {}

        return { ...queryParameters, prefixes: parameters?.prefixes ?? {}, queryType: "CONSTRUCT", template: (queryParameters.template ?? []).concat(NIST_SP$22$811$W$Comment.sparqlConstructTemplateTriples({ ignoreRdfType, subject })), type: "query", where: (queryParameters.where ?? []).concat(NIST_SP$22$811$W$Comment.sparqlWherePatterns({ ignoreRdfType, subject })) };
    }

    export function sparqlConstructQueryString(parameters?: { ignoreRdfType?: boolean; subject?: sparqljs.Triple["subject"]; variablePrefix?: string; } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type"> & sparqljs.GeneratorOptions): string {
        return new sparqljs.Generator(parameters).stringify(NIST_SP$22$811$W$Comment.sparqlConstructQuery(parameters));
    }

    export function sparqlConstructTemplateTriples(parameters?: { ignoreRdfType?: boolean; subject?: sparqljs.Triple["subject"], variablePrefix?: string }): readonly sparqljs.Triple[] {
        const subject = parameters?.subject ?? dataFactory.variable!("nistSp_22_811WComment");
        const variablePrefix = parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "nistSp_22_811WComment");
        return [...Comment.sparqlConstructTemplateTriples({ ignoreRdfType: true, subject, variablePrefix }), ...(parameters?.ignoreRdfType ? [] : [{ subject, predicate: dataFactory.namedNode("http://www.w3.org/1999/02/22-rdf-syntax-ns#type"), object: dataFactory.variable!(`${variablePrefix}RdfType`) }])];
    }

    export function sparqlWherePatterns(parameters: { ignoreRdfType?: boolean; subject?: sparqljs.Triple["subject"], variablePrefix?: string }): readonly sparqljs.Pattern[] {
        const subject = parameters?.subject ?? dataFactory.variable!("nistSp_22_811WComment");
        const variablePrefix = parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "nistSp_22_811WComment");
        return [...Comment.sparqlWherePatterns({ ignoreRdfType: true, subject, variablePrefix }), ...(parameters?.ignoreRdfType ? [] : [{ triples: [{ subject, predicate: dataFactory.namedNode("http://www.w3.org/1999/02/22-rdf-syntax-ns#type"), object: dataFactory.namedNode("http://qudt.org/schema/qudt/NIST_SP811_Comment") }], type: "bgp" as const }, { triples: [{ subject, predicate: dataFactory.namedNode("http://www.w3.org/1999/02/22-rdf-syntax-ns#type"), object: dataFactory.variable!(`${variablePrefix}RdfType`) }], type: "bgp" as const }])];
    }
}
/**
 * Logarithmic Unit
 */
export class Logarithmic_Unit extends Dimensionless_Unit {
    override readonly type = "Logarithmic_Unit";

    // biome-ignore lint/complexity/noUselessConstructor: Always have a constructor
    constructor(parameters: { readonly identifier?: (rdfjs.BlankNode | rdfjs.NamedNode) | string } & ConstructorParameters<typeof Dimensionless_Unit>[0]) {
        super(parameters);
    }

    override get identifier(): (rdfjs.BlankNode | rdfjs.NamedNode) {
        if (typeof this._identifier === "undefined") { this._identifier = dataFactory.blankNode(); } return this._identifier;
    }

    override toRdf({ ignoreRdfType, mutateGraph, resourceSet }: { ignoreRdfType?: boolean; mutateGraph?: rdfjsResource.MutableResource.MutateGraph, resourceSet: rdfjsResource.MutableResourceSet }): rdfjsResource.MutableResource {
        const _resource = super.toRdf({ ignoreRdfType: true, mutateGraph, resourceSet });
        if (!ignoreRdfType) { _resource.add(_resource.dataFactory.namedNode("http://www.w3.org/1999/02/22-rdf-syntax-ns#type"), _resource.dataFactory.namedNode("http://qudt.org/schema/qudt/LogarithmicUnit")); }

        return _resource;
    }

    override toString(): string {
        return JSON.stringify(this.toJson());
    }
}

export namespace Logarithmic_Unit {
    export function _propertiesFromJson(_json: unknown): purify.Either<zod.ZodError, { identifier: (rdfjs.BlankNode | rdfjs.NamedNode); } & UnwrapR<ReturnType<typeof Dimensionless_Unit._propertiesFromJson>>> {
        const _jsonSafeParseResult = logarithmicUnitJsonZodSchema().safeParse(_json);
        if (!_jsonSafeParseResult.success) { return purify.Left(_jsonSafeParseResult.error); }

        const _jsonObject = _jsonSafeParseResult.data;
        const _super0Either = Dimensionless_Unit._propertiesFromJson(_jsonObject);
        if (_super0Either.isLeft()) { return _super0Either; }

        const _super0 = _super0Either.unsafeCoerce()
        const identifier = (_jsonObject["@id"].startsWith("_:") ? dataFactory.blankNode(_jsonObject["@id"].substring(2)) : dataFactory.namedNode(_jsonObject["@id"]));
        return purify.Either.of({ ..._super0, identifier })
    }

    export function fromJson(json: unknown): purify.Either<zod.ZodError, Logarithmic_Unit> {
        return Logarithmic_Unit._propertiesFromJson(json).map(properties => new Logarithmic_Unit(properties));
    }

    export function _propertiesFromRdf({ ignoreRdfType: _ignoreRdfType, languageIn: _languageIn, resource: _resource,
        // @ts-ignore
        ..._context }: { [_index: string]: any; ignoreRdfType?: boolean; languageIn?: readonly string[]; resource: rdfjsResource.Resource; }): purify.Either<rdfjsResource.Resource.ValueError, { identifier: (rdfjs.BlankNode | rdfjs.NamedNode); } & UnwrapR<ReturnType<typeof Dimensionless_Unit._propertiesFromRdf>>> {
        const _super0Either = Dimensionless_Unit._propertiesFromRdf({ ..._context, ignoreRdfType: true, languageIn: _languageIn, resource: _resource });
        if (_super0Either.isLeft()) { return _super0Either; }

        const _super0 = _super0Either.unsafeCoerce()
        if (!_ignoreRdfType && !_resource.isInstanceOf(dataFactory.namedNode("http://qudt.org/schema/qudt/LogarithmicUnit"))) { return purify.Left(new rdfjsResource.Resource.ValueError({ focusResource: _resource, message: `${rdfjsResource.Resource.Identifier.toString(_resource.identifier)} has unexpected RDF type (expected http://qudt.org/schema/qudt/LogarithmicUnit)`, predicate: dataFactory.namedNode("http://qudt.org/schema/qudt/LogarithmicUnit") })); }

        const identifier = _resource.identifier
        return purify.Either.of({ ..._super0, identifier })
    }

    export function fromRdf(parameters: Parameters<typeof Logarithmic_Unit._propertiesFromRdf>[0]): purify.Either<rdfjsResource.Resource.ValueError, Logarithmic_Unit> {
        return Logarithmic_Unit._propertiesFromRdf(parameters).map(properties => new Logarithmic_Unit(properties));
    }

    export let fromRdfType: rdfjs.NamedNode<string> = dataFactory.namedNode("http://qudt.org/schema/qudt/LogarithmicUnit");

    export function jsonSchema() {
        return zodToJsonSchema(logarithmicUnitJsonZodSchema());
    }

    export function logarithmicUnitJsonUiSchema(parameters?: { scopePrefix?: string }) {
        const scopePrefix = parameters?.scopePrefix ?? "#";
        return { "elements": [ Dimensionless_Unit.dimensionlessUnitJsonUiSchema({ scopePrefix }) ], label: "Logarithmic Unit", type: "Group" }
    }

    export function logarithmicUnitJsonZodSchema() {
        return Dimensionless_Unit.dimensionlessUnitJsonZodSchema().merge(zod.object({ "@id": zod.string().min(1),"type": zod.literal("Logarithmic_Unit") }));
    }

    export function sparqlConstructQuery(parameters?: { ignoreRdfType?: boolean; prefixes?: { [prefix: string]: string }; subject?: sparqljs.Triple["subject"]; } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type">): sparqljs.ConstructQuery {
        const { ignoreRdfType, subject, ...queryParameters } = parameters ?? {}

        return { ...queryParameters, prefixes: parameters?.prefixes ?? {}, queryType: "CONSTRUCT", template: (queryParameters.template ?? []).concat(Logarithmic_Unit.sparqlConstructTemplateTriples({ ignoreRdfType, subject })), type: "query", where: (queryParameters.where ?? []).concat(Logarithmic_Unit.sparqlWherePatterns({ ignoreRdfType, subject })) };
    }

    export function sparqlConstructQueryString(parameters?: { ignoreRdfType?: boolean; subject?: sparqljs.Triple["subject"]; variablePrefix?: string; } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type"> & sparqljs.GeneratorOptions): string {
        return new sparqljs.Generator(parameters).stringify(Logarithmic_Unit.sparqlConstructQuery(parameters));
    }

    export function sparqlConstructTemplateTriples(parameters?: { ignoreRdfType?: boolean; subject?: sparqljs.Triple["subject"], variablePrefix?: string }): readonly sparqljs.Triple[] {
        const subject = parameters?.subject ?? dataFactory.variable!("logarithmicUnit");
        const variablePrefix = parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "logarithmicUnit");
        return [...Dimensionless_Unit.sparqlConstructTemplateTriples({ ignoreRdfType: true, subject, variablePrefix }), ...(parameters?.ignoreRdfType ? [] : [{ subject, predicate: dataFactory.namedNode("http://www.w3.org/1999/02/22-rdf-syntax-ns#type"), object: dataFactory.variable!(`${variablePrefix}RdfType`) }])];
    }

    export function sparqlWherePatterns(parameters: { ignoreRdfType?: boolean; subject?: sparqljs.Triple["subject"], variablePrefix?: string }): readonly sparqljs.Pattern[] {
        const subject = parameters?.subject ?? dataFactory.variable!("logarithmicUnit");
        const variablePrefix = parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "logarithmicUnit");
        return [...Dimensionless_Unit.sparqlWherePatterns({ ignoreRdfType: true, subject, variablePrefix }), ...(parameters?.ignoreRdfType ? [] : [{ triples: [{ subject, predicate: dataFactory.namedNode("http://www.w3.org/1999/02/22-rdf-syntax-ns#type"), object: dataFactory.namedNode("http://qudt.org/schema/qudt/LogarithmicUnit") }], type: "bgp" as const }, { triples: [{ subject, predicate: dataFactory.namedNode("http://www.w3.org/1999/02/22-rdf-syntax-ns#type"), object: dataFactory.variable!(`${variablePrefix}RdfType`) }], type: "bgp" as const }])];
    }
}
/**
 * Scale
 */
export class Scale extends QUDT_Concept {
    override readonly type: "Interval_scale" | "Nominal_scale" | "Ordinal_scale" | "Ratio_scale" | "Scale" = "Scale";
    readonly qudt_Scale$j$dataStructure: purify.Maybe<string>;
    readonly qudt_Scale$j$permissibleMaths: readonly ((rdfjs.BlankNode | rdfjs.NamedNode | rdfjs.Literal))[];
    readonly qudt_Scale$j$permissibleTransformation: readonly (Transform_type)[];
    readonly qudt_Scale$j$scaleType: purify.Maybe<Scale_type>;

    constructor(parameters: { readonly identifier?: (rdfjs.BlankNode | rdfjs.NamedNode) | string, readonly qudt_Scale$j$dataStructure?: purify.Maybe<string> | string, readonly qudt_Scale$j$permissibleMaths?: readonly ((rdfjs.BlankNode | rdfjs.NamedNode | rdfjs.Literal))[], readonly qudt_Scale$j$permissibleTransformation?: readonly (Transform_type)[], readonly qudt_Scale$j$scaleType?: Scale_type | purify.Maybe<Scale_type> } & ConstructorParameters<typeof QUDT_Concept>[0]) {
        super(parameters);
        if (purify.Maybe.isMaybe(parameters.qudt_Scale$j$dataStructure)) { this.qudt_Scale$j$dataStructure = parameters.qudt_Scale$j$dataStructure; } else if (typeof parameters.qudt_Scale$j$dataStructure === "string") { this.qudt_Scale$j$dataStructure = purify.Maybe.of(parameters.qudt_Scale$j$dataStructure); } else if (typeof parameters.qudt_Scale$j$dataStructure === "undefined") { this.qudt_Scale$j$dataStructure = purify.Maybe.empty(); } else { this.qudt_Scale$j$dataStructure =( parameters.qudt_Scale$j$dataStructure) as never;
         }

        if (typeof parameters.qudt_Scale$j$permissibleMaths === "undefined") { this.qudt_Scale$j$permissibleMaths = []; } else if (Array.isArray(parameters.qudt_Scale$j$permissibleMaths)) { this.qudt_Scale$j$permissibleMaths = parameters.qudt_Scale$j$permissibleMaths; } else { this.qudt_Scale$j$permissibleMaths =( parameters.qudt_Scale$j$permissibleMaths) as never;
         }

        if (typeof parameters.qudt_Scale$j$permissibleTransformation === "undefined") { this.qudt_Scale$j$permissibleTransformation = []; } else if (Array.isArray(parameters.qudt_Scale$j$permissibleTransformation)) { this.qudt_Scale$j$permissibleTransformation = parameters.qudt_Scale$j$permissibleTransformation; } else { this.qudt_Scale$j$permissibleTransformation =( parameters.qudt_Scale$j$permissibleTransformation) as never;
         }

        if (purify.Maybe.isMaybe(parameters.qudt_Scale$j$scaleType)) { this.qudt_Scale$j$scaleType = parameters.qudt_Scale$j$scaleType; } else if (typeof parameters.qudt_Scale$j$scaleType === "object" && parameters.qudt_Scale$j$scaleType instanceof Scale_type) { this.qudt_Scale$j$scaleType = purify.Maybe.of(parameters.qudt_Scale$j$scaleType); } else if (typeof parameters.qudt_Scale$j$scaleType === "undefined") { this.qudt_Scale$j$scaleType = purify.Maybe.empty(); } else { this.qudt_Scale$j$scaleType =( parameters.qudt_Scale$j$scaleType) as never;
         }
    }

    override get identifier(): (rdfjs.BlankNode | rdfjs.NamedNode) {
        if (typeof this._identifier === "undefined") { this._identifier = dataFactory.blankNode(); } return this._identifier;
    }

    override equals(other: Scale): EqualsResult {
        return super.equals(other).chain(() => (((left, right) => maybeEquals(left, right, strictEquals)))(this.qudt_Scale$j$dataStructure, other.qudt_Scale$j$dataStructure).mapLeft(propertyValuesUnequal => ({ left: this, right: other, propertyName: "qudt_Scale$j$dataStructure", propertyValuesUnequal, type: "Property" as const }))).chain(() => (((left, right) => arrayEquals(left, right, booleanEquals)))(this.qudt_Scale$j$permissibleMaths, other.qudt_Scale$j$permissibleMaths).mapLeft(propertyValuesUnequal => ({ left: this, right: other, propertyName: "qudt_Scale$j$permissibleMaths", propertyValuesUnequal, type: "Property" as const }))).chain(() => (((left, right) => arrayEquals(left, right, ((left, right) => left.equals(right)))))(this.qudt_Scale$j$permissibleTransformation, other.qudt_Scale$j$permissibleTransformation).mapLeft(propertyValuesUnequal => ({ left: this, right: other, propertyName: "qudt_Scale$j$permissibleTransformation", propertyValuesUnequal, type: "Property" as const }))).chain(() => (((left, right) => maybeEquals(left, right, ((left, right) => left.equals(right)))))(this.qudt_Scale$j$scaleType, other.qudt_Scale$j$scaleType).mapLeft(propertyValuesUnequal => ({ left: this, right: other, propertyName: "qudt_Scale$j$scaleType", propertyValuesUnequal, type: "Property" as const })));
    }

    override hash<HasherT extends { update: (message: string | number[] | ArrayBuffer | Uint8Array) => void; }>(_hasher: HasherT): HasherT {
        this.hashShaclProperties(_hasher);
        return _hasher;
    }

    protected override hashShaclProperties<HasherT extends { update: (message: string | number[] | ArrayBuffer | Uint8Array) => void; }>(_hasher: HasherT): HasherT {
        super.hashShaclProperties(_hasher);
        this.qudt_Scale$j$dataStructure.ifJust((_value0) => { _hasher.update(_value0); })
        for (const _item0 of this.qudt_Scale$j$permissibleMaths) { _hasher.update(_item0.termType);
        _hasher.update(_item0.value); }

        for (const _item0 of this.qudt_Scale$j$permissibleTransformation) { _item0.hash(_hasher); }

        this.qudt_Scale$j$scaleType.ifJust((_value0) => { _value0.hash(_hasher); })
        return _hasher;
    }

    override toJson(): { readonly "qudt_Scale$j$dataStructure": (string) | undefined; readonly "qudt_Scale$j$permissibleMaths": readonly ({ readonly "@id": string, readonly termType: "BlankNode" | "NamedNode" } | { readonly "@language": string | undefined, readonly "@type": string | undefined, readonly "@value": string, readonly termType: "Literal" })[]; readonly "qudt_Scale$j$permissibleTransformation": readonly (ReturnType<Transform_type["toJson"]>)[]; readonly "qudt_Scale$j$scaleType": (ReturnType<Scale_type["toJson"]>) | undefined } & ReturnType<QUDT_Concept["toJson"]> {
        return JSON.parse(JSON.stringify({ ...super.toJson(),qudt_Scale$j$dataStructure: this.qudt_Scale$j$dataStructure.map(_item => (_item)).extract(),qudt_Scale$j$permissibleMaths: this.qudt_Scale$j$permissibleMaths.map(_item => ((_item.termType === "Literal") ? { "@language": _item.language.length > 0 ? _item.language : undefined, "@type": _item.datatype.value !== "http://www.w3.org/2001/XMLSchema#string" ? _item.datatype.value : undefined, "@value": _item.value, termType: "Literal" as const } : (_item.termType === "NamedNode") ? { "@id": _item.value, termType: "NamedNode" as const } : { "@id": `_:${_item.value}`, termType: "BlankNode" as const })),qudt_Scale$j$permissibleTransformation: this.qudt_Scale$j$permissibleTransformation.map(_item => (_item.toJson())),qudt_Scale$j$scaleType: this.qudt_Scale$j$scaleType.map(_item => (_item.toJson())).extract() } satisfies ReturnType<Scale["toJson"]>));
    }

    override toRdf({ ignoreRdfType, mutateGraph, resourceSet }: { ignoreRdfType?: boolean; mutateGraph?: rdfjsResource.MutableResource.MutateGraph, resourceSet: rdfjsResource.MutableResourceSet }): rdfjsResource.MutableResource {
        const _resource = super.toRdf({ ignoreRdfType: true, mutateGraph, resourceSet });
        if (!ignoreRdfType) { _resource.add(_resource.dataFactory.namedNode("http://www.w3.org/1999/02/22-rdf-syntax-ns#type"), _resource.dataFactory.namedNode("http://qudt.org/schema/qudt/Scale")); }

        _resource.add(dataFactory.namedNode("http://qudt.org/schema/qudt/dataStructure"), this.qudt_Scale$j$dataStructure);
        _resource.add(dataFactory.namedNode("http://qudt.org/schema/qudt/permissibleMaths"), this.qudt_Scale$j$permissibleMaths.map((_item) => _item));
        _resource.add(dataFactory.namedNode("http://qudt.org/schema/qudt/permissibleTransformation"), this.qudt_Scale$j$permissibleTransformation.map((_item) => _item.toRdf({ mutateGraph: mutateGraph, resourceSet: resourceSet })));
        _resource.add(dataFactory.namedNode("http://qudt.org/schema/qudt/scaleType"), this.qudt_Scale$j$scaleType.map((_value) => _value.toRdf({ mutateGraph: mutateGraph, resourceSet: resourceSet })));
        return _resource;
    }

    override toString(): string {
        return JSON.stringify(this.toJson());
    }
}

export namespace Scale {
    export function _propertiesFromJson(_json: unknown): purify.Either<zod.ZodError, { identifier: (rdfjs.BlankNode | rdfjs.NamedNode); qudt_Scale$j$dataStructure: purify.Maybe<string>; qudt_Scale$j$permissibleMaths: readonly ((rdfjs.BlankNode | rdfjs.NamedNode | rdfjs.Literal))[]; qudt_Scale$j$permissibleTransformation: readonly (Transform_type)[]; qudt_Scale$j$scaleType: purify.Maybe<Scale_type>; } & UnwrapR<ReturnType<typeof QUDT_Concept._propertiesFromJson>>> {
        const _jsonSafeParseResult = scaleJsonZodSchema().safeParse(_json);
        if (!_jsonSafeParseResult.success) { return purify.Left(_jsonSafeParseResult.error); }

        const _jsonObject = _jsonSafeParseResult.data;
        const _super0Either = QUDT_Concept._propertiesFromJson(_jsonObject);
        if (_super0Either.isLeft()) { return _super0Either; }

        const _super0 = _super0Either.unsafeCoerce()
        const identifier = (_jsonObject["@id"].startsWith("_:") ? dataFactory.blankNode(_jsonObject["@id"].substring(2)) : dataFactory.namedNode(_jsonObject["@id"]));
        const qudt_Scale$j$dataStructure = purify.Maybe.fromNullable(_jsonObject["qudt_Scale$j$dataStructure"]);
        const qudt_Scale$j$permissibleMaths = _jsonObject["qudt_Scale$j$permissibleMaths"].map(_item => (((_item.termType === "Literal") ? (dataFactory.literal(_item["@value"], typeof _item["@language"] !== "undefined" ? _item["@language"] : (typeof _item["@type"] !== "undefined" ? dataFactory.namedNode(_item["@type"]) : undefined))) : (((_item.termType === "NamedNode") ? (dataFactory.namedNode(_item["@id"])) : (dataFactory.blankNode(_item["@id"].substring(2))))))));
        const qudt_Scale$j$permissibleTransformation = _jsonObject["qudt_Scale$j$permissibleTransformation"].map(_item => (Transform_type.fromJson(_item).unsafeCoerce()));
        const qudt_Scale$j$scaleType = purify.Maybe.fromNullable(_jsonObject["qudt_Scale$j$scaleType"]).map(_item => (Scale_type.fromJson(_item).unsafeCoerce()));
        return purify.Either.of({ ..._super0, identifier, qudt_Scale$j$dataStructure, qudt_Scale$j$permissibleMaths, qudt_Scale$j$permissibleTransformation, qudt_Scale$j$scaleType })
    }

    export function fromJson(json: unknown): purify.Either<zod.ZodError, Scale> {
        return (Interval_scale.fromJson(json) as purify.Either<zod.ZodError, Scale>).altLazy(() => (Nominal_scale.fromJson(json) as purify.Either<zod.ZodError, Scale>)).altLazy(() => (Ordinal_scale.fromJson(json) as purify.Either<zod.ZodError, Scale>)).altLazy(() => (Ratio_scale.fromJson(json) as purify.Either<zod.ZodError, Scale>)).altLazy(() => Scale._propertiesFromJson(json).map(properties => new Scale(properties)));
    }

    export function _propertiesFromRdf({ ignoreRdfType: _ignoreRdfType, languageIn: _languageIn, resource: _resource,
        // @ts-ignore
        ..._context }: { [_index: string]: any; ignoreRdfType?: boolean; languageIn?: readonly string[]; resource: rdfjsResource.Resource; }): purify.Either<rdfjsResource.Resource.ValueError, { identifier: (rdfjs.BlankNode | rdfjs.NamedNode); qudt_Scale$j$dataStructure: purify.Maybe<string>; qudt_Scale$j$permissibleMaths: readonly ((rdfjs.BlankNode | rdfjs.NamedNode | rdfjs.Literal))[]; qudt_Scale$j$permissibleTransformation: readonly (Transform_type)[]; qudt_Scale$j$scaleType: purify.Maybe<Scale_type>; } & UnwrapR<ReturnType<typeof QUDT_Concept._propertiesFromRdf>>> {
        const _super0Either = QUDT_Concept._propertiesFromRdf({ ..._context, ignoreRdfType: true, languageIn: _languageIn, resource: _resource });
        if (_super0Either.isLeft()) { return _super0Either; }

        const _super0 = _super0Either.unsafeCoerce()
        if (!_ignoreRdfType && !_resource.isInstanceOf(dataFactory.namedNode("http://qudt.org/schema/qudt/Scale"))) { return purify.Left(new rdfjsResource.Resource.ValueError({ focusResource: _resource, message: `${rdfjsResource.Resource.Identifier.toString(_resource.identifier)} has unexpected RDF type (expected http://qudt.org/schema/qudt/Scale)`, predicate: dataFactory.namedNode("http://qudt.org/schema/qudt/Scale") })); }

        const identifier = _resource.identifier
        const _qudt_Scale$j$dataStructureEither: purify.Either<rdfjsResource.Resource.ValueError, purify.Maybe<string>> = purify.Either.of(_resource.values(dataFactory.namedNode("http://qudt.org/schema/qudt/dataStructure"), { unique: true }).head().chain(_value => _value.toString()).toMaybe());
        if (_qudt_Scale$j$dataStructureEither.isLeft()) { return _qudt_Scale$j$dataStructureEither; }

        const qudt_Scale$j$dataStructure = _qudt_Scale$j$dataStructureEither.unsafeCoerce();
        const _qudt_Scale$j$permissibleMathsEither: purify.Either<rdfjsResource.Resource.ValueError, readonly ((rdfjs.BlankNode | rdfjs.NamedNode | rdfjs.Literal))[]> = purify.Either.of([..._resource.values(dataFactory.namedNode("http://qudt.org/schema/qudt/permissibleMaths"), { unique: true }).flatMap(_item => _item.toValues().head().chain(_value => purify.Either.of(_value.toTerm())).toMaybe().toList())]);
        if (_qudt_Scale$j$permissibleMathsEither.isLeft()) { return _qudt_Scale$j$permissibleMathsEither; }

        const qudt_Scale$j$permissibleMaths = _qudt_Scale$j$permissibleMathsEither.unsafeCoerce();
        const _qudt_Scale$j$permissibleTransformationEither: purify.Either<rdfjsResource.Resource.ValueError, readonly (Transform_type)[]> = purify.Either.of([..._resource.values(dataFactory.namedNode("http://qudt.org/schema/qudt/permissibleTransformation"), { unique: true }).flatMap(_item => _item.toValues().head().chain(value => value.toResource()).chain(_resource => Transform_type.fromRdf({ ..._context, ignoreRdfType: true, languageIn: _languageIn, resource: _resource })).toMaybe().toList())]);
        if (_qudt_Scale$j$permissibleTransformationEither.isLeft()) { return _qudt_Scale$j$permissibleTransformationEither; }

        const qudt_Scale$j$permissibleTransformation = _qudt_Scale$j$permissibleTransformationEither.unsafeCoerce();
        const _qudt_Scale$j$scaleTypeEither: purify.Either<rdfjsResource.Resource.ValueError, purify.Maybe<Scale_type>> = purify.Either.of(_resource.values(dataFactory.namedNode("http://qudt.org/schema/qudt/scaleType"), { unique: true }).head().chain(value => value.toResource()).chain(_resource => Scale_type.fromRdf({ ..._context, ignoreRdfType: true, languageIn: _languageIn, resource: _resource })).toMaybe());
        if (_qudt_Scale$j$scaleTypeEither.isLeft()) { return _qudt_Scale$j$scaleTypeEither; }

        const qudt_Scale$j$scaleType = _qudt_Scale$j$scaleTypeEither.unsafeCoerce();
        return purify.Either.of({ ..._super0, identifier, qudt_Scale$j$dataStructure, qudt_Scale$j$permissibleMaths, qudt_Scale$j$permissibleTransformation, qudt_Scale$j$scaleType })
    }

    export function fromRdf(parameters: Parameters<typeof Scale._propertiesFromRdf>[0]): purify.Either<rdfjsResource.Resource.ValueError, Scale> {
        const { ignoreRdfType: _ignoreRdfType, ...otherParameters } = parameters
        return (Interval_scale.fromRdf(otherParameters) as purify.Either<rdfjsResource.Resource.ValueError, Scale>).altLazy(() => (Nominal_scale.fromRdf(otherParameters) as purify.Either<rdfjsResource.Resource.ValueError, Scale>)).altLazy(() => (Ordinal_scale.fromRdf(otherParameters) as purify.Either<rdfjsResource.Resource.ValueError, Scale>)).altLazy(() => (Ratio_scale.fromRdf(otherParameters) as purify.Either<rdfjsResource.Resource.ValueError, Scale>)).altLazy(() => Scale._propertiesFromRdf(parameters).map(properties => new Scale(properties)));
    }

    export let fromRdfType: rdfjs.NamedNode<string> = dataFactory.namedNode("http://qudt.org/schema/qudt/Scale");

    export function jsonSchema() {
        return zodToJsonSchema(scaleJsonZodSchema());
    }

    export function scaleJsonUiSchema(parameters?: { scopePrefix?: string }) {
        const scopePrefix = parameters?.scopePrefix ?? "#";
        return { "elements": [ QUDT_Concept.qudtConceptJsonUiSchema({ scopePrefix }), { scope: `${scopePrefix}/properties/qudt_Scale$j$dataStructure`, type: "Control" }, { scope: `${scopePrefix}/properties/qudt_Scale$j$permissibleMaths`, type: "Control" }, Transform_type.transformTypeJsonUiSchema({ scopePrefix: `${scopePrefix}/properties/qudt_Scale$j$permissibleTransformation` }), Scale_type.scaleTypeJsonUiSchema({ scopePrefix: `${scopePrefix}/properties/qudt_Scale$j$scaleType` }) ], label: "Scale", type: "Group" }
    }

    export function scaleJsonZodSchema() {
        return QUDT_Concept.qudtConceptJsonZodSchema().merge(zod.object({ "@id": zod.string().min(1),"type": zod.enum(["Interval_scale","Nominal_scale","Ordinal_scale","Ratio_scale","Scale"]),"qudt_Scale$j$dataStructure": zod.string().optional(),"qudt_Scale$j$permissibleMaths": zod.discriminatedUnion("termType", [zod.object({ "@id": zod.string().min(1), termType: zod.literal("BlankNode") }), zod.object({ "@id": zod.string().min(1), termType: zod.literal("NamedNode") }), zod.object({ "@language": zod.string().optional(), "@type": zod.string().optional(), "@value": zod.string(), termType: zod.literal("Literal") })]).array(),"qudt_Scale$j$permissibleTransformation": Transform_type.transformTypeJsonZodSchema().array(),"qudt_Scale$j$scaleType": Scale_type.scaleTypeJsonZodSchema().optional() }));
    }

    export function sparqlConstructQuery(parameters?: { ignoreRdfType?: boolean; prefixes?: { [prefix: string]: string }; subject?: sparqljs.Triple["subject"]; } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type">): sparqljs.ConstructQuery {
        const { ignoreRdfType, subject, ...queryParameters } = parameters ?? {}

        return { ...queryParameters, prefixes: parameters?.prefixes ?? {}, queryType: "CONSTRUCT", template: (queryParameters.template ?? []).concat(Scale.sparqlConstructTemplateTriples({ ignoreRdfType, subject })), type: "query", where: (queryParameters.where ?? []).concat(Scale.sparqlWherePatterns({ ignoreRdfType, subject })) };
    }

    export function sparqlConstructQueryString(parameters?: { ignoreRdfType?: boolean; subject?: sparqljs.Triple["subject"]; variablePrefix?: string; } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type"> & sparqljs.GeneratorOptions): string {
        return new sparqljs.Generator(parameters).stringify(Scale.sparqlConstructQuery(parameters));
    }

    export function sparqlConstructTemplateTriples(parameters?: { ignoreRdfType?: boolean; subject?: sparqljs.Triple["subject"], variablePrefix?: string }): readonly sparqljs.Triple[] {
        const subject = parameters?.subject ?? dataFactory.variable!("scale");
        const variablePrefix = parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "scale");
        return [...QUDT_Concept.sparqlConstructTemplateTriples({ ignoreRdfType: true, subject, variablePrefix }), ...(parameters?.ignoreRdfType ? [] : [{ subject, predicate: dataFactory.namedNode("http://www.w3.org/1999/02/22-rdf-syntax-ns#type"), object: dataFactory.variable!(`${variablePrefix}RdfType`) }]), { object: dataFactory.variable!(`${variablePrefix}QudtScaleJDataStructure`), predicate: dataFactory.namedNode("http://qudt.org/schema/qudt/dataStructure"), subject }, { object: dataFactory.variable!(`${variablePrefix}QudtScaleJPermissibleMaths`), predicate: dataFactory.namedNode("http://qudt.org/schema/qudt/permissibleMaths"), subject }, { object: dataFactory.variable!(`${variablePrefix}QudtScaleJPermissibleTransformation`), predicate: dataFactory.namedNode("http://qudt.org/schema/qudt/permissibleTransformation"), subject }, ...Transform_type.sparqlConstructTemplateTriples({ ignoreRdfType: true, subject: dataFactory.variable!(`${variablePrefix}QudtScaleJPermissibleTransformation`), variablePrefix: `${variablePrefix}QudtScaleJPermissibleTransformation` }), { object: dataFactory.variable!(`${variablePrefix}QudtScaleJScaleType`), predicate: dataFactory.namedNode("http://qudt.org/schema/qudt/scaleType"), subject }, ...Scale_type.sparqlConstructTemplateTriples({ ignoreRdfType: true, subject: dataFactory.variable!(`${variablePrefix}QudtScaleJScaleType`), variablePrefix: `${variablePrefix}QudtScaleJScaleType` })];
    }

    export function sparqlWherePatterns(parameters: { ignoreRdfType?: boolean; subject?: sparqljs.Triple["subject"], variablePrefix?: string }): readonly sparqljs.Pattern[] {
        const subject = parameters?.subject ?? dataFactory.variable!("scale");
        const variablePrefix = parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "scale");
        return [...QUDT_Concept.sparqlWherePatterns({ ignoreRdfType: true, subject, variablePrefix }), ...(parameters?.ignoreRdfType ? [] : [{ triples: [{ subject, predicate: dataFactory.namedNode("http://www.w3.org/1999/02/22-rdf-syntax-ns#type"), object: dataFactory.namedNode("http://qudt.org/schema/qudt/Scale") }], type: "bgp" as const }, { triples: [{ subject, predicate: dataFactory.namedNode("http://www.w3.org/1999/02/22-rdf-syntax-ns#type"), object: dataFactory.variable!(`${variablePrefix}RdfType`) }], type: "bgp" as const }]), { patterns: [{ triples: [{ object: dataFactory.variable!(`${variablePrefix}QudtScaleJDataStructure`), predicate: dataFactory.namedNode("http://qudt.org/schema/qudt/dataStructure"), subject }], type: "bgp" }], type: "optional" }, { patterns: [{ triples: [{ object: dataFactory.variable!(`${variablePrefix}QudtScaleJPermissibleMaths`), predicate: dataFactory.namedNode("http://qudt.org/schema/qudt/permissibleMaths"), subject }], type: "bgp" }], type: "optional" }, { patterns: [{ triples: [{ object: dataFactory.variable!(`${variablePrefix}QudtScaleJPermissibleTransformation`), predicate: dataFactory.namedNode("http://qudt.org/schema/qudt/permissibleTransformation"), subject }], type: "bgp" }, ...Transform_type.sparqlWherePatterns({ ignoreRdfType: true, subject: dataFactory.variable!(`${variablePrefix}QudtScaleJPermissibleTransformation`), variablePrefix: `${variablePrefix}QudtScaleJPermissibleTransformation` })], type: "optional" }, { patterns: [{ triples: [{ object: dataFactory.variable!(`${variablePrefix}QudtScaleJScaleType`), predicate: dataFactory.namedNode("http://qudt.org/schema/qudt/scaleType"), subject }], type: "bgp" }, ...Scale_type.sparqlWherePatterns({ ignoreRdfType: true, subject: dataFactory.variable!(`${variablePrefix}QudtScaleJScaleType`), variablePrefix: `${variablePrefix}QudtScaleJScaleType` })], type: "optional" }];
    }
}
/**
 * Ratio scale
 */
export class Ratio_scale extends Scale {
    override readonly type = "Ratio_scale";

    // biome-ignore lint/complexity/noUselessConstructor: Always have a constructor
    constructor(parameters: { readonly identifier?: (rdfjs.BlankNode | rdfjs.NamedNode) | string } & ConstructorParameters<typeof Scale>[0]) {
        super(parameters);
    }

    override get identifier(): (rdfjs.BlankNode | rdfjs.NamedNode) {
        if (typeof this._identifier === "undefined") { this._identifier = dataFactory.blankNode(); } return this._identifier;
    }

    override toRdf({ ignoreRdfType, mutateGraph, resourceSet }: { ignoreRdfType?: boolean; mutateGraph?: rdfjsResource.MutableResource.MutateGraph, resourceSet: rdfjsResource.MutableResourceSet }): rdfjsResource.MutableResource {
        const _resource = super.toRdf({ ignoreRdfType: true, mutateGraph, resourceSet });
        if (!ignoreRdfType) { _resource.add(_resource.dataFactory.namedNode("http://www.w3.org/1999/02/22-rdf-syntax-ns#type"), _resource.dataFactory.namedNode("http://qudt.org/schema/qudt/RatioScale")); }

        return _resource;
    }

    override toString(): string {
        return JSON.stringify(this.toJson());
    }
}

export namespace Ratio_scale {
    export function _propertiesFromJson(_json: unknown): purify.Either<zod.ZodError, { identifier: (rdfjs.BlankNode | rdfjs.NamedNode); } & UnwrapR<ReturnType<typeof Scale._propertiesFromJson>>> {
        const _jsonSafeParseResult = ratioScaleJsonZodSchema().safeParse(_json);
        if (!_jsonSafeParseResult.success) { return purify.Left(_jsonSafeParseResult.error); }

        const _jsonObject = _jsonSafeParseResult.data;
        const _super0Either = Scale._propertiesFromJson(_jsonObject);
        if (_super0Either.isLeft()) { return _super0Either; }

        const _super0 = _super0Either.unsafeCoerce()
        const identifier = (_jsonObject["@id"].startsWith("_:") ? dataFactory.blankNode(_jsonObject["@id"].substring(2)) : dataFactory.namedNode(_jsonObject["@id"]));
        return purify.Either.of({ ..._super0, identifier })
    }

    export function fromJson(json: unknown): purify.Either<zod.ZodError, Ratio_scale> {
        return Ratio_scale._propertiesFromJson(json).map(properties => new Ratio_scale(properties));
    }

    export function _propertiesFromRdf({ ignoreRdfType: _ignoreRdfType, languageIn: _languageIn, resource: _resource,
        // @ts-ignore
        ..._context }: { [_index: string]: any; ignoreRdfType?: boolean; languageIn?: readonly string[]; resource: rdfjsResource.Resource; }): purify.Either<rdfjsResource.Resource.ValueError, { identifier: (rdfjs.BlankNode | rdfjs.NamedNode); } & UnwrapR<ReturnType<typeof Scale._propertiesFromRdf>>> {
        const _super0Either = Scale._propertiesFromRdf({ ..._context, ignoreRdfType: true, languageIn: _languageIn, resource: _resource });
        if (_super0Either.isLeft()) { return _super0Either; }

        const _super0 = _super0Either.unsafeCoerce()
        if (!_ignoreRdfType && !_resource.isInstanceOf(dataFactory.namedNode("http://qudt.org/schema/qudt/RatioScale"))) { return purify.Left(new rdfjsResource.Resource.ValueError({ focusResource: _resource, message: `${rdfjsResource.Resource.Identifier.toString(_resource.identifier)} has unexpected RDF type (expected http://qudt.org/schema/qudt/RatioScale)`, predicate: dataFactory.namedNode("http://qudt.org/schema/qudt/RatioScale") })); }

        const identifier = _resource.identifier
        return purify.Either.of({ ..._super0, identifier })
    }

    export function fromRdf(parameters: Parameters<typeof Ratio_scale._propertiesFromRdf>[0]): purify.Either<rdfjsResource.Resource.ValueError, Ratio_scale> {
        return Ratio_scale._propertiesFromRdf(parameters).map(properties => new Ratio_scale(properties));
    }

    export let fromRdfType: rdfjs.NamedNode<string> = dataFactory.namedNode("http://qudt.org/schema/qudt/RatioScale");

    export function jsonSchema() {
        return zodToJsonSchema(ratioScaleJsonZodSchema());
    }

    export function ratioScaleJsonUiSchema(parameters?: { scopePrefix?: string }) {
        const scopePrefix = parameters?.scopePrefix ?? "#";
        return { "elements": [ Scale.scaleJsonUiSchema({ scopePrefix }) ], label: "Ratio scale", type: "Group" }
    }

    export function ratioScaleJsonZodSchema() {
        return Scale.scaleJsonZodSchema().merge(zod.object({ "@id": zod.string().min(1),"type": zod.literal("Ratio_scale") }));
    }

    export function sparqlConstructQuery(parameters?: { ignoreRdfType?: boolean; prefixes?: { [prefix: string]: string }; subject?: sparqljs.Triple["subject"]; } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type">): sparqljs.ConstructQuery {
        const { ignoreRdfType, subject, ...queryParameters } = parameters ?? {}

        return { ...queryParameters, prefixes: parameters?.prefixes ?? {}, queryType: "CONSTRUCT", template: (queryParameters.template ?? []).concat(Ratio_scale.sparqlConstructTemplateTriples({ ignoreRdfType, subject })), type: "query", where: (queryParameters.where ?? []).concat(Ratio_scale.sparqlWherePatterns({ ignoreRdfType, subject })) };
    }

    export function sparqlConstructQueryString(parameters?: { ignoreRdfType?: boolean; subject?: sparqljs.Triple["subject"]; variablePrefix?: string; } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type"> & sparqljs.GeneratorOptions): string {
        return new sparqljs.Generator(parameters).stringify(Ratio_scale.sparqlConstructQuery(parameters));
    }

    export function sparqlConstructTemplateTriples(parameters?: { ignoreRdfType?: boolean; subject?: sparqljs.Triple["subject"], variablePrefix?: string }): readonly sparqljs.Triple[] {
        const subject = parameters?.subject ?? dataFactory.variable!("ratioScale");
        const variablePrefix = parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "ratioScale");
        return [...Scale.sparqlConstructTemplateTriples({ ignoreRdfType: true, subject, variablePrefix }), ...(parameters?.ignoreRdfType ? [] : [{ subject, predicate: dataFactory.namedNode("http://www.w3.org/1999/02/22-rdf-syntax-ns#type"), object: dataFactory.variable!(`${variablePrefix}RdfType`) }])];
    }

    export function sparqlWherePatterns(parameters: { ignoreRdfType?: boolean; subject?: sparqljs.Triple["subject"], variablePrefix?: string }): readonly sparqljs.Pattern[] {
        const subject = parameters?.subject ?? dataFactory.variable!("ratioScale");
        const variablePrefix = parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "ratioScale");
        return [...Scale.sparqlWherePatterns({ ignoreRdfType: true, subject, variablePrefix }), ...(parameters?.ignoreRdfType ? [] : [{ triples: [{ subject, predicate: dataFactory.namedNode("http://www.w3.org/1999/02/22-rdf-syntax-ns#type"), object: dataFactory.namedNode("http://qudt.org/schema/qudt/RatioScale") }], type: "bgp" as const }, { triples: [{ subject, predicate: dataFactory.namedNode("http://www.w3.org/1999/02/22-rdf-syntax-ns#type"), object: dataFactory.variable!(`${variablePrefix}RdfType`) }], type: "bgp" as const }])];
    }
}
/**
 * Ordinal scale
 */
export class Ordinal_scale extends Scale {
    override readonly type = "Ordinal_scale";
    readonly qudt_OrdinalScale$j$order: number;

    constructor(parameters: { readonly identifier?: (rdfjs.BlankNode | rdfjs.NamedNode) | string, readonly qudt_OrdinalScale$j$order: number } & ConstructorParameters<typeof Scale>[0]) {
        super(parameters);
        this.qudt_OrdinalScale$j$order = parameters.qudt_OrdinalScale$j$order;
    }

    override get identifier(): (rdfjs.BlankNode | rdfjs.NamedNode) {
        if (typeof this._identifier === "undefined") { this._identifier = dataFactory.blankNode(); } return this._identifier;
    }

    override equals(other: Ordinal_scale): EqualsResult {
        return super.equals(other).chain(() => (strictEquals)(this.qudt_OrdinalScale$j$order, other.qudt_OrdinalScale$j$order).mapLeft(propertyValuesUnequal => ({ left: this, right: other, propertyName: "qudt_OrdinalScale$j$order", propertyValuesUnequal, type: "Property" as const })));
    }

    override hash<HasherT extends { update: (message: string | number[] | ArrayBuffer | Uint8Array) => void; }>(_hasher: HasherT): HasherT {
        this.hashShaclProperties(_hasher);
        return _hasher;
    }

    protected override hashShaclProperties<HasherT extends { update: (message: string | number[] | ArrayBuffer | Uint8Array) => void; }>(_hasher: HasherT): HasherT {
        super.hashShaclProperties(_hasher);
        _hasher.update(this.qudt_OrdinalScale$j$order.toString());
        return _hasher;
    }

    override toJson(): { readonly "qudt_OrdinalScale$j$order": number } & ReturnType<Scale["toJson"]> {
        return JSON.parse(JSON.stringify({ ...super.toJson(),qudt_OrdinalScale$j$order: this.qudt_OrdinalScale$j$order } satisfies ReturnType<Ordinal_scale["toJson"]>));
    }

    override toRdf({ ignoreRdfType, mutateGraph, resourceSet }: { ignoreRdfType?: boolean; mutateGraph?: rdfjsResource.MutableResource.MutateGraph, resourceSet: rdfjsResource.MutableResourceSet }): rdfjsResource.MutableResource {
        const _resource = super.toRdf({ ignoreRdfType: true, mutateGraph, resourceSet });
        if (!ignoreRdfType) { _resource.add(_resource.dataFactory.namedNode("http://www.w3.org/1999/02/22-rdf-syntax-ns#type"), _resource.dataFactory.namedNode("http://qudt.org/schema/qudt/OrdinalScale")); }

        _resource.add(dataFactory.namedNode("http://qudt.org/schema/qudt/order"), this.qudt_OrdinalScale$j$order);
        return _resource;
    }

    override toString(): string {
        return JSON.stringify(this.toJson());
    }
}

export namespace Ordinal_scale {
    export function _propertiesFromJson(_json: unknown): purify.Either<zod.ZodError, { identifier: (rdfjs.BlankNode | rdfjs.NamedNode); qudt_OrdinalScale$j$order: number; } & UnwrapR<ReturnType<typeof Scale._propertiesFromJson>>> {
        const _jsonSafeParseResult = ordinalScaleJsonZodSchema().safeParse(_json);
        if (!_jsonSafeParseResult.success) { return purify.Left(_jsonSafeParseResult.error); }

        const _jsonObject = _jsonSafeParseResult.data;
        const _super0Either = Scale._propertiesFromJson(_jsonObject);
        if (_super0Either.isLeft()) { return _super0Either; }

        const _super0 = _super0Either.unsafeCoerce()
        const identifier = (_jsonObject["@id"].startsWith("_:") ? dataFactory.blankNode(_jsonObject["@id"].substring(2)) : dataFactory.namedNode(_jsonObject["@id"]));
        const qudt_OrdinalScale$j$order = _jsonObject["qudt_OrdinalScale$j$order"];
        return purify.Either.of({ ..._super0, identifier, qudt_OrdinalScale$j$order })
    }

    export function fromJson(json: unknown): purify.Either<zod.ZodError, Ordinal_scale> {
        return Ordinal_scale._propertiesFromJson(json).map(properties => new Ordinal_scale(properties));
    }

    export function _propertiesFromRdf({ ignoreRdfType: _ignoreRdfType, languageIn: _languageIn, resource: _resource,
        // @ts-ignore
        ..._context }: { [_index: string]: any; ignoreRdfType?: boolean; languageIn?: readonly string[]; resource: rdfjsResource.Resource; }): purify.Either<rdfjsResource.Resource.ValueError, { identifier: (rdfjs.BlankNode | rdfjs.NamedNode); qudt_OrdinalScale$j$order: number; } & UnwrapR<ReturnType<typeof Scale._propertiesFromRdf>>> {
        const _super0Either = Scale._propertiesFromRdf({ ..._context, ignoreRdfType: true, languageIn: _languageIn, resource: _resource });
        if (_super0Either.isLeft()) { return _super0Either; }

        const _super0 = _super0Either.unsafeCoerce()
        if (!_ignoreRdfType && !_resource.isInstanceOf(dataFactory.namedNode("http://qudt.org/schema/qudt/OrdinalScale"))) { return purify.Left(new rdfjsResource.Resource.ValueError({ focusResource: _resource, message: `${rdfjsResource.Resource.Identifier.toString(_resource.identifier)} has unexpected RDF type (expected http://qudt.org/schema/qudt/OrdinalScale)`, predicate: dataFactory.namedNode("http://qudt.org/schema/qudt/OrdinalScale") })); }

        const identifier = _resource.identifier
        const _qudt_OrdinalScale$j$orderEither: purify.Either<rdfjsResource.Resource.ValueError, number> = _resource.values(dataFactory.namedNode("http://qudt.org/schema/qudt/order"), { unique: true }).head().chain(_value => _value.toNumber());
        if (_qudt_OrdinalScale$j$orderEither.isLeft()) { return _qudt_OrdinalScale$j$orderEither; }

        const qudt_OrdinalScale$j$order = _qudt_OrdinalScale$j$orderEither.unsafeCoerce();
        return purify.Either.of({ ..._super0, identifier, qudt_OrdinalScale$j$order })
    }

    export function fromRdf(parameters: Parameters<typeof Ordinal_scale._propertiesFromRdf>[0]): purify.Either<rdfjsResource.Resource.ValueError, Ordinal_scale> {
        return Ordinal_scale._propertiesFromRdf(parameters).map(properties => new Ordinal_scale(properties));
    }

    export let fromRdfType: rdfjs.NamedNode<string> = dataFactory.namedNode("http://qudt.org/schema/qudt/OrdinalScale");

    export function jsonSchema() {
        return zodToJsonSchema(ordinalScaleJsonZodSchema());
    }

    export function ordinalScaleJsonUiSchema(parameters?: { scopePrefix?: string }) {
        const scopePrefix = parameters?.scopePrefix ?? "#";
        return { "elements": [ Scale.scaleJsonUiSchema({ scopePrefix }), { scope: `${scopePrefix}/properties/qudt_OrdinalScale$j$order`, type: "Control" } ], label: "Ordinal scale", type: "Group" }
    }

    export function ordinalScaleJsonZodSchema() {
        return Scale.scaleJsonZodSchema().merge(zod.object({ "@id": zod.string().min(1),"type": zod.literal("Ordinal_scale"),"qudt_OrdinalScale$j$order": zod.number() }));
    }

    export function sparqlConstructQuery(parameters?: { ignoreRdfType?: boolean; prefixes?: { [prefix: string]: string }; subject?: sparqljs.Triple["subject"]; } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type">): sparqljs.ConstructQuery {
        const { ignoreRdfType, subject, ...queryParameters } = parameters ?? {}

        return { ...queryParameters, prefixes: parameters?.prefixes ?? {}, queryType: "CONSTRUCT", template: (queryParameters.template ?? []).concat(Ordinal_scale.sparqlConstructTemplateTriples({ ignoreRdfType, subject })), type: "query", where: (queryParameters.where ?? []).concat(Ordinal_scale.sparqlWherePatterns({ ignoreRdfType, subject })) };
    }

    export function sparqlConstructQueryString(parameters?: { ignoreRdfType?: boolean; subject?: sparqljs.Triple["subject"]; variablePrefix?: string; } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type"> & sparqljs.GeneratorOptions): string {
        return new sparqljs.Generator(parameters).stringify(Ordinal_scale.sparqlConstructQuery(parameters));
    }

    export function sparqlConstructTemplateTriples(parameters?: { ignoreRdfType?: boolean; subject?: sparqljs.Triple["subject"], variablePrefix?: string }): readonly sparqljs.Triple[] {
        const subject = parameters?.subject ?? dataFactory.variable!("ordinalScale");
        const variablePrefix = parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "ordinalScale");
        return [...Scale.sparqlConstructTemplateTriples({ ignoreRdfType: true, subject, variablePrefix }), ...(parameters?.ignoreRdfType ? [] : [{ subject, predicate: dataFactory.namedNode("http://www.w3.org/1999/02/22-rdf-syntax-ns#type"), object: dataFactory.variable!(`${variablePrefix}RdfType`) }]), { object: dataFactory.variable!(`${variablePrefix}QudtOrdinalScaleJOrder`), predicate: dataFactory.namedNode("http://qudt.org/schema/qudt/order"), subject }];
    }

    export function sparqlWherePatterns(parameters: { ignoreRdfType?: boolean; subject?: sparqljs.Triple["subject"], variablePrefix?: string }): readonly sparqljs.Pattern[] {
        const subject = parameters?.subject ?? dataFactory.variable!("ordinalScale");
        const variablePrefix = parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "ordinalScale");
        return [...Scale.sparqlWherePatterns({ ignoreRdfType: true, subject, variablePrefix }), ...(parameters?.ignoreRdfType ? [] : [{ triples: [{ subject, predicate: dataFactory.namedNode("http://www.w3.org/1999/02/22-rdf-syntax-ns#type"), object: dataFactory.namedNode("http://qudt.org/schema/qudt/OrdinalScale") }], type: "bgp" as const }, { triples: [{ subject, predicate: dataFactory.namedNode("http://www.w3.org/1999/02/22-rdf-syntax-ns#type"), object: dataFactory.variable!(`${variablePrefix}RdfType`) }], type: "bgp" as const }]), { triples: [{ object: dataFactory.variable!(`${variablePrefix}QudtOrdinalScaleJOrder`), predicate: dataFactory.namedNode("http://qudt.org/schema/qudt/order"), subject }], type: "bgp" }];
    }
}
/**
 * Nominal scale
 */
export class Nominal_scale extends Scale {
    override readonly type = "Nominal_scale";

    // biome-ignore lint/complexity/noUselessConstructor: Always have a constructor
    constructor(parameters: { readonly identifier?: (rdfjs.BlankNode | rdfjs.NamedNode) | string } & ConstructorParameters<typeof Scale>[0]) {
        super(parameters);
    }

    override get identifier(): (rdfjs.BlankNode | rdfjs.NamedNode) {
        if (typeof this._identifier === "undefined") { this._identifier = dataFactory.blankNode(); } return this._identifier;
    }

    override toRdf({ ignoreRdfType, mutateGraph, resourceSet }: { ignoreRdfType?: boolean; mutateGraph?: rdfjsResource.MutableResource.MutateGraph, resourceSet: rdfjsResource.MutableResourceSet }): rdfjsResource.MutableResource {
        const _resource = super.toRdf({ ignoreRdfType: true, mutateGraph, resourceSet });
        if (!ignoreRdfType) { _resource.add(_resource.dataFactory.namedNode("http://www.w3.org/1999/02/22-rdf-syntax-ns#type"), _resource.dataFactory.namedNode("http://qudt.org/schema/qudt/NominalScale")); }

        return _resource;
    }

    override toString(): string {
        return JSON.stringify(this.toJson());
    }
}

export namespace Nominal_scale {
    export function _propertiesFromJson(_json: unknown): purify.Either<zod.ZodError, { identifier: (rdfjs.BlankNode | rdfjs.NamedNode); } & UnwrapR<ReturnType<typeof Scale._propertiesFromJson>>> {
        const _jsonSafeParseResult = nominalScaleJsonZodSchema().safeParse(_json);
        if (!_jsonSafeParseResult.success) { return purify.Left(_jsonSafeParseResult.error); }

        const _jsonObject = _jsonSafeParseResult.data;
        const _super0Either = Scale._propertiesFromJson(_jsonObject);
        if (_super0Either.isLeft()) { return _super0Either; }

        const _super0 = _super0Either.unsafeCoerce()
        const identifier = (_jsonObject["@id"].startsWith("_:") ? dataFactory.blankNode(_jsonObject["@id"].substring(2)) : dataFactory.namedNode(_jsonObject["@id"]));
        return purify.Either.of({ ..._super0, identifier })
    }

    export function fromJson(json: unknown): purify.Either<zod.ZodError, Nominal_scale> {
        return Nominal_scale._propertiesFromJson(json).map(properties => new Nominal_scale(properties));
    }

    export function _propertiesFromRdf({ ignoreRdfType: _ignoreRdfType, languageIn: _languageIn, resource: _resource,
        // @ts-ignore
        ..._context }: { [_index: string]: any; ignoreRdfType?: boolean; languageIn?: readonly string[]; resource: rdfjsResource.Resource; }): purify.Either<rdfjsResource.Resource.ValueError, { identifier: (rdfjs.BlankNode | rdfjs.NamedNode); } & UnwrapR<ReturnType<typeof Scale._propertiesFromRdf>>> {
        const _super0Either = Scale._propertiesFromRdf({ ..._context, ignoreRdfType: true, languageIn: _languageIn, resource: _resource });
        if (_super0Either.isLeft()) { return _super0Either; }

        const _super0 = _super0Either.unsafeCoerce()
        if (!_ignoreRdfType && !_resource.isInstanceOf(dataFactory.namedNode("http://qudt.org/schema/qudt/NominalScale"))) { return purify.Left(new rdfjsResource.Resource.ValueError({ focusResource: _resource, message: `${rdfjsResource.Resource.Identifier.toString(_resource.identifier)} has unexpected RDF type (expected http://qudt.org/schema/qudt/NominalScale)`, predicate: dataFactory.namedNode("http://qudt.org/schema/qudt/NominalScale") })); }

        const identifier = _resource.identifier
        return purify.Either.of({ ..._super0, identifier })
    }

    export function fromRdf(parameters: Parameters<typeof Nominal_scale._propertiesFromRdf>[0]): purify.Either<rdfjsResource.Resource.ValueError, Nominal_scale> {
        return Nominal_scale._propertiesFromRdf(parameters).map(properties => new Nominal_scale(properties));
    }

    export let fromRdfType: rdfjs.NamedNode<string> = dataFactory.namedNode("http://qudt.org/schema/qudt/NominalScale");

    export function jsonSchema() {
        return zodToJsonSchema(nominalScaleJsonZodSchema());
    }

    export function nominalScaleJsonUiSchema(parameters?: { scopePrefix?: string }) {
        const scopePrefix = parameters?.scopePrefix ?? "#";
        return { "elements": [ Scale.scaleJsonUiSchema({ scopePrefix }) ], label: "Nominal scale", type: "Group" }
    }

    export function nominalScaleJsonZodSchema() {
        return Scale.scaleJsonZodSchema().merge(zod.object({ "@id": zod.string().min(1),"type": zod.literal("Nominal_scale") }));
    }

    export function sparqlConstructQuery(parameters?: { ignoreRdfType?: boolean; prefixes?: { [prefix: string]: string }; subject?: sparqljs.Triple["subject"]; } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type">): sparqljs.ConstructQuery {
        const { ignoreRdfType, subject, ...queryParameters } = parameters ?? {}

        return { ...queryParameters, prefixes: parameters?.prefixes ?? {}, queryType: "CONSTRUCT", template: (queryParameters.template ?? []).concat(Nominal_scale.sparqlConstructTemplateTriples({ ignoreRdfType, subject })), type: "query", where: (queryParameters.where ?? []).concat(Nominal_scale.sparqlWherePatterns({ ignoreRdfType, subject })) };
    }

    export function sparqlConstructQueryString(parameters?: { ignoreRdfType?: boolean; subject?: sparqljs.Triple["subject"]; variablePrefix?: string; } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type"> & sparqljs.GeneratorOptions): string {
        return new sparqljs.Generator(parameters).stringify(Nominal_scale.sparqlConstructQuery(parameters));
    }

    export function sparqlConstructTemplateTriples(parameters?: { ignoreRdfType?: boolean; subject?: sparqljs.Triple["subject"], variablePrefix?: string }): readonly sparqljs.Triple[] {
        const subject = parameters?.subject ?? dataFactory.variable!("nominalScale");
        const variablePrefix = parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "nominalScale");
        return [...Scale.sparqlConstructTemplateTriples({ ignoreRdfType: true, subject, variablePrefix }), ...(parameters?.ignoreRdfType ? [] : [{ subject, predicate: dataFactory.namedNode("http://www.w3.org/1999/02/22-rdf-syntax-ns#type"), object: dataFactory.variable!(`${variablePrefix}RdfType`) }])];
    }

    export function sparqlWherePatterns(parameters: { ignoreRdfType?: boolean; subject?: sparqljs.Triple["subject"], variablePrefix?: string }): readonly sparqljs.Pattern[] {
        const subject = parameters?.subject ?? dataFactory.variable!("nominalScale");
        const variablePrefix = parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "nominalScale");
        return [...Scale.sparqlWherePatterns({ ignoreRdfType: true, subject, variablePrefix }), ...(parameters?.ignoreRdfType ? [] : [{ triples: [{ subject, predicate: dataFactory.namedNode("http://www.w3.org/1999/02/22-rdf-syntax-ns#type"), object: dataFactory.namedNode("http://qudt.org/schema/qudt/NominalScale") }], type: "bgp" as const }, { triples: [{ subject, predicate: dataFactory.namedNode("http://www.w3.org/1999/02/22-rdf-syntax-ns#type"), object: dataFactory.variable!(`${variablePrefix}RdfType`) }], type: "bgp" as const }])];
    }
}
/**
 * Interval scale
 */
export class Interval_scale extends Scale {
    override readonly type = "Interval_scale";

    // biome-ignore lint/complexity/noUselessConstructor: Always have a constructor
    constructor(parameters: { readonly identifier?: (rdfjs.BlankNode | rdfjs.NamedNode) | string } & ConstructorParameters<typeof Scale>[0]) {
        super(parameters);
    }

    override get identifier(): (rdfjs.BlankNode | rdfjs.NamedNode) {
        if (typeof this._identifier === "undefined") { this._identifier = dataFactory.blankNode(); } return this._identifier;
    }

    override toRdf({ ignoreRdfType, mutateGraph, resourceSet }: { ignoreRdfType?: boolean; mutateGraph?: rdfjsResource.MutableResource.MutateGraph, resourceSet: rdfjsResource.MutableResourceSet }): rdfjsResource.MutableResource {
        const _resource = super.toRdf({ ignoreRdfType: true, mutateGraph, resourceSet });
        if (!ignoreRdfType) { _resource.add(_resource.dataFactory.namedNode("http://www.w3.org/1999/02/22-rdf-syntax-ns#type"), _resource.dataFactory.namedNode("http://qudt.org/schema/qudt/IntervalScale")); }

        return _resource;
    }

    override toString(): string {
        return JSON.stringify(this.toJson());
    }
}

export namespace Interval_scale {
    export function _propertiesFromJson(_json: unknown): purify.Either<zod.ZodError, { identifier: (rdfjs.BlankNode | rdfjs.NamedNode); } & UnwrapR<ReturnType<typeof Scale._propertiesFromJson>>> {
        const _jsonSafeParseResult = intervalScaleJsonZodSchema().safeParse(_json);
        if (!_jsonSafeParseResult.success) { return purify.Left(_jsonSafeParseResult.error); }

        const _jsonObject = _jsonSafeParseResult.data;
        const _super0Either = Scale._propertiesFromJson(_jsonObject);
        if (_super0Either.isLeft()) { return _super0Either; }

        const _super0 = _super0Either.unsafeCoerce()
        const identifier = (_jsonObject["@id"].startsWith("_:") ? dataFactory.blankNode(_jsonObject["@id"].substring(2)) : dataFactory.namedNode(_jsonObject["@id"]));
        return purify.Either.of({ ..._super0, identifier })
    }

    export function fromJson(json: unknown): purify.Either<zod.ZodError, Interval_scale> {
        return Interval_scale._propertiesFromJson(json).map(properties => new Interval_scale(properties));
    }

    export function _propertiesFromRdf({ ignoreRdfType: _ignoreRdfType, languageIn: _languageIn, resource: _resource,
        // @ts-ignore
        ..._context }: { [_index: string]: any; ignoreRdfType?: boolean; languageIn?: readonly string[]; resource: rdfjsResource.Resource; }): purify.Either<rdfjsResource.Resource.ValueError, { identifier: (rdfjs.BlankNode | rdfjs.NamedNode); } & UnwrapR<ReturnType<typeof Scale._propertiesFromRdf>>> {
        const _super0Either = Scale._propertiesFromRdf({ ..._context, ignoreRdfType: true, languageIn: _languageIn, resource: _resource });
        if (_super0Either.isLeft()) { return _super0Either; }

        const _super0 = _super0Either.unsafeCoerce()
        if (!_ignoreRdfType && !_resource.isInstanceOf(dataFactory.namedNode("http://qudt.org/schema/qudt/IntervalScale"))) { return purify.Left(new rdfjsResource.Resource.ValueError({ focusResource: _resource, message: `${rdfjsResource.Resource.Identifier.toString(_resource.identifier)} has unexpected RDF type (expected http://qudt.org/schema/qudt/IntervalScale)`, predicate: dataFactory.namedNode("http://qudt.org/schema/qudt/IntervalScale") })); }

        const identifier = _resource.identifier
        return purify.Either.of({ ..._super0, identifier })
    }

    export function fromRdf(parameters: Parameters<typeof Interval_scale._propertiesFromRdf>[0]): purify.Either<rdfjsResource.Resource.ValueError, Interval_scale> {
        return Interval_scale._propertiesFromRdf(parameters).map(properties => new Interval_scale(properties));
    }

    export let fromRdfType: rdfjs.NamedNode<string> = dataFactory.namedNode("http://qudt.org/schema/qudt/IntervalScale");

    export function jsonSchema() {
        return zodToJsonSchema(intervalScaleJsonZodSchema());
    }

    export function intervalScaleJsonUiSchema(parameters?: { scopePrefix?: string }) {
        const scopePrefix = parameters?.scopePrefix ?? "#";
        return { "elements": [ Scale.scaleJsonUiSchema({ scopePrefix }) ], label: "Interval scale", type: "Group" }
    }

    export function intervalScaleJsonZodSchema() {
        return Scale.scaleJsonZodSchema().merge(zod.object({ "@id": zod.string().min(1),"type": zod.literal("Interval_scale") }));
    }

    export function sparqlConstructQuery(parameters?: { ignoreRdfType?: boolean; prefixes?: { [prefix: string]: string }; subject?: sparqljs.Triple["subject"]; } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type">): sparqljs.ConstructQuery {
        const { ignoreRdfType, subject, ...queryParameters } = parameters ?? {}

        return { ...queryParameters, prefixes: parameters?.prefixes ?? {}, queryType: "CONSTRUCT", template: (queryParameters.template ?? []).concat(Interval_scale.sparqlConstructTemplateTriples({ ignoreRdfType, subject })), type: "query", where: (queryParameters.where ?? []).concat(Interval_scale.sparqlWherePatterns({ ignoreRdfType, subject })) };
    }

    export function sparqlConstructQueryString(parameters?: { ignoreRdfType?: boolean; subject?: sparqljs.Triple["subject"]; variablePrefix?: string; } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type"> & sparqljs.GeneratorOptions): string {
        return new sparqljs.Generator(parameters).stringify(Interval_scale.sparqlConstructQuery(parameters));
    }

    export function sparqlConstructTemplateTriples(parameters?: { ignoreRdfType?: boolean; subject?: sparqljs.Triple["subject"], variablePrefix?: string }): readonly sparqljs.Triple[] {
        const subject = parameters?.subject ?? dataFactory.variable!("intervalScale");
        const variablePrefix = parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "intervalScale");
        return [...Scale.sparqlConstructTemplateTriples({ ignoreRdfType: true, subject, variablePrefix }), ...(parameters?.ignoreRdfType ? [] : [{ subject, predicate: dataFactory.namedNode("http://www.w3.org/1999/02/22-rdf-syntax-ns#type"), object: dataFactory.variable!(`${variablePrefix}RdfType`) }])];
    }

    export function sparqlWherePatterns(parameters: { ignoreRdfType?: boolean; subject?: sparqljs.Triple["subject"], variablePrefix?: string }): readonly sparqljs.Pattern[] {
        const subject = parameters?.subject ?? dataFactory.variable!("intervalScale");
        const variablePrefix = parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "intervalScale");
        return [...Scale.sparqlWherePatterns({ ignoreRdfType: true, subject, variablePrefix }), ...(parameters?.ignoreRdfType ? [] : [{ triples: [{ subject, predicate: dataFactory.namedNode("http://www.w3.org/1999/02/22-rdf-syntax-ns#type"), object: dataFactory.namedNode("http://qudt.org/schema/qudt/IntervalScale") }], type: "bgp" as const }, { triples: [{ subject, predicate: dataFactory.namedNode("http://www.w3.org/1999/02/22-rdf-syntax-ns#type"), object: dataFactory.variable!(`${variablePrefix}RdfType`) }], type: "bgp" as const }])];
    }
}
/**
 * Figure
 */
export class Figure extends QUDT_Concept {
    override readonly type = "Figure";
    readonly qudt_Figure$j$figureCaption: purify.Maybe<string>;
    readonly qudt_Figure$j$figureLabel: purify.Maybe<string>;
    readonly qudt_Figure$j$height: purify.Maybe<string>;
    readonly qudt_Figure$j$image: purify.Maybe<string>;
    readonly qudt_Figure$j$imageLocation: string;
    readonly qudt_Figure$j$landscape: purify.Maybe<boolean>;
    readonly qudt_Figure$j$width: purify.Maybe<string>;

    constructor(parameters: { readonly identifier?: (rdfjs.BlankNode | rdfjs.NamedNode) | string, readonly qudt_Figure$j$figureCaption?: purify.Maybe<string> | string, readonly qudt_Figure$j$figureLabel?: purify.Maybe<string> | string, readonly qudt_Figure$j$height?: purify.Maybe<string> | string, readonly qudt_Figure$j$image?: purify.Maybe<string> | string, readonly qudt_Figure$j$imageLocation: string, readonly qudt_Figure$j$landscape?: boolean | purify.Maybe<boolean>, readonly qudt_Figure$j$width?: purify.Maybe<string> | string } & ConstructorParameters<typeof QUDT_Concept>[0]) {
        super(parameters);
        if (purify.Maybe.isMaybe(parameters.qudt_Figure$j$figureCaption)) { this.qudt_Figure$j$figureCaption = parameters.qudt_Figure$j$figureCaption; } else if (typeof parameters.qudt_Figure$j$figureCaption === "string") { this.qudt_Figure$j$figureCaption = purify.Maybe.of(parameters.qudt_Figure$j$figureCaption); } else if (typeof parameters.qudt_Figure$j$figureCaption === "undefined") { this.qudt_Figure$j$figureCaption = purify.Maybe.empty(); } else { this.qudt_Figure$j$figureCaption =( parameters.qudt_Figure$j$figureCaption) as never;
         }

        if (purify.Maybe.isMaybe(parameters.qudt_Figure$j$figureLabel)) { this.qudt_Figure$j$figureLabel = parameters.qudt_Figure$j$figureLabel; } else if (typeof parameters.qudt_Figure$j$figureLabel === "string") { this.qudt_Figure$j$figureLabel = purify.Maybe.of(parameters.qudt_Figure$j$figureLabel); } else if (typeof parameters.qudt_Figure$j$figureLabel === "undefined") { this.qudt_Figure$j$figureLabel = purify.Maybe.empty(); } else { this.qudt_Figure$j$figureLabel =( parameters.qudt_Figure$j$figureLabel) as never;
         }

        if (purify.Maybe.isMaybe(parameters.qudt_Figure$j$height)) { this.qudt_Figure$j$height = parameters.qudt_Figure$j$height; } else if (typeof parameters.qudt_Figure$j$height === "string") { this.qudt_Figure$j$height = purify.Maybe.of(parameters.qudt_Figure$j$height); } else if (typeof parameters.qudt_Figure$j$height === "undefined") { this.qudt_Figure$j$height = purify.Maybe.empty(); } else { this.qudt_Figure$j$height =( parameters.qudt_Figure$j$height) as never;
         }

        if (purify.Maybe.isMaybe(parameters.qudt_Figure$j$image)) { this.qudt_Figure$j$image = parameters.qudt_Figure$j$image; } else if (typeof parameters.qudt_Figure$j$image === "string") { this.qudt_Figure$j$image = purify.Maybe.of(parameters.qudt_Figure$j$image); } else if (typeof parameters.qudt_Figure$j$image === "undefined") { this.qudt_Figure$j$image = purify.Maybe.empty(); } else { this.qudt_Figure$j$image =( parameters.qudt_Figure$j$image) as never;
         }

        this.qudt_Figure$j$imageLocation = parameters.qudt_Figure$j$imageLocation;
        if (purify.Maybe.isMaybe(parameters.qudt_Figure$j$landscape)) { this.qudt_Figure$j$landscape = parameters.qudt_Figure$j$landscape; } else if (typeof parameters.qudt_Figure$j$landscape === "boolean") { this.qudt_Figure$j$landscape = purify.Maybe.of(parameters.qudt_Figure$j$landscape); } else if (typeof parameters.qudt_Figure$j$landscape === "undefined") { this.qudt_Figure$j$landscape = purify.Maybe.empty(); } else { this.qudt_Figure$j$landscape =( parameters.qudt_Figure$j$landscape) as never;
         }

        if (purify.Maybe.isMaybe(parameters.qudt_Figure$j$width)) { this.qudt_Figure$j$width = parameters.qudt_Figure$j$width; } else if (typeof parameters.qudt_Figure$j$width === "string") { this.qudt_Figure$j$width = purify.Maybe.of(parameters.qudt_Figure$j$width); } else if (typeof parameters.qudt_Figure$j$width === "undefined") { this.qudt_Figure$j$width = purify.Maybe.empty(); } else { this.qudt_Figure$j$width =( parameters.qudt_Figure$j$width) as never;
         }
    }

    override get identifier(): (rdfjs.BlankNode | rdfjs.NamedNode) {
        if (typeof this._identifier === "undefined") { this._identifier = dataFactory.blankNode(); } return this._identifier;
    }

    override equals(other: Figure): EqualsResult {
        return super.equals(other).chain(() => (((left, right) => maybeEquals(left, right, strictEquals)))(this.qudt_Figure$j$figureCaption, other.qudt_Figure$j$figureCaption).mapLeft(propertyValuesUnequal => ({ left: this, right: other, propertyName: "qudt_Figure$j$figureCaption", propertyValuesUnequal, type: "Property" as const }))).chain(() => (((left, right) => maybeEquals(left, right, strictEquals)))(this.qudt_Figure$j$figureLabel, other.qudt_Figure$j$figureLabel).mapLeft(propertyValuesUnequal => ({ left: this, right: other, propertyName: "qudt_Figure$j$figureLabel", propertyValuesUnequal, type: "Property" as const }))).chain(() => (((left, right) => maybeEquals(left, right, strictEquals)))(this.qudt_Figure$j$height, other.qudt_Figure$j$height).mapLeft(propertyValuesUnequal => ({ left: this, right: other, propertyName: "qudt_Figure$j$height", propertyValuesUnequal, type: "Property" as const }))).chain(() => (((left, right) => maybeEquals(left, right, strictEquals)))(this.qudt_Figure$j$image, other.qudt_Figure$j$image).mapLeft(propertyValuesUnequal => ({ left: this, right: other, propertyName: "qudt_Figure$j$image", propertyValuesUnequal, type: "Property" as const }))).chain(() => (strictEquals)(this.qudt_Figure$j$imageLocation, other.qudt_Figure$j$imageLocation).mapLeft(propertyValuesUnequal => ({ left: this, right: other, propertyName: "qudt_Figure$j$imageLocation", propertyValuesUnequal, type: "Property" as const }))).chain(() => (((left, right) => maybeEquals(left, right, strictEquals)))(this.qudt_Figure$j$landscape, other.qudt_Figure$j$landscape).mapLeft(propertyValuesUnequal => ({ left: this, right: other, propertyName: "qudt_Figure$j$landscape", propertyValuesUnequal, type: "Property" as const }))).chain(() => (((left, right) => maybeEquals(left, right, strictEquals)))(this.qudt_Figure$j$width, other.qudt_Figure$j$width).mapLeft(propertyValuesUnequal => ({ left: this, right: other, propertyName: "qudt_Figure$j$width", propertyValuesUnequal, type: "Property" as const })));
    }

    override hash<HasherT extends { update: (message: string | number[] | ArrayBuffer | Uint8Array) => void; }>(_hasher: HasherT): HasherT {
        this.hashShaclProperties(_hasher);
        return _hasher;
    }

    protected override hashShaclProperties<HasherT extends { update: (message: string | number[] | ArrayBuffer | Uint8Array) => void; }>(_hasher: HasherT): HasherT {
        super.hashShaclProperties(_hasher);
        this.qudt_Figure$j$figureCaption.ifJust((_value0) => { _hasher.update(_value0); })
        this.qudt_Figure$j$figureLabel.ifJust((_value0) => { _hasher.update(_value0); })
        this.qudt_Figure$j$height.ifJust((_value0) => { _hasher.update(_value0); })
        this.qudt_Figure$j$image.ifJust((_value0) => { _hasher.update(_value0); })
        _hasher.update(this.qudt_Figure$j$imageLocation);
        this.qudt_Figure$j$landscape.ifJust((_value0) => { _hasher.update(_value0.toString()); })
        this.qudt_Figure$j$width.ifJust((_value0) => { _hasher.update(_value0); })
        return _hasher;
    }

    override toJson(): { readonly "qudt_Figure$j$figureCaption": (string) | undefined; readonly "qudt_Figure$j$figureLabel": (string) | undefined; readonly "qudt_Figure$j$height": (string) | undefined; readonly "qudt_Figure$j$image": (string) | undefined; readonly "qudt_Figure$j$imageLocation": string; readonly "qudt_Figure$j$landscape": (boolean) | undefined; readonly "qudt_Figure$j$width": (string) | undefined } & ReturnType<QUDT_Concept["toJson"]> {
        return JSON.parse(JSON.stringify({ ...super.toJson(),qudt_Figure$j$figureCaption: this.qudt_Figure$j$figureCaption.map(_item => (_item)).extract(),qudt_Figure$j$figureLabel: this.qudt_Figure$j$figureLabel.map(_item => (_item)).extract(),qudt_Figure$j$height: this.qudt_Figure$j$height.map(_item => (_item)).extract(),qudt_Figure$j$image: this.qudt_Figure$j$image.map(_item => (_item)).extract(),qudt_Figure$j$imageLocation: this.qudt_Figure$j$imageLocation,qudt_Figure$j$landscape: this.qudt_Figure$j$landscape.map(_item => (_item)).extract(),qudt_Figure$j$width: this.qudt_Figure$j$width.map(_item => (_item)).extract() } satisfies ReturnType<Figure["toJson"]>));
    }

    override toRdf({ ignoreRdfType, mutateGraph, resourceSet }: { ignoreRdfType?: boolean; mutateGraph?: rdfjsResource.MutableResource.MutateGraph, resourceSet: rdfjsResource.MutableResourceSet }): rdfjsResource.MutableResource {
        const _resource = super.toRdf({ ignoreRdfType: true, mutateGraph, resourceSet });
        if (!ignoreRdfType) { _resource.add(_resource.dataFactory.namedNode("http://www.w3.org/1999/02/22-rdf-syntax-ns#type"), _resource.dataFactory.namedNode("http://qudt.org/schema/qudt/Figure")); }

        _resource.add(dataFactory.namedNode("http://qudt.org/schema/qudt/figureCaption"), this.qudt_Figure$j$figureCaption);
        _resource.add(dataFactory.namedNode("http://qudt.org/schema/qudt/figureLabel"), this.qudt_Figure$j$figureLabel);
        _resource.add(dataFactory.namedNode("http://qudt.org/schema/qudt/height"), this.qudt_Figure$j$height);
        _resource.add(dataFactory.namedNode("http://qudt.org/schema/qudt/image"), this.qudt_Figure$j$image);
        _resource.add(dataFactory.namedNode("http://qudt.org/schema/qudt/imageLocation"), this.qudt_Figure$j$imageLocation);
        _resource.add(dataFactory.namedNode("http://qudt.org/schema/qudt/landscape"), this.qudt_Figure$j$landscape);
        _resource.add(dataFactory.namedNode("http://qudt.org/schema/qudt/width"), this.qudt_Figure$j$width);
        return _resource;
    }

    override toString(): string {
        return JSON.stringify(this.toJson());
    }
}

export namespace Figure {
    export function _propertiesFromJson(_json: unknown): purify.Either<zod.ZodError, { identifier: (rdfjs.BlankNode | rdfjs.NamedNode); qudt_Figure$j$figureCaption: purify.Maybe<string>; qudt_Figure$j$figureLabel: purify.Maybe<string>; qudt_Figure$j$height: purify.Maybe<string>; qudt_Figure$j$image: purify.Maybe<string>; qudt_Figure$j$imageLocation: string; qudt_Figure$j$landscape: purify.Maybe<boolean>; qudt_Figure$j$width: purify.Maybe<string>; } & UnwrapR<ReturnType<typeof QUDT_Concept._propertiesFromJson>>> {
        const _jsonSafeParseResult = figureJsonZodSchema().safeParse(_json);
        if (!_jsonSafeParseResult.success) { return purify.Left(_jsonSafeParseResult.error); }

        const _jsonObject = _jsonSafeParseResult.data;
        const _super0Either = QUDT_Concept._propertiesFromJson(_jsonObject);
        if (_super0Either.isLeft()) { return _super0Either; }

        const _super0 = _super0Either.unsafeCoerce()
        const identifier = (_jsonObject["@id"].startsWith("_:") ? dataFactory.blankNode(_jsonObject["@id"].substring(2)) : dataFactory.namedNode(_jsonObject["@id"]));
        const qudt_Figure$j$figureCaption = purify.Maybe.fromNullable(_jsonObject["qudt_Figure$j$figureCaption"]);
        const qudt_Figure$j$figureLabel = purify.Maybe.fromNullable(_jsonObject["qudt_Figure$j$figureLabel"]);
        const qudt_Figure$j$height = purify.Maybe.fromNullable(_jsonObject["qudt_Figure$j$height"]);
        const qudt_Figure$j$image = purify.Maybe.fromNullable(_jsonObject["qudt_Figure$j$image"]);
        const qudt_Figure$j$imageLocation = _jsonObject["qudt_Figure$j$imageLocation"];
        const qudt_Figure$j$landscape = purify.Maybe.fromNullable(_jsonObject["qudt_Figure$j$landscape"]);
        const qudt_Figure$j$width = purify.Maybe.fromNullable(_jsonObject["qudt_Figure$j$width"]);
        return purify.Either.of({ ..._super0, identifier, qudt_Figure$j$figureCaption, qudt_Figure$j$figureLabel, qudt_Figure$j$height, qudt_Figure$j$image, qudt_Figure$j$imageLocation, qudt_Figure$j$landscape, qudt_Figure$j$width })
    }

    export function fromJson(json: unknown): purify.Either<zod.ZodError, Figure> {
        return Figure._propertiesFromJson(json).map(properties => new Figure(properties));
    }

    export function _propertiesFromRdf({ ignoreRdfType: _ignoreRdfType, languageIn: _languageIn, resource: _resource,
        // @ts-ignore
        ..._context }: { [_index: string]: any; ignoreRdfType?: boolean; languageIn?: readonly string[]; resource: rdfjsResource.Resource; }): purify.Either<rdfjsResource.Resource.ValueError, { identifier: (rdfjs.BlankNode | rdfjs.NamedNode); qudt_Figure$j$figureCaption: purify.Maybe<string>; qudt_Figure$j$figureLabel: purify.Maybe<string>; qudt_Figure$j$height: purify.Maybe<string>; qudt_Figure$j$image: purify.Maybe<string>; qudt_Figure$j$imageLocation: string; qudt_Figure$j$landscape: purify.Maybe<boolean>; qudt_Figure$j$width: purify.Maybe<string>; } & UnwrapR<ReturnType<typeof QUDT_Concept._propertiesFromRdf>>> {
        const _super0Either = QUDT_Concept._propertiesFromRdf({ ..._context, ignoreRdfType: true, languageIn: _languageIn, resource: _resource });
        if (_super0Either.isLeft()) { return _super0Either; }

        const _super0 = _super0Either.unsafeCoerce()
        if (!_ignoreRdfType && !_resource.isInstanceOf(dataFactory.namedNode("http://qudt.org/schema/qudt/Figure"))) { return purify.Left(new rdfjsResource.Resource.ValueError({ focusResource: _resource, message: `${rdfjsResource.Resource.Identifier.toString(_resource.identifier)} has unexpected RDF type (expected http://qudt.org/schema/qudt/Figure)`, predicate: dataFactory.namedNode("http://qudt.org/schema/qudt/Figure") })); }

        const identifier = _resource.identifier
        const _qudt_Figure$j$figureCaptionEither: purify.Either<rdfjsResource.Resource.ValueError, purify.Maybe<string>> = purify.Either.of(_resource.values(dataFactory.namedNode("http://qudt.org/schema/qudt/figureCaption"), { unique: true }).head().chain(_value => _value.toString()).toMaybe());
        if (_qudt_Figure$j$figureCaptionEither.isLeft()) { return _qudt_Figure$j$figureCaptionEither; }

        const qudt_Figure$j$figureCaption = _qudt_Figure$j$figureCaptionEither.unsafeCoerce();
        const _qudt_Figure$j$figureLabelEither: purify.Either<rdfjsResource.Resource.ValueError, purify.Maybe<string>> = purify.Either.of(_resource.values(dataFactory.namedNode("http://qudt.org/schema/qudt/figureLabel"), { unique: true }).head().chain(_value => _value.toString()).toMaybe());
        if (_qudt_Figure$j$figureLabelEither.isLeft()) { return _qudt_Figure$j$figureLabelEither; }

        const qudt_Figure$j$figureLabel = _qudt_Figure$j$figureLabelEither.unsafeCoerce();
        const _qudt_Figure$j$heightEither: purify.Either<rdfjsResource.Resource.ValueError, purify.Maybe<string>> = purify.Either.of(_resource.values(dataFactory.namedNode("http://qudt.org/schema/qudt/height"), { unique: true }).head().chain(_value => _value.toString()).toMaybe());
        if (_qudt_Figure$j$heightEither.isLeft()) { return _qudt_Figure$j$heightEither; }

        const qudt_Figure$j$height = _qudt_Figure$j$heightEither.unsafeCoerce();
        const _qudt_Figure$j$imageEither: purify.Either<rdfjsResource.Resource.ValueError, purify.Maybe<string>> = purify.Either.of(_resource.values(dataFactory.namedNode("http://qudt.org/schema/qudt/image"), { unique: true }).head().chain(_value => _value.toString()).toMaybe());
        if (_qudt_Figure$j$imageEither.isLeft()) { return _qudt_Figure$j$imageEither; }

        const qudt_Figure$j$image = _qudt_Figure$j$imageEither.unsafeCoerce();
        const _qudt_Figure$j$imageLocationEither: purify.Either<rdfjsResource.Resource.ValueError, string> = _resource.values(dataFactory.namedNode("http://qudt.org/schema/qudt/imageLocation"), { unique: true }).head().chain(_value => _value.toString());
        if (_qudt_Figure$j$imageLocationEither.isLeft()) { return _qudt_Figure$j$imageLocationEither; }

        const qudt_Figure$j$imageLocation = _qudt_Figure$j$imageLocationEither.unsafeCoerce();
        const _qudt_Figure$j$landscapeEither: purify.Either<rdfjsResource.Resource.ValueError, purify.Maybe<boolean>> = purify.Either.of(_resource.values(dataFactory.namedNode("http://qudt.org/schema/qudt/landscape"), { unique: true }).head().chain(_value => _value.toBoolean()).toMaybe());
        if (_qudt_Figure$j$landscapeEither.isLeft()) { return _qudt_Figure$j$landscapeEither; }

        const qudt_Figure$j$landscape = _qudt_Figure$j$landscapeEither.unsafeCoerce();
        const _qudt_Figure$j$widthEither: purify.Either<rdfjsResource.Resource.ValueError, purify.Maybe<string>> = purify.Either.of(_resource.values(dataFactory.namedNode("http://qudt.org/schema/qudt/width"), { unique: true }).head().chain(_value => _value.toString()).toMaybe());
        if (_qudt_Figure$j$widthEither.isLeft()) { return _qudt_Figure$j$widthEither; }

        const qudt_Figure$j$width = _qudt_Figure$j$widthEither.unsafeCoerce();
        return purify.Either.of({ ..._super0, identifier, qudt_Figure$j$figureCaption, qudt_Figure$j$figureLabel, qudt_Figure$j$height, qudt_Figure$j$image, qudt_Figure$j$imageLocation, qudt_Figure$j$landscape, qudt_Figure$j$width })
    }

    export function fromRdf(parameters: Parameters<typeof Figure._propertiesFromRdf>[0]): purify.Either<rdfjsResource.Resource.ValueError, Figure> {
        return Figure._propertiesFromRdf(parameters).map(properties => new Figure(properties));
    }

    export let fromRdfType: rdfjs.NamedNode<string> = dataFactory.namedNode("http://qudt.org/schema/qudt/Figure");

    export function jsonSchema() {
        return zodToJsonSchema(figureJsonZodSchema());
    }

    export function figureJsonUiSchema(parameters?: { scopePrefix?: string }) {
        const scopePrefix = parameters?.scopePrefix ?? "#";
        return { "elements": [ QUDT_Concept.qudtConceptJsonUiSchema({ scopePrefix }), { scope: `${scopePrefix}/properties/qudt_Figure$j$figureCaption`, type: "Control" }, { scope: `${scopePrefix}/properties/qudt_Figure$j$figureLabel`, type: "Control" }, { scope: `${scopePrefix}/properties/qudt_Figure$j$height`, type: "Control" }, { scope: `${scopePrefix}/properties/qudt_Figure$j$image`, type: "Control" }, { scope: `${scopePrefix}/properties/qudt_Figure$j$imageLocation`, type: "Control" }, { scope: `${scopePrefix}/properties/qudt_Figure$j$landscape`, type: "Control" }, { scope: `${scopePrefix}/properties/qudt_Figure$j$width`, type: "Control" } ], label: "Figure", type: "Group" }
    }

    export function figureJsonZodSchema() {
        return QUDT_Concept.qudtConceptJsonZodSchema().merge(zod.object({ "@id": zod.string().min(1),"type": zod.literal("Figure"),"qudt_Figure$j$figureCaption": zod.string().optional(),"qudt_Figure$j$figureLabel": zod.string().optional(),"qudt_Figure$j$height": zod.string().optional(),"qudt_Figure$j$image": zod.string().optional(),"qudt_Figure$j$imageLocation": zod.string(),"qudt_Figure$j$landscape": zod.boolean().optional(),"qudt_Figure$j$width": zod.string().optional() }));
    }

    export function sparqlConstructQuery(parameters?: { ignoreRdfType?: boolean; prefixes?: { [prefix: string]: string }; subject?: sparqljs.Triple["subject"]; } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type">): sparqljs.ConstructQuery {
        const { ignoreRdfType, subject, ...queryParameters } = parameters ?? {}

        return { ...queryParameters, prefixes: parameters?.prefixes ?? {}, queryType: "CONSTRUCT", template: (queryParameters.template ?? []).concat(Figure.sparqlConstructTemplateTriples({ ignoreRdfType, subject })), type: "query", where: (queryParameters.where ?? []).concat(Figure.sparqlWherePatterns({ ignoreRdfType, subject })) };
    }

    export function sparqlConstructQueryString(parameters?: { ignoreRdfType?: boolean; subject?: sparqljs.Triple["subject"]; variablePrefix?: string; } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type"> & sparqljs.GeneratorOptions): string {
        return new sparqljs.Generator(parameters).stringify(Figure.sparqlConstructQuery(parameters));
    }

    export function sparqlConstructTemplateTriples(parameters?: { ignoreRdfType?: boolean; subject?: sparqljs.Triple["subject"], variablePrefix?: string }): readonly sparqljs.Triple[] {
        const subject = parameters?.subject ?? dataFactory.variable!("figure");
        const variablePrefix = parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "figure");
        return [...QUDT_Concept.sparqlConstructTemplateTriples({ ignoreRdfType: true, subject, variablePrefix }), ...(parameters?.ignoreRdfType ? [] : [{ subject, predicate: dataFactory.namedNode("http://www.w3.org/1999/02/22-rdf-syntax-ns#type"), object: dataFactory.variable!(`${variablePrefix}RdfType`) }]), { object: dataFactory.variable!(`${variablePrefix}QudtFigureJFigureCaption`), predicate: dataFactory.namedNode("http://qudt.org/schema/qudt/figureCaption"), subject }, { object: dataFactory.variable!(`${variablePrefix}QudtFigureJFigureLabel`), predicate: dataFactory.namedNode("http://qudt.org/schema/qudt/figureLabel"), subject }, { object: dataFactory.variable!(`${variablePrefix}QudtFigureJHeight`), predicate: dataFactory.namedNode("http://qudt.org/schema/qudt/height"), subject }, { object: dataFactory.variable!(`${variablePrefix}QudtFigureJImage`), predicate: dataFactory.namedNode("http://qudt.org/schema/qudt/image"), subject }, { object: dataFactory.variable!(`${variablePrefix}QudtFigureJImageLocation`), predicate: dataFactory.namedNode("http://qudt.org/schema/qudt/imageLocation"), subject }, { object: dataFactory.variable!(`${variablePrefix}QudtFigureJLandscape`), predicate: dataFactory.namedNode("http://qudt.org/schema/qudt/landscape"), subject }, { object: dataFactory.variable!(`${variablePrefix}QudtFigureJWidth`), predicate: dataFactory.namedNode("http://qudt.org/schema/qudt/width"), subject }];
    }

    export function sparqlWherePatterns(parameters: { ignoreRdfType?: boolean; subject?: sparqljs.Triple["subject"], variablePrefix?: string }): readonly sparqljs.Pattern[] {
        const subject = parameters?.subject ?? dataFactory.variable!("figure");
        const variablePrefix = parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "figure");
        return [...QUDT_Concept.sparqlWherePatterns({ ignoreRdfType: true, subject, variablePrefix }), ...(parameters?.ignoreRdfType ? [] : [{ triples: [{ subject, predicate: dataFactory.namedNode("http://www.w3.org/1999/02/22-rdf-syntax-ns#type"), object: dataFactory.namedNode("http://qudt.org/schema/qudt/Figure") }], type: "bgp" as const }, { triples: [{ subject, predicate: dataFactory.namedNode("http://www.w3.org/1999/02/22-rdf-syntax-ns#type"), object: dataFactory.variable!(`${variablePrefix}RdfType`) }], type: "bgp" as const }]), { patterns: [{ triples: [{ object: dataFactory.variable!(`${variablePrefix}QudtFigureJFigureCaption`), predicate: dataFactory.namedNode("http://qudt.org/schema/qudt/figureCaption"), subject }], type: "bgp" }], type: "optional" }, { patterns: [{ triples: [{ object: dataFactory.variable!(`${variablePrefix}QudtFigureJFigureLabel`), predicate: dataFactory.namedNode("http://qudt.org/schema/qudt/figureLabel"), subject }], type: "bgp" }], type: "optional" }, { patterns: [{ triples: [{ object: dataFactory.variable!(`${variablePrefix}QudtFigureJHeight`), predicate: dataFactory.namedNode("http://qudt.org/schema/qudt/height"), subject }], type: "bgp" }], type: "optional" }, { patterns: [{ triples: [{ object: dataFactory.variable!(`${variablePrefix}QudtFigureJImage`), predicate: dataFactory.namedNode("http://qudt.org/schema/qudt/image"), subject }], type: "bgp" }], type: "optional" }, { triples: [{ object: dataFactory.variable!(`${variablePrefix}QudtFigureJImageLocation`), predicate: dataFactory.namedNode("http://qudt.org/schema/qudt/imageLocation"), subject }], type: "bgp" }, { patterns: [{ triples: [{ object: dataFactory.variable!(`${variablePrefix}QudtFigureJLandscape`), predicate: dataFactory.namedNode("http://qudt.org/schema/qudt/landscape"), subject }], type: "bgp" }], type: "optional" }, { patterns: [{ triples: [{ object: dataFactory.variable!(`${variablePrefix}QudtFigureJWidth`), predicate: dataFactory.namedNode("http://qudt.org/schema/qudt/width"), subject }], type: "bgp" }], type: "optional" }];
    }
}
/**
 * Factor Unit
 */
export class Factor_Unit extends QUDT_Concept {
    override readonly type = "Factor_Unit";
    readonly qudt_FactorUnit$j$exponent: purify.Maybe<number>;
    readonly qudt_FactorUnit$j$hasUnit: purify.Maybe<Abstract_Unit>;

    constructor(parameters: { readonly identifier?: (rdfjs.BlankNode | rdfjs.NamedNode) | string, readonly qudt_FactorUnit$j$exponent?: number | purify.Maybe<number>, readonly qudt_FactorUnit$j$hasUnit?: Abstract_Unit | purify.Maybe<Abstract_Unit> } & ConstructorParameters<typeof QUDT_Concept>[0]) {
        super(parameters);
        if (purify.Maybe.isMaybe(parameters.qudt_FactorUnit$j$exponent)) { this.qudt_FactorUnit$j$exponent = parameters.qudt_FactorUnit$j$exponent; } else if (typeof parameters.qudt_FactorUnit$j$exponent === "number") { this.qudt_FactorUnit$j$exponent = purify.Maybe.of(parameters.qudt_FactorUnit$j$exponent); } else if (typeof parameters.qudt_FactorUnit$j$exponent === "undefined") { this.qudt_FactorUnit$j$exponent = purify.Maybe.empty(); } else { this.qudt_FactorUnit$j$exponent =( parameters.qudt_FactorUnit$j$exponent) as never;
         }

        if (purify.Maybe.isMaybe(parameters.qudt_FactorUnit$j$hasUnit)) { this.qudt_FactorUnit$j$hasUnit = parameters.qudt_FactorUnit$j$hasUnit; } else if (typeof parameters.qudt_FactorUnit$j$hasUnit === "object" && parameters.qudt_FactorUnit$j$hasUnit instanceof Abstract_Unit) { this.qudt_FactorUnit$j$hasUnit = purify.Maybe.of(parameters.qudt_FactorUnit$j$hasUnit); } else if (typeof parameters.qudt_FactorUnit$j$hasUnit === "undefined") { this.qudt_FactorUnit$j$hasUnit = purify.Maybe.empty(); } else { this.qudt_FactorUnit$j$hasUnit =( parameters.qudt_FactorUnit$j$hasUnit) as never;
         }
    }

    override get identifier(): (rdfjs.BlankNode | rdfjs.NamedNode) {
        if (typeof this._identifier === "undefined") { this._identifier = dataFactory.blankNode(); } return this._identifier;
    }

    override equals(other: Factor_Unit): EqualsResult {
        return super.equals(other).chain(() => (((left, right) => maybeEquals(left, right, strictEquals)))(this.qudt_FactorUnit$j$exponent, other.qudt_FactorUnit$j$exponent).mapLeft(propertyValuesUnequal => ({ left: this, right: other, propertyName: "qudt_FactorUnit$j$exponent", propertyValuesUnequal, type: "Property" as const }))).chain(() => (((left, right) => maybeEquals(left, right, ((left, right) => left.equals(right)))))(this.qudt_FactorUnit$j$hasUnit, other.qudt_FactorUnit$j$hasUnit).mapLeft(propertyValuesUnequal => ({ left: this, right: other, propertyName: "qudt_FactorUnit$j$hasUnit", propertyValuesUnequal, type: "Property" as const })));
    }

    override hash<HasherT extends { update: (message: string | number[] | ArrayBuffer | Uint8Array) => void; }>(_hasher: HasherT): HasherT {
        this.hashShaclProperties(_hasher);
        return _hasher;
    }

    protected override hashShaclProperties<HasherT extends { update: (message: string | number[] | ArrayBuffer | Uint8Array) => void; }>(_hasher: HasherT): HasherT {
        super.hashShaclProperties(_hasher);
        this.qudt_FactorUnit$j$exponent.ifJust((_value0) => { _hasher.update(_value0.toString()); })
        this.qudt_FactorUnit$j$hasUnit.ifJust((_value0) => { _value0.hash(_hasher); })
        return _hasher;
    }

    override toJson(): { readonly "qudt_FactorUnit$j$exponent": (number) | undefined; readonly "qudt_FactorUnit$j$hasUnit": (ReturnType<Abstract_Unit["toJson"]>) | undefined } & ReturnType<QUDT_Concept["toJson"]> {
        return JSON.parse(JSON.stringify({ ...super.toJson(),qudt_FactorUnit$j$exponent: this.qudt_FactorUnit$j$exponent.map(_item => (_item)).extract(),qudt_FactorUnit$j$hasUnit: this.qudt_FactorUnit$j$hasUnit.map(_item => (_item.toJson())).extract() } satisfies ReturnType<Factor_Unit["toJson"]>));
    }

    override toRdf({ ignoreRdfType, mutateGraph, resourceSet }: { ignoreRdfType?: boolean; mutateGraph?: rdfjsResource.MutableResource.MutateGraph, resourceSet: rdfjsResource.MutableResourceSet }): rdfjsResource.MutableResource {
        const _resource = super.toRdf({ ignoreRdfType: true, mutateGraph, resourceSet });
        if (!ignoreRdfType) { _resource.add(_resource.dataFactory.namedNode("http://www.w3.org/1999/02/22-rdf-syntax-ns#type"), _resource.dataFactory.namedNode("http://qudt.org/schema/qudt/FactorUnit")); }

        _resource.add(dataFactory.namedNode("http://qudt.org/schema/qudt/exponent"), this.qudt_FactorUnit$j$exponent);
        _resource.add(dataFactory.namedNode("http://qudt.org/schema/qudt/hasUnit"), this.qudt_FactorUnit$j$hasUnit.map((_value) => _value.toRdf({ mutateGraph: mutateGraph, resourceSet: resourceSet })));
        return _resource;
    }

    override toString(): string {
        return JSON.stringify(this.toJson());
    }
}

export namespace Factor_Unit {
    export function _propertiesFromJson(_json: unknown): purify.Either<zod.ZodError, { identifier: (rdfjs.BlankNode | rdfjs.NamedNode); qudt_FactorUnit$j$exponent: purify.Maybe<number>; qudt_FactorUnit$j$hasUnit: purify.Maybe<Abstract_Unit>; } & UnwrapR<ReturnType<typeof QUDT_Concept._propertiesFromJson>>> {
        const _jsonSafeParseResult = factorUnitJsonZodSchema().safeParse(_json);
        if (!_jsonSafeParseResult.success) { return purify.Left(_jsonSafeParseResult.error); }

        const _jsonObject = _jsonSafeParseResult.data;
        const _super0Either = QUDT_Concept._propertiesFromJson(_jsonObject);
        if (_super0Either.isLeft()) { return _super0Either; }

        const _super0 = _super0Either.unsafeCoerce()
        const identifier = (_jsonObject["@id"].startsWith("_:") ? dataFactory.blankNode(_jsonObject["@id"].substring(2)) : dataFactory.namedNode(_jsonObject["@id"]));
        const qudt_FactorUnit$j$exponent = purify.Maybe.fromNullable(_jsonObject["qudt_FactorUnit$j$exponent"]);
        const qudt_FactorUnit$j$hasUnit = purify.Maybe.fromNullable(_jsonObject["qudt_FactorUnit$j$hasUnit"]).map(_item => (Abstract_Unit.fromJson(_item).unsafeCoerce()));
        return purify.Either.of({ ..._super0, identifier, qudt_FactorUnit$j$exponent, qudt_FactorUnit$j$hasUnit })
    }

    export function fromJson(json: unknown): purify.Either<zod.ZodError, Factor_Unit> {
        return Factor_Unit._propertiesFromJson(json).map(properties => new Factor_Unit(properties));
    }

    export function _propertiesFromRdf({ ignoreRdfType: _ignoreRdfType, languageIn: _languageIn, resource: _resource,
        // @ts-ignore
        ..._context }: { [_index: string]: any; ignoreRdfType?: boolean; languageIn?: readonly string[]; resource: rdfjsResource.Resource; }): purify.Either<rdfjsResource.Resource.ValueError, { identifier: (rdfjs.BlankNode | rdfjs.NamedNode); qudt_FactorUnit$j$exponent: purify.Maybe<number>; qudt_FactorUnit$j$hasUnit: purify.Maybe<Abstract_Unit>; } & UnwrapR<ReturnType<typeof QUDT_Concept._propertiesFromRdf>>> {
        const _super0Either = QUDT_Concept._propertiesFromRdf({ ..._context, ignoreRdfType: true, languageIn: _languageIn, resource: _resource });
        if (_super0Either.isLeft()) { return _super0Either; }

        const _super0 = _super0Either.unsafeCoerce()
        if (!_ignoreRdfType && !_resource.isInstanceOf(dataFactory.namedNode("http://qudt.org/schema/qudt/FactorUnit"))) { return purify.Left(new rdfjsResource.Resource.ValueError({ focusResource: _resource, message: `${rdfjsResource.Resource.Identifier.toString(_resource.identifier)} has unexpected RDF type (expected http://qudt.org/schema/qudt/FactorUnit)`, predicate: dataFactory.namedNode("http://qudt.org/schema/qudt/FactorUnit") })); }

        const identifier = _resource.identifier
        const _qudt_FactorUnit$j$exponentEither: purify.Either<rdfjsResource.Resource.ValueError, purify.Maybe<number>> = purify.Either.of(_resource.values(dataFactory.namedNode("http://qudt.org/schema/qudt/exponent"), { unique: true }).head().chain(_value => _value.toNumber()).toMaybe());
        if (_qudt_FactorUnit$j$exponentEither.isLeft()) { return _qudt_FactorUnit$j$exponentEither; }

        const qudt_FactorUnit$j$exponent = _qudt_FactorUnit$j$exponentEither.unsafeCoerce();
        const _qudt_FactorUnit$j$hasUnitEither: purify.Either<rdfjsResource.Resource.ValueError, purify.Maybe<Abstract_Unit>> = purify.Either.of(_resource.values(dataFactory.namedNode("http://qudt.org/schema/qudt/hasUnit"), { unique: true }).head().chain(value => value.toResource()).chain(_resource => Abstract_Unit.fromRdf({ ..._context, ignoreRdfType: true, languageIn: _languageIn, resource: _resource })).toMaybe());
        if (_qudt_FactorUnit$j$hasUnitEither.isLeft()) { return _qudt_FactorUnit$j$hasUnitEither; }

        const qudt_FactorUnit$j$hasUnit = _qudt_FactorUnit$j$hasUnitEither.unsafeCoerce();
        return purify.Either.of({ ..._super0, identifier, qudt_FactorUnit$j$exponent, qudt_FactorUnit$j$hasUnit })
    }

    export function fromRdf(parameters: Parameters<typeof Factor_Unit._propertiesFromRdf>[0]): purify.Either<rdfjsResource.Resource.ValueError, Factor_Unit> {
        return Factor_Unit._propertiesFromRdf(parameters).map(properties => new Factor_Unit(properties));
    }

    export let fromRdfType: rdfjs.NamedNode<string> = dataFactory.namedNode("http://qudt.org/schema/qudt/FactorUnit");

    export function jsonSchema() {
        return zodToJsonSchema(factorUnitJsonZodSchema());
    }

    export function factorUnitJsonUiSchema(parameters?: { scopePrefix?: string }) {
        const scopePrefix = parameters?.scopePrefix ?? "#";
        return { "elements": [ QUDT_Concept.qudtConceptJsonUiSchema({ scopePrefix }), { scope: `${scopePrefix}/properties/qudt_FactorUnit$j$exponent`, type: "Control" }, Abstract_Unit.abstractUnitJsonUiSchema({ scopePrefix: `${scopePrefix}/properties/qudt_FactorUnit$j$hasUnit` }) ], label: "Factor Unit", type: "Group" }
    }

    export function factorUnitJsonZodSchema() {
        return QUDT_Concept.qudtConceptJsonZodSchema().merge(zod.object({ "@id": zod.string().min(1),"type": zod.literal("Factor_Unit"),"qudt_FactorUnit$j$exponent": zod.number().optional(),"qudt_FactorUnit$j$hasUnit": Abstract_Unit.abstractUnitJsonZodSchema().optional() }));
    }

    export function sparqlConstructQuery(parameters?: { ignoreRdfType?: boolean; prefixes?: { [prefix: string]: string }; subject?: sparqljs.Triple["subject"]; } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type">): sparqljs.ConstructQuery {
        const { ignoreRdfType, subject, ...queryParameters } = parameters ?? {}

        return { ...queryParameters, prefixes: parameters?.prefixes ?? {}, queryType: "CONSTRUCT", template: (queryParameters.template ?? []).concat(Factor_Unit.sparqlConstructTemplateTriples({ ignoreRdfType, subject })), type: "query", where: (queryParameters.where ?? []).concat(Factor_Unit.sparqlWherePatterns({ ignoreRdfType, subject })) };
    }

    export function sparqlConstructQueryString(parameters?: { ignoreRdfType?: boolean; subject?: sparqljs.Triple["subject"]; variablePrefix?: string; } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type"> & sparqljs.GeneratorOptions): string {
        return new sparqljs.Generator(parameters).stringify(Factor_Unit.sparqlConstructQuery(parameters));
    }

    export function sparqlConstructTemplateTriples(parameters?: { ignoreRdfType?: boolean; subject?: sparqljs.Triple["subject"], variablePrefix?: string }): readonly sparqljs.Triple[] {
        const subject = parameters?.subject ?? dataFactory.variable!("factorUnit");
        const variablePrefix = parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "factorUnit");
        return [...QUDT_Concept.sparqlConstructTemplateTriples({ ignoreRdfType: true, subject, variablePrefix }), ...(parameters?.ignoreRdfType ? [] : [{ subject, predicate: dataFactory.namedNode("http://www.w3.org/1999/02/22-rdf-syntax-ns#type"), object: dataFactory.variable!(`${variablePrefix}RdfType`) }]), { object: dataFactory.variable!(`${variablePrefix}QudtFactorUnitJExponent`), predicate: dataFactory.namedNode("http://qudt.org/schema/qudt/exponent"), subject }, { object: dataFactory.variable!(`${variablePrefix}QudtFactorUnitJHasUnit`), predicate: dataFactory.namedNode("http://qudt.org/schema/qudt/hasUnit"), subject }, ...Abstract_Unit.sparqlConstructTemplateTriples({ ignoreRdfType: true, subject: dataFactory.variable!(`${variablePrefix}QudtFactorUnitJHasUnit`), variablePrefix: `${variablePrefix}QudtFactorUnitJHasUnit` })];
    }

    export function sparqlWherePatterns(parameters: { ignoreRdfType?: boolean; subject?: sparqljs.Triple["subject"], variablePrefix?: string }): readonly sparqljs.Pattern[] {
        const subject = parameters?.subject ?? dataFactory.variable!("factorUnit");
        const variablePrefix = parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "factorUnit");
        return [...QUDT_Concept.sparqlWherePatterns({ ignoreRdfType: true, subject, variablePrefix }), ...(parameters?.ignoreRdfType ? [] : [{ triples: [{ subject, predicate: dataFactory.namedNode("http://www.w3.org/1999/02/22-rdf-syntax-ns#type"), object: dataFactory.namedNode("http://qudt.org/schema/qudt/FactorUnit") }], type: "bgp" as const }, { triples: [{ subject, predicate: dataFactory.namedNode("http://www.w3.org/1999/02/22-rdf-syntax-ns#type"), object: dataFactory.variable!(`${variablePrefix}RdfType`) }], type: "bgp" as const }]), { patterns: [{ triples: [{ object: dataFactory.variable!(`${variablePrefix}QudtFactorUnitJExponent`), predicate: dataFactory.namedNode("http://qudt.org/schema/qudt/exponent"), subject }], type: "bgp" }], type: "optional" }, { patterns: [{ triples: [{ object: dataFactory.variable!(`${variablePrefix}QudtFactorUnitJHasUnit`), predicate: dataFactory.namedNode("http://qudt.org/schema/qudt/hasUnit"), subject }], type: "bgp" }, ...Abstract_Unit.sparqlWherePatterns({ ignoreRdfType: true, subject: dataFactory.variable!(`${variablePrefix}QudtFactorUnitJHasUnit`), variablePrefix: `${variablePrefix}QudtFactorUnitJHasUnit` })], type: "optional" }];
    }
}
/**
 * Enumeration
 */
export class Enumeration extends QUDT_Concept {
    override readonly type = "Enumeration";
    readonly qudt_Enumeration$j$abbreviation: purify.Maybe<string>;
    readonly qudt_Enumeration$j$default: purify.Maybe<Enumerated_Value>;
    readonly qudt_Enumeration$j$element: purify.NonEmptyList<Enumerated_Value>;

    constructor(parameters: { readonly identifier?: (rdfjs.BlankNode | rdfjs.NamedNode) | string, readonly qudt_Enumeration$j$abbreviation?: purify.Maybe<string> | string, readonly qudt_Enumeration$j$default?: Enumerated_Value | purify.Maybe<Enumerated_Value>, readonly qudt_Enumeration$j$element: purify.NonEmptyList<Enumerated_Value> } & ConstructorParameters<typeof QUDT_Concept>[0]) {
        super(parameters);
        if (purify.Maybe.isMaybe(parameters.qudt_Enumeration$j$abbreviation)) { this.qudt_Enumeration$j$abbreviation = parameters.qudt_Enumeration$j$abbreviation; } else if (typeof parameters.qudt_Enumeration$j$abbreviation === "string") { this.qudt_Enumeration$j$abbreviation = purify.Maybe.of(parameters.qudt_Enumeration$j$abbreviation); } else if (typeof parameters.qudt_Enumeration$j$abbreviation === "undefined") { this.qudt_Enumeration$j$abbreviation = purify.Maybe.empty(); } else { this.qudt_Enumeration$j$abbreviation =( parameters.qudt_Enumeration$j$abbreviation) as never;
         }

        if (purify.Maybe.isMaybe(parameters.qudt_Enumeration$j$default)) { this.qudt_Enumeration$j$default = parameters.qudt_Enumeration$j$default; } else if (typeof parameters.qudt_Enumeration$j$default === "object" && parameters.qudt_Enumeration$j$default instanceof Enumerated_Value) { this.qudt_Enumeration$j$default = purify.Maybe.of(parameters.qudt_Enumeration$j$default); } else if (typeof parameters.qudt_Enumeration$j$default === "undefined") { this.qudt_Enumeration$j$default = purify.Maybe.empty(); } else { this.qudt_Enumeration$j$default =( parameters.qudt_Enumeration$j$default) as never;
         }

        this.qudt_Enumeration$j$element = parameters.qudt_Enumeration$j$element;
    }

    override get identifier(): (rdfjs.BlankNode | rdfjs.NamedNode) {
        if (typeof this._identifier === "undefined") { this._identifier = dataFactory.blankNode(); } return this._identifier;
    }

    override equals(other: Enumeration): EqualsResult {
        return super.equals(other).chain(() => (((left, right) => maybeEquals(left, right, strictEquals)))(this.qudt_Enumeration$j$abbreviation, other.qudt_Enumeration$j$abbreviation).mapLeft(propertyValuesUnequal => ({ left: this, right: other, propertyName: "qudt_Enumeration$j$abbreviation", propertyValuesUnequal, type: "Property" as const }))).chain(() => (((left, right) => maybeEquals(left, right, ((left, right) => left.equals(right)))))(this.qudt_Enumeration$j$default, other.qudt_Enumeration$j$default).mapLeft(propertyValuesUnequal => ({ left: this, right: other, propertyName: "qudt_Enumeration$j$default", propertyValuesUnequal, type: "Property" as const }))).chain(() => (((left, right) => arrayEquals(left, right, ((left, right) => left.equals(right)))))(this.qudt_Enumeration$j$element, other.qudt_Enumeration$j$element).mapLeft(propertyValuesUnequal => ({ left: this, right: other, propertyName: "qudt_Enumeration$j$element", propertyValuesUnequal, type: "Property" as const })));
    }

    override hash<HasherT extends { update: (message: string | number[] | ArrayBuffer | Uint8Array) => void; }>(_hasher: HasherT): HasherT {
        this.hashShaclProperties(_hasher);
        return _hasher;
    }

    protected override hashShaclProperties<HasherT extends { update: (message: string | number[] | ArrayBuffer | Uint8Array) => void; }>(_hasher: HasherT): HasherT {
        super.hashShaclProperties(_hasher);
        this.qudt_Enumeration$j$abbreviation.ifJust((_value0) => { _hasher.update(_value0); })
        this.qudt_Enumeration$j$default.ifJust((_value0) => { _value0.hash(_hasher); })
        for (const _item0 of this.qudt_Enumeration$j$element) { _item0.hash(_hasher); }

        return _hasher;
    }

    override toJson(): { readonly "qudt_Enumeration$j$abbreviation": (string) | undefined; readonly "qudt_Enumeration$j$default": (ReturnType<Enumerated_Value["toJson"]>) | undefined; readonly "qudt_Enumeration$j$element": readonly (ReturnType<Enumerated_Value["toJson"]>)[] } & ReturnType<QUDT_Concept["toJson"]> {
        return JSON.parse(JSON.stringify({ ...super.toJson(),qudt_Enumeration$j$abbreviation: this.qudt_Enumeration$j$abbreviation.map(_item => (_item)).extract(),qudt_Enumeration$j$default: this.qudt_Enumeration$j$default.map(_item => (_item.toJson())).extract(),qudt_Enumeration$j$element: this.qudt_Enumeration$j$element.map(_item => (_item.toJson())) } satisfies ReturnType<Enumeration["toJson"]>));
    }

    override toRdf({ ignoreRdfType, mutateGraph, resourceSet }: { ignoreRdfType?: boolean; mutateGraph?: rdfjsResource.MutableResource.MutateGraph, resourceSet: rdfjsResource.MutableResourceSet }): rdfjsResource.MutableResource {
        const _resource = super.toRdf({ ignoreRdfType: true, mutateGraph, resourceSet });
        if (!ignoreRdfType) { _resource.add(_resource.dataFactory.namedNode("http://www.w3.org/1999/02/22-rdf-syntax-ns#type"), _resource.dataFactory.namedNode("http://qudt.org/schema/qudt/Enumeration")); }

        _resource.add(dataFactory.namedNode("http://qudt.org/schema/qudt/abbreviation"), this.qudt_Enumeration$j$abbreviation);
        _resource.add(dataFactory.namedNode("http://qudt.org/schema/qudt/default"), this.qudt_Enumeration$j$default.map((_value) => _value.toRdf({ mutateGraph: mutateGraph, resourceSet: resourceSet })));
        _resource.add(dataFactory.namedNode("http://qudt.org/schema/qudt/element"), this.qudt_Enumeration$j$element.map((_item) => _item.toRdf({ mutateGraph: mutateGraph, resourceSet: resourceSet })));
        return _resource;
    }

    override toString(): string {
        return JSON.stringify(this.toJson());
    }
}

export namespace Enumeration {
    export function _propertiesFromJson(_json: unknown): purify.Either<zod.ZodError, { identifier: (rdfjs.BlankNode | rdfjs.NamedNode); qudt_Enumeration$j$abbreviation: purify.Maybe<string>; qudt_Enumeration$j$default: purify.Maybe<Enumerated_Value>; qudt_Enumeration$j$element: purify.NonEmptyList<Enumerated_Value>; } & UnwrapR<ReturnType<typeof QUDT_Concept._propertiesFromJson>>> {
        const _jsonSafeParseResult = enumerationJsonZodSchema().safeParse(_json);
        if (!_jsonSafeParseResult.success) { return purify.Left(_jsonSafeParseResult.error); }

        const _jsonObject = _jsonSafeParseResult.data;
        const _super0Either = QUDT_Concept._propertiesFromJson(_jsonObject);
        if (_super0Either.isLeft()) { return _super0Either; }

        const _super0 = _super0Either.unsafeCoerce()
        const identifier = (_jsonObject["@id"].startsWith("_:") ? dataFactory.blankNode(_jsonObject["@id"].substring(2)) : dataFactory.namedNode(_jsonObject["@id"]));
        const qudt_Enumeration$j$abbreviation = purify.Maybe.fromNullable(_jsonObject["qudt_Enumeration$j$abbreviation"]);
        const qudt_Enumeration$j$default = purify.Maybe.fromNullable(_jsonObject["qudt_Enumeration$j$default"]).map(_item => (Enumerated_Value.fromJson(_item).unsafeCoerce()));
        const qudt_Enumeration$j$element = purify.NonEmptyList.fromArray(_jsonObject["qudt_Enumeration$j$element"]).unsafeCoerce().map(_item => (Enumerated_Value.fromJson(_item).unsafeCoerce()));
        return purify.Either.of({ ..._super0, identifier, qudt_Enumeration$j$abbreviation, qudt_Enumeration$j$default, qudt_Enumeration$j$element })
    }

    export function fromJson(json: unknown): purify.Either<zod.ZodError, Enumeration> {
        return Enumeration._propertiesFromJson(json).map(properties => new Enumeration(properties));
    }

    export function _propertiesFromRdf({ ignoreRdfType: _ignoreRdfType, languageIn: _languageIn, resource: _resource,
        // @ts-ignore
        ..._context }: { [_index: string]: any; ignoreRdfType?: boolean; languageIn?: readonly string[]; resource: rdfjsResource.Resource; }): purify.Either<rdfjsResource.Resource.ValueError, { identifier: (rdfjs.BlankNode | rdfjs.NamedNode); qudt_Enumeration$j$abbreviation: purify.Maybe<string>; qudt_Enumeration$j$default: purify.Maybe<Enumerated_Value>; qudt_Enumeration$j$element: purify.NonEmptyList<Enumerated_Value>; } & UnwrapR<ReturnType<typeof QUDT_Concept._propertiesFromRdf>>> {
        const _super0Either = QUDT_Concept._propertiesFromRdf({ ..._context, ignoreRdfType: true, languageIn: _languageIn, resource: _resource });
        if (_super0Either.isLeft()) { return _super0Either; }

        const _super0 = _super0Either.unsafeCoerce()
        if (!_ignoreRdfType && !_resource.isInstanceOf(dataFactory.namedNode("http://qudt.org/schema/qudt/Enumeration"))) { return purify.Left(new rdfjsResource.Resource.ValueError({ focusResource: _resource, message: `${rdfjsResource.Resource.Identifier.toString(_resource.identifier)} has unexpected RDF type (expected http://qudt.org/schema/qudt/Enumeration)`, predicate: dataFactory.namedNode("http://qudt.org/schema/qudt/Enumeration") })); }

        const identifier = _resource.identifier
        const _qudt_Enumeration$j$abbreviationEither: purify.Either<rdfjsResource.Resource.ValueError, purify.Maybe<string>> = purify.Either.of(_resource.values(dataFactory.namedNode("http://qudt.org/schema/qudt/abbreviation"), { unique: true }).head().chain(_value => _value.toString()).toMaybe());
        if (_qudt_Enumeration$j$abbreviationEither.isLeft()) { return _qudt_Enumeration$j$abbreviationEither; }

        const qudt_Enumeration$j$abbreviation = _qudt_Enumeration$j$abbreviationEither.unsafeCoerce();
        const _qudt_Enumeration$j$defaultEither: purify.Either<rdfjsResource.Resource.ValueError, purify.Maybe<Enumerated_Value>> = purify.Either.of(_resource.values(dataFactory.namedNode("http://qudt.org/schema/qudt/default"), { unique: true }).head().chain(value => value.toResource()).chain(_resource => Enumerated_Value.fromRdf({ ..._context, ignoreRdfType: true, languageIn: _languageIn, resource: _resource })).toMaybe());
        if (_qudt_Enumeration$j$defaultEither.isLeft()) { return _qudt_Enumeration$j$defaultEither; }

        const qudt_Enumeration$j$default = _qudt_Enumeration$j$defaultEither.unsafeCoerce();
        const _qudt_Enumeration$j$elementEither: purify.Either<rdfjsResource.Resource.ValueError, purify.NonEmptyList<Enumerated_Value>> = purify.NonEmptyList.fromArray([..._resource.values(dataFactory.namedNode("http://qudt.org/schema/qudt/element"), { unique: true }).flatMap(_item => _item.toValues().head().chain(value => value.toResource()).chain(_resource => Enumerated_Value.fromRdf({ ..._context, ignoreRdfType: true, languageIn: _languageIn, resource: _resource })).toMaybe().toList())]).toEither(new rdfjsResource.Resource.ValueError({ focusResource: _resource, message: `${rdfjsResource.Resource.Identifier.toString(_resource.identifier)} is empty`, predicate: dataFactory.namedNode("http://qudt.org/schema/qudt/element") }));
        if (_qudt_Enumeration$j$elementEither.isLeft()) { return _qudt_Enumeration$j$elementEither; }

        const qudt_Enumeration$j$element = _qudt_Enumeration$j$elementEither.unsafeCoerce();
        return purify.Either.of({ ..._super0, identifier, qudt_Enumeration$j$abbreviation, qudt_Enumeration$j$default, qudt_Enumeration$j$element })
    }

    export function fromRdf(parameters: Parameters<typeof Enumeration._propertiesFromRdf>[0]): purify.Either<rdfjsResource.Resource.ValueError, Enumeration> {
        return Enumeration._propertiesFromRdf(parameters).map(properties => new Enumeration(properties));
    }

    export let fromRdfType: rdfjs.NamedNode<string> = dataFactory.namedNode("http://qudt.org/schema/qudt/Enumeration");

    export function jsonSchema() {
        return zodToJsonSchema(enumerationJsonZodSchema());
    }

    export function enumerationJsonUiSchema(parameters?: { scopePrefix?: string }) {
        const scopePrefix = parameters?.scopePrefix ?? "#";
        return { "elements": [ QUDT_Concept.qudtConceptJsonUiSchema({ scopePrefix }), { scope: `${scopePrefix}/properties/qudt_Enumeration$j$abbreviation`, type: "Control" }, Enumerated_Value.enumeratedValueJsonUiSchema({ scopePrefix: `${scopePrefix}/properties/qudt_Enumeration$j$default` }), Enumerated_Value.enumeratedValueJsonUiSchema({ scopePrefix: `${scopePrefix}/properties/qudt_Enumeration$j$element` }) ], label: "Enumeration", type: "Group" }
    }

    export function enumerationJsonZodSchema() {
        return QUDT_Concept.qudtConceptJsonZodSchema().merge(zod.object({ "@id": zod.string().min(1),"type": zod.literal("Enumeration"),"qudt_Enumeration$j$abbreviation": zod.string().optional(),"qudt_Enumeration$j$default": Enumerated_Value.enumeratedValueJsonZodSchema().optional(),"qudt_Enumeration$j$element": Enumerated_Value.enumeratedValueJsonZodSchema().array().nonempty().min(1) }));
    }

    export function sparqlConstructQuery(parameters?: { ignoreRdfType?: boolean; prefixes?: { [prefix: string]: string }; subject?: sparqljs.Triple["subject"]; } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type">): sparqljs.ConstructQuery {
        const { ignoreRdfType, subject, ...queryParameters } = parameters ?? {}

        return { ...queryParameters, prefixes: parameters?.prefixes ?? {}, queryType: "CONSTRUCT", template: (queryParameters.template ?? []).concat(Enumeration.sparqlConstructTemplateTriples({ ignoreRdfType, subject })), type: "query", where: (queryParameters.where ?? []).concat(Enumeration.sparqlWherePatterns({ ignoreRdfType, subject })) };
    }

    export function sparqlConstructQueryString(parameters?: { ignoreRdfType?: boolean; subject?: sparqljs.Triple["subject"]; variablePrefix?: string; } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type"> & sparqljs.GeneratorOptions): string {
        return new sparqljs.Generator(parameters).stringify(Enumeration.sparqlConstructQuery(parameters));
    }

    export function sparqlConstructTemplateTriples(parameters?: { ignoreRdfType?: boolean; subject?: sparqljs.Triple["subject"], variablePrefix?: string }): readonly sparqljs.Triple[] {
        const subject = parameters?.subject ?? dataFactory.variable!("enumeration");
        const variablePrefix = parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "enumeration");
        return [...QUDT_Concept.sparqlConstructTemplateTriples({ ignoreRdfType: true, subject, variablePrefix }), ...(parameters?.ignoreRdfType ? [] : [{ subject, predicate: dataFactory.namedNode("http://www.w3.org/1999/02/22-rdf-syntax-ns#type"), object: dataFactory.variable!(`${variablePrefix}RdfType`) }]), { object: dataFactory.variable!(`${variablePrefix}QudtEnumerationJAbbreviation`), predicate: dataFactory.namedNode("http://qudt.org/schema/qudt/abbreviation"), subject }, { object: dataFactory.variable!(`${variablePrefix}QudtEnumerationJDefault`), predicate: dataFactory.namedNode("http://qudt.org/schema/qudt/default"), subject }, ...Enumerated_Value.sparqlConstructTemplateTriples({ ignoreRdfType: true, subject: dataFactory.variable!(`${variablePrefix}QudtEnumerationJDefault`), variablePrefix: `${variablePrefix}QudtEnumerationJDefault` }), { object: dataFactory.variable!(`${variablePrefix}QudtEnumerationJElement`), predicate: dataFactory.namedNode("http://qudt.org/schema/qudt/element"), subject }, ...Enumerated_Value.sparqlConstructTemplateTriples({ ignoreRdfType: true, subject: dataFactory.variable!(`${variablePrefix}QudtEnumerationJElement`), variablePrefix: `${variablePrefix}QudtEnumerationJElement` })];
    }

    export function sparqlWherePatterns(parameters: { ignoreRdfType?: boolean; subject?: sparqljs.Triple["subject"], variablePrefix?: string }): readonly sparqljs.Pattern[] {
        const subject = parameters?.subject ?? dataFactory.variable!("enumeration");
        const variablePrefix = parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "enumeration");
        return [...QUDT_Concept.sparqlWherePatterns({ ignoreRdfType: true, subject, variablePrefix }), ...(parameters?.ignoreRdfType ? [] : [{ triples: [{ subject, predicate: dataFactory.namedNode("http://www.w3.org/1999/02/22-rdf-syntax-ns#type"), object: dataFactory.namedNode("http://qudt.org/schema/qudt/Enumeration") }], type: "bgp" as const }, { triples: [{ subject, predicate: dataFactory.namedNode("http://www.w3.org/1999/02/22-rdf-syntax-ns#type"), object: dataFactory.variable!(`${variablePrefix}RdfType`) }], type: "bgp" as const }]), { patterns: [{ triples: [{ object: dataFactory.variable!(`${variablePrefix}QudtEnumerationJAbbreviation`), predicate: dataFactory.namedNode("http://qudt.org/schema/qudt/abbreviation"), subject }], type: "bgp" }], type: "optional" }, { patterns: [{ triples: [{ object: dataFactory.variable!(`${variablePrefix}QudtEnumerationJDefault`), predicate: dataFactory.namedNode("http://qudt.org/schema/qudt/default"), subject }], type: "bgp" }, ...Enumerated_Value.sparqlWherePatterns({ ignoreRdfType: true, subject: dataFactory.variable!(`${variablePrefix}QudtEnumerationJDefault`), variablePrefix: `${variablePrefix}QudtEnumerationJDefault` })], type: "optional" }, { triples: [{ object: dataFactory.variable!(`${variablePrefix}QudtEnumerationJElement`), predicate: dataFactory.namedNode("http://qudt.org/schema/qudt/element"), subject }], type: "bgp" }, ...Enumerated_Value.sparqlWherePatterns({ ignoreRdfType: true, subject: dataFactory.variable!(`${variablePrefix}QudtEnumerationJElement`), variablePrefix: `${variablePrefix}QudtEnumerationJElement` })];
    }
}
/**
 * Enumerated Quantity
 */
export class Enumerated_Quantity extends QUDT_Concept {
    override readonly type = "Enumerated_Quantity";
    readonly qudt_EnumeratedQuantity$j$enumeratedValue: purify.Maybe<Enumerated_Value>;
    readonly qudt_EnumeratedQuantity$j$enumeration: purify.Maybe<Enumeration>;

    constructor(parameters: { readonly identifier?: (rdfjs.BlankNode | rdfjs.NamedNode) | string, readonly qudt_EnumeratedQuantity$j$enumeratedValue?: Enumerated_Value | purify.Maybe<Enumerated_Value>, readonly qudt_EnumeratedQuantity$j$enumeration?: Enumeration | purify.Maybe<Enumeration> } & ConstructorParameters<typeof QUDT_Concept>[0]) {
        super(parameters);
        if (purify.Maybe.isMaybe(parameters.qudt_EnumeratedQuantity$j$enumeratedValue)) { this.qudt_EnumeratedQuantity$j$enumeratedValue = parameters.qudt_EnumeratedQuantity$j$enumeratedValue; } else if (typeof parameters.qudt_EnumeratedQuantity$j$enumeratedValue === "object" && parameters.qudt_EnumeratedQuantity$j$enumeratedValue instanceof Enumerated_Value) { this.qudt_EnumeratedQuantity$j$enumeratedValue = purify.Maybe.of(parameters.qudt_EnumeratedQuantity$j$enumeratedValue); } else if (typeof parameters.qudt_EnumeratedQuantity$j$enumeratedValue === "undefined") { this.qudt_EnumeratedQuantity$j$enumeratedValue = purify.Maybe.empty(); } else { this.qudt_EnumeratedQuantity$j$enumeratedValue =( parameters.qudt_EnumeratedQuantity$j$enumeratedValue) as never;
         }

        if (purify.Maybe.isMaybe(parameters.qudt_EnumeratedQuantity$j$enumeration)) { this.qudt_EnumeratedQuantity$j$enumeration = parameters.qudt_EnumeratedQuantity$j$enumeration; } else if (typeof parameters.qudt_EnumeratedQuantity$j$enumeration === "object" && parameters.qudt_EnumeratedQuantity$j$enumeration instanceof Enumeration) { this.qudt_EnumeratedQuantity$j$enumeration = purify.Maybe.of(parameters.qudt_EnumeratedQuantity$j$enumeration); } else if (typeof parameters.qudt_EnumeratedQuantity$j$enumeration === "undefined") { this.qudt_EnumeratedQuantity$j$enumeration = purify.Maybe.empty(); } else { this.qudt_EnumeratedQuantity$j$enumeration =( parameters.qudt_EnumeratedQuantity$j$enumeration) as never;
         }
    }

    override get identifier(): (rdfjs.BlankNode | rdfjs.NamedNode) {
        if (typeof this._identifier === "undefined") { this._identifier = dataFactory.blankNode(); } return this._identifier;
    }

    override equals(other: Enumerated_Quantity): EqualsResult {
        return super.equals(other).chain(() => (((left, right) => maybeEquals(left, right, ((left, right) => left.equals(right)))))(this.qudt_EnumeratedQuantity$j$enumeratedValue, other.qudt_EnumeratedQuantity$j$enumeratedValue).mapLeft(propertyValuesUnequal => ({ left: this, right: other, propertyName: "qudt_EnumeratedQuantity$j$enumeratedValue", propertyValuesUnequal, type: "Property" as const }))).chain(() => (((left, right) => maybeEquals(left, right, ((left, right) => left.equals(right)))))(this.qudt_EnumeratedQuantity$j$enumeration, other.qudt_EnumeratedQuantity$j$enumeration).mapLeft(propertyValuesUnequal => ({ left: this, right: other, propertyName: "qudt_EnumeratedQuantity$j$enumeration", propertyValuesUnequal, type: "Property" as const })));
    }

    override hash<HasherT extends { update: (message: string | number[] | ArrayBuffer | Uint8Array) => void; }>(_hasher: HasherT): HasherT {
        this.hashShaclProperties(_hasher);
        return _hasher;
    }

    protected override hashShaclProperties<HasherT extends { update: (message: string | number[] | ArrayBuffer | Uint8Array) => void; }>(_hasher: HasherT): HasherT {
        super.hashShaclProperties(_hasher);
        this.qudt_EnumeratedQuantity$j$enumeratedValue.ifJust((_value0) => { _value0.hash(_hasher); })
        this.qudt_EnumeratedQuantity$j$enumeration.ifJust((_value0) => { _value0.hash(_hasher); })
        return _hasher;
    }

    override toJson(): { readonly "qudt_EnumeratedQuantity$j$enumeratedValue": (ReturnType<Enumerated_Value["toJson"]>) | undefined; readonly "qudt_EnumeratedQuantity$j$enumeration": (ReturnType<Enumeration["toJson"]>) | undefined } & ReturnType<QUDT_Concept["toJson"]> {
        return JSON.parse(JSON.stringify({ ...super.toJson(),qudt_EnumeratedQuantity$j$enumeratedValue: this.qudt_EnumeratedQuantity$j$enumeratedValue.map(_item => (_item.toJson())).extract(),qudt_EnumeratedQuantity$j$enumeration: this.qudt_EnumeratedQuantity$j$enumeration.map(_item => (_item.toJson())).extract() } satisfies ReturnType<Enumerated_Quantity["toJson"]>));
    }

    override toRdf({ ignoreRdfType, mutateGraph, resourceSet }: { ignoreRdfType?: boolean; mutateGraph?: rdfjsResource.MutableResource.MutateGraph, resourceSet: rdfjsResource.MutableResourceSet }): rdfjsResource.MutableResource {
        const _resource = super.toRdf({ ignoreRdfType: true, mutateGraph, resourceSet });
        if (!ignoreRdfType) { _resource.add(_resource.dataFactory.namedNode("http://www.w3.org/1999/02/22-rdf-syntax-ns#type"), _resource.dataFactory.namedNode("http://qudt.org/schema/qudt/EnumeratedQuantity")); }

        _resource.add(dataFactory.namedNode("http://qudt.org/schema/qudt/enumeratedValue"), this.qudt_EnumeratedQuantity$j$enumeratedValue.map((_value) => _value.toRdf({ mutateGraph: mutateGraph, resourceSet: resourceSet })));
        _resource.add(dataFactory.namedNode("http://qudt.org/schema/qudt/enumeration"), this.qudt_EnumeratedQuantity$j$enumeration.map((_value) => _value.toRdf({ mutateGraph: mutateGraph, resourceSet: resourceSet })));
        return _resource;
    }

    override toString(): string {
        return JSON.stringify(this.toJson());
    }
}

export namespace Enumerated_Quantity {
    export function _propertiesFromJson(_json: unknown): purify.Either<zod.ZodError, { identifier: (rdfjs.BlankNode | rdfjs.NamedNode); qudt_EnumeratedQuantity$j$enumeratedValue: purify.Maybe<Enumerated_Value>; qudt_EnumeratedQuantity$j$enumeration: purify.Maybe<Enumeration>; } & UnwrapR<ReturnType<typeof QUDT_Concept._propertiesFromJson>>> {
        const _jsonSafeParseResult = enumeratedQuantityJsonZodSchema().safeParse(_json);
        if (!_jsonSafeParseResult.success) { return purify.Left(_jsonSafeParseResult.error); }

        const _jsonObject = _jsonSafeParseResult.data;
        const _super0Either = QUDT_Concept._propertiesFromJson(_jsonObject);
        if (_super0Either.isLeft()) { return _super0Either; }

        const _super0 = _super0Either.unsafeCoerce()
        const identifier = (_jsonObject["@id"].startsWith("_:") ? dataFactory.blankNode(_jsonObject["@id"].substring(2)) : dataFactory.namedNode(_jsonObject["@id"]));
        const qudt_EnumeratedQuantity$j$enumeratedValue = purify.Maybe.fromNullable(_jsonObject["qudt_EnumeratedQuantity$j$enumeratedValue"]).map(_item => (Enumerated_Value.fromJson(_item).unsafeCoerce()));
        const qudt_EnumeratedQuantity$j$enumeration = purify.Maybe.fromNullable(_jsonObject["qudt_EnumeratedQuantity$j$enumeration"]).map(_item => (Enumeration.fromJson(_item).unsafeCoerce()));
        return purify.Either.of({ ..._super0, identifier, qudt_EnumeratedQuantity$j$enumeratedValue, qudt_EnumeratedQuantity$j$enumeration })
    }

    export function fromJson(json: unknown): purify.Either<zod.ZodError, Enumerated_Quantity> {
        return Enumerated_Quantity._propertiesFromJson(json).map(properties => new Enumerated_Quantity(properties));
    }

    export function _propertiesFromRdf({ ignoreRdfType: _ignoreRdfType, languageIn: _languageIn, resource: _resource,
        // @ts-ignore
        ..._context }: { [_index: string]: any; ignoreRdfType?: boolean; languageIn?: readonly string[]; resource: rdfjsResource.Resource; }): purify.Either<rdfjsResource.Resource.ValueError, { identifier: (rdfjs.BlankNode | rdfjs.NamedNode); qudt_EnumeratedQuantity$j$enumeratedValue: purify.Maybe<Enumerated_Value>; qudt_EnumeratedQuantity$j$enumeration: purify.Maybe<Enumeration>; } & UnwrapR<ReturnType<typeof QUDT_Concept._propertiesFromRdf>>> {
        const _super0Either = QUDT_Concept._propertiesFromRdf({ ..._context, ignoreRdfType: true, languageIn: _languageIn, resource: _resource });
        if (_super0Either.isLeft()) { return _super0Either; }

        const _super0 = _super0Either.unsafeCoerce()
        if (!_ignoreRdfType && !_resource.isInstanceOf(dataFactory.namedNode("http://qudt.org/schema/qudt/EnumeratedQuantity"))) { return purify.Left(new rdfjsResource.Resource.ValueError({ focusResource: _resource, message: `${rdfjsResource.Resource.Identifier.toString(_resource.identifier)} has unexpected RDF type (expected http://qudt.org/schema/qudt/EnumeratedQuantity)`, predicate: dataFactory.namedNode("http://qudt.org/schema/qudt/EnumeratedQuantity") })); }

        const identifier = _resource.identifier
        const _qudt_EnumeratedQuantity$j$enumeratedValueEither: purify.Either<rdfjsResource.Resource.ValueError, purify.Maybe<Enumerated_Value>> = purify.Either.of(_resource.values(dataFactory.namedNode("http://qudt.org/schema/qudt/enumeratedValue"), { unique: true }).head().chain(value => value.toResource()).chain(_resource => Enumerated_Value.fromRdf({ ..._context, ignoreRdfType: true, languageIn: _languageIn, resource: _resource })).toMaybe());
        if (_qudt_EnumeratedQuantity$j$enumeratedValueEither.isLeft()) { return _qudt_EnumeratedQuantity$j$enumeratedValueEither; }

        const qudt_EnumeratedQuantity$j$enumeratedValue = _qudt_EnumeratedQuantity$j$enumeratedValueEither.unsafeCoerce();
        const _qudt_EnumeratedQuantity$j$enumerationEither: purify.Either<rdfjsResource.Resource.ValueError, purify.Maybe<Enumeration>> = purify.Either.of(_resource.values(dataFactory.namedNode("http://qudt.org/schema/qudt/enumeration"), { unique: true }).head().chain(value => value.toResource()).chain(_resource => Enumeration.fromRdf({ ..._context, ignoreRdfType: true, languageIn: _languageIn, resource: _resource })).toMaybe());
        if (_qudt_EnumeratedQuantity$j$enumerationEither.isLeft()) { return _qudt_EnumeratedQuantity$j$enumerationEither; }

        const qudt_EnumeratedQuantity$j$enumeration = _qudt_EnumeratedQuantity$j$enumerationEither.unsafeCoerce();
        return purify.Either.of({ ..._super0, identifier, qudt_EnumeratedQuantity$j$enumeratedValue, qudt_EnumeratedQuantity$j$enumeration })
    }

    export function fromRdf(parameters: Parameters<typeof Enumerated_Quantity._propertiesFromRdf>[0]): purify.Either<rdfjsResource.Resource.ValueError, Enumerated_Quantity> {
        return Enumerated_Quantity._propertiesFromRdf(parameters).map(properties => new Enumerated_Quantity(properties));
    }

    export let fromRdfType: rdfjs.NamedNode<string> = dataFactory.namedNode("http://qudt.org/schema/qudt/EnumeratedQuantity");

    export function jsonSchema() {
        return zodToJsonSchema(enumeratedQuantityJsonZodSchema());
    }

    export function enumeratedQuantityJsonUiSchema(parameters?: { scopePrefix?: string }) {
        const scopePrefix = parameters?.scopePrefix ?? "#";
        return { "elements": [ QUDT_Concept.qudtConceptJsonUiSchema({ scopePrefix }), Enumerated_Value.enumeratedValueJsonUiSchema({ scopePrefix: `${scopePrefix}/properties/qudt_EnumeratedQuantity$j$enumeratedValue` }), Enumeration.enumerationJsonUiSchema({ scopePrefix: `${scopePrefix}/properties/qudt_EnumeratedQuantity$j$enumeration` }) ], label: "Enumerated Quantity", type: "Group" }
    }

    export function enumeratedQuantityJsonZodSchema() {
        return QUDT_Concept.qudtConceptJsonZodSchema().merge(zod.object({ "@id": zod.string().min(1),"type": zod.literal("Enumerated_Quantity"),"qudt_EnumeratedQuantity$j$enumeratedValue": Enumerated_Value.enumeratedValueJsonZodSchema().optional(),"qudt_EnumeratedQuantity$j$enumeration": Enumeration.enumerationJsonZodSchema().optional() }));
    }

    export function sparqlConstructQuery(parameters?: { ignoreRdfType?: boolean; prefixes?: { [prefix: string]: string }; subject?: sparqljs.Triple["subject"]; } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type">): sparqljs.ConstructQuery {
        const { ignoreRdfType, subject, ...queryParameters } = parameters ?? {}

        return { ...queryParameters, prefixes: parameters?.prefixes ?? {}, queryType: "CONSTRUCT", template: (queryParameters.template ?? []).concat(Enumerated_Quantity.sparqlConstructTemplateTriples({ ignoreRdfType, subject })), type: "query", where: (queryParameters.where ?? []).concat(Enumerated_Quantity.sparqlWherePatterns({ ignoreRdfType, subject })) };
    }

    export function sparqlConstructQueryString(parameters?: { ignoreRdfType?: boolean; subject?: sparqljs.Triple["subject"]; variablePrefix?: string; } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type"> & sparqljs.GeneratorOptions): string {
        return new sparqljs.Generator(parameters).stringify(Enumerated_Quantity.sparqlConstructQuery(parameters));
    }

    export function sparqlConstructTemplateTriples(parameters?: { ignoreRdfType?: boolean; subject?: sparqljs.Triple["subject"], variablePrefix?: string }): readonly sparqljs.Triple[] {
        const subject = parameters?.subject ?? dataFactory.variable!("enumeratedQuantity");
        const variablePrefix = parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "enumeratedQuantity");
        return [...QUDT_Concept.sparqlConstructTemplateTriples({ ignoreRdfType: true, subject, variablePrefix }), ...(parameters?.ignoreRdfType ? [] : [{ subject, predicate: dataFactory.namedNode("http://www.w3.org/1999/02/22-rdf-syntax-ns#type"), object: dataFactory.variable!(`${variablePrefix}RdfType`) }]), { object: dataFactory.variable!(`${variablePrefix}QudtEnumeratedQuantityJEnumeratedValue`), predicate: dataFactory.namedNode("http://qudt.org/schema/qudt/enumeratedValue"), subject }, ...Enumerated_Value.sparqlConstructTemplateTriples({ ignoreRdfType: true, subject: dataFactory.variable!(`${variablePrefix}QudtEnumeratedQuantityJEnumeratedValue`), variablePrefix: `${variablePrefix}QudtEnumeratedQuantityJEnumeratedValue` }), { object: dataFactory.variable!(`${variablePrefix}QudtEnumeratedQuantityJEnumeration`), predicate: dataFactory.namedNode("http://qudt.org/schema/qudt/enumeration"), subject }, ...Enumeration.sparqlConstructTemplateTriples({ ignoreRdfType: true, subject: dataFactory.variable!(`${variablePrefix}QudtEnumeratedQuantityJEnumeration`), variablePrefix: `${variablePrefix}QudtEnumeratedQuantityJEnumeration` })];
    }

    export function sparqlWherePatterns(parameters: { ignoreRdfType?: boolean; subject?: sparqljs.Triple["subject"], variablePrefix?: string }): readonly sparqljs.Pattern[] {
        const subject = parameters?.subject ?? dataFactory.variable!("enumeratedQuantity");
        const variablePrefix = parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "enumeratedQuantity");
        return [...QUDT_Concept.sparqlWherePatterns({ ignoreRdfType: true, subject, variablePrefix }), ...(parameters?.ignoreRdfType ? [] : [{ triples: [{ subject, predicate: dataFactory.namedNode("http://www.w3.org/1999/02/22-rdf-syntax-ns#type"), object: dataFactory.namedNode("http://qudt.org/schema/qudt/EnumeratedQuantity") }], type: "bgp" as const }, { triples: [{ subject, predicate: dataFactory.namedNode("http://www.w3.org/1999/02/22-rdf-syntax-ns#type"), object: dataFactory.variable!(`${variablePrefix}RdfType`) }], type: "bgp" as const }]), { patterns: [{ triples: [{ object: dataFactory.variable!(`${variablePrefix}QudtEnumeratedQuantityJEnumeratedValue`), predicate: dataFactory.namedNode("http://qudt.org/schema/qudt/enumeratedValue"), subject }], type: "bgp" }, ...Enumerated_Value.sparqlWherePatterns({ ignoreRdfType: true, subject: dataFactory.variable!(`${variablePrefix}QudtEnumeratedQuantityJEnumeratedValue`), variablePrefix: `${variablePrefix}QudtEnumeratedQuantityJEnumeratedValue` })], type: "optional" }, { patterns: [{ triples: [{ object: dataFactory.variable!(`${variablePrefix}QudtEnumeratedQuantityJEnumeration`), predicate: dataFactory.namedNode("http://qudt.org/schema/qudt/enumeration"), subject }], type: "bgp" }, ...Enumeration.sparqlWherePatterns({ ignoreRdfType: true, subject: dataFactory.variable!(`${variablePrefix}QudtEnumeratedQuantityJEnumeration`), variablePrefix: `${variablePrefix}QudtEnumeratedQuantityJEnumeration` })], type: "optional" }];
    }
}
/**
 * Discipline
 */
export class Discipline extends QUDT_Concept {
    override readonly type = "Discipline";

    // biome-ignore lint/complexity/noUselessConstructor: Always have a constructor
    constructor(parameters: { readonly identifier?: (rdfjs.BlankNode | rdfjs.NamedNode) | string } & ConstructorParameters<typeof QUDT_Concept>[0]) {
        super(parameters);
    }

    override get identifier(): (rdfjs.BlankNode | rdfjs.NamedNode) {
        if (typeof this._identifier === "undefined") { this._identifier = dataFactory.blankNode(); } return this._identifier;
    }

    override toRdf({ ignoreRdfType, mutateGraph, resourceSet }: { ignoreRdfType?: boolean; mutateGraph?: rdfjsResource.MutableResource.MutateGraph, resourceSet: rdfjsResource.MutableResourceSet }): rdfjsResource.MutableResource {
        const _resource = super.toRdf({ ignoreRdfType: true, mutateGraph, resourceSet });
        if (!ignoreRdfType) { _resource.add(_resource.dataFactory.namedNode("http://www.w3.org/1999/02/22-rdf-syntax-ns#type"), _resource.dataFactory.namedNode("http://qudt.org/schema/qudt/Discipline")); }

        return _resource;
    }

    override toString(): string {
        return JSON.stringify(this.toJson());
    }
}

export namespace Discipline {
    export function _propertiesFromJson(_json: unknown): purify.Either<zod.ZodError, { identifier: (rdfjs.BlankNode | rdfjs.NamedNode); } & UnwrapR<ReturnType<typeof QUDT_Concept._propertiesFromJson>>> {
        const _jsonSafeParseResult = disciplineJsonZodSchema().safeParse(_json);
        if (!_jsonSafeParseResult.success) { return purify.Left(_jsonSafeParseResult.error); }

        const _jsonObject = _jsonSafeParseResult.data;
        const _super0Either = QUDT_Concept._propertiesFromJson(_jsonObject);
        if (_super0Either.isLeft()) { return _super0Either; }

        const _super0 = _super0Either.unsafeCoerce()
        const identifier = (_jsonObject["@id"].startsWith("_:") ? dataFactory.blankNode(_jsonObject["@id"].substring(2)) : dataFactory.namedNode(_jsonObject["@id"]));
        return purify.Either.of({ ..._super0, identifier })
    }

    export function fromJson(json: unknown): purify.Either<zod.ZodError, Discipline> {
        return Discipline._propertiesFromJson(json).map(properties => new Discipline(properties));
    }

    export function _propertiesFromRdf({ ignoreRdfType: _ignoreRdfType, languageIn: _languageIn, resource: _resource,
        // @ts-ignore
        ..._context }: { [_index: string]: any; ignoreRdfType?: boolean; languageIn?: readonly string[]; resource: rdfjsResource.Resource; }): purify.Either<rdfjsResource.Resource.ValueError, { identifier: (rdfjs.BlankNode | rdfjs.NamedNode); } & UnwrapR<ReturnType<typeof QUDT_Concept._propertiesFromRdf>>> {
        const _super0Either = QUDT_Concept._propertiesFromRdf({ ..._context, ignoreRdfType: true, languageIn: _languageIn, resource: _resource });
        if (_super0Either.isLeft()) { return _super0Either; }

        const _super0 = _super0Either.unsafeCoerce()
        if (!_ignoreRdfType && !_resource.isInstanceOf(dataFactory.namedNode("http://qudt.org/schema/qudt/Discipline"))) { return purify.Left(new rdfjsResource.Resource.ValueError({ focusResource: _resource, message: `${rdfjsResource.Resource.Identifier.toString(_resource.identifier)} has unexpected RDF type (expected http://qudt.org/schema/qudt/Discipline)`, predicate: dataFactory.namedNode("http://qudt.org/schema/qudt/Discipline") })); }

        const identifier = _resource.identifier
        return purify.Either.of({ ..._super0, identifier })
    }

    export function fromRdf(parameters: Parameters<typeof Discipline._propertiesFromRdf>[0]): purify.Either<rdfjsResource.Resource.ValueError, Discipline> {
        return Discipline._propertiesFromRdf(parameters).map(properties => new Discipline(properties));
    }

    export let fromRdfType: rdfjs.NamedNode<string> = dataFactory.namedNode("http://qudt.org/schema/qudt/Discipline");

    export function jsonSchema() {
        return zodToJsonSchema(disciplineJsonZodSchema());
    }

    export function disciplineJsonUiSchema(parameters?: { scopePrefix?: string }) {
        const scopePrefix = parameters?.scopePrefix ?? "#";
        return { "elements": [ QUDT_Concept.qudtConceptJsonUiSchema({ scopePrefix }) ], label: "Discipline", type: "Group" }
    }

    export function disciplineJsonZodSchema() {
        return QUDT_Concept.qudtConceptJsonZodSchema().merge(zod.object({ "@id": zod.string().min(1),"type": zod.literal("Discipline") }));
    }

    export function sparqlConstructQuery(parameters?: { ignoreRdfType?: boolean; prefixes?: { [prefix: string]: string }; subject?: sparqljs.Triple["subject"]; } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type">): sparqljs.ConstructQuery {
        const { ignoreRdfType, subject, ...queryParameters } = parameters ?? {}

        return { ...queryParameters, prefixes: parameters?.prefixes ?? {}, queryType: "CONSTRUCT", template: (queryParameters.template ?? []).concat(Discipline.sparqlConstructTemplateTriples({ ignoreRdfType, subject })), type: "query", where: (queryParameters.where ?? []).concat(Discipline.sparqlWherePatterns({ ignoreRdfType, subject })) };
    }

    export function sparqlConstructQueryString(parameters?: { ignoreRdfType?: boolean; subject?: sparqljs.Triple["subject"]; variablePrefix?: string; } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type"> & sparqljs.GeneratorOptions): string {
        return new sparqljs.Generator(parameters).stringify(Discipline.sparqlConstructQuery(parameters));
    }

    export function sparqlConstructTemplateTriples(parameters?: { ignoreRdfType?: boolean; subject?: sparqljs.Triple["subject"], variablePrefix?: string }): readonly sparqljs.Triple[] {
        const subject = parameters?.subject ?? dataFactory.variable!("discipline");
        const variablePrefix = parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "discipline");
        return [...QUDT_Concept.sparqlConstructTemplateTriples({ ignoreRdfType: true, subject, variablePrefix }), ...(parameters?.ignoreRdfType ? [] : [{ subject, predicate: dataFactory.namedNode("http://www.w3.org/1999/02/22-rdf-syntax-ns#type"), object: dataFactory.variable!(`${variablePrefix}RdfType`) }])];
    }

    export function sparqlWherePatterns(parameters: { ignoreRdfType?: boolean; subject?: sparqljs.Triple["subject"], variablePrefix?: string }): readonly sparqljs.Pattern[] {
        const subject = parameters?.subject ?? dataFactory.variable!("discipline");
        const variablePrefix = parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "discipline");
        return [...QUDT_Concept.sparqlWherePatterns({ ignoreRdfType: true, subject, variablePrefix }), ...(parameters?.ignoreRdfType ? [] : [{ triples: [{ subject, predicate: dataFactory.namedNode("http://www.w3.org/1999/02/22-rdf-syntax-ns#type"), object: dataFactory.namedNode("http://qudt.org/schema/qudt/Discipline") }], type: "bgp" as const }, { triples: [{ subject, predicate: dataFactory.namedNode("http://www.w3.org/1999/02/22-rdf-syntax-ns#type"), object: dataFactory.variable!(`${variablePrefix}RdfType`) }], type: "bgp" as const }])];
    }
}
/**
 * Derived Unit
 */
export class Derived_Unit extends Unit {
    override readonly type = "Derived_Unit";

    // biome-ignore lint/complexity/noUselessConstructor: Always have a constructor
    constructor(parameters: { readonly identifier?: (rdfjs.BlankNode | rdfjs.NamedNode) | string } & ConstructorParameters<typeof Unit>[0]) {
        super(parameters);
    }

    override get identifier(): (rdfjs.BlankNode | rdfjs.NamedNode) {
        if (typeof this._identifier === "undefined") { this._identifier = dataFactory.blankNode(); } return this._identifier;
    }

    override toRdf({ ignoreRdfType, mutateGraph, resourceSet }: { ignoreRdfType?: boolean; mutateGraph?: rdfjsResource.MutableResource.MutateGraph, resourceSet: rdfjsResource.MutableResourceSet }): rdfjsResource.MutableResource {
        const _resource = super.toRdf({ ignoreRdfType: true, mutateGraph, resourceSet });
        if (!ignoreRdfType) { _resource.add(_resource.dataFactory.namedNode("http://www.w3.org/1999/02/22-rdf-syntax-ns#type"), _resource.dataFactory.namedNode("http://qudt.org/schema/qudt/DerivedUnit")); }

        return _resource;
    }

    override toString(): string {
        return JSON.stringify(this.toJson());
    }
}

export namespace Derived_Unit {
    export function _propertiesFromJson(_json: unknown): purify.Either<zod.ZodError, { identifier: (rdfjs.BlankNode | rdfjs.NamedNode); } & UnwrapR<ReturnType<typeof Unit._propertiesFromJson>>> {
        const _jsonSafeParseResult = derivedUnitJsonZodSchema().safeParse(_json);
        if (!_jsonSafeParseResult.success) { return purify.Left(_jsonSafeParseResult.error); }

        const _jsonObject = _jsonSafeParseResult.data;
        const _super0Either = Unit._propertiesFromJson(_jsonObject);
        if (_super0Either.isLeft()) { return _super0Either; }

        const _super0 = _super0Either.unsafeCoerce()
        const identifier = (_jsonObject["@id"].startsWith("_:") ? dataFactory.blankNode(_jsonObject["@id"].substring(2)) : dataFactory.namedNode(_jsonObject["@id"]));
        return purify.Either.of({ ..._super0, identifier })
    }

    export function fromJson(json: unknown): purify.Either<zod.ZodError, Derived_Unit> {
        return Derived_Unit._propertiesFromJson(json).map(properties => new Derived_Unit(properties));
    }

    export function _propertiesFromRdf({ ignoreRdfType: _ignoreRdfType, languageIn: _languageIn, resource: _resource,
        // @ts-ignore
        ..._context }: { [_index: string]: any; ignoreRdfType?: boolean; languageIn?: readonly string[]; resource: rdfjsResource.Resource; }): purify.Either<rdfjsResource.Resource.ValueError, { identifier: (rdfjs.BlankNode | rdfjs.NamedNode); } & UnwrapR<ReturnType<typeof Unit._propertiesFromRdf>>> {
        const _super0Either = Unit._propertiesFromRdf({ ..._context, ignoreRdfType: true, languageIn: _languageIn, resource: _resource });
        if (_super0Either.isLeft()) { return _super0Either; }

        const _super0 = _super0Either.unsafeCoerce()
        if (!_ignoreRdfType && !_resource.isInstanceOf(dataFactory.namedNode("http://qudt.org/schema/qudt/DerivedUnit"))) { return purify.Left(new rdfjsResource.Resource.ValueError({ focusResource: _resource, message: `${rdfjsResource.Resource.Identifier.toString(_resource.identifier)} has unexpected RDF type (expected http://qudt.org/schema/qudt/DerivedUnit)`, predicate: dataFactory.namedNode("http://qudt.org/schema/qudt/DerivedUnit") })); }

        const identifier = _resource.identifier
        return purify.Either.of({ ..._super0, identifier })
    }

    export function fromRdf(parameters: Parameters<typeof Derived_Unit._propertiesFromRdf>[0]): purify.Either<rdfjsResource.Resource.ValueError, Derived_Unit> {
        return Derived_Unit._propertiesFromRdf(parameters).map(properties => new Derived_Unit(properties));
    }

    export let fromRdfType: rdfjs.NamedNode<string> = dataFactory.namedNode("http://qudt.org/schema/qudt/DerivedUnit");

    export function jsonSchema() {
        return zodToJsonSchema(derivedUnitJsonZodSchema());
    }

    export function derivedUnitJsonUiSchema(parameters?: { scopePrefix?: string }) {
        const scopePrefix = parameters?.scopePrefix ?? "#";
        return { "elements": [ Unit.unitJsonUiSchema({ scopePrefix }) ], label: "Derived Unit", type: "Group" }
    }

    export function derivedUnitJsonZodSchema() {
        return Unit.unitJsonZodSchema().merge(zod.object({ "@id": zod.string().min(1),"type": zod.literal("Derived_Unit") }));
    }

    export function sparqlConstructQuery(parameters?: { ignoreRdfType?: boolean; prefixes?: { [prefix: string]: string }; subject?: sparqljs.Triple["subject"]; } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type">): sparqljs.ConstructQuery {
        const { ignoreRdfType, subject, ...queryParameters } = parameters ?? {}

        return { ...queryParameters, prefixes: parameters?.prefixes ?? {}, queryType: "CONSTRUCT", template: (queryParameters.template ?? []).concat(Derived_Unit.sparqlConstructTemplateTriples({ ignoreRdfType, subject })), type: "query", where: (queryParameters.where ?? []).concat(Derived_Unit.sparqlWherePatterns({ ignoreRdfType, subject })) };
    }

    export function sparqlConstructQueryString(parameters?: { ignoreRdfType?: boolean; subject?: sparqljs.Triple["subject"]; variablePrefix?: string; } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type"> & sparqljs.GeneratorOptions): string {
        return new sparqljs.Generator(parameters).stringify(Derived_Unit.sparqlConstructQuery(parameters));
    }

    export function sparqlConstructTemplateTriples(parameters?: { ignoreRdfType?: boolean; subject?: sparqljs.Triple["subject"], variablePrefix?: string }): readonly sparqljs.Triple[] {
        const subject = parameters?.subject ?? dataFactory.variable!("derivedUnit");
        const variablePrefix = parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "derivedUnit");
        return [...Unit.sparqlConstructTemplateTriples({ ignoreRdfType: true, subject, variablePrefix }), ...(parameters?.ignoreRdfType ? [] : [{ subject, predicate: dataFactory.namedNode("http://www.w3.org/1999/02/22-rdf-syntax-ns#type"), object: dataFactory.variable!(`${variablePrefix}RdfType`) }])];
    }

    export function sparqlWherePatterns(parameters: { ignoreRdfType?: boolean; subject?: sparqljs.Triple["subject"], variablePrefix?: string }): readonly sparqljs.Pattern[] {
        const subject = parameters?.subject ?? dataFactory.variable!("derivedUnit");
        const variablePrefix = parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "derivedUnit");
        return [...Unit.sparqlWherePatterns({ ignoreRdfType: true, subject, variablePrefix }), ...(parameters?.ignoreRdfType ? [] : [{ triples: [{ subject, predicate: dataFactory.namedNode("http://www.w3.org/1999/02/22-rdf-syntax-ns#type"), object: dataFactory.namedNode("http://qudt.org/schema/qudt/DerivedUnit") }], type: "bgp" as const }, { triples: [{ subject, predicate: dataFactory.namedNode("http://www.w3.org/1999/02/22-rdf-syntax-ns#type"), object: dataFactory.variable!(`${variablePrefix}RdfType`) }], type: "bgp" as const }])];
    }
}
/**
 * Prefix
 */
export class Prefix extends QUDT_Concept {
    override readonly type: "Binary_Prefix" | "Decimal_Prefix" | "Prefix" = "Prefix";
    readonly qudt_Prefix$j$altSymbol: readonly ((rdfjs.BlankNode | rdfjs.NamedNode | rdfjs.Literal))[];
    readonly qudt_Prefix$j$latexSymbol: readonly (string)[];
    readonly qudt_Prefix$j$prefixMultiplier: purify.Maybe<number>;
    readonly qudt_Prefix$j$prefixMultiplierSN: purify.Maybe<number>;
    readonly qudt_Prefix$j$siExactMatch: purify.Maybe<(rdfjs.BlankNode | rdfjs.NamedNode | rdfjs.Literal)>;
    readonly qudt_Prefix$j$symbol: purify.Maybe<(rdfjs.BlankNode | rdfjs.NamedNode | rdfjs.Literal)>;
    readonly qudt_Prefix$j$ucumCode: readonly (string)[];

    constructor(parameters: { readonly identifier?: (rdfjs.BlankNode | rdfjs.NamedNode) | string, readonly qudt_Prefix$j$altSymbol?: readonly ((rdfjs.BlankNode | rdfjs.NamedNode | rdfjs.Literal))[], readonly qudt_Prefix$j$latexSymbol?: readonly (string)[], readonly qudt_Prefix$j$prefixMultiplier?: number | purify.Maybe<number>, readonly qudt_Prefix$j$prefixMultiplierSN?: number | purify.Maybe<number>, readonly qudt_Prefix$j$siExactMatch?: (rdfjs.BlankNode | rdfjs.NamedNode | rdfjs.Literal) | Date | boolean | number | purify.Maybe<(rdfjs.BlankNode | rdfjs.NamedNode | rdfjs.Literal)> | string, readonly qudt_Prefix$j$symbol?: (rdfjs.BlankNode | rdfjs.NamedNode | rdfjs.Literal) | Date | boolean | number | purify.Maybe<(rdfjs.BlankNode | rdfjs.NamedNode | rdfjs.Literal)> | string, readonly qudt_Prefix$j$ucumCode?: readonly (string)[] } & ConstructorParameters<typeof QUDT_Concept>[0]) {
        super(parameters);
        if (typeof parameters.qudt_Prefix$j$altSymbol === "undefined") { this.qudt_Prefix$j$altSymbol = []; } else if (Array.isArray(parameters.qudt_Prefix$j$altSymbol)) { this.qudt_Prefix$j$altSymbol = parameters.qudt_Prefix$j$altSymbol; } else { this.qudt_Prefix$j$altSymbol =( parameters.qudt_Prefix$j$altSymbol) as never;
         }

        if (typeof parameters.qudt_Prefix$j$latexSymbol === "undefined") { this.qudt_Prefix$j$latexSymbol = []; } else if (Array.isArray(parameters.qudt_Prefix$j$latexSymbol)) { this.qudt_Prefix$j$latexSymbol = parameters.qudt_Prefix$j$latexSymbol; } else { this.qudt_Prefix$j$latexSymbol =( parameters.qudt_Prefix$j$latexSymbol) as never;
         }

        if (purify.Maybe.isMaybe(parameters.qudt_Prefix$j$prefixMultiplier)) { this.qudt_Prefix$j$prefixMultiplier = parameters.qudt_Prefix$j$prefixMultiplier; } else if (typeof parameters.qudt_Prefix$j$prefixMultiplier === "number") { this.qudt_Prefix$j$prefixMultiplier = purify.Maybe.of(parameters.qudt_Prefix$j$prefixMultiplier); } else if (typeof parameters.qudt_Prefix$j$prefixMultiplier === "undefined") { this.qudt_Prefix$j$prefixMultiplier = purify.Maybe.empty(); } else { this.qudt_Prefix$j$prefixMultiplier =( parameters.qudt_Prefix$j$prefixMultiplier) as never;
         }

        if (purify.Maybe.isMaybe(parameters.qudt_Prefix$j$prefixMultiplierSN)) { this.qudt_Prefix$j$prefixMultiplierSN = parameters.qudt_Prefix$j$prefixMultiplierSN; } else if (typeof parameters.qudt_Prefix$j$prefixMultiplierSN === "number") { this.qudt_Prefix$j$prefixMultiplierSN = purify.Maybe.of(parameters.qudt_Prefix$j$prefixMultiplierSN); } else if (typeof parameters.qudt_Prefix$j$prefixMultiplierSN === "undefined") { this.qudt_Prefix$j$prefixMultiplierSN = purify.Maybe.empty(); } else { this.qudt_Prefix$j$prefixMultiplierSN =( parameters.qudt_Prefix$j$prefixMultiplierSN) as never;
         }

        if (purify.Maybe.isMaybe(parameters.qudt_Prefix$j$siExactMatch)) { this.qudt_Prefix$j$siExactMatch = parameters.qudt_Prefix$j$siExactMatch; } else if (typeof parameters.qudt_Prefix$j$siExactMatch === "boolean") { this.qudt_Prefix$j$siExactMatch = purify.Maybe.of(rdfLiteral.toRdf(parameters.qudt_Prefix$j$siExactMatch, { dataFactory })); } else if (typeof parameters.qudt_Prefix$j$siExactMatch === "object" && parameters.qudt_Prefix$j$siExactMatch instanceof Date) { this.qudt_Prefix$j$siExactMatch = purify.Maybe.of(rdfLiteral.toRdf(parameters.qudt_Prefix$j$siExactMatch, { dataFactory })); } else if (typeof parameters.qudt_Prefix$j$siExactMatch === "number") { this.qudt_Prefix$j$siExactMatch = purify.Maybe.of(rdfLiteral.toRdf(parameters.qudt_Prefix$j$siExactMatch, { dataFactory })); } else if (typeof parameters.qudt_Prefix$j$siExactMatch === "string") { this.qudt_Prefix$j$siExactMatch = purify.Maybe.of(dataFactory.literal(parameters.qudt_Prefix$j$siExactMatch)); } else if (typeof parameters.qudt_Prefix$j$siExactMatch === "object") { this.qudt_Prefix$j$siExactMatch = purify.Maybe.of(parameters.qudt_Prefix$j$siExactMatch); } else if (typeof parameters.qudt_Prefix$j$siExactMatch === "undefined") { this.qudt_Prefix$j$siExactMatch = purify.Maybe.empty(); } else { this.qudt_Prefix$j$siExactMatch =( parameters.qudt_Prefix$j$siExactMatch) as never;
         }

        if (purify.Maybe.isMaybe(parameters.qudt_Prefix$j$symbol)) { this.qudt_Prefix$j$symbol = parameters.qudt_Prefix$j$symbol; } else if (typeof parameters.qudt_Prefix$j$symbol === "boolean") { this.qudt_Prefix$j$symbol = purify.Maybe.of(rdfLiteral.toRdf(parameters.qudt_Prefix$j$symbol, { dataFactory })); } else if (typeof parameters.qudt_Prefix$j$symbol === "object" && parameters.qudt_Prefix$j$symbol instanceof Date) { this.qudt_Prefix$j$symbol = purify.Maybe.of(rdfLiteral.toRdf(parameters.qudt_Prefix$j$symbol, { dataFactory })); } else if (typeof parameters.qudt_Prefix$j$symbol === "number") { this.qudt_Prefix$j$symbol = purify.Maybe.of(rdfLiteral.toRdf(parameters.qudt_Prefix$j$symbol, { dataFactory })); } else if (typeof parameters.qudt_Prefix$j$symbol === "string") { this.qudt_Prefix$j$symbol = purify.Maybe.of(dataFactory.literal(parameters.qudt_Prefix$j$symbol)); } else if (typeof parameters.qudt_Prefix$j$symbol === "object") { this.qudt_Prefix$j$symbol = purify.Maybe.of(parameters.qudt_Prefix$j$symbol); } else if (typeof parameters.qudt_Prefix$j$symbol === "undefined") { this.qudt_Prefix$j$symbol = purify.Maybe.empty(); } else { this.qudt_Prefix$j$symbol =( parameters.qudt_Prefix$j$symbol) as never;
         }

        if (typeof parameters.qudt_Prefix$j$ucumCode === "undefined") { this.qudt_Prefix$j$ucumCode = []; } else if (Array.isArray(parameters.qudt_Prefix$j$ucumCode)) { this.qudt_Prefix$j$ucumCode = parameters.qudt_Prefix$j$ucumCode; } else { this.qudt_Prefix$j$ucumCode =( parameters.qudt_Prefix$j$ucumCode) as never;
         }
    }

    override get identifier(): (rdfjs.BlankNode | rdfjs.NamedNode) {
        if (typeof this._identifier === "undefined") { this._identifier = dataFactory.blankNode(); } return this._identifier;
    }

    override equals(other: Prefix): EqualsResult {
        return super.equals(other).chain(() => (((left, right) => arrayEquals(left, right, booleanEquals)))(this.qudt_Prefix$j$altSymbol, other.qudt_Prefix$j$altSymbol).mapLeft(propertyValuesUnequal => ({ left: this, right: other, propertyName: "qudt_Prefix$j$altSymbol", propertyValuesUnequal, type: "Property" as const }))).chain(() => (((left, right) => arrayEquals(left, right, strictEquals)))(this.qudt_Prefix$j$latexSymbol, other.qudt_Prefix$j$latexSymbol).mapLeft(propertyValuesUnequal => ({ left: this, right: other, propertyName: "qudt_Prefix$j$latexSymbol", propertyValuesUnequal, type: "Property" as const }))).chain(() => (((left, right) => maybeEquals(left, right, strictEquals)))(this.qudt_Prefix$j$prefixMultiplier, other.qudt_Prefix$j$prefixMultiplier).mapLeft(propertyValuesUnequal => ({ left: this, right: other, propertyName: "qudt_Prefix$j$prefixMultiplier", propertyValuesUnequal, type: "Property" as const }))).chain(() => (((left, right) => maybeEquals(left, right, strictEquals)))(this.qudt_Prefix$j$prefixMultiplierSN, other.qudt_Prefix$j$prefixMultiplierSN).mapLeft(propertyValuesUnequal => ({ left: this, right: other, propertyName: "qudt_Prefix$j$prefixMultiplierSN", propertyValuesUnequal, type: "Property" as const }))).chain(() => (((left, right) => maybeEquals(left, right, booleanEquals)))(this.qudt_Prefix$j$siExactMatch, other.qudt_Prefix$j$siExactMatch).mapLeft(propertyValuesUnequal => ({ left: this, right: other, propertyName: "qudt_Prefix$j$siExactMatch", propertyValuesUnequal, type: "Property" as const }))).chain(() => (((left, right) => maybeEquals(left, right, booleanEquals)))(this.qudt_Prefix$j$symbol, other.qudt_Prefix$j$symbol).mapLeft(propertyValuesUnequal => ({ left: this, right: other, propertyName: "qudt_Prefix$j$symbol", propertyValuesUnequal, type: "Property" as const }))).chain(() => (((left, right) => arrayEquals(left, right, strictEquals)))(this.qudt_Prefix$j$ucumCode, other.qudt_Prefix$j$ucumCode).mapLeft(propertyValuesUnequal => ({ left: this, right: other, propertyName: "qudt_Prefix$j$ucumCode", propertyValuesUnequal, type: "Property" as const })));
    }

    override hash<HasherT extends { update: (message: string | number[] | ArrayBuffer | Uint8Array) => void; }>(_hasher: HasherT): HasherT {
        this.hashShaclProperties(_hasher);
        return _hasher;
    }

    protected override hashShaclProperties<HasherT extends { update: (message: string | number[] | ArrayBuffer | Uint8Array) => void; }>(_hasher: HasherT): HasherT {
        super.hashShaclProperties(_hasher);
        for (const _item0 of this.qudt_Prefix$j$altSymbol) { _hasher.update(_item0.termType);
        _hasher.update(_item0.value); }

        for (const _item0 of this.qudt_Prefix$j$latexSymbol) { _hasher.update(_item0); }

        this.qudt_Prefix$j$prefixMultiplier.ifJust((_value0) => { _hasher.update(_value0.toString()); })
        this.qudt_Prefix$j$prefixMultiplierSN.ifJust((_value0) => { _hasher.update(_value0.toString()); })
        this.qudt_Prefix$j$siExactMatch.ifJust((_value0) => { _hasher.update(_value0.termType);
        _hasher.update(_value0.value); })
        this.qudt_Prefix$j$symbol.ifJust((_value0) => { _hasher.update(_value0.termType);
        _hasher.update(_value0.value); })
        for (const _item0 of this.qudt_Prefix$j$ucumCode) { _hasher.update(_item0); }

        return _hasher;
    }

    override toJson(): { readonly "qudt_Prefix$j$altSymbol": readonly ({ readonly "@id": string, readonly termType: "BlankNode" | "NamedNode" } | { readonly "@language": string | undefined, readonly "@type": string | undefined, readonly "@value": string, readonly termType: "Literal" })[]; readonly "qudt_Prefix$j$latexSymbol": readonly (string)[]; readonly "qudt_Prefix$j$prefixMultiplier": (number) | undefined; readonly "qudt_Prefix$j$prefixMultiplierSN": (number) | undefined; readonly "qudt_Prefix$j$siExactMatch": ({ readonly "@id": string, readonly termType: "BlankNode" | "NamedNode" } | { readonly "@language": string | undefined, readonly "@type": string | undefined, readonly "@value": string, readonly termType: "Literal" }) | undefined; readonly "qudt_Prefix$j$symbol": ({ readonly "@id": string, readonly termType: "BlankNode" | "NamedNode" } | { readonly "@language": string | undefined, readonly "@type": string | undefined, readonly "@value": string, readonly termType: "Literal" }) | undefined; readonly "qudt_Prefix$j$ucumCode": readonly (string)[] } & ReturnType<QUDT_Concept["toJson"]> {
        return JSON.parse(JSON.stringify({ ...super.toJson(),qudt_Prefix$j$altSymbol: this.qudt_Prefix$j$altSymbol.map(_item => ((_item.termType === "Literal") ? { "@language": _item.language.length > 0 ? _item.language : undefined, "@type": _item.datatype.value !== "http://www.w3.org/2001/XMLSchema#string" ? _item.datatype.value : undefined, "@value": _item.value, termType: "Literal" as const } : (_item.termType === "NamedNode") ? { "@id": _item.value, termType: "NamedNode" as const } : { "@id": `_:${_item.value}`, termType: "BlankNode" as const })),qudt_Prefix$j$latexSymbol: this.qudt_Prefix$j$latexSymbol.map(_item => (_item)),qudt_Prefix$j$prefixMultiplier: this.qudt_Prefix$j$prefixMultiplier.map(_item => (_item)).extract(),qudt_Prefix$j$prefixMultiplierSN: this.qudt_Prefix$j$prefixMultiplierSN.map(_item => (_item)).extract(),qudt_Prefix$j$siExactMatch: this.qudt_Prefix$j$siExactMatch.map(_item => ((_item.termType === "Literal") ? { "@language": _item.language.length > 0 ? _item.language : undefined, "@type": _item.datatype.value !== "http://www.w3.org/2001/XMLSchema#string" ? _item.datatype.value : undefined, "@value": _item.value, termType: "Literal" as const } : (_item.termType === "NamedNode") ? { "@id": _item.value, termType: "NamedNode" as const } : { "@id": `_:${_item.value}`, termType: "BlankNode" as const })).extract(),qudt_Prefix$j$symbol: this.qudt_Prefix$j$symbol.map(_item => ((_item.termType === "Literal") ? { "@language": _item.language.length > 0 ? _item.language : undefined, "@type": _item.datatype.value !== "http://www.w3.org/2001/XMLSchema#string" ? _item.datatype.value : undefined, "@value": _item.value, termType: "Literal" as const } : (_item.termType === "NamedNode") ? { "@id": _item.value, termType: "NamedNode" as const } : { "@id": `_:${_item.value}`, termType: "BlankNode" as const })).extract(),qudt_Prefix$j$ucumCode: this.qudt_Prefix$j$ucumCode.map(_item => (_item)) } satisfies ReturnType<Prefix["toJson"]>));
    }

    override toRdf({ ignoreRdfType, mutateGraph, resourceSet }: { ignoreRdfType?: boolean; mutateGraph?: rdfjsResource.MutableResource.MutateGraph, resourceSet: rdfjsResource.MutableResourceSet }): rdfjsResource.MutableResource {
        const _resource = super.toRdf({ ignoreRdfType: true, mutateGraph, resourceSet });
        if (!ignoreRdfType) { _resource.add(_resource.dataFactory.namedNode("http://www.w3.org/1999/02/22-rdf-syntax-ns#type"), _resource.dataFactory.namedNode("http://qudt.org/schema/qudt/Prefix")); }

        _resource.add(dataFactory.namedNode("http://qudt.org/schema/qudt/altSymbol"), this.qudt_Prefix$j$altSymbol.map((_item) => _item));
        _resource.add(dataFactory.namedNode("http://qudt.org/schema/qudt/latexSymbol"), this.qudt_Prefix$j$latexSymbol.map((_item) => _item));
        _resource.add(dataFactory.namedNode("http://qudt.org/schema/qudt/prefixMultiplier"), this.qudt_Prefix$j$prefixMultiplier);
        _resource.add(dataFactory.namedNode("http://qudt.org/schema/qudt/prefixMultiplierSN"), this.qudt_Prefix$j$prefixMultiplierSN);
        _resource.add(dataFactory.namedNode("http://qudt.org/schema/qudt/siExactMatch"), this.qudt_Prefix$j$siExactMatch);
        _resource.add(dataFactory.namedNode("http://qudt.org/schema/qudt/symbol"), this.qudt_Prefix$j$symbol);
        _resource.add(dataFactory.namedNode("http://qudt.org/schema/qudt/ucumCode"), this.qudt_Prefix$j$ucumCode.map((_item) => _item));
        return _resource;
    }

    override toString(): string {
        return JSON.stringify(this.toJson());
    }
}

export namespace Prefix {
    export function _propertiesFromJson(_json: unknown): purify.Either<zod.ZodError, { identifier: (rdfjs.BlankNode | rdfjs.NamedNode); qudt_Prefix$j$altSymbol: readonly ((rdfjs.BlankNode | rdfjs.NamedNode | rdfjs.Literal))[]; qudt_Prefix$j$latexSymbol: readonly (string)[]; qudt_Prefix$j$prefixMultiplier: purify.Maybe<number>; qudt_Prefix$j$prefixMultiplierSN: purify.Maybe<number>; qudt_Prefix$j$siExactMatch: purify.Maybe<(rdfjs.BlankNode | rdfjs.NamedNode | rdfjs.Literal)>; qudt_Prefix$j$symbol: purify.Maybe<(rdfjs.BlankNode | rdfjs.NamedNode | rdfjs.Literal)>; qudt_Prefix$j$ucumCode: readonly (string)[]; } & UnwrapR<ReturnType<typeof QUDT_Concept._propertiesFromJson>>> {
        const _jsonSafeParseResult = prefixJsonZodSchema().safeParse(_json);
        if (!_jsonSafeParseResult.success) { return purify.Left(_jsonSafeParseResult.error); }

        const _jsonObject = _jsonSafeParseResult.data;
        const _super0Either = QUDT_Concept._propertiesFromJson(_jsonObject);
        if (_super0Either.isLeft()) { return _super0Either; }

        const _super0 = _super0Either.unsafeCoerce()
        const identifier = (_jsonObject["@id"].startsWith("_:") ? dataFactory.blankNode(_jsonObject["@id"].substring(2)) : dataFactory.namedNode(_jsonObject["@id"]));
        const qudt_Prefix$j$altSymbol = _jsonObject["qudt_Prefix$j$altSymbol"].map(_item => (((_item.termType === "Literal") ? (dataFactory.literal(_item["@value"], typeof _item["@language"] !== "undefined" ? _item["@language"] : (typeof _item["@type"] !== "undefined" ? dataFactory.namedNode(_item["@type"]) : undefined))) : (((_item.termType === "NamedNode") ? (dataFactory.namedNode(_item["@id"])) : (dataFactory.blankNode(_item["@id"].substring(2))))))));
        const qudt_Prefix$j$latexSymbol = _jsonObject["qudt_Prefix$j$latexSymbol"];
        const qudt_Prefix$j$prefixMultiplier = purify.Maybe.fromNullable(_jsonObject["qudt_Prefix$j$prefixMultiplier"]);
        const qudt_Prefix$j$prefixMultiplierSN = purify.Maybe.fromNullable(_jsonObject["qudt_Prefix$j$prefixMultiplierSN"]);
        const qudt_Prefix$j$siExactMatch = purify.Maybe.fromNullable(_jsonObject["qudt_Prefix$j$siExactMatch"]).map(_item => (((_item.termType === "Literal") ? (dataFactory.literal(_item["@value"], typeof _item["@language"] !== "undefined" ? _item["@language"] : (typeof _item["@type"] !== "undefined" ? dataFactory.namedNode(_item["@type"]) : undefined))) : (((_item.termType === "NamedNode") ? (dataFactory.namedNode(_item["@id"])) : (dataFactory.blankNode(_item["@id"].substring(2))))))));
        const qudt_Prefix$j$symbol = purify.Maybe.fromNullable(_jsonObject["qudt_Prefix$j$symbol"]).map(_item => (((_item.termType === "Literal") ? (dataFactory.literal(_item["@value"], typeof _item["@language"] !== "undefined" ? _item["@language"] : (typeof _item["@type"] !== "undefined" ? dataFactory.namedNode(_item["@type"]) : undefined))) : (((_item.termType === "NamedNode") ? (dataFactory.namedNode(_item["@id"])) : (dataFactory.blankNode(_item["@id"].substring(2))))))));
        const qudt_Prefix$j$ucumCode = _jsonObject["qudt_Prefix$j$ucumCode"];
        return purify.Either.of({ ..._super0, identifier, qudt_Prefix$j$altSymbol, qudt_Prefix$j$latexSymbol, qudt_Prefix$j$prefixMultiplier, qudt_Prefix$j$prefixMultiplierSN, qudt_Prefix$j$siExactMatch, qudt_Prefix$j$symbol, qudt_Prefix$j$ucumCode })
    }

    export function fromJson(json: unknown): purify.Either<zod.ZodError, Prefix> {
        return (Binary_Prefix.fromJson(json) as purify.Either<zod.ZodError, Prefix>).altLazy(() => (Decimal_Prefix.fromJson(json) as purify.Either<zod.ZodError, Prefix>)).altLazy(() => Prefix._propertiesFromJson(json).map(properties => new Prefix(properties)));
    }

    export function _propertiesFromRdf({ ignoreRdfType: _ignoreRdfType, languageIn: _languageIn, resource: _resource,
        // @ts-ignore
        ..._context }: { [_index: string]: any; ignoreRdfType?: boolean; languageIn?: readonly string[]; resource: rdfjsResource.Resource; }): purify.Either<rdfjsResource.Resource.ValueError, { identifier: (rdfjs.BlankNode | rdfjs.NamedNode); qudt_Prefix$j$altSymbol: readonly ((rdfjs.BlankNode | rdfjs.NamedNode | rdfjs.Literal))[]; qudt_Prefix$j$latexSymbol: readonly (string)[]; qudt_Prefix$j$prefixMultiplier: purify.Maybe<number>; qudt_Prefix$j$prefixMultiplierSN: purify.Maybe<number>; qudt_Prefix$j$siExactMatch: purify.Maybe<(rdfjs.BlankNode | rdfjs.NamedNode | rdfjs.Literal)>; qudt_Prefix$j$symbol: purify.Maybe<(rdfjs.BlankNode | rdfjs.NamedNode | rdfjs.Literal)>; qudt_Prefix$j$ucumCode: readonly (string)[]; } & UnwrapR<ReturnType<typeof QUDT_Concept._propertiesFromRdf>>> {
        const _super0Either = QUDT_Concept._propertiesFromRdf({ ..._context, ignoreRdfType: true, languageIn: _languageIn, resource: _resource });
        if (_super0Either.isLeft()) { return _super0Either; }

        const _super0 = _super0Either.unsafeCoerce()
        if (!_ignoreRdfType && !_resource.isInstanceOf(dataFactory.namedNode("http://qudt.org/schema/qudt/Prefix"))) { return purify.Left(new rdfjsResource.Resource.ValueError({ focusResource: _resource, message: `${rdfjsResource.Resource.Identifier.toString(_resource.identifier)} has unexpected RDF type (expected http://qudt.org/schema/qudt/Prefix)`, predicate: dataFactory.namedNode("http://qudt.org/schema/qudt/Prefix") })); }

        const identifier = _resource.identifier
        const _qudt_Prefix$j$altSymbolEither: purify.Either<rdfjsResource.Resource.ValueError, readonly ((rdfjs.BlankNode | rdfjs.NamedNode | rdfjs.Literal))[]> = purify.Either.of([..._resource.values(dataFactory.namedNode("http://qudt.org/schema/qudt/altSymbol"), { unique: true }).flatMap(_item => _item.toValues().head().chain(_value => purify.Either.of(_value.toTerm())).toMaybe().toList())]);
        if (_qudt_Prefix$j$altSymbolEither.isLeft()) { return _qudt_Prefix$j$altSymbolEither; }

        const qudt_Prefix$j$altSymbol = _qudt_Prefix$j$altSymbolEither.unsafeCoerce();
        const _qudt_Prefix$j$latexSymbolEither: purify.Either<rdfjsResource.Resource.ValueError, readonly (string)[]> = purify.Either.of([..._resource.values(dataFactory.namedNode("http://qudt.org/schema/qudt/latexSymbol"), { unique: true }).flatMap(_item => _item.toValues().head().chain(_value => _value.toString()).toMaybe().toList())]);
        if (_qudt_Prefix$j$latexSymbolEither.isLeft()) { return _qudt_Prefix$j$latexSymbolEither; }

        const qudt_Prefix$j$latexSymbol = _qudt_Prefix$j$latexSymbolEither.unsafeCoerce();
        const _qudt_Prefix$j$prefixMultiplierEither: purify.Either<rdfjsResource.Resource.ValueError, purify.Maybe<number>> = purify.Either.of(_resource.values(dataFactory.namedNode("http://qudt.org/schema/qudt/prefixMultiplier"), { unique: true }).head().chain(_value => _value.toNumber()).toMaybe());
        if (_qudt_Prefix$j$prefixMultiplierEither.isLeft()) { return _qudt_Prefix$j$prefixMultiplierEither; }

        const qudt_Prefix$j$prefixMultiplier = _qudt_Prefix$j$prefixMultiplierEither.unsafeCoerce();
        const _qudt_Prefix$j$prefixMultiplierSNEither: purify.Either<rdfjsResource.Resource.ValueError, purify.Maybe<number>> = purify.Either.of(_resource.values(dataFactory.namedNode("http://qudt.org/schema/qudt/prefixMultiplierSN"), { unique: true }).head().chain(_value => _value.toNumber()).toMaybe());
        if (_qudt_Prefix$j$prefixMultiplierSNEither.isLeft()) { return _qudt_Prefix$j$prefixMultiplierSNEither; }

        const qudt_Prefix$j$prefixMultiplierSN = _qudt_Prefix$j$prefixMultiplierSNEither.unsafeCoerce();
        const _qudt_Prefix$j$siExactMatchEither: purify.Either<rdfjsResource.Resource.ValueError, purify.Maybe<(rdfjs.BlankNode | rdfjs.NamedNode | rdfjs.Literal)>> = purify.Either.of(_resource.values(dataFactory.namedNode("http://qudt.org/schema/qudt/siExactMatch"), { unique: true }).head().chain(_value => purify.Either.of(_value.toTerm())).toMaybe());
        if (_qudt_Prefix$j$siExactMatchEither.isLeft()) { return _qudt_Prefix$j$siExactMatchEither; }

        const qudt_Prefix$j$siExactMatch = _qudt_Prefix$j$siExactMatchEither.unsafeCoerce();
        const _qudt_Prefix$j$symbolEither: purify.Either<rdfjsResource.Resource.ValueError, purify.Maybe<(rdfjs.BlankNode | rdfjs.NamedNode | rdfjs.Literal)>> = purify.Either.of(_resource.values(dataFactory.namedNode("http://qudt.org/schema/qudt/symbol"), { unique: true }).head().chain(_value => purify.Either.of(_value.toTerm())).toMaybe());
        if (_qudt_Prefix$j$symbolEither.isLeft()) { return _qudt_Prefix$j$symbolEither; }

        const qudt_Prefix$j$symbol = _qudt_Prefix$j$symbolEither.unsafeCoerce();
        const _qudt_Prefix$j$ucumCodeEither: purify.Either<rdfjsResource.Resource.ValueError, readonly (string)[]> = purify.Either.of([..._resource.values(dataFactory.namedNode("http://qudt.org/schema/qudt/ucumCode"), { unique: true }).flatMap(_item => _item.toValues().head().chain(_value => _value.toString()).toMaybe().toList())]);
        if (_qudt_Prefix$j$ucumCodeEither.isLeft()) { return _qudt_Prefix$j$ucumCodeEither; }

        const qudt_Prefix$j$ucumCode = _qudt_Prefix$j$ucumCodeEither.unsafeCoerce();
        return purify.Either.of({ ..._super0, identifier, qudt_Prefix$j$altSymbol, qudt_Prefix$j$latexSymbol, qudt_Prefix$j$prefixMultiplier, qudt_Prefix$j$prefixMultiplierSN, qudt_Prefix$j$siExactMatch, qudt_Prefix$j$symbol, qudt_Prefix$j$ucumCode })
    }

    export function fromRdf(parameters: Parameters<typeof Prefix._propertiesFromRdf>[0]): purify.Either<rdfjsResource.Resource.ValueError, Prefix> {
        const { ignoreRdfType: _ignoreRdfType, ...otherParameters } = parameters
        return (Binary_Prefix.fromRdf(otherParameters) as purify.Either<rdfjsResource.Resource.ValueError, Prefix>).altLazy(() => (Decimal_Prefix.fromRdf(otherParameters) as purify.Either<rdfjsResource.Resource.ValueError, Prefix>)).altLazy(() => Prefix._propertiesFromRdf(parameters).map(properties => new Prefix(properties)));
    }

    export let fromRdfType: rdfjs.NamedNode<string> = dataFactory.namedNode("http://qudt.org/schema/qudt/Prefix");

    export function jsonSchema() {
        return zodToJsonSchema(prefixJsonZodSchema());
    }

    export function prefixJsonUiSchema(parameters?: { scopePrefix?: string }) {
        const scopePrefix = parameters?.scopePrefix ?? "#";
        return { "elements": [ QUDT_Concept.qudtConceptJsonUiSchema({ scopePrefix }), { scope: `${scopePrefix}/properties/qudt_Prefix$j$altSymbol`, type: "Control" }, { scope: `${scopePrefix}/properties/qudt_Prefix$j$latexSymbol`, type: "Control" }, { scope: `${scopePrefix}/properties/qudt_Prefix$j$prefixMultiplier`, type: "Control" }, { scope: `${scopePrefix}/properties/qudt_Prefix$j$prefixMultiplierSN`, type: "Control" }, { scope: `${scopePrefix}/properties/qudt_Prefix$j$siExactMatch`, type: "Control" }, { scope: `${scopePrefix}/properties/qudt_Prefix$j$symbol`, type: "Control" }, { scope: `${scopePrefix}/properties/qudt_Prefix$j$ucumCode`, type: "Control" } ], label: "Prefix", type: "Group" }
    }

    export function prefixJsonZodSchema() {
        return QUDT_Concept.qudtConceptJsonZodSchema().merge(zod.object({ "@id": zod.string().min(1),"type": zod.enum(["Binary_Prefix","Decimal_Prefix","Prefix"]),"qudt_Prefix$j$altSymbol": zod.discriminatedUnion("termType", [zod.object({ "@id": zod.string().min(1), termType: zod.literal("BlankNode") }), zod.object({ "@id": zod.string().min(1), termType: zod.literal("NamedNode") }), zod.object({ "@language": zod.string().optional(), "@type": zod.string().optional(), "@value": zod.string(), termType: zod.literal("Literal") })]).array(),"qudt_Prefix$j$latexSymbol": zod.string().array(),"qudt_Prefix$j$prefixMultiplier": zod.number().optional(),"qudt_Prefix$j$prefixMultiplierSN": zod.number().optional(),"qudt_Prefix$j$siExactMatch": zod.discriminatedUnion("termType", [zod.object({ "@id": zod.string().min(1), termType: zod.literal("BlankNode") }), zod.object({ "@id": zod.string().min(1), termType: zod.literal("NamedNode") }), zod.object({ "@language": zod.string().optional(), "@type": zod.string().optional(), "@value": zod.string(), termType: zod.literal("Literal") })]).optional(),"qudt_Prefix$j$symbol": zod.discriminatedUnion("termType", [zod.object({ "@id": zod.string().min(1), termType: zod.literal("BlankNode") }), zod.object({ "@id": zod.string().min(1), termType: zod.literal("NamedNode") }), zod.object({ "@language": zod.string().optional(), "@type": zod.string().optional(), "@value": zod.string(), termType: zod.literal("Literal") })]).optional(),"qudt_Prefix$j$ucumCode": zod.string().array() }));
    }

    export function sparqlConstructQuery(parameters?: { ignoreRdfType?: boolean; prefixes?: { [prefix: string]: string }; subject?: sparqljs.Triple["subject"]; } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type">): sparqljs.ConstructQuery {
        const { ignoreRdfType, subject, ...queryParameters } = parameters ?? {}

        return { ...queryParameters, prefixes: parameters?.prefixes ?? {}, queryType: "CONSTRUCT", template: (queryParameters.template ?? []).concat(Prefix.sparqlConstructTemplateTriples({ ignoreRdfType, subject })), type: "query", where: (queryParameters.where ?? []).concat(Prefix.sparqlWherePatterns({ ignoreRdfType, subject })) };
    }

    export function sparqlConstructQueryString(parameters?: { ignoreRdfType?: boolean; subject?: sparqljs.Triple["subject"]; variablePrefix?: string; } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type"> & sparqljs.GeneratorOptions): string {
        return new sparqljs.Generator(parameters).stringify(Prefix.sparqlConstructQuery(parameters));
    }

    export function sparqlConstructTemplateTriples(parameters?: { ignoreRdfType?: boolean; subject?: sparqljs.Triple["subject"], variablePrefix?: string }): readonly sparqljs.Triple[] {
        const subject = parameters?.subject ?? dataFactory.variable!("prefix");
        const variablePrefix = parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "prefix");
        return [...QUDT_Concept.sparqlConstructTemplateTriples({ ignoreRdfType: true, subject, variablePrefix }), ...(parameters?.ignoreRdfType ? [] : [{ subject, predicate: dataFactory.namedNode("http://www.w3.org/1999/02/22-rdf-syntax-ns#type"), object: dataFactory.variable!(`${variablePrefix}RdfType`) }]), { object: dataFactory.variable!(`${variablePrefix}QudtPrefixJAltSymbol`), predicate: dataFactory.namedNode("http://qudt.org/schema/qudt/altSymbol"), subject }, { object: dataFactory.variable!(`${variablePrefix}QudtPrefixJLatexSymbol`), predicate: dataFactory.namedNode("http://qudt.org/schema/qudt/latexSymbol"), subject }, { object: dataFactory.variable!(`${variablePrefix}QudtPrefixJPrefixMultiplier`), predicate: dataFactory.namedNode("http://qudt.org/schema/qudt/prefixMultiplier"), subject }, { object: dataFactory.variable!(`${variablePrefix}QudtPrefixJPrefixMultiplierSn`), predicate: dataFactory.namedNode("http://qudt.org/schema/qudt/prefixMultiplierSN"), subject }, { object: dataFactory.variable!(`${variablePrefix}QudtPrefixJSiExactMatch`), predicate: dataFactory.namedNode("http://qudt.org/schema/qudt/siExactMatch"), subject }, { object: dataFactory.variable!(`${variablePrefix}QudtPrefixJSymbol`), predicate: dataFactory.namedNode("http://qudt.org/schema/qudt/symbol"), subject }, { object: dataFactory.variable!(`${variablePrefix}QudtPrefixJUcumCode`), predicate: dataFactory.namedNode("http://qudt.org/schema/qudt/ucumCode"), subject }];
    }

    export function sparqlWherePatterns(parameters: { ignoreRdfType?: boolean; subject?: sparqljs.Triple["subject"], variablePrefix?: string }): readonly sparqljs.Pattern[] {
        const subject = parameters?.subject ?? dataFactory.variable!("prefix");
        const variablePrefix = parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "prefix");
        return [...QUDT_Concept.sparqlWherePatterns({ ignoreRdfType: true, subject, variablePrefix }), ...(parameters?.ignoreRdfType ? [] : [{ triples: [{ subject, predicate: dataFactory.namedNode("http://www.w3.org/1999/02/22-rdf-syntax-ns#type"), object: dataFactory.namedNode("http://qudt.org/schema/qudt/Prefix") }], type: "bgp" as const }, { triples: [{ subject, predicate: dataFactory.namedNode("http://www.w3.org/1999/02/22-rdf-syntax-ns#type"), object: dataFactory.variable!(`${variablePrefix}RdfType`) }], type: "bgp" as const }]), { patterns: [{ triples: [{ object: dataFactory.variable!(`${variablePrefix}QudtPrefixJAltSymbol`), predicate: dataFactory.namedNode("http://qudt.org/schema/qudt/altSymbol"), subject }], type: "bgp" }], type: "optional" }, { patterns: [{ triples: [{ object: dataFactory.variable!(`${variablePrefix}QudtPrefixJLatexSymbol`), predicate: dataFactory.namedNode("http://qudt.org/schema/qudt/latexSymbol"), subject }], type: "bgp" }], type: "optional" }, { patterns: [{ triples: [{ object: dataFactory.variable!(`${variablePrefix}QudtPrefixJPrefixMultiplier`), predicate: dataFactory.namedNode("http://qudt.org/schema/qudt/prefixMultiplier"), subject }], type: "bgp" }], type: "optional" }, { patterns: [{ triples: [{ object: dataFactory.variable!(`${variablePrefix}QudtPrefixJPrefixMultiplierSn`), predicate: dataFactory.namedNode("http://qudt.org/schema/qudt/prefixMultiplierSN"), subject }], type: "bgp" }], type: "optional" }, { patterns: [{ triples: [{ object: dataFactory.variable!(`${variablePrefix}QudtPrefixJSiExactMatch`), predicate: dataFactory.namedNode("http://qudt.org/schema/qudt/siExactMatch"), subject }], type: "bgp" }], type: "optional" }, { patterns: [{ triples: [{ object: dataFactory.variable!(`${variablePrefix}QudtPrefixJSymbol`), predicate: dataFactory.namedNode("http://qudt.org/schema/qudt/symbol"), subject }], type: "bgp" }], type: "optional" }, { patterns: [{ triples: [{ object: dataFactory.variable!(`${variablePrefix}QudtPrefixJUcumCode`), predicate: dataFactory.namedNode("http://qudt.org/schema/qudt/ucumCode"), subject }], type: "bgp" }], type: "optional" }];
    }
}
/**
 * Decimal Prefix
 */
export class Decimal_Prefix extends Prefix {
    override readonly type = "Decimal_Prefix";

    // biome-ignore lint/complexity/noUselessConstructor: Always have a constructor
    constructor(parameters: { readonly identifier?: (rdfjs.BlankNode | rdfjs.NamedNode) | string } & ConstructorParameters<typeof Prefix>[0]) {
        super(parameters);
    }

    override get identifier(): (rdfjs.BlankNode | rdfjs.NamedNode) {
        if (typeof this._identifier === "undefined") { this._identifier = dataFactory.blankNode(); } return this._identifier;
    }

    override toRdf({ ignoreRdfType, mutateGraph, resourceSet }: { ignoreRdfType?: boolean; mutateGraph?: rdfjsResource.MutableResource.MutateGraph, resourceSet: rdfjsResource.MutableResourceSet }): rdfjsResource.MutableResource {
        const _resource = super.toRdf({ ignoreRdfType: true, mutateGraph, resourceSet });
        if (!ignoreRdfType) { _resource.add(_resource.dataFactory.namedNode("http://www.w3.org/1999/02/22-rdf-syntax-ns#type"), _resource.dataFactory.namedNode("http://qudt.org/schema/qudt/DecimalPrefix")); }

        return _resource;
    }

    override toString(): string {
        return JSON.stringify(this.toJson());
    }
}

export namespace Decimal_Prefix {
    export function _propertiesFromJson(_json: unknown): purify.Either<zod.ZodError, { identifier: (rdfjs.BlankNode | rdfjs.NamedNode); } & UnwrapR<ReturnType<typeof Prefix._propertiesFromJson>>> {
        const _jsonSafeParseResult = decimalPrefixJsonZodSchema().safeParse(_json);
        if (!_jsonSafeParseResult.success) { return purify.Left(_jsonSafeParseResult.error); }

        const _jsonObject = _jsonSafeParseResult.data;
        const _super0Either = Prefix._propertiesFromJson(_jsonObject);
        if (_super0Either.isLeft()) { return _super0Either; }

        const _super0 = _super0Either.unsafeCoerce()
        const identifier = (_jsonObject["@id"].startsWith("_:") ? dataFactory.blankNode(_jsonObject["@id"].substring(2)) : dataFactory.namedNode(_jsonObject["@id"]));
        return purify.Either.of({ ..._super0, identifier })
    }

    export function fromJson(json: unknown): purify.Either<zod.ZodError, Decimal_Prefix> {
        return Decimal_Prefix._propertiesFromJson(json).map(properties => new Decimal_Prefix(properties));
    }

    export function _propertiesFromRdf({ ignoreRdfType: _ignoreRdfType, languageIn: _languageIn, resource: _resource,
        // @ts-ignore
        ..._context }: { [_index: string]: any; ignoreRdfType?: boolean; languageIn?: readonly string[]; resource: rdfjsResource.Resource; }): purify.Either<rdfjsResource.Resource.ValueError, { identifier: (rdfjs.BlankNode | rdfjs.NamedNode); } & UnwrapR<ReturnType<typeof Prefix._propertiesFromRdf>>> {
        const _super0Either = Prefix._propertiesFromRdf({ ..._context, ignoreRdfType: true, languageIn: _languageIn, resource: _resource });
        if (_super0Either.isLeft()) { return _super0Either; }

        const _super0 = _super0Either.unsafeCoerce()
        if (!_ignoreRdfType && !_resource.isInstanceOf(dataFactory.namedNode("http://qudt.org/schema/qudt/DecimalPrefix"))) { return purify.Left(new rdfjsResource.Resource.ValueError({ focusResource: _resource, message: `${rdfjsResource.Resource.Identifier.toString(_resource.identifier)} has unexpected RDF type (expected http://qudt.org/schema/qudt/DecimalPrefix)`, predicate: dataFactory.namedNode("http://qudt.org/schema/qudt/DecimalPrefix") })); }

        const identifier = _resource.identifier
        return purify.Either.of({ ..._super0, identifier })
    }

    export function fromRdf(parameters: Parameters<typeof Decimal_Prefix._propertiesFromRdf>[0]): purify.Either<rdfjsResource.Resource.ValueError, Decimal_Prefix> {
        return Decimal_Prefix._propertiesFromRdf(parameters).map(properties => new Decimal_Prefix(properties));
    }

    export let fromRdfType: rdfjs.NamedNode<string> = dataFactory.namedNode("http://qudt.org/schema/qudt/DecimalPrefix");

    export function jsonSchema() {
        return zodToJsonSchema(decimalPrefixJsonZodSchema());
    }

    export function decimalPrefixJsonUiSchema(parameters?: { scopePrefix?: string }) {
        const scopePrefix = parameters?.scopePrefix ?? "#";
        return { "elements": [ Prefix.prefixJsonUiSchema({ scopePrefix }) ], label: "Decimal Prefix", type: "Group" }
    }

    export function decimalPrefixJsonZodSchema() {
        return Prefix.prefixJsonZodSchema().merge(zod.object({ "@id": zod.string().min(1),"type": zod.literal("Decimal_Prefix") }));
    }

    export function sparqlConstructQuery(parameters?: { ignoreRdfType?: boolean; prefixes?: { [prefix: string]: string }; subject?: sparqljs.Triple["subject"]; } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type">): sparqljs.ConstructQuery {
        const { ignoreRdfType, subject, ...queryParameters } = parameters ?? {}

        return { ...queryParameters, prefixes: parameters?.prefixes ?? {}, queryType: "CONSTRUCT", template: (queryParameters.template ?? []).concat(Decimal_Prefix.sparqlConstructTemplateTriples({ ignoreRdfType, subject })), type: "query", where: (queryParameters.where ?? []).concat(Decimal_Prefix.sparqlWherePatterns({ ignoreRdfType, subject })) };
    }

    export function sparqlConstructQueryString(parameters?: { ignoreRdfType?: boolean; subject?: sparqljs.Triple["subject"]; variablePrefix?: string; } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type"> & sparqljs.GeneratorOptions): string {
        return new sparqljs.Generator(parameters).stringify(Decimal_Prefix.sparqlConstructQuery(parameters));
    }

    export function sparqlConstructTemplateTriples(parameters?: { ignoreRdfType?: boolean; subject?: sparqljs.Triple["subject"], variablePrefix?: string }): readonly sparqljs.Triple[] {
        const subject = parameters?.subject ?? dataFactory.variable!("decimalPrefix");
        const variablePrefix = parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "decimalPrefix");
        return [...Prefix.sparqlConstructTemplateTriples({ ignoreRdfType: true, subject, variablePrefix }), ...(parameters?.ignoreRdfType ? [] : [{ subject, predicate: dataFactory.namedNode("http://www.w3.org/1999/02/22-rdf-syntax-ns#type"), object: dataFactory.variable!(`${variablePrefix}RdfType`) }])];
    }

    export function sparqlWherePatterns(parameters: { ignoreRdfType?: boolean; subject?: sparqljs.Triple["subject"], variablePrefix?: string }): readonly sparqljs.Pattern[] {
        const subject = parameters?.subject ?? dataFactory.variable!("decimalPrefix");
        const variablePrefix = parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "decimalPrefix");
        return [...Prefix.sparqlWherePatterns({ ignoreRdfType: true, subject, variablePrefix }), ...(parameters?.ignoreRdfType ? [] : [{ triples: [{ subject, predicate: dataFactory.namedNode("http://www.w3.org/1999/02/22-rdf-syntax-ns#type"), object: dataFactory.namedNode("http://qudt.org/schema/qudt/DecimalPrefix") }], type: "bgp" as const }, { triples: [{ subject, predicate: dataFactory.namedNode("http://www.w3.org/1999/02/22-rdf-syntax-ns#type"), object: dataFactory.variable!(`${variablePrefix}RdfType`) }], type: "bgp" as const }])];
    }
}
/**
 * Data Item
 */
export class Data_Item extends QUDT_Concept {
    override readonly type = "Data_Item";
    readonly qudt_DataItem$j$value: purify.Maybe<(rdfjs.BlankNode | rdfjs.NamedNode | rdfjs.Literal)>;

    constructor(parameters: { readonly identifier?: (rdfjs.BlankNode | rdfjs.NamedNode) | string, readonly qudt_DataItem$j$value?: (rdfjs.BlankNode | rdfjs.NamedNode | rdfjs.Literal) | Date | boolean | number | purify.Maybe<(rdfjs.BlankNode | rdfjs.NamedNode | rdfjs.Literal)> | string } & ConstructorParameters<typeof QUDT_Concept>[0]) {
        super(parameters);
        if (purify.Maybe.isMaybe(parameters.qudt_DataItem$j$value)) { this.qudt_DataItem$j$value = parameters.qudt_DataItem$j$value; } else if (typeof parameters.qudt_DataItem$j$value === "boolean") { this.qudt_DataItem$j$value = purify.Maybe.of(rdfLiteral.toRdf(parameters.qudt_DataItem$j$value, { dataFactory })); } else if (typeof parameters.qudt_DataItem$j$value === "object" && parameters.qudt_DataItem$j$value instanceof Date) { this.qudt_DataItem$j$value = purify.Maybe.of(rdfLiteral.toRdf(parameters.qudt_DataItem$j$value, { dataFactory })); } else if (typeof parameters.qudt_DataItem$j$value === "number") { this.qudt_DataItem$j$value = purify.Maybe.of(rdfLiteral.toRdf(parameters.qudt_DataItem$j$value, { dataFactory })); } else if (typeof parameters.qudt_DataItem$j$value === "string") { this.qudt_DataItem$j$value = purify.Maybe.of(dataFactory.literal(parameters.qudt_DataItem$j$value)); } else if (typeof parameters.qudt_DataItem$j$value === "object") { this.qudt_DataItem$j$value = purify.Maybe.of(parameters.qudt_DataItem$j$value); } else if (typeof parameters.qudt_DataItem$j$value === "undefined") { this.qudt_DataItem$j$value = purify.Maybe.empty(); } else { this.qudt_DataItem$j$value =( parameters.qudt_DataItem$j$value) as never;
         }
    }

    override get identifier(): (rdfjs.BlankNode | rdfjs.NamedNode) {
        if (typeof this._identifier === "undefined") { this._identifier = dataFactory.blankNode(); } return this._identifier;
    }

    override equals(other: Data_Item): EqualsResult {
        return super.equals(other).chain(() => (((left, right) => maybeEquals(left, right, booleanEquals)))(this.qudt_DataItem$j$value, other.qudt_DataItem$j$value).mapLeft(propertyValuesUnequal => ({ left: this, right: other, propertyName: "qudt_DataItem$j$value", propertyValuesUnequal, type: "Property" as const })));
    }

    override hash<HasherT extends { update: (message: string | number[] | ArrayBuffer | Uint8Array) => void; }>(_hasher: HasherT): HasherT {
        this.hashShaclProperties(_hasher);
        return _hasher;
    }

    protected override hashShaclProperties<HasherT extends { update: (message: string | number[] | ArrayBuffer | Uint8Array) => void; }>(_hasher: HasherT): HasherT {
        super.hashShaclProperties(_hasher);
        this.qudt_DataItem$j$value.ifJust((_value0) => { _hasher.update(_value0.termType);
        _hasher.update(_value0.value); })
        return _hasher;
    }

    override toJson(): { readonly "qudt_DataItem$j$value": ({ readonly "@id": string, readonly termType: "BlankNode" | "NamedNode" } | { readonly "@language": string | undefined, readonly "@type": string | undefined, readonly "@value": string, readonly termType: "Literal" }) | undefined } & ReturnType<QUDT_Concept["toJson"]> {
        return JSON.parse(JSON.stringify({ ...super.toJson(),qudt_DataItem$j$value: this.qudt_DataItem$j$value.map(_item => ((_item.termType === "Literal") ? { "@language": _item.language.length > 0 ? _item.language : undefined, "@type": _item.datatype.value !== "http://www.w3.org/2001/XMLSchema#string" ? _item.datatype.value : undefined, "@value": _item.value, termType: "Literal" as const } : (_item.termType === "NamedNode") ? { "@id": _item.value, termType: "NamedNode" as const } : { "@id": `_:${_item.value}`, termType: "BlankNode" as const })).extract() } satisfies ReturnType<Data_Item["toJson"]>));
    }

    override toRdf({ ignoreRdfType, mutateGraph, resourceSet }: { ignoreRdfType?: boolean; mutateGraph?: rdfjsResource.MutableResource.MutateGraph, resourceSet: rdfjsResource.MutableResourceSet }): rdfjsResource.MutableResource {
        const _resource = super.toRdf({ ignoreRdfType: true, mutateGraph, resourceSet });
        if (!ignoreRdfType) { _resource.add(_resource.dataFactory.namedNode("http://www.w3.org/1999/02/22-rdf-syntax-ns#type"), _resource.dataFactory.namedNode("http://qudt.org/schema/qudt/DataItem")); }

        _resource.add(dataFactory.namedNode("http://qudt.org/schema/qudt/value"), this.qudt_DataItem$j$value);
        return _resource;
    }

    override toString(): string {
        return JSON.stringify(this.toJson());
    }
}

export namespace Data_Item {
    export function _propertiesFromJson(_json: unknown): purify.Either<zod.ZodError, { identifier: (rdfjs.BlankNode | rdfjs.NamedNode); qudt_DataItem$j$value: purify.Maybe<(rdfjs.BlankNode | rdfjs.NamedNode | rdfjs.Literal)>; } & UnwrapR<ReturnType<typeof QUDT_Concept._propertiesFromJson>>> {
        const _jsonSafeParseResult = dataItemJsonZodSchema().safeParse(_json);
        if (!_jsonSafeParseResult.success) { return purify.Left(_jsonSafeParseResult.error); }

        const _jsonObject = _jsonSafeParseResult.data;
        const _super0Either = QUDT_Concept._propertiesFromJson(_jsonObject);
        if (_super0Either.isLeft()) { return _super0Either; }

        const _super0 = _super0Either.unsafeCoerce()
        const identifier = (_jsonObject["@id"].startsWith("_:") ? dataFactory.blankNode(_jsonObject["@id"].substring(2)) : dataFactory.namedNode(_jsonObject["@id"]));
        const qudt_DataItem$j$value = purify.Maybe.fromNullable(_jsonObject["qudt_DataItem$j$value"]).map(_item => (((_item.termType === "Literal") ? (dataFactory.literal(_item["@value"], typeof _item["@language"] !== "undefined" ? _item["@language"] : (typeof _item["@type"] !== "undefined" ? dataFactory.namedNode(_item["@type"]) : undefined))) : (((_item.termType === "NamedNode") ? (dataFactory.namedNode(_item["@id"])) : (dataFactory.blankNode(_item["@id"].substring(2))))))));
        return purify.Either.of({ ..._super0, identifier, qudt_DataItem$j$value })
    }

    export function fromJson(json: unknown): purify.Either<zod.ZodError, Data_Item> {
        return Data_Item._propertiesFromJson(json).map(properties => new Data_Item(properties));
    }

    export function _propertiesFromRdf({ ignoreRdfType: _ignoreRdfType, languageIn: _languageIn, resource: _resource,
        // @ts-ignore
        ..._context }: { [_index: string]: any; ignoreRdfType?: boolean; languageIn?: readonly string[]; resource: rdfjsResource.Resource; }): purify.Either<rdfjsResource.Resource.ValueError, { identifier: (rdfjs.BlankNode | rdfjs.NamedNode); qudt_DataItem$j$value: purify.Maybe<(rdfjs.BlankNode | rdfjs.NamedNode | rdfjs.Literal)>; } & UnwrapR<ReturnType<typeof QUDT_Concept._propertiesFromRdf>>> {
        const _super0Either = QUDT_Concept._propertiesFromRdf({ ..._context, ignoreRdfType: true, languageIn: _languageIn, resource: _resource });
        if (_super0Either.isLeft()) { return _super0Either; }

        const _super0 = _super0Either.unsafeCoerce()
        if (!_ignoreRdfType && !_resource.isInstanceOf(dataFactory.namedNode("http://qudt.org/schema/qudt/DataItem"))) { return purify.Left(new rdfjsResource.Resource.ValueError({ focusResource: _resource, message: `${rdfjsResource.Resource.Identifier.toString(_resource.identifier)} has unexpected RDF type (expected http://qudt.org/schema/qudt/DataItem)`, predicate: dataFactory.namedNode("http://qudt.org/schema/qudt/DataItem") })); }

        const identifier = _resource.identifier
        const _qudt_DataItem$j$valueEither: purify.Either<rdfjsResource.Resource.ValueError, purify.Maybe<(rdfjs.BlankNode | rdfjs.NamedNode | rdfjs.Literal)>> = purify.Either.of(_resource.values(dataFactory.namedNode("http://qudt.org/schema/qudt/value"), { unique: true }).head().chain(_value => purify.Either.of(_value.toTerm())).toMaybe());
        if (_qudt_DataItem$j$valueEither.isLeft()) { return _qudt_DataItem$j$valueEither; }

        const qudt_DataItem$j$value = _qudt_DataItem$j$valueEither.unsafeCoerce();
        return purify.Either.of({ ..._super0, identifier, qudt_DataItem$j$value })
    }

    export function fromRdf(parameters: Parameters<typeof Data_Item._propertiesFromRdf>[0]): purify.Either<rdfjsResource.Resource.ValueError, Data_Item> {
        return Data_Item._propertiesFromRdf(parameters).map(properties => new Data_Item(properties));
    }

    export let fromRdfType: rdfjs.NamedNode<string> = dataFactory.namedNode("http://qudt.org/schema/qudt/DataItem");

    export function jsonSchema() {
        return zodToJsonSchema(dataItemJsonZodSchema());
    }

    export function dataItemJsonUiSchema(parameters?: { scopePrefix?: string }) {
        const scopePrefix = parameters?.scopePrefix ?? "#";
        return { "elements": [ QUDT_Concept.qudtConceptJsonUiSchema({ scopePrefix }), { scope: `${scopePrefix}/properties/qudt_DataItem$j$value`, type: "Control" } ], label: "Data Item", type: "Group" }
    }

    export function dataItemJsonZodSchema() {
        return QUDT_Concept.qudtConceptJsonZodSchema().merge(zod.object({ "@id": zod.string().min(1),"type": zod.literal("Data_Item"),"qudt_DataItem$j$value": zod.discriminatedUnion("termType", [zod.object({ "@id": zod.string().min(1), termType: zod.literal("BlankNode") }), zod.object({ "@id": zod.string().min(1), termType: zod.literal("NamedNode") }), zod.object({ "@language": zod.string().optional(), "@type": zod.string().optional(), "@value": zod.string(), termType: zod.literal("Literal") })]).optional() }));
    }

    export function sparqlConstructQuery(parameters?: { ignoreRdfType?: boolean; prefixes?: { [prefix: string]: string }; subject?: sparqljs.Triple["subject"]; } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type">): sparqljs.ConstructQuery {
        const { ignoreRdfType, subject, ...queryParameters } = parameters ?? {}

        return { ...queryParameters, prefixes: parameters?.prefixes ?? {}, queryType: "CONSTRUCT", template: (queryParameters.template ?? []).concat(Data_Item.sparqlConstructTemplateTriples({ ignoreRdfType, subject })), type: "query", where: (queryParameters.where ?? []).concat(Data_Item.sparqlWherePatterns({ ignoreRdfType, subject })) };
    }

    export function sparqlConstructQueryString(parameters?: { ignoreRdfType?: boolean; subject?: sparqljs.Triple["subject"]; variablePrefix?: string; } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type"> & sparqljs.GeneratorOptions): string {
        return new sparqljs.Generator(parameters).stringify(Data_Item.sparqlConstructQuery(parameters));
    }

    export function sparqlConstructTemplateTriples(parameters?: { ignoreRdfType?: boolean; subject?: sparqljs.Triple["subject"], variablePrefix?: string }): readonly sparqljs.Triple[] {
        const subject = parameters?.subject ?? dataFactory.variable!("dataItem");
        const variablePrefix = parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "dataItem");
        return [...QUDT_Concept.sparqlConstructTemplateTriples({ ignoreRdfType: true, subject, variablePrefix }), ...(parameters?.ignoreRdfType ? [] : [{ subject, predicate: dataFactory.namedNode("http://www.w3.org/1999/02/22-rdf-syntax-ns#type"), object: dataFactory.variable!(`${variablePrefix}RdfType`) }]), { object: dataFactory.variable!(`${variablePrefix}QudtDataItemJValue`), predicate: dataFactory.namedNode("http://qudt.org/schema/qudt/value"), subject }];
    }

    export function sparqlWherePatterns(parameters: { ignoreRdfType?: boolean; subject?: sparqljs.Triple["subject"], variablePrefix?: string }): readonly sparqljs.Pattern[] {
        const subject = parameters?.subject ?? dataFactory.variable!("dataItem");
        const variablePrefix = parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "dataItem");
        return [...QUDT_Concept.sparqlWherePatterns({ ignoreRdfType: true, subject, variablePrefix }), ...(parameters?.ignoreRdfType ? [] : [{ triples: [{ subject, predicate: dataFactory.namedNode("http://www.w3.org/1999/02/22-rdf-syntax-ns#type"), object: dataFactory.namedNode("http://qudt.org/schema/qudt/DataItem") }], type: "bgp" as const }, { triples: [{ subject, predicate: dataFactory.namedNode("http://www.w3.org/1999/02/22-rdf-syntax-ns#type"), object: dataFactory.variable!(`${variablePrefix}RdfType`) }], type: "bgp" as const }]), { patterns: [{ triples: [{ object: dataFactory.variable!(`${variablePrefix}QudtDataItemJValue`), predicate: dataFactory.namedNode("http://qudt.org/schema/qudt/value"), subject }], type: "bgp" }], type: "optional" }];
    }
}
/**
 * Currency Unit
 */
export class Currency_Unit extends Dimensionless_Unit {
    override readonly type = "Currency_Unit";
    readonly qudt_CurrencyUnit$j$currencyCode: readonly (string)[];
    readonly qudt_CurrencyUnit$j$currencyExponent: readonly (number)[];
    readonly qudt_CurrencyUnit$j$currencyNumber: readonly (string)[];

    constructor(parameters: { readonly identifier?: (rdfjs.BlankNode | rdfjs.NamedNode) | string, readonly qudt_CurrencyUnit$j$currencyCode?: readonly (string)[], readonly qudt_CurrencyUnit$j$currencyExponent?: readonly (number)[], readonly qudt_CurrencyUnit$j$currencyNumber?: readonly (string)[] } & ConstructorParameters<typeof Dimensionless_Unit>[0]) {
        super(parameters);
        if (typeof parameters.qudt_CurrencyUnit$j$currencyCode === "undefined") { this.qudt_CurrencyUnit$j$currencyCode = []; } else if (Array.isArray(parameters.qudt_CurrencyUnit$j$currencyCode)) { this.qudt_CurrencyUnit$j$currencyCode = parameters.qudt_CurrencyUnit$j$currencyCode; } else { this.qudt_CurrencyUnit$j$currencyCode =( parameters.qudt_CurrencyUnit$j$currencyCode) as never;
         }

        if (typeof parameters.qudt_CurrencyUnit$j$currencyExponent === "undefined") { this.qudt_CurrencyUnit$j$currencyExponent = []; } else if (Array.isArray(parameters.qudt_CurrencyUnit$j$currencyExponent)) { this.qudt_CurrencyUnit$j$currencyExponent = parameters.qudt_CurrencyUnit$j$currencyExponent; } else { this.qudt_CurrencyUnit$j$currencyExponent =( parameters.qudt_CurrencyUnit$j$currencyExponent) as never;
         }

        if (typeof parameters.qudt_CurrencyUnit$j$currencyNumber === "undefined") { this.qudt_CurrencyUnit$j$currencyNumber = []; } else if (Array.isArray(parameters.qudt_CurrencyUnit$j$currencyNumber)) { this.qudt_CurrencyUnit$j$currencyNumber = parameters.qudt_CurrencyUnit$j$currencyNumber; } else { this.qudt_CurrencyUnit$j$currencyNumber =( parameters.qudt_CurrencyUnit$j$currencyNumber) as never;
         }
    }

    override get identifier(): (rdfjs.BlankNode | rdfjs.NamedNode) {
        if (typeof this._identifier === "undefined") { this._identifier = dataFactory.blankNode(); } return this._identifier;
    }

    override equals(other: Currency_Unit): EqualsResult {
        return super.equals(other).chain(() => (((left, right) => arrayEquals(left, right, strictEquals)))(this.qudt_CurrencyUnit$j$currencyCode, other.qudt_CurrencyUnit$j$currencyCode).mapLeft(propertyValuesUnequal => ({ left: this, right: other, propertyName: "qudt_CurrencyUnit$j$currencyCode", propertyValuesUnequal, type: "Property" as const }))).chain(() => (((left, right) => arrayEquals(left, right, strictEquals)))(this.qudt_CurrencyUnit$j$currencyExponent, other.qudt_CurrencyUnit$j$currencyExponent).mapLeft(propertyValuesUnequal => ({ left: this, right: other, propertyName: "qudt_CurrencyUnit$j$currencyExponent", propertyValuesUnequal, type: "Property" as const }))).chain(() => (((left, right) => arrayEquals(left, right, strictEquals)))(this.qudt_CurrencyUnit$j$currencyNumber, other.qudt_CurrencyUnit$j$currencyNumber).mapLeft(propertyValuesUnequal => ({ left: this, right: other, propertyName: "qudt_CurrencyUnit$j$currencyNumber", propertyValuesUnequal, type: "Property" as const })));
    }

    override hash<HasherT extends { update: (message: string | number[] | ArrayBuffer | Uint8Array) => void; }>(_hasher: HasherT): HasherT {
        this.hashShaclProperties(_hasher);
        return _hasher;
    }

    protected override hashShaclProperties<HasherT extends { update: (message: string | number[] | ArrayBuffer | Uint8Array) => void; }>(_hasher: HasherT): HasherT {
        super.hashShaclProperties(_hasher);
        for (const _item0 of this.qudt_CurrencyUnit$j$currencyCode) { _hasher.update(_item0); }

        for (const _item0 of this.qudt_CurrencyUnit$j$currencyExponent) { _hasher.update(_item0.toString()); }

        for (const _item0 of this.qudt_CurrencyUnit$j$currencyNumber) { _hasher.update(_item0); }

        return _hasher;
    }

    override toJson(): { readonly "qudt_CurrencyUnit$j$currencyCode": readonly (string)[]; readonly "qudt_CurrencyUnit$j$currencyExponent": readonly (number)[]; readonly "qudt_CurrencyUnit$j$currencyNumber": readonly (string)[] } & ReturnType<Dimensionless_Unit["toJson"]> {
        return JSON.parse(JSON.stringify({ ...super.toJson(),qudt_CurrencyUnit$j$currencyCode: this.qudt_CurrencyUnit$j$currencyCode.map(_item => (_item)),qudt_CurrencyUnit$j$currencyExponent: this.qudt_CurrencyUnit$j$currencyExponent.map(_item => (_item)),qudt_CurrencyUnit$j$currencyNumber: this.qudt_CurrencyUnit$j$currencyNumber.map(_item => (_item)) } satisfies ReturnType<Currency_Unit["toJson"]>));
    }

    override toRdf({ ignoreRdfType, mutateGraph, resourceSet }: { ignoreRdfType?: boolean; mutateGraph?: rdfjsResource.MutableResource.MutateGraph, resourceSet: rdfjsResource.MutableResourceSet }): rdfjsResource.MutableResource {
        const _resource = super.toRdf({ ignoreRdfType: true, mutateGraph, resourceSet });
        if (!ignoreRdfType) { _resource.add(_resource.dataFactory.namedNode("http://www.w3.org/1999/02/22-rdf-syntax-ns#type"), _resource.dataFactory.namedNode("http://qudt.org/schema/qudt/CurrencyUnit")); }

        _resource.add(dataFactory.namedNode("http://qudt.org/schema/qudt/currencyCode"), this.qudt_CurrencyUnit$j$currencyCode.map((_item) => _item));
        _resource.add(dataFactory.namedNode("http://qudt.org/schema/qudt/currencyExponent"), this.qudt_CurrencyUnit$j$currencyExponent.map((_item) => _item));
        _resource.add(dataFactory.namedNode("http://qudt.org/schema/qudt/currencyNumber"), this.qudt_CurrencyUnit$j$currencyNumber.map((_item) => _item));
        return _resource;
    }

    override toString(): string {
        return JSON.stringify(this.toJson());
    }
}

export namespace Currency_Unit {
    export function _propertiesFromJson(_json: unknown): purify.Either<zod.ZodError, { identifier: (rdfjs.BlankNode | rdfjs.NamedNode); qudt_CurrencyUnit$j$currencyCode: readonly (string)[]; qudt_CurrencyUnit$j$currencyExponent: readonly (number)[]; qudt_CurrencyUnit$j$currencyNumber: readonly (string)[]; } & UnwrapR<ReturnType<typeof Dimensionless_Unit._propertiesFromJson>>> {
        const _jsonSafeParseResult = currencyUnitJsonZodSchema().safeParse(_json);
        if (!_jsonSafeParseResult.success) { return purify.Left(_jsonSafeParseResult.error); }

        const _jsonObject = _jsonSafeParseResult.data;
        const _super0Either = Dimensionless_Unit._propertiesFromJson(_jsonObject);
        if (_super0Either.isLeft()) { return _super0Either; }

        const _super0 = _super0Either.unsafeCoerce()
        const identifier = (_jsonObject["@id"].startsWith("_:") ? dataFactory.blankNode(_jsonObject["@id"].substring(2)) : dataFactory.namedNode(_jsonObject["@id"]));
        const qudt_CurrencyUnit$j$currencyCode = _jsonObject["qudt_CurrencyUnit$j$currencyCode"];
        const qudt_CurrencyUnit$j$currencyExponent = _jsonObject["qudt_CurrencyUnit$j$currencyExponent"];
        const qudt_CurrencyUnit$j$currencyNumber = _jsonObject["qudt_CurrencyUnit$j$currencyNumber"];
        return purify.Either.of({ ..._super0, identifier, qudt_CurrencyUnit$j$currencyCode, qudt_CurrencyUnit$j$currencyExponent, qudt_CurrencyUnit$j$currencyNumber })
    }

    export function fromJson(json: unknown): purify.Either<zod.ZodError, Currency_Unit> {
        return Currency_Unit._propertiesFromJson(json).map(properties => new Currency_Unit(properties));
    }

    export function _propertiesFromRdf({ ignoreRdfType: _ignoreRdfType, languageIn: _languageIn, resource: _resource,
        // @ts-ignore
        ..._context }: { [_index: string]: any; ignoreRdfType?: boolean; languageIn?: readonly string[]; resource: rdfjsResource.Resource; }): purify.Either<rdfjsResource.Resource.ValueError, { identifier: (rdfjs.BlankNode | rdfjs.NamedNode); qudt_CurrencyUnit$j$currencyCode: readonly (string)[]; qudt_CurrencyUnit$j$currencyExponent: readonly (number)[]; qudt_CurrencyUnit$j$currencyNumber: readonly (string)[]; } & UnwrapR<ReturnType<typeof Dimensionless_Unit._propertiesFromRdf>>> {
        const _super0Either = Dimensionless_Unit._propertiesFromRdf({ ..._context, ignoreRdfType: true, languageIn: _languageIn, resource: _resource });
        if (_super0Either.isLeft()) { return _super0Either; }

        const _super0 = _super0Either.unsafeCoerce()
        if (!_ignoreRdfType && !_resource.isInstanceOf(dataFactory.namedNode("http://qudt.org/schema/qudt/CurrencyUnit"))) { return purify.Left(new rdfjsResource.Resource.ValueError({ focusResource: _resource, message: `${rdfjsResource.Resource.Identifier.toString(_resource.identifier)} has unexpected RDF type (expected http://qudt.org/schema/qudt/CurrencyUnit)`, predicate: dataFactory.namedNode("http://qudt.org/schema/qudt/CurrencyUnit") })); }

        const identifier = _resource.identifier
        const _qudt_CurrencyUnit$j$currencyCodeEither: purify.Either<rdfjsResource.Resource.ValueError, readonly (string)[]> = purify.Either.of([..._resource.values(dataFactory.namedNode("http://qudt.org/schema/qudt/currencyCode"), { unique: true }).flatMap(_item => _item.toValues().head().chain(_value => _value.toString()).toMaybe().toList())]);
        if (_qudt_CurrencyUnit$j$currencyCodeEither.isLeft()) { return _qudt_CurrencyUnit$j$currencyCodeEither; }

        const qudt_CurrencyUnit$j$currencyCode = _qudt_CurrencyUnit$j$currencyCodeEither.unsafeCoerce();
        const _qudt_CurrencyUnit$j$currencyExponentEither: purify.Either<rdfjsResource.Resource.ValueError, readonly (number)[]> = purify.Either.of([..._resource.values(dataFactory.namedNode("http://qudt.org/schema/qudt/currencyExponent"), { unique: true }).flatMap(_item => _item.toValues().head().chain(_value => _value.toNumber()).toMaybe().toList())]);
        if (_qudt_CurrencyUnit$j$currencyExponentEither.isLeft()) { return _qudt_CurrencyUnit$j$currencyExponentEither; }

        const qudt_CurrencyUnit$j$currencyExponent = _qudt_CurrencyUnit$j$currencyExponentEither.unsafeCoerce();
        const _qudt_CurrencyUnit$j$currencyNumberEither: purify.Either<rdfjsResource.Resource.ValueError, readonly (string)[]> = purify.Either.of([..._resource.values(dataFactory.namedNode("http://qudt.org/schema/qudt/currencyNumber"), { unique: true }).flatMap(_item => _item.toValues().head().chain(_value => _value.toString()).toMaybe().toList())]);
        if (_qudt_CurrencyUnit$j$currencyNumberEither.isLeft()) { return _qudt_CurrencyUnit$j$currencyNumberEither; }

        const qudt_CurrencyUnit$j$currencyNumber = _qudt_CurrencyUnit$j$currencyNumberEither.unsafeCoerce();
        return purify.Either.of({ ..._super0, identifier, qudt_CurrencyUnit$j$currencyCode, qudt_CurrencyUnit$j$currencyExponent, qudt_CurrencyUnit$j$currencyNumber })
    }

    export function fromRdf(parameters: Parameters<typeof Currency_Unit._propertiesFromRdf>[0]): purify.Either<rdfjsResource.Resource.ValueError, Currency_Unit> {
        return Currency_Unit._propertiesFromRdf(parameters).map(properties => new Currency_Unit(properties));
    }

    export let fromRdfType: rdfjs.NamedNode<string> = dataFactory.namedNode("http://qudt.org/schema/qudt/CurrencyUnit");

    export function jsonSchema() {
        return zodToJsonSchema(currencyUnitJsonZodSchema());
    }

    export function currencyUnitJsonUiSchema(parameters?: { scopePrefix?: string }) {
        const scopePrefix = parameters?.scopePrefix ?? "#";
        return { "elements": [ Dimensionless_Unit.dimensionlessUnitJsonUiSchema({ scopePrefix }), { scope: `${scopePrefix}/properties/qudt_CurrencyUnit$j$currencyCode`, type: "Control" }, { scope: `${scopePrefix}/properties/qudt_CurrencyUnit$j$currencyExponent`, type: "Control" }, { scope: `${scopePrefix}/properties/qudt_CurrencyUnit$j$currencyNumber`, type: "Control" } ], label: "Currency Unit", type: "Group" }
    }

    export function currencyUnitJsonZodSchema() {
        return Dimensionless_Unit.dimensionlessUnitJsonZodSchema().merge(zod.object({ "@id": zod.string().min(1),"type": zod.literal("Currency_Unit"),"qudt_CurrencyUnit$j$currencyCode": zod.string().array(),"qudt_CurrencyUnit$j$currencyExponent": zod.number().array(),"qudt_CurrencyUnit$j$currencyNumber": zod.string().array() }));
    }

    export function sparqlConstructQuery(parameters?: { ignoreRdfType?: boolean; prefixes?: { [prefix: string]: string }; subject?: sparqljs.Triple["subject"]; } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type">): sparqljs.ConstructQuery {
        const { ignoreRdfType, subject, ...queryParameters } = parameters ?? {}

        return { ...queryParameters, prefixes: parameters?.prefixes ?? {}, queryType: "CONSTRUCT", template: (queryParameters.template ?? []).concat(Currency_Unit.sparqlConstructTemplateTriples({ ignoreRdfType, subject })), type: "query", where: (queryParameters.where ?? []).concat(Currency_Unit.sparqlWherePatterns({ ignoreRdfType, subject })) };
    }

    export function sparqlConstructQueryString(parameters?: { ignoreRdfType?: boolean; subject?: sparqljs.Triple["subject"]; variablePrefix?: string; } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type"> & sparqljs.GeneratorOptions): string {
        return new sparqljs.Generator(parameters).stringify(Currency_Unit.sparqlConstructQuery(parameters));
    }

    export function sparqlConstructTemplateTriples(parameters?: { ignoreRdfType?: boolean; subject?: sparqljs.Triple["subject"], variablePrefix?: string }): readonly sparqljs.Triple[] {
        const subject = parameters?.subject ?? dataFactory.variable!("currencyUnit");
        const variablePrefix = parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "currencyUnit");
        return [...Dimensionless_Unit.sparqlConstructTemplateTriples({ ignoreRdfType: true, subject, variablePrefix }), ...(parameters?.ignoreRdfType ? [] : [{ subject, predicate: dataFactory.namedNode("http://www.w3.org/1999/02/22-rdf-syntax-ns#type"), object: dataFactory.variable!(`${variablePrefix}RdfType`) }]), { object: dataFactory.variable!(`${variablePrefix}QudtCurrencyUnitJCurrencyCode`), predicate: dataFactory.namedNode("http://qudt.org/schema/qudt/currencyCode"), subject }, { object: dataFactory.variable!(`${variablePrefix}QudtCurrencyUnitJCurrencyExponent`), predicate: dataFactory.namedNode("http://qudt.org/schema/qudt/currencyExponent"), subject }, { object: dataFactory.variable!(`${variablePrefix}QudtCurrencyUnitJCurrencyNumber`), predicate: dataFactory.namedNode("http://qudt.org/schema/qudt/currencyNumber"), subject }];
    }

    export function sparqlWherePatterns(parameters: { ignoreRdfType?: boolean; subject?: sparqljs.Triple["subject"], variablePrefix?: string }): readonly sparqljs.Pattern[] {
        const subject = parameters?.subject ?? dataFactory.variable!("currencyUnit");
        const variablePrefix = parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "currencyUnit");
        return [...Dimensionless_Unit.sparqlWherePatterns({ ignoreRdfType: true, subject, variablePrefix }), ...(parameters?.ignoreRdfType ? [] : [{ triples: [{ subject, predicate: dataFactory.namedNode("http://www.w3.org/1999/02/22-rdf-syntax-ns#type"), object: dataFactory.namedNode("http://qudt.org/schema/qudt/CurrencyUnit") }], type: "bgp" as const }, { triples: [{ subject, predicate: dataFactory.namedNode("http://www.w3.org/1999/02/22-rdf-syntax-ns#type"), object: dataFactory.variable!(`${variablePrefix}RdfType`) }], type: "bgp" as const }]), { patterns: [{ triples: [{ object: dataFactory.variable!(`${variablePrefix}QudtCurrencyUnitJCurrencyCode`), predicate: dataFactory.namedNode("http://qudt.org/schema/qudt/currencyCode"), subject }], type: "bgp" }], type: "optional" }, { patterns: [{ triples: [{ object: dataFactory.variable!(`${variablePrefix}QudtCurrencyUnitJCurrencyExponent`), predicate: dataFactory.namedNode("http://qudt.org/schema/qudt/currencyExponent"), subject }], type: "bgp" }], type: "optional" }, { patterns: [{ triples: [{ object: dataFactory.variable!(`${variablePrefix}QudtCurrencyUnitJCurrencyNumber`), predicate: dataFactory.namedNode("http://qudt.org/schema/qudt/currencyNumber"), subject }], type: "bgp" }], type: "optional" }];
    }
}
/**
 * Counting Unit
 */
export class Counting_Unit extends Dimensionless_Unit {
    override readonly type = "Counting_Unit";

    // biome-ignore lint/complexity/noUselessConstructor: Always have a constructor
    constructor(parameters: { readonly identifier?: (rdfjs.BlankNode | rdfjs.NamedNode) | string } & ConstructorParameters<typeof Dimensionless_Unit>[0]) {
        super(parameters);
    }

    override get identifier(): (rdfjs.BlankNode | rdfjs.NamedNode) {
        if (typeof this._identifier === "undefined") { this._identifier = dataFactory.blankNode(); } return this._identifier;
    }

    override toRdf({ ignoreRdfType, mutateGraph, resourceSet }: { ignoreRdfType?: boolean; mutateGraph?: rdfjsResource.MutableResource.MutateGraph, resourceSet: rdfjsResource.MutableResourceSet }): rdfjsResource.MutableResource {
        const _resource = super.toRdf({ ignoreRdfType: true, mutateGraph, resourceSet });
        if (!ignoreRdfType) { _resource.add(_resource.dataFactory.namedNode("http://www.w3.org/1999/02/22-rdf-syntax-ns#type"), _resource.dataFactory.namedNode("http://qudt.org/schema/qudt/CountingUnit")); }

        return _resource;
    }

    override toString(): string {
        return JSON.stringify(this.toJson());
    }
}

export namespace Counting_Unit {
    export function _propertiesFromJson(_json: unknown): purify.Either<zod.ZodError, { identifier: (rdfjs.BlankNode | rdfjs.NamedNode); } & UnwrapR<ReturnType<typeof Dimensionless_Unit._propertiesFromJson>>> {
        const _jsonSafeParseResult = countingUnitJsonZodSchema().safeParse(_json);
        if (!_jsonSafeParseResult.success) { return purify.Left(_jsonSafeParseResult.error); }

        const _jsonObject = _jsonSafeParseResult.data;
        const _super0Either = Dimensionless_Unit._propertiesFromJson(_jsonObject);
        if (_super0Either.isLeft()) { return _super0Either; }

        const _super0 = _super0Either.unsafeCoerce()
        const identifier = (_jsonObject["@id"].startsWith("_:") ? dataFactory.blankNode(_jsonObject["@id"].substring(2)) : dataFactory.namedNode(_jsonObject["@id"]));
        return purify.Either.of({ ..._super0, identifier })
    }

    export function fromJson(json: unknown): purify.Either<zod.ZodError, Counting_Unit> {
        return Counting_Unit._propertiesFromJson(json).map(properties => new Counting_Unit(properties));
    }

    export function _propertiesFromRdf({ ignoreRdfType: _ignoreRdfType, languageIn: _languageIn, resource: _resource,
        // @ts-ignore
        ..._context }: { [_index: string]: any; ignoreRdfType?: boolean; languageIn?: readonly string[]; resource: rdfjsResource.Resource; }): purify.Either<rdfjsResource.Resource.ValueError, { identifier: (rdfjs.BlankNode | rdfjs.NamedNode); } & UnwrapR<ReturnType<typeof Dimensionless_Unit._propertiesFromRdf>>> {
        const _super0Either = Dimensionless_Unit._propertiesFromRdf({ ..._context, ignoreRdfType: true, languageIn: _languageIn, resource: _resource });
        if (_super0Either.isLeft()) { return _super0Either; }

        const _super0 = _super0Either.unsafeCoerce()
        if (!_ignoreRdfType && !_resource.isInstanceOf(dataFactory.namedNode("http://qudt.org/schema/qudt/CountingUnit"))) { return purify.Left(new rdfjsResource.Resource.ValueError({ focusResource: _resource, message: `${rdfjsResource.Resource.Identifier.toString(_resource.identifier)} has unexpected RDF type (expected http://qudt.org/schema/qudt/CountingUnit)`, predicate: dataFactory.namedNode("http://qudt.org/schema/qudt/CountingUnit") })); }

        const identifier = _resource.identifier
        return purify.Either.of({ ..._super0, identifier })
    }

    export function fromRdf(parameters: Parameters<typeof Counting_Unit._propertiesFromRdf>[0]): purify.Either<rdfjsResource.Resource.ValueError, Counting_Unit> {
        return Counting_Unit._propertiesFromRdf(parameters).map(properties => new Counting_Unit(properties));
    }

    export let fromRdfType: rdfjs.NamedNode<string> = dataFactory.namedNode("http://qudt.org/schema/qudt/CountingUnit");

    export function jsonSchema() {
        return zodToJsonSchema(countingUnitJsonZodSchema());
    }

    export function countingUnitJsonUiSchema(parameters?: { scopePrefix?: string }) {
        const scopePrefix = parameters?.scopePrefix ?? "#";
        return { "elements": [ Dimensionless_Unit.dimensionlessUnitJsonUiSchema({ scopePrefix }) ], label: "Counting Unit", type: "Group" }
    }

    export function countingUnitJsonZodSchema() {
        return Dimensionless_Unit.dimensionlessUnitJsonZodSchema().merge(zod.object({ "@id": zod.string().min(1),"type": zod.literal("Counting_Unit") }));
    }

    export function sparqlConstructQuery(parameters?: { ignoreRdfType?: boolean; prefixes?: { [prefix: string]: string }; subject?: sparqljs.Triple["subject"]; } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type">): sparqljs.ConstructQuery {
        const { ignoreRdfType, subject, ...queryParameters } = parameters ?? {}

        return { ...queryParameters, prefixes: parameters?.prefixes ?? {}, queryType: "CONSTRUCT", template: (queryParameters.template ?? []).concat(Counting_Unit.sparqlConstructTemplateTriples({ ignoreRdfType, subject })), type: "query", where: (queryParameters.where ?? []).concat(Counting_Unit.sparqlWherePatterns({ ignoreRdfType, subject })) };
    }

    export function sparqlConstructQueryString(parameters?: { ignoreRdfType?: boolean; subject?: sparqljs.Triple["subject"]; variablePrefix?: string; } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type"> & sparqljs.GeneratorOptions): string {
        return new sparqljs.Generator(parameters).stringify(Counting_Unit.sparqlConstructQuery(parameters));
    }

    export function sparqlConstructTemplateTriples(parameters?: { ignoreRdfType?: boolean; subject?: sparqljs.Triple["subject"], variablePrefix?: string }): readonly sparqljs.Triple[] {
        const subject = parameters?.subject ?? dataFactory.variable!("countingUnit");
        const variablePrefix = parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "countingUnit");
        return [...Dimensionless_Unit.sparqlConstructTemplateTriples({ ignoreRdfType: true, subject, variablePrefix }), ...(parameters?.ignoreRdfType ? [] : [{ subject, predicate: dataFactory.namedNode("http://www.w3.org/1999/02/22-rdf-syntax-ns#type"), object: dataFactory.variable!(`${variablePrefix}RdfType`) }])];
    }

    export function sparqlWherePatterns(parameters: { ignoreRdfType?: boolean; subject?: sparqljs.Triple["subject"], variablePrefix?: string }): readonly sparqljs.Pattern[] {
        const subject = parameters?.subject ?? dataFactory.variable!("countingUnit");
        const variablePrefix = parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "countingUnit");
        return [...Dimensionless_Unit.sparqlWherePatterns({ ignoreRdfType: true, subject, variablePrefix }), ...(parameters?.ignoreRdfType ? [] : [{ triples: [{ subject, predicate: dataFactory.namedNode("http://www.w3.org/1999/02/22-rdf-syntax-ns#type"), object: dataFactory.namedNode("http://qudt.org/schema/qudt/CountingUnit") }], type: "bgp" as const }, { triples: [{ subject, predicate: dataFactory.namedNode("http://www.w3.org/1999/02/22-rdf-syntax-ns#type"), object: dataFactory.variable!(`${variablePrefix}RdfType`) }], type: "bgp" as const }])];
    }
}
/**
 * Contextual Unit
 */
export class Contextual_Unit extends Unit {
    override readonly type = "Contextual_Unit";
    readonly qudt_ContextualUnit$j$broader: readonly (Abstract_Unit)[];

    constructor(parameters: { readonly identifier?: (rdfjs.BlankNode | rdfjs.NamedNode) | string, readonly qudt_ContextualUnit$j$broader?: readonly (Abstract_Unit)[] } & ConstructorParameters<typeof Unit>[0]) {
        super(parameters);
        if (typeof parameters.qudt_ContextualUnit$j$broader === "undefined") { this.qudt_ContextualUnit$j$broader = []; } else if (Array.isArray(parameters.qudt_ContextualUnit$j$broader)) { this.qudt_ContextualUnit$j$broader = parameters.qudt_ContextualUnit$j$broader; } else { this.qudt_ContextualUnit$j$broader =( parameters.qudt_ContextualUnit$j$broader) as never;
         }
    }

    override get identifier(): (rdfjs.BlankNode | rdfjs.NamedNode) {
        if (typeof this._identifier === "undefined") { this._identifier = dataFactory.blankNode(); } return this._identifier;
    }

    override equals(other: Contextual_Unit): EqualsResult {
        return super.equals(other).chain(() => (((left, right) => arrayEquals(left, right, ((left, right) => left.equals(right)))))(this.qudt_ContextualUnit$j$broader, other.qudt_ContextualUnit$j$broader).mapLeft(propertyValuesUnequal => ({ left: this, right: other, propertyName: "qudt_ContextualUnit$j$broader", propertyValuesUnequal, type: "Property" as const })));
    }

    override hash<HasherT extends { update: (message: string | number[] | ArrayBuffer | Uint8Array) => void; }>(_hasher: HasherT): HasherT {
        this.hashShaclProperties(_hasher);
        return _hasher;
    }

    protected override hashShaclProperties<HasherT extends { update: (message: string | number[] | ArrayBuffer | Uint8Array) => void; }>(_hasher: HasherT): HasherT {
        super.hashShaclProperties(_hasher);
        for (const _item0 of this.qudt_ContextualUnit$j$broader) { _item0.hash(_hasher); }

        return _hasher;
    }

    override toJson(): { readonly "qudt_ContextualUnit$j$broader": readonly (ReturnType<Abstract_Unit["toJson"]>)[] } & ReturnType<Unit["toJson"]> {
        return JSON.parse(JSON.stringify({ ...super.toJson(),qudt_ContextualUnit$j$broader: this.qudt_ContextualUnit$j$broader.map(_item => (_item.toJson())) } satisfies ReturnType<Contextual_Unit["toJson"]>));
    }

    override toRdf({ ignoreRdfType, mutateGraph, resourceSet }: { ignoreRdfType?: boolean; mutateGraph?: rdfjsResource.MutableResource.MutateGraph, resourceSet: rdfjsResource.MutableResourceSet }): rdfjsResource.MutableResource {
        const _resource = super.toRdf({ ignoreRdfType: true, mutateGraph, resourceSet });
        if (!ignoreRdfType) { _resource.add(_resource.dataFactory.namedNode("http://www.w3.org/1999/02/22-rdf-syntax-ns#type"), _resource.dataFactory.namedNode("http://qudt.org/schema/qudt/ContextualUnit")); }

        _resource.add(dataFactory.namedNode("http://www.w3.org/2004/02/skos/core#broader"), this.qudt_ContextualUnit$j$broader.map((_item) => _item.toRdf({ mutateGraph: mutateGraph, resourceSet: resourceSet })));
        return _resource;
    }

    override toString(): string {
        return JSON.stringify(this.toJson());
    }
}

export namespace Contextual_Unit {
    export function _propertiesFromJson(_json: unknown): purify.Either<zod.ZodError, { identifier: (rdfjs.BlankNode | rdfjs.NamedNode); qudt_ContextualUnit$j$broader: readonly (Abstract_Unit)[]; } & UnwrapR<ReturnType<typeof Unit._propertiesFromJson>>> {
        const _jsonSafeParseResult = contextualUnitJsonZodSchema().safeParse(_json);
        if (!_jsonSafeParseResult.success) { return purify.Left(_jsonSafeParseResult.error); }

        const _jsonObject = _jsonSafeParseResult.data;
        const _super0Either = Unit._propertiesFromJson(_jsonObject);
        if (_super0Either.isLeft()) { return _super0Either; }

        const _super0 = _super0Either.unsafeCoerce()
        const identifier = (_jsonObject["@id"].startsWith("_:") ? dataFactory.blankNode(_jsonObject["@id"].substring(2)) : dataFactory.namedNode(_jsonObject["@id"]));
        const qudt_ContextualUnit$j$broader = _jsonObject["qudt_ContextualUnit$j$broader"].map(_item => (Abstract_Unit.fromJson(_item).unsafeCoerce()));
        return purify.Either.of({ ..._super0, identifier, qudt_ContextualUnit$j$broader })
    }

    export function fromJson(json: unknown): purify.Either<zod.ZodError, Contextual_Unit> {
        return Contextual_Unit._propertiesFromJson(json).map(properties => new Contextual_Unit(properties));
    }

    export function _propertiesFromRdf({ ignoreRdfType: _ignoreRdfType, languageIn: _languageIn, resource: _resource,
        // @ts-ignore
        ..._context }: { [_index: string]: any; ignoreRdfType?: boolean; languageIn?: readonly string[]; resource: rdfjsResource.Resource; }): purify.Either<rdfjsResource.Resource.ValueError, { identifier: (rdfjs.BlankNode | rdfjs.NamedNode); qudt_ContextualUnit$j$broader: readonly (Abstract_Unit)[]; } & UnwrapR<ReturnType<typeof Unit._propertiesFromRdf>>> {
        const _super0Either = Unit._propertiesFromRdf({ ..._context, ignoreRdfType: true, languageIn: _languageIn, resource: _resource });
        if (_super0Either.isLeft()) { return _super0Either; }

        const _super0 = _super0Either.unsafeCoerce()
        if (!_ignoreRdfType && !_resource.isInstanceOf(dataFactory.namedNode("http://qudt.org/schema/qudt/ContextualUnit"))) { return purify.Left(new rdfjsResource.Resource.ValueError({ focusResource: _resource, message: `${rdfjsResource.Resource.Identifier.toString(_resource.identifier)} has unexpected RDF type (expected http://qudt.org/schema/qudt/ContextualUnit)`, predicate: dataFactory.namedNode("http://qudt.org/schema/qudt/ContextualUnit") })); }

        const identifier = _resource.identifier
        const _qudt_ContextualUnit$j$broaderEither: purify.Either<rdfjsResource.Resource.ValueError, readonly (Abstract_Unit)[]> = purify.Either.of([..._resource.values(dataFactory.namedNode("http://www.w3.org/2004/02/skos/core#broader"), { unique: true }).flatMap(_item => _item.toValues().head().chain(value => value.toResource()).chain(_resource => Abstract_Unit.fromRdf({ ..._context, ignoreRdfType: true, languageIn: _languageIn, resource: _resource })).toMaybe().toList())]);
        if (_qudt_ContextualUnit$j$broaderEither.isLeft()) { return _qudt_ContextualUnit$j$broaderEither; }

        const qudt_ContextualUnit$j$broader = _qudt_ContextualUnit$j$broaderEither.unsafeCoerce();
        return purify.Either.of({ ..._super0, identifier, qudt_ContextualUnit$j$broader })
    }

    export function fromRdf(parameters: Parameters<typeof Contextual_Unit._propertiesFromRdf>[0]): purify.Either<rdfjsResource.Resource.ValueError, Contextual_Unit> {
        return Contextual_Unit._propertiesFromRdf(parameters).map(properties => new Contextual_Unit(properties));
    }

    export let fromRdfType: rdfjs.NamedNode<string> = dataFactory.namedNode("http://qudt.org/schema/qudt/ContextualUnit");

    export function jsonSchema() {
        return zodToJsonSchema(contextualUnitJsonZodSchema());
    }

    export function contextualUnitJsonUiSchema(parameters?: { scopePrefix?: string }) {
        const scopePrefix = parameters?.scopePrefix ?? "#";
        return { "elements": [ Unit.unitJsonUiSchema({ scopePrefix }), Abstract_Unit.abstractUnitJsonUiSchema({ scopePrefix: `${scopePrefix}/properties/qudt_ContextualUnit$j$broader` }) ], label: "Contextual Unit", type: "Group" }
    }

    export function contextualUnitJsonZodSchema() {
        return Unit.unitJsonZodSchema().merge(zod.object({ "@id": zod.string().min(1),"type": zod.literal("Contextual_Unit"),"qudt_ContextualUnit$j$broader": Abstract_Unit.abstractUnitJsonZodSchema().array() }));
    }

    export function sparqlConstructQuery(parameters?: { ignoreRdfType?: boolean; prefixes?: { [prefix: string]: string }; subject?: sparqljs.Triple["subject"]; } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type">): sparqljs.ConstructQuery {
        const { ignoreRdfType, subject, ...queryParameters } = parameters ?? {}

        return { ...queryParameters, prefixes: parameters?.prefixes ?? {}, queryType: "CONSTRUCT", template: (queryParameters.template ?? []).concat(Contextual_Unit.sparqlConstructTemplateTriples({ ignoreRdfType, subject })), type: "query", where: (queryParameters.where ?? []).concat(Contextual_Unit.sparqlWherePatterns({ ignoreRdfType, subject })) };
    }

    export function sparqlConstructQueryString(parameters?: { ignoreRdfType?: boolean; subject?: sparqljs.Triple["subject"]; variablePrefix?: string; } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type"> & sparqljs.GeneratorOptions): string {
        return new sparqljs.Generator(parameters).stringify(Contextual_Unit.sparqlConstructQuery(parameters));
    }

    export function sparqlConstructTemplateTriples(parameters?: { ignoreRdfType?: boolean; subject?: sparqljs.Triple["subject"], variablePrefix?: string }): readonly sparqljs.Triple[] {
        const subject = parameters?.subject ?? dataFactory.variable!("contextualUnit");
        const variablePrefix = parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "contextualUnit");
        return [...Unit.sparqlConstructTemplateTriples({ ignoreRdfType: true, subject, variablePrefix }), ...(parameters?.ignoreRdfType ? [] : [{ subject, predicate: dataFactory.namedNode("http://www.w3.org/1999/02/22-rdf-syntax-ns#type"), object: dataFactory.variable!(`${variablePrefix}RdfType`) }]), { object: dataFactory.variable!(`${variablePrefix}QudtContextualUnitJBroader`), predicate: dataFactory.namedNode("http://www.w3.org/2004/02/skos/core#broader"), subject }, ...Abstract_Unit.sparqlConstructTemplateTriples({ ignoreRdfType: true, subject: dataFactory.variable!(`${variablePrefix}QudtContextualUnitJBroader`), variablePrefix: `${variablePrefix}QudtContextualUnitJBroader` })];
    }

    export function sparqlWherePatterns(parameters: { ignoreRdfType?: boolean; subject?: sparqljs.Triple["subject"], variablePrefix?: string }): readonly sparqljs.Pattern[] {
        const subject = parameters?.subject ?? dataFactory.variable!("contextualUnit");
        const variablePrefix = parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "contextualUnit");
        return [...Unit.sparqlWherePatterns({ ignoreRdfType: true, subject, variablePrefix }), ...(parameters?.ignoreRdfType ? [] : [{ triples: [{ subject, predicate: dataFactory.namedNode("http://www.w3.org/1999/02/22-rdf-syntax-ns#type"), object: dataFactory.namedNode("http://qudt.org/schema/qudt/ContextualUnit") }], type: "bgp" as const }, { triples: [{ subject, predicate: dataFactory.namedNode("http://www.w3.org/1999/02/22-rdf-syntax-ns#type"), object: dataFactory.variable!(`${variablePrefix}RdfType`) }], type: "bgp" as const }]), { patterns: [{ triples: [{ object: dataFactory.variable!(`${variablePrefix}QudtContextualUnitJBroader`), predicate: dataFactory.namedNode("http://www.w3.org/2004/02/skos/core#broader"), subject }], type: "bgp" }, ...Abstract_Unit.sparqlWherePatterns({ ignoreRdfType: true, subject: dataFactory.variable!(`${variablePrefix}QudtContextualUnitJBroader`), variablePrefix: `${variablePrefix}QudtContextualUnitJBroader` })], type: "optional" }];
    }
}
/**
 * Quantity value
 */
export class Quantity_value extends QUDT_Concept {
    override readonly type: "Constant_value" | "Quantity_value" = "Quantity_value";

    // biome-ignore lint/complexity/noUselessConstructor: Always have a constructor
    constructor(parameters: { readonly identifier?: (rdfjs.BlankNode | rdfjs.NamedNode) | string } & ConstructorParameters<typeof QUDT_Concept>[0]) {
        super(parameters);
    }

    override get identifier(): (rdfjs.BlankNode | rdfjs.NamedNode) {
        if (typeof this._identifier === "undefined") { this._identifier = dataFactory.blankNode(); } return this._identifier;
    }

    override toRdf({ ignoreRdfType, mutateGraph, resourceSet }: { ignoreRdfType?: boolean; mutateGraph?: rdfjsResource.MutableResource.MutateGraph, resourceSet: rdfjsResource.MutableResourceSet }): rdfjsResource.MutableResource {
        const _resource = super.toRdf({ ignoreRdfType: true, mutateGraph, resourceSet });
        if (!ignoreRdfType) { _resource.add(_resource.dataFactory.namedNode("http://www.w3.org/1999/02/22-rdf-syntax-ns#type"), _resource.dataFactory.namedNode("http://qudt.org/schema/qudt/QuantityValue")); }

        return _resource;
    }

    override toString(): string {
        return JSON.stringify(this.toJson());
    }
}

export namespace Quantity_value {
    export function _propertiesFromJson(_json: unknown): purify.Either<zod.ZodError, { identifier: (rdfjs.BlankNode | rdfjs.NamedNode); } & UnwrapR<ReturnType<typeof QUDT_Concept._propertiesFromJson>>> {
        const _jsonSafeParseResult = quantityValueJsonZodSchema().safeParse(_json);
        if (!_jsonSafeParseResult.success) { return purify.Left(_jsonSafeParseResult.error); }

        const _jsonObject = _jsonSafeParseResult.data;
        const _super0Either = QUDT_Concept._propertiesFromJson(_jsonObject);
        if (_super0Either.isLeft()) { return _super0Either; }

        const _super0 = _super0Either.unsafeCoerce()
        const identifier = (_jsonObject["@id"].startsWith("_:") ? dataFactory.blankNode(_jsonObject["@id"].substring(2)) : dataFactory.namedNode(_jsonObject["@id"]));
        return purify.Either.of({ ..._super0, identifier })
    }

    export function fromJson(json: unknown): purify.Either<zod.ZodError, Quantity_value> {
        return (Constant_value.fromJson(json) as purify.Either<zod.ZodError, Quantity_value>).altLazy(() => Quantity_value._propertiesFromJson(json).map(properties => new Quantity_value(properties)));
    }

    export function _propertiesFromRdf({ ignoreRdfType: _ignoreRdfType, languageIn: _languageIn, resource: _resource,
        // @ts-ignore
        ..._context }: { [_index: string]: any; ignoreRdfType?: boolean; languageIn?: readonly string[]; resource: rdfjsResource.Resource; }): purify.Either<rdfjsResource.Resource.ValueError, { identifier: (rdfjs.BlankNode | rdfjs.NamedNode); } & UnwrapR<ReturnType<typeof QUDT_Concept._propertiesFromRdf>>> {
        const _super0Either = QUDT_Concept._propertiesFromRdf({ ..._context, ignoreRdfType: true, languageIn: _languageIn, resource: _resource });
        if (_super0Either.isLeft()) { return _super0Either; }

        const _super0 = _super0Either.unsafeCoerce()
        if (!_ignoreRdfType && !_resource.isInstanceOf(dataFactory.namedNode("http://qudt.org/schema/qudt/QuantityValue"))) { return purify.Left(new rdfjsResource.Resource.ValueError({ focusResource: _resource, message: `${rdfjsResource.Resource.Identifier.toString(_resource.identifier)} has unexpected RDF type (expected http://qudt.org/schema/qudt/QuantityValue)`, predicate: dataFactory.namedNode("http://qudt.org/schema/qudt/QuantityValue") })); }

        const identifier = _resource.identifier
        return purify.Either.of({ ..._super0, identifier })
    }

    export function fromRdf(parameters: Parameters<typeof Quantity_value._propertiesFromRdf>[0]): purify.Either<rdfjsResource.Resource.ValueError, Quantity_value> {
        const { ignoreRdfType: _ignoreRdfType, ...otherParameters } = parameters
        return (Constant_value.fromRdf(otherParameters) as purify.Either<rdfjsResource.Resource.ValueError, Quantity_value>).altLazy(() => Quantity_value._propertiesFromRdf(parameters).map(properties => new Quantity_value(properties)));
    }

    export let fromRdfType: rdfjs.NamedNode<string> = dataFactory.namedNode("http://qudt.org/schema/qudt/QuantityValue");

    export function jsonSchema() {
        return zodToJsonSchema(quantityValueJsonZodSchema());
    }

    export function quantityValueJsonUiSchema(parameters?: { scopePrefix?: string }) {
        const scopePrefix = parameters?.scopePrefix ?? "#";
        return { "elements": [ QUDT_Concept.qudtConceptJsonUiSchema({ scopePrefix }) ], label: "Quantity value", type: "Group" }
    }

    export function quantityValueJsonZodSchema() {
        return QUDT_Concept.qudtConceptJsonZodSchema().merge(zod.object({ "@id": zod.string().min(1),"type": zod.enum(["Constant_value","Quantity_value"]) }));
    }

    export function sparqlConstructQuery(parameters?: { ignoreRdfType?: boolean; prefixes?: { [prefix: string]: string }; subject?: sparqljs.Triple["subject"]; } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type">): sparqljs.ConstructQuery {
        const { ignoreRdfType, subject, ...queryParameters } = parameters ?? {}

        return { ...queryParameters, prefixes: parameters?.prefixes ?? {}, queryType: "CONSTRUCT", template: (queryParameters.template ?? []).concat(Quantity_value.sparqlConstructTemplateTriples({ ignoreRdfType, subject })), type: "query", where: (queryParameters.where ?? []).concat(Quantity_value.sparqlWherePatterns({ ignoreRdfType, subject })) };
    }

    export function sparqlConstructQueryString(parameters?: { ignoreRdfType?: boolean; subject?: sparqljs.Triple["subject"]; variablePrefix?: string; } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type"> & sparqljs.GeneratorOptions): string {
        return new sparqljs.Generator(parameters).stringify(Quantity_value.sparqlConstructQuery(parameters));
    }

    export function sparqlConstructTemplateTriples(parameters?: { ignoreRdfType?: boolean; subject?: sparqljs.Triple["subject"], variablePrefix?: string }): readonly sparqljs.Triple[] {
        const subject = parameters?.subject ?? dataFactory.variable!("quantityValue");
        const variablePrefix = parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "quantityValue");
        return [...QUDT_Concept.sparqlConstructTemplateTriples({ ignoreRdfType: true, subject, variablePrefix }), ...(parameters?.ignoreRdfType ? [] : [{ subject, predicate: dataFactory.namedNode("http://www.w3.org/1999/02/22-rdf-syntax-ns#type"), object: dataFactory.variable!(`${variablePrefix}RdfType`) }])];
    }

    export function sparqlWherePatterns(parameters: { ignoreRdfType?: boolean; subject?: sparqljs.Triple["subject"], variablePrefix?: string }): readonly sparqljs.Pattern[] {
        const subject = parameters?.subject ?? dataFactory.variable!("quantityValue");
        const variablePrefix = parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "quantityValue");
        return [...QUDT_Concept.sparqlWherePatterns({ ignoreRdfType: true, subject, variablePrefix }), ...(parameters?.ignoreRdfType ? [] : [{ triples: [{ subject, predicate: dataFactory.namedNode("http://www.w3.org/1999/02/22-rdf-syntax-ns#type"), object: dataFactory.namedNode("http://qudt.org/schema/qudt/QuantityValue") }], type: "bgp" as const }, { triples: [{ subject, predicate: dataFactory.namedNode("http://www.w3.org/1999/02/22-rdf-syntax-ns#type"), object: dataFactory.variable!(`${variablePrefix}RdfType`) }], type: "bgp" as const }])];
    }
}
/**
 * Constant value
 */
export class Constant_value extends Quantity_value {
    override readonly type = "Constant_value";
    readonly qudt_ConstantValue$j$exactConstant: purify.Maybe<boolean>;

    constructor(parameters: { readonly identifier?: (rdfjs.BlankNode | rdfjs.NamedNode) | string, readonly qudt_ConstantValue$j$exactConstant?: boolean | purify.Maybe<boolean> } & ConstructorParameters<typeof Quantity_value>[0]) {
        super(parameters);
        if (purify.Maybe.isMaybe(parameters.qudt_ConstantValue$j$exactConstant)) { this.qudt_ConstantValue$j$exactConstant = parameters.qudt_ConstantValue$j$exactConstant; } else if (typeof parameters.qudt_ConstantValue$j$exactConstant === "boolean") { this.qudt_ConstantValue$j$exactConstant = purify.Maybe.of(parameters.qudt_ConstantValue$j$exactConstant); } else if (typeof parameters.qudt_ConstantValue$j$exactConstant === "undefined") { this.qudt_ConstantValue$j$exactConstant = purify.Maybe.empty(); } else { this.qudt_ConstantValue$j$exactConstant =( parameters.qudt_ConstantValue$j$exactConstant) as never;
         }
    }

    override get identifier(): (rdfjs.BlankNode | rdfjs.NamedNode) {
        if (typeof this._identifier === "undefined") { this._identifier = dataFactory.blankNode(); } return this._identifier;
    }

    override equals(other: Constant_value): EqualsResult {
        return super.equals(other).chain(() => (((left, right) => maybeEquals(left, right, strictEquals)))(this.qudt_ConstantValue$j$exactConstant, other.qudt_ConstantValue$j$exactConstant).mapLeft(propertyValuesUnequal => ({ left: this, right: other, propertyName: "qudt_ConstantValue$j$exactConstant", propertyValuesUnequal, type: "Property" as const })));
    }

    override hash<HasherT extends { update: (message: string | number[] | ArrayBuffer | Uint8Array) => void; }>(_hasher: HasherT): HasherT {
        this.hashShaclProperties(_hasher);
        return _hasher;
    }

    protected override hashShaclProperties<HasherT extends { update: (message: string | number[] | ArrayBuffer | Uint8Array) => void; }>(_hasher: HasherT): HasherT {
        super.hashShaclProperties(_hasher);
        this.qudt_ConstantValue$j$exactConstant.ifJust((_value0) => { _hasher.update(_value0.toString()); })
        return _hasher;
    }

    override toJson(): { readonly "qudt_ConstantValue$j$exactConstant": (boolean) | undefined } & ReturnType<Quantity_value["toJson"]> {
        return JSON.parse(JSON.stringify({ ...super.toJson(),qudt_ConstantValue$j$exactConstant: this.qudt_ConstantValue$j$exactConstant.map(_item => (_item)).extract() } satisfies ReturnType<Constant_value["toJson"]>));
    }

    override toRdf({ ignoreRdfType, mutateGraph, resourceSet }: { ignoreRdfType?: boolean; mutateGraph?: rdfjsResource.MutableResource.MutateGraph, resourceSet: rdfjsResource.MutableResourceSet }): rdfjsResource.MutableResource {
        const _resource = super.toRdf({ ignoreRdfType: true, mutateGraph, resourceSet });
        if (!ignoreRdfType) { _resource.add(_resource.dataFactory.namedNode("http://www.w3.org/1999/02/22-rdf-syntax-ns#type"), _resource.dataFactory.namedNode("http://qudt.org/schema/qudt/ConstantValue")); }

        _resource.add(dataFactory.namedNode("http://qudt.org/schema/qudt/exactConstant"), this.qudt_ConstantValue$j$exactConstant);
        return _resource;
    }

    override toString(): string {
        return JSON.stringify(this.toJson());
    }
}

export namespace Constant_value {
    export function _propertiesFromJson(_json: unknown): purify.Either<zod.ZodError, { identifier: (rdfjs.BlankNode | rdfjs.NamedNode); qudt_ConstantValue$j$exactConstant: purify.Maybe<boolean>; } & UnwrapR<ReturnType<typeof Quantity_value._propertiesFromJson>>> {
        const _jsonSafeParseResult = constantValueJsonZodSchema().safeParse(_json);
        if (!_jsonSafeParseResult.success) { return purify.Left(_jsonSafeParseResult.error); }

        const _jsonObject = _jsonSafeParseResult.data;
        const _super0Either = Quantity_value._propertiesFromJson(_jsonObject);
        if (_super0Either.isLeft()) { return _super0Either; }

        const _super0 = _super0Either.unsafeCoerce()
        const identifier = (_jsonObject["@id"].startsWith("_:") ? dataFactory.blankNode(_jsonObject["@id"].substring(2)) : dataFactory.namedNode(_jsonObject["@id"]));
        const qudt_ConstantValue$j$exactConstant = purify.Maybe.fromNullable(_jsonObject["qudt_ConstantValue$j$exactConstant"]);
        return purify.Either.of({ ..._super0, identifier, qudt_ConstantValue$j$exactConstant })
    }

    export function fromJson(json: unknown): purify.Either<zod.ZodError, Constant_value> {
        return Constant_value._propertiesFromJson(json).map(properties => new Constant_value(properties));
    }

    export function _propertiesFromRdf({ ignoreRdfType: _ignoreRdfType, languageIn: _languageIn, resource: _resource,
        // @ts-ignore
        ..._context }: { [_index: string]: any; ignoreRdfType?: boolean; languageIn?: readonly string[]; resource: rdfjsResource.Resource; }): purify.Either<rdfjsResource.Resource.ValueError, { identifier: (rdfjs.BlankNode | rdfjs.NamedNode); qudt_ConstantValue$j$exactConstant: purify.Maybe<boolean>; } & UnwrapR<ReturnType<typeof Quantity_value._propertiesFromRdf>>> {
        const _super0Either = Quantity_value._propertiesFromRdf({ ..._context, ignoreRdfType: true, languageIn: _languageIn, resource: _resource });
        if (_super0Either.isLeft()) { return _super0Either; }

        const _super0 = _super0Either.unsafeCoerce()
        if (!_ignoreRdfType && !_resource.isInstanceOf(dataFactory.namedNode("http://qudt.org/schema/qudt/ConstantValue"))) { return purify.Left(new rdfjsResource.Resource.ValueError({ focusResource: _resource, message: `${rdfjsResource.Resource.Identifier.toString(_resource.identifier)} has unexpected RDF type (expected http://qudt.org/schema/qudt/ConstantValue)`, predicate: dataFactory.namedNode("http://qudt.org/schema/qudt/ConstantValue") })); }

        const identifier = _resource.identifier
        const _qudt_ConstantValue$j$exactConstantEither: purify.Either<rdfjsResource.Resource.ValueError, purify.Maybe<boolean>> = purify.Either.of(_resource.values(dataFactory.namedNode("http://qudt.org/schema/qudt/exactConstant"), { unique: true }).head().chain(_value => _value.toBoolean()).toMaybe());
        if (_qudt_ConstantValue$j$exactConstantEither.isLeft()) { return _qudt_ConstantValue$j$exactConstantEither; }

        const qudt_ConstantValue$j$exactConstant = _qudt_ConstantValue$j$exactConstantEither.unsafeCoerce();
        return purify.Either.of({ ..._super0, identifier, qudt_ConstantValue$j$exactConstant })
    }

    export function fromRdf(parameters: Parameters<typeof Constant_value._propertiesFromRdf>[0]): purify.Either<rdfjsResource.Resource.ValueError, Constant_value> {
        return Constant_value._propertiesFromRdf(parameters).map(properties => new Constant_value(properties));
    }

    export let fromRdfType: rdfjs.NamedNode<string> = dataFactory.namedNode("http://qudt.org/schema/qudt/ConstantValue");

    export function jsonSchema() {
        return zodToJsonSchema(constantValueJsonZodSchema());
    }

    export function constantValueJsonUiSchema(parameters?: { scopePrefix?: string }) {
        const scopePrefix = parameters?.scopePrefix ?? "#";
        return { "elements": [ Quantity_value.quantityValueJsonUiSchema({ scopePrefix }), { scope: `${scopePrefix}/properties/qudt_ConstantValue$j$exactConstant`, type: "Control" } ], label: "Constant value", type: "Group" }
    }

    export function constantValueJsonZodSchema() {
        return Quantity_value.quantityValueJsonZodSchema().merge(zod.object({ "@id": zod.string().min(1),"type": zod.literal("Constant_value"),"qudt_ConstantValue$j$exactConstant": zod.boolean().optional() }));
    }

    export function sparqlConstructQuery(parameters?: { ignoreRdfType?: boolean; prefixes?: { [prefix: string]: string }; subject?: sparqljs.Triple["subject"]; } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type">): sparqljs.ConstructQuery {
        const { ignoreRdfType, subject, ...queryParameters } = parameters ?? {}

        return { ...queryParameters, prefixes: parameters?.prefixes ?? {}, queryType: "CONSTRUCT", template: (queryParameters.template ?? []).concat(Constant_value.sparqlConstructTemplateTriples({ ignoreRdfType, subject })), type: "query", where: (queryParameters.where ?? []).concat(Constant_value.sparqlWherePatterns({ ignoreRdfType, subject })) };
    }

    export function sparqlConstructQueryString(parameters?: { ignoreRdfType?: boolean; subject?: sparqljs.Triple["subject"]; variablePrefix?: string; } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type"> & sparqljs.GeneratorOptions): string {
        return new sparqljs.Generator(parameters).stringify(Constant_value.sparqlConstructQuery(parameters));
    }

    export function sparqlConstructTemplateTriples(parameters?: { ignoreRdfType?: boolean; subject?: sparqljs.Triple["subject"], variablePrefix?: string }): readonly sparqljs.Triple[] {
        const subject = parameters?.subject ?? dataFactory.variable!("constantValue");
        const variablePrefix = parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "constantValue");
        return [...Quantity_value.sparqlConstructTemplateTriples({ ignoreRdfType: true, subject, variablePrefix }), ...(parameters?.ignoreRdfType ? [] : [{ subject, predicate: dataFactory.namedNode("http://www.w3.org/1999/02/22-rdf-syntax-ns#type"), object: dataFactory.variable!(`${variablePrefix}RdfType`) }]), { object: dataFactory.variable!(`${variablePrefix}QudtConstantValueJExactConstant`), predicate: dataFactory.namedNode("http://qudt.org/schema/qudt/exactConstant"), subject }];
    }

    export function sparqlWherePatterns(parameters: { ignoreRdfType?: boolean; subject?: sparqljs.Triple["subject"], variablePrefix?: string }): readonly sparqljs.Pattern[] {
        const subject = parameters?.subject ?? dataFactory.variable!("constantValue");
        const variablePrefix = parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "constantValue");
        return [...Quantity_value.sparqlWherePatterns({ ignoreRdfType: true, subject, variablePrefix }), ...(parameters?.ignoreRdfType ? [] : [{ triples: [{ subject, predicate: dataFactory.namedNode("http://www.w3.org/1999/02/22-rdf-syntax-ns#type"), object: dataFactory.namedNode("http://qudt.org/schema/qudt/ConstantValue") }], type: "bgp" as const }, { triples: [{ subject, predicate: dataFactory.namedNode("http://www.w3.org/1999/02/22-rdf-syntax-ns#type"), object: dataFactory.variable!(`${variablePrefix}RdfType`) }], type: "bgp" as const }]), { patterns: [{ triples: [{ object: dataFactory.variable!(`${variablePrefix}QudtConstantValueJExactConstant`), predicate: dataFactory.namedNode("http://qudt.org/schema/qudt/exactConstant"), subject }], type: "bgp" }], type: "optional" }];
    }
}
/**
 * Citation
 */
export class Citation extends QUDT_Concept {
    override readonly type = "Citation";
    readonly qudt_Citation$j$description: (rdfjs.BlankNode | rdfjs.NamedNode | rdfjs.Literal);
    readonly qudt_Citation$j$url: purify.Maybe<string>;

    constructor(parameters: { readonly identifier?: (rdfjs.BlankNode | rdfjs.NamedNode) | string, readonly qudt_Citation$j$description: (rdfjs.BlankNode | rdfjs.NamedNode | rdfjs.Literal) | Date | boolean | number | string, readonly qudt_Citation$j$url?: purify.Maybe<string> | string } & ConstructorParameters<typeof QUDT_Concept>[0]) {
        super(parameters);
        if (typeof parameters.qudt_Citation$j$description === "boolean") { this.qudt_Citation$j$description = rdfLiteral.toRdf(parameters.qudt_Citation$j$description, { dataFactory }); } else if (typeof parameters.qudt_Citation$j$description === "object" && parameters.qudt_Citation$j$description instanceof Date) { this.qudt_Citation$j$description = rdfLiteral.toRdf(parameters.qudt_Citation$j$description, { dataFactory }); } else if (typeof parameters.qudt_Citation$j$description === "number") { this.qudt_Citation$j$description = rdfLiteral.toRdf(parameters.qudt_Citation$j$description, { dataFactory }); } else if (typeof parameters.qudt_Citation$j$description === "string") { this.qudt_Citation$j$description = dataFactory.literal(parameters.qudt_Citation$j$description); } else if (typeof parameters.qudt_Citation$j$description === "object") { this.qudt_Citation$j$description = parameters.qudt_Citation$j$description; } else { this.qudt_Citation$j$description =( parameters.qudt_Citation$j$description) as never;
         }

        if (purify.Maybe.isMaybe(parameters.qudt_Citation$j$url)) { this.qudt_Citation$j$url = parameters.qudt_Citation$j$url; } else if (typeof parameters.qudt_Citation$j$url === "string") { this.qudt_Citation$j$url = purify.Maybe.of(parameters.qudt_Citation$j$url); } else if (typeof parameters.qudt_Citation$j$url === "undefined") { this.qudt_Citation$j$url = purify.Maybe.empty(); } else { this.qudt_Citation$j$url =( parameters.qudt_Citation$j$url) as never;
         }
    }

    override get identifier(): (rdfjs.BlankNode | rdfjs.NamedNode) {
        if (typeof this._identifier === "undefined") { this._identifier = dataFactory.blankNode(); } return this._identifier;
    }

    override equals(other: Citation): EqualsResult {
        return super.equals(other).chain(() => (booleanEquals)(this.qudt_Citation$j$description, other.qudt_Citation$j$description).mapLeft(propertyValuesUnequal => ({ left: this, right: other, propertyName: "qudt_Citation$j$description", propertyValuesUnequal, type: "Property" as const }))).chain(() => (((left, right) => maybeEquals(left, right, strictEquals)))(this.qudt_Citation$j$url, other.qudt_Citation$j$url).mapLeft(propertyValuesUnequal => ({ left: this, right: other, propertyName: "qudt_Citation$j$url", propertyValuesUnequal, type: "Property" as const })));
    }

    override hash<HasherT extends { update: (message: string | number[] | ArrayBuffer | Uint8Array) => void; }>(_hasher: HasherT): HasherT {
        this.hashShaclProperties(_hasher);
        return _hasher;
    }

    protected override hashShaclProperties<HasherT extends { update: (message: string | number[] | ArrayBuffer | Uint8Array) => void; }>(_hasher: HasherT): HasherT {
        super.hashShaclProperties(_hasher);
        _hasher.update(this.qudt_Citation$j$description.termType);
        _hasher.update(this.qudt_Citation$j$description.value);
        this.qudt_Citation$j$url.ifJust((_value0) => { _hasher.update(_value0); })
        return _hasher;
    }

    override toJson(): { readonly "qudt_Citation$j$description": { readonly "@id": string, readonly termType: "BlankNode" | "NamedNode" } | { readonly "@language": string | undefined, readonly "@type": string | undefined, readonly "@value": string, readonly termType: "Literal" }; readonly "qudt_Citation$j$url": (string) | undefined } & ReturnType<QUDT_Concept["toJson"]> {
        return JSON.parse(JSON.stringify({ ...super.toJson(),qudt_Citation$j$description: (this.qudt_Citation$j$description.termType === "Literal") ? { "@language": this.qudt_Citation$j$description.language.length > 0 ? this.qudt_Citation$j$description.language : undefined, "@type": this.qudt_Citation$j$description.datatype.value !== "http://www.w3.org/2001/XMLSchema#string" ? this.qudt_Citation$j$description.datatype.value : undefined, "@value": this.qudt_Citation$j$description.value, termType: "Literal" as const } : (this.qudt_Citation$j$description.termType === "NamedNode") ? { "@id": this.qudt_Citation$j$description.value, termType: "NamedNode" as const } : { "@id": `_:${this.qudt_Citation$j$description.value}`, termType: "BlankNode" as const },qudt_Citation$j$url: this.qudt_Citation$j$url.map(_item => (_item)).extract() } satisfies ReturnType<Citation["toJson"]>));
    }

    override toRdf({ ignoreRdfType, mutateGraph, resourceSet }: { ignoreRdfType?: boolean; mutateGraph?: rdfjsResource.MutableResource.MutateGraph, resourceSet: rdfjsResource.MutableResourceSet }): rdfjsResource.MutableResource {
        const _resource = super.toRdf({ ignoreRdfType: true, mutateGraph, resourceSet });
        if (!ignoreRdfType) { _resource.add(_resource.dataFactory.namedNode("http://www.w3.org/1999/02/22-rdf-syntax-ns#type"), _resource.dataFactory.namedNode("http://qudt.org/schema/qudt/Citation")); }

        _resource.add(dataFactory.namedNode("http://purl.org/dc/terms/description"), this.qudt_Citation$j$description);
        _resource.add(dataFactory.namedNode("http://qudt.org/schema/qudt/url"), this.qudt_Citation$j$url);
        return _resource;
    }

    override toString(): string {
        return JSON.stringify(this.toJson());
    }
}

export namespace Citation {
    export function _propertiesFromJson(_json: unknown): purify.Either<zod.ZodError, { identifier: (rdfjs.BlankNode | rdfjs.NamedNode); qudt_Citation$j$description: (rdfjs.BlankNode | rdfjs.NamedNode | rdfjs.Literal); qudt_Citation$j$url: purify.Maybe<string>; } & UnwrapR<ReturnType<typeof QUDT_Concept._propertiesFromJson>>> {
        const _jsonSafeParseResult = citationJsonZodSchema().safeParse(_json);
        if (!_jsonSafeParseResult.success) { return purify.Left(_jsonSafeParseResult.error); }

        const _jsonObject = _jsonSafeParseResult.data;
        const _super0Either = QUDT_Concept._propertiesFromJson(_jsonObject);
        if (_super0Either.isLeft()) { return _super0Either; }

        const _super0 = _super0Either.unsafeCoerce()
        const identifier = (_jsonObject["@id"].startsWith("_:") ? dataFactory.blankNode(_jsonObject["@id"].substring(2)) : dataFactory.namedNode(_jsonObject["@id"]));
        const qudt_Citation$j$description = ((_jsonObject["qudt_Citation$j$description"].termType === "Literal") ? (dataFactory.literal(_jsonObject["qudt_Citation$j$description"]["@value"], typeof _jsonObject["qudt_Citation$j$description"]["@language"] !== "undefined" ? _jsonObject["qudt_Citation$j$description"]["@language"] : (typeof _jsonObject["qudt_Citation$j$description"]["@type"] !== "undefined" ? dataFactory.namedNode(_jsonObject["qudt_Citation$j$description"]["@type"]) : undefined))) : (((_jsonObject["qudt_Citation$j$description"].termType === "NamedNode") ? (dataFactory.namedNode(_jsonObject["qudt_Citation$j$description"]["@id"])) : (dataFactory.blankNode(_jsonObject["qudt_Citation$j$description"]["@id"].substring(2))))));
        const qudt_Citation$j$url = purify.Maybe.fromNullable(_jsonObject["qudt_Citation$j$url"]);
        return purify.Either.of({ ..._super0, identifier, qudt_Citation$j$description, qudt_Citation$j$url })
    }

    export function fromJson(json: unknown): purify.Either<zod.ZodError, Citation> {
        return Citation._propertiesFromJson(json).map(properties => new Citation(properties));
    }

    export function _propertiesFromRdf({ ignoreRdfType: _ignoreRdfType, languageIn: _languageIn, resource: _resource,
        // @ts-ignore
        ..._context }: { [_index: string]: any; ignoreRdfType?: boolean; languageIn?: readonly string[]; resource: rdfjsResource.Resource; }): purify.Either<rdfjsResource.Resource.ValueError, { identifier: (rdfjs.BlankNode | rdfjs.NamedNode); qudt_Citation$j$description: (rdfjs.BlankNode | rdfjs.NamedNode | rdfjs.Literal); qudt_Citation$j$url: purify.Maybe<string>; } & UnwrapR<ReturnType<typeof QUDT_Concept._propertiesFromRdf>>> {
        const _super0Either = QUDT_Concept._propertiesFromRdf({ ..._context, ignoreRdfType: true, languageIn: _languageIn, resource: _resource });
        if (_super0Either.isLeft()) { return _super0Either; }

        const _super0 = _super0Either.unsafeCoerce()
        if (!_ignoreRdfType && !_resource.isInstanceOf(dataFactory.namedNode("http://qudt.org/schema/qudt/Citation"))) { return purify.Left(new rdfjsResource.Resource.ValueError({ focusResource: _resource, message: `${rdfjsResource.Resource.Identifier.toString(_resource.identifier)} has unexpected RDF type (expected http://qudt.org/schema/qudt/Citation)`, predicate: dataFactory.namedNode("http://qudt.org/schema/qudt/Citation") })); }

        const identifier = _resource.identifier
        const _qudt_Citation$j$descriptionEither: purify.Either<rdfjsResource.Resource.ValueError, (rdfjs.BlankNode | rdfjs.NamedNode | rdfjs.Literal)> = _resource.values(dataFactory.namedNode("http://purl.org/dc/terms/description"), { unique: true }).head().chain(_value => purify.Either.of(_value.toTerm()));
        if (_qudt_Citation$j$descriptionEither.isLeft()) { return _qudt_Citation$j$descriptionEither; }

        const qudt_Citation$j$description = _qudt_Citation$j$descriptionEither.unsafeCoerce();
        const _qudt_Citation$j$urlEither: purify.Either<rdfjsResource.Resource.ValueError, purify.Maybe<string>> = purify.Either.of(_resource.values(dataFactory.namedNode("http://qudt.org/schema/qudt/url"), { unique: true }).head().chain(_value => _value.toString()).toMaybe());
        if (_qudt_Citation$j$urlEither.isLeft()) { return _qudt_Citation$j$urlEither; }

        const qudt_Citation$j$url = _qudt_Citation$j$urlEither.unsafeCoerce();
        return purify.Either.of({ ..._super0, identifier, qudt_Citation$j$description, qudt_Citation$j$url })
    }

    export function fromRdf(parameters: Parameters<typeof Citation._propertiesFromRdf>[0]): purify.Either<rdfjsResource.Resource.ValueError, Citation> {
        return Citation._propertiesFromRdf(parameters).map(properties => new Citation(properties));
    }

    export let fromRdfType: rdfjs.NamedNode<string> = dataFactory.namedNode("http://qudt.org/schema/qudt/Citation");

    export function jsonSchema() {
        return zodToJsonSchema(citationJsonZodSchema());
    }

    export function citationJsonUiSchema(parameters?: { scopePrefix?: string }) {
        const scopePrefix = parameters?.scopePrefix ?? "#";
        return { "elements": [ QUDT_Concept.qudtConceptJsonUiSchema({ scopePrefix }), { scope: `${scopePrefix}/properties/qudt_Citation$j$description`, type: "Control" }, { scope: `${scopePrefix}/properties/qudt_Citation$j$url`, type: "Control" } ], label: "Citation", type: "Group" }
    }

    export function citationJsonZodSchema() {
        return QUDT_Concept.qudtConceptJsonZodSchema().merge(zod.object({ "@id": zod.string().min(1),"type": zod.literal("Citation"),"qudt_Citation$j$description": zod.discriminatedUnion("termType", [zod.object({ "@id": zod.string().min(1), termType: zod.literal("BlankNode") }), zod.object({ "@id": zod.string().min(1), termType: zod.literal("NamedNode") }), zod.object({ "@language": zod.string().optional(), "@type": zod.string().optional(), "@value": zod.string(), termType: zod.literal("Literal") })]),"qudt_Citation$j$url": zod.string().optional() }));
    }

    export function sparqlConstructQuery(parameters?: { ignoreRdfType?: boolean; prefixes?: { [prefix: string]: string }; subject?: sparqljs.Triple["subject"]; } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type">): sparqljs.ConstructQuery {
        const { ignoreRdfType, subject, ...queryParameters } = parameters ?? {}

        return { ...queryParameters, prefixes: parameters?.prefixes ?? {}, queryType: "CONSTRUCT", template: (queryParameters.template ?? []).concat(Citation.sparqlConstructTemplateTriples({ ignoreRdfType, subject })), type: "query", where: (queryParameters.where ?? []).concat(Citation.sparqlWherePatterns({ ignoreRdfType, subject })) };
    }

    export function sparqlConstructQueryString(parameters?: { ignoreRdfType?: boolean; subject?: sparqljs.Triple["subject"]; variablePrefix?: string; } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type"> & sparqljs.GeneratorOptions): string {
        return new sparqljs.Generator(parameters).stringify(Citation.sparqlConstructQuery(parameters));
    }

    export function sparqlConstructTemplateTriples(parameters?: { ignoreRdfType?: boolean; subject?: sparqljs.Triple["subject"], variablePrefix?: string }): readonly sparqljs.Triple[] {
        const subject = parameters?.subject ?? dataFactory.variable!("citation");
        const variablePrefix = parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "citation");
        return [...QUDT_Concept.sparqlConstructTemplateTriples({ ignoreRdfType: true, subject, variablePrefix }), ...(parameters?.ignoreRdfType ? [] : [{ subject, predicate: dataFactory.namedNode("http://www.w3.org/1999/02/22-rdf-syntax-ns#type"), object: dataFactory.variable!(`${variablePrefix}RdfType`) }]), { object: dataFactory.variable!(`${variablePrefix}QudtCitationJDescription`), predicate: dataFactory.namedNode("http://purl.org/dc/terms/description"), subject }, { object: dataFactory.variable!(`${variablePrefix}QudtCitationJUrl`), predicate: dataFactory.namedNode("http://qudt.org/schema/qudt/url"), subject }];
    }

    export function sparqlWherePatterns(parameters: { ignoreRdfType?: boolean; subject?: sparqljs.Triple["subject"], variablePrefix?: string }): readonly sparqljs.Pattern[] {
        const subject = parameters?.subject ?? dataFactory.variable!("citation");
        const variablePrefix = parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "citation");
        return [...QUDT_Concept.sparqlWherePatterns({ ignoreRdfType: true, subject, variablePrefix }), ...(parameters?.ignoreRdfType ? [] : [{ triples: [{ subject, predicate: dataFactory.namedNode("http://www.w3.org/1999/02/22-rdf-syntax-ns#type"), object: dataFactory.namedNode("http://qudt.org/schema/qudt/Citation") }], type: "bgp" as const }, { triples: [{ subject, predicate: dataFactory.namedNode("http://www.w3.org/1999/02/22-rdf-syntax-ns#type"), object: dataFactory.variable!(`${variablePrefix}RdfType`) }], type: "bgp" as const }]), { triples: [{ object: dataFactory.variable!(`${variablePrefix}QudtCitationJDescription`), predicate: dataFactory.namedNode("http://purl.org/dc/terms/description"), subject }], type: "bgp" }, { patterns: [{ triples: [{ object: dataFactory.variable!(`${variablePrefix}QudtCitationJUrl`), predicate: dataFactory.namedNode("http://qudt.org/schema/qudt/url"), subject }], type: "bgp" }], type: "optional" }];
    }
}
/**
 * Binary Prefix
 */
export class Binary_Prefix extends Prefix {
    override readonly type = "Binary_Prefix";

    // biome-ignore lint/complexity/noUselessConstructor: Always have a constructor
    constructor(parameters: { readonly identifier?: (rdfjs.BlankNode | rdfjs.NamedNode) | string } & ConstructorParameters<typeof Prefix>[0]) {
        super(parameters);
    }

    override get identifier(): (rdfjs.BlankNode | rdfjs.NamedNode) {
        if (typeof this._identifier === "undefined") { this._identifier = dataFactory.blankNode(); } return this._identifier;
    }

    override toRdf({ ignoreRdfType, mutateGraph, resourceSet }: { ignoreRdfType?: boolean; mutateGraph?: rdfjsResource.MutableResource.MutateGraph, resourceSet: rdfjsResource.MutableResourceSet }): rdfjsResource.MutableResource {
        const _resource = super.toRdf({ ignoreRdfType: true, mutateGraph, resourceSet });
        if (!ignoreRdfType) { _resource.add(_resource.dataFactory.namedNode("http://www.w3.org/1999/02/22-rdf-syntax-ns#type"), _resource.dataFactory.namedNode("http://qudt.org/schema/qudt/BinaryPrefix")); }

        return _resource;
    }

    override toString(): string {
        return JSON.stringify(this.toJson());
    }
}

export namespace Binary_Prefix {
    export function _propertiesFromJson(_json: unknown): purify.Either<zod.ZodError, { identifier: (rdfjs.BlankNode | rdfjs.NamedNode); } & UnwrapR<ReturnType<typeof Prefix._propertiesFromJson>>> {
        const _jsonSafeParseResult = binaryPrefixJsonZodSchema().safeParse(_json);
        if (!_jsonSafeParseResult.success) { return purify.Left(_jsonSafeParseResult.error); }

        const _jsonObject = _jsonSafeParseResult.data;
        const _super0Either = Prefix._propertiesFromJson(_jsonObject);
        if (_super0Either.isLeft()) { return _super0Either; }

        const _super0 = _super0Either.unsafeCoerce()
        const identifier = (_jsonObject["@id"].startsWith("_:") ? dataFactory.blankNode(_jsonObject["@id"].substring(2)) : dataFactory.namedNode(_jsonObject["@id"]));
        return purify.Either.of({ ..._super0, identifier })
    }

    export function fromJson(json: unknown): purify.Either<zod.ZodError, Binary_Prefix> {
        return Binary_Prefix._propertiesFromJson(json).map(properties => new Binary_Prefix(properties));
    }

    export function _propertiesFromRdf({ ignoreRdfType: _ignoreRdfType, languageIn: _languageIn, resource: _resource,
        // @ts-ignore
        ..._context }: { [_index: string]: any; ignoreRdfType?: boolean; languageIn?: readonly string[]; resource: rdfjsResource.Resource; }): purify.Either<rdfjsResource.Resource.ValueError, { identifier: (rdfjs.BlankNode | rdfjs.NamedNode); } & UnwrapR<ReturnType<typeof Prefix._propertiesFromRdf>>> {
        const _super0Either = Prefix._propertiesFromRdf({ ..._context, ignoreRdfType: true, languageIn: _languageIn, resource: _resource });
        if (_super0Either.isLeft()) { return _super0Either; }

        const _super0 = _super0Either.unsafeCoerce()
        if (!_ignoreRdfType && !_resource.isInstanceOf(dataFactory.namedNode("http://qudt.org/schema/qudt/BinaryPrefix"))) { return purify.Left(new rdfjsResource.Resource.ValueError({ focusResource: _resource, message: `${rdfjsResource.Resource.Identifier.toString(_resource.identifier)} has unexpected RDF type (expected http://qudt.org/schema/qudt/BinaryPrefix)`, predicate: dataFactory.namedNode("http://qudt.org/schema/qudt/BinaryPrefix") })); }

        const identifier = _resource.identifier
        return purify.Either.of({ ..._super0, identifier })
    }

    export function fromRdf(parameters: Parameters<typeof Binary_Prefix._propertiesFromRdf>[0]): purify.Either<rdfjsResource.Resource.ValueError, Binary_Prefix> {
        return Binary_Prefix._propertiesFromRdf(parameters).map(properties => new Binary_Prefix(properties));
    }

    export let fromRdfType: rdfjs.NamedNode<string> = dataFactory.namedNode("http://qudt.org/schema/qudt/BinaryPrefix");

    export function jsonSchema() {
        return zodToJsonSchema(binaryPrefixJsonZodSchema());
    }

    export function binaryPrefixJsonUiSchema(parameters?: { scopePrefix?: string }) {
        const scopePrefix = parameters?.scopePrefix ?? "#";
        return { "elements": [ Prefix.prefixJsonUiSchema({ scopePrefix }) ], label: "Binary Prefix", type: "Group" }
    }

    export function binaryPrefixJsonZodSchema() {
        return Prefix.prefixJsonZodSchema().merge(zod.object({ "@id": zod.string().min(1),"type": zod.literal("Binary_Prefix") }));
    }

    export function sparqlConstructQuery(parameters?: { ignoreRdfType?: boolean; prefixes?: { [prefix: string]: string }; subject?: sparqljs.Triple["subject"]; } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type">): sparqljs.ConstructQuery {
        const { ignoreRdfType, subject, ...queryParameters } = parameters ?? {}

        return { ...queryParameters, prefixes: parameters?.prefixes ?? {}, queryType: "CONSTRUCT", template: (queryParameters.template ?? []).concat(Binary_Prefix.sparqlConstructTemplateTriples({ ignoreRdfType, subject })), type: "query", where: (queryParameters.where ?? []).concat(Binary_Prefix.sparqlWherePatterns({ ignoreRdfType, subject })) };
    }

    export function sparqlConstructQueryString(parameters?: { ignoreRdfType?: boolean; subject?: sparqljs.Triple["subject"]; variablePrefix?: string; } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type"> & sparqljs.GeneratorOptions): string {
        return new sparqljs.Generator(parameters).stringify(Binary_Prefix.sparqlConstructQuery(parameters));
    }

    export function sparqlConstructTemplateTriples(parameters?: { ignoreRdfType?: boolean; subject?: sparqljs.Triple["subject"], variablePrefix?: string }): readonly sparqljs.Triple[] {
        const subject = parameters?.subject ?? dataFactory.variable!("binaryPrefix");
        const variablePrefix = parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "binaryPrefix");
        return [...Prefix.sparqlConstructTemplateTriples({ ignoreRdfType: true, subject, variablePrefix }), ...(parameters?.ignoreRdfType ? [] : [{ subject, predicate: dataFactory.namedNode("http://www.w3.org/1999/02/22-rdf-syntax-ns#type"), object: dataFactory.variable!(`${variablePrefix}RdfType`) }])];
    }

    export function sparqlWherePatterns(parameters: { ignoreRdfType?: boolean; subject?: sparqljs.Triple["subject"], variablePrefix?: string }): readonly sparqljs.Pattern[] {
        const subject = parameters?.subject ?? dataFactory.variable!("binaryPrefix");
        const variablePrefix = parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "binaryPrefix");
        return [...Prefix.sparqlWherePatterns({ ignoreRdfType: true, subject, variablePrefix }), ...(parameters?.ignoreRdfType ? [] : [{ triples: [{ subject, predicate: dataFactory.namedNode("http://www.w3.org/1999/02/22-rdf-syntax-ns#type"), object: dataFactory.namedNode("http://qudt.org/schema/qudt/BinaryPrefix") }], type: "bgp" as const }, { triples: [{ subject, predicate: dataFactory.namedNode("http://www.w3.org/1999/02/22-rdf-syntax-ns#type"), object: dataFactory.variable!(`${variablePrefix}RdfType`) }], type: "bgp" as const }])];
    }
}
/**
 * Base Dimension Magnitude
 */
export class Base_Dimension$W$Magnitude extends QUDT_Concept {
    override readonly type = "Base_Dimension$W$Magnitude";
    readonly qudt_BaseDimensionMagnitude$j$hasBaseQuantityKind: Quantity_Kind;
    readonly qudt_BaseDimensionMagnitude$j$vectorMagnitude: number;

    constructor(parameters: { readonly identifier?: (rdfjs.BlankNode | rdfjs.NamedNode) | string, readonly qudt_BaseDimensionMagnitude$j$hasBaseQuantityKind: Quantity_Kind, readonly qudt_BaseDimensionMagnitude$j$vectorMagnitude: number } & ConstructorParameters<typeof QUDT_Concept>[0]) {
        super(parameters);
        this.qudt_BaseDimensionMagnitude$j$hasBaseQuantityKind = parameters.qudt_BaseDimensionMagnitude$j$hasBaseQuantityKind;
        this.qudt_BaseDimensionMagnitude$j$vectorMagnitude = parameters.qudt_BaseDimensionMagnitude$j$vectorMagnitude;
    }

    override get identifier(): (rdfjs.BlankNode | rdfjs.NamedNode) {
        if (typeof this._identifier === "undefined") { this._identifier = dataFactory.blankNode(); } return this._identifier;
    }

    override equals(other: Base_Dimension$W$Magnitude): EqualsResult {
        return super.equals(other).chain(() => (((left, right) => left.equals(right)))(this.qudt_BaseDimensionMagnitude$j$hasBaseQuantityKind, other.qudt_BaseDimensionMagnitude$j$hasBaseQuantityKind).mapLeft(propertyValuesUnequal => ({ left: this, right: other, propertyName: "qudt_BaseDimensionMagnitude$j$hasBaseQuantityKind", propertyValuesUnequal, type: "Property" as const }))).chain(() => (strictEquals)(this.qudt_BaseDimensionMagnitude$j$vectorMagnitude, other.qudt_BaseDimensionMagnitude$j$vectorMagnitude).mapLeft(propertyValuesUnequal => ({ left: this, right: other, propertyName: "qudt_BaseDimensionMagnitude$j$vectorMagnitude", propertyValuesUnequal, type: "Property" as const })));
    }

    override hash<HasherT extends { update: (message: string | number[] | ArrayBuffer | Uint8Array) => void; }>(_hasher: HasherT): HasherT {
        this.hashShaclProperties(_hasher);
        return _hasher;
    }

    protected override hashShaclProperties<HasherT extends { update: (message: string | number[] | ArrayBuffer | Uint8Array) => void; }>(_hasher: HasherT): HasherT {
        super.hashShaclProperties(_hasher);
        this.qudt_BaseDimensionMagnitude$j$hasBaseQuantityKind.hash(_hasher);
        _hasher.update(this.qudt_BaseDimensionMagnitude$j$vectorMagnitude.toString());
        return _hasher;
    }

    override toJson(): { readonly "qudt_BaseDimensionMagnitude$j$hasBaseQuantityKind": ReturnType<Quantity_Kind["toJson"]>; readonly "qudt_BaseDimensionMagnitude$j$vectorMagnitude": number } & ReturnType<QUDT_Concept["toJson"]> {
        return JSON.parse(JSON.stringify({ ...super.toJson(),qudt_BaseDimensionMagnitude$j$hasBaseQuantityKind: this.qudt_BaseDimensionMagnitude$j$hasBaseQuantityKind.toJson(),qudt_BaseDimensionMagnitude$j$vectorMagnitude: this.qudt_BaseDimensionMagnitude$j$vectorMagnitude } satisfies ReturnType<Base_Dimension$W$Magnitude["toJson"]>));
    }

    override toRdf({ ignoreRdfType, mutateGraph, resourceSet }: { ignoreRdfType?: boolean; mutateGraph?: rdfjsResource.MutableResource.MutateGraph, resourceSet: rdfjsResource.MutableResourceSet }): rdfjsResource.MutableResource {
        const _resource = super.toRdf({ ignoreRdfType: true, mutateGraph, resourceSet });
        if (!ignoreRdfType) { _resource.add(_resource.dataFactory.namedNode("http://www.w3.org/1999/02/22-rdf-syntax-ns#type"), _resource.dataFactory.namedNode("http://qudt.org/schema/qudt/BaseDimensionMagnitude")); }

        _resource.add(dataFactory.namedNode("http://qudt.org/schema/qudt/hasBaseQuantityKind"), this.qudt_BaseDimensionMagnitude$j$hasBaseQuantityKind.toRdf({ mutateGraph: mutateGraph, resourceSet: resourceSet }));
        _resource.add(dataFactory.namedNode("http://qudt.org/schema/qudt/vectorMagnitude"), this.qudt_BaseDimensionMagnitude$j$vectorMagnitude);
        return _resource;
    }

    override toString(): string {
        return JSON.stringify(this.toJson());
    }
}

export namespace Base_Dimension$W$Magnitude {
    export function _propertiesFromJson(_json: unknown): purify.Either<zod.ZodError, { identifier: (rdfjs.BlankNode | rdfjs.NamedNode); qudt_BaseDimensionMagnitude$j$hasBaseQuantityKind: Quantity_Kind; qudt_BaseDimensionMagnitude$j$vectorMagnitude: number; } & UnwrapR<ReturnType<typeof QUDT_Concept._propertiesFromJson>>> {
        const _jsonSafeParseResult = baseDimensionWMagnitudeJsonZodSchema().safeParse(_json);
        if (!_jsonSafeParseResult.success) { return purify.Left(_jsonSafeParseResult.error); }

        const _jsonObject = _jsonSafeParseResult.data;
        const _super0Either = QUDT_Concept._propertiesFromJson(_jsonObject);
        if (_super0Either.isLeft()) { return _super0Either; }

        const _super0 = _super0Either.unsafeCoerce()
        const identifier = (_jsonObject["@id"].startsWith("_:") ? dataFactory.blankNode(_jsonObject["@id"].substring(2)) : dataFactory.namedNode(_jsonObject["@id"]));
        const qudt_BaseDimensionMagnitude$j$hasBaseQuantityKind = Quantity_Kind.fromJson(_jsonObject["qudt_BaseDimensionMagnitude$j$hasBaseQuantityKind"]).unsafeCoerce();
        const qudt_BaseDimensionMagnitude$j$vectorMagnitude = _jsonObject["qudt_BaseDimensionMagnitude$j$vectorMagnitude"];
        return purify.Either.of({ ..._super0, identifier, qudt_BaseDimensionMagnitude$j$hasBaseQuantityKind, qudt_BaseDimensionMagnitude$j$vectorMagnitude })
    }

    export function fromJson(json: unknown): purify.Either<zod.ZodError, Base_Dimension$W$Magnitude> {
        return Base_Dimension$W$Magnitude._propertiesFromJson(json).map(properties => new Base_Dimension$W$Magnitude(properties));
    }

    export function _propertiesFromRdf({ ignoreRdfType: _ignoreRdfType, languageIn: _languageIn, resource: _resource,
        // @ts-ignore
        ..._context }: { [_index: string]: any; ignoreRdfType?: boolean; languageIn?: readonly string[]; resource: rdfjsResource.Resource; }): purify.Either<rdfjsResource.Resource.ValueError, { identifier: (rdfjs.BlankNode | rdfjs.NamedNode); qudt_BaseDimensionMagnitude$j$hasBaseQuantityKind: Quantity_Kind; qudt_BaseDimensionMagnitude$j$vectorMagnitude: number; } & UnwrapR<ReturnType<typeof QUDT_Concept._propertiesFromRdf>>> {
        const _super0Either = QUDT_Concept._propertiesFromRdf({ ..._context, ignoreRdfType: true, languageIn: _languageIn, resource: _resource });
        if (_super0Either.isLeft()) { return _super0Either; }

        const _super0 = _super0Either.unsafeCoerce()
        if (!_ignoreRdfType && !_resource.isInstanceOf(dataFactory.namedNode("http://qudt.org/schema/qudt/BaseDimensionMagnitude"))) { return purify.Left(new rdfjsResource.Resource.ValueError({ focusResource: _resource, message: `${rdfjsResource.Resource.Identifier.toString(_resource.identifier)} has unexpected RDF type (expected http://qudt.org/schema/qudt/BaseDimensionMagnitude)`, predicate: dataFactory.namedNode("http://qudt.org/schema/qudt/BaseDimensionMagnitude") })); }

        const identifier = _resource.identifier
        const _qudt_BaseDimensionMagnitude$j$hasBaseQuantityKindEither: purify.Either<rdfjsResource.Resource.ValueError, Quantity_Kind> = _resource.values(dataFactory.namedNode("http://qudt.org/schema/qudt/hasBaseQuantityKind"), { unique: true }).head().chain(value => value.toResource()).chain(_resource => Quantity_Kind.fromRdf({ ..._context, ignoreRdfType: true, languageIn: _languageIn, resource: _resource }));
        if (_qudt_BaseDimensionMagnitude$j$hasBaseQuantityKindEither.isLeft()) { return _qudt_BaseDimensionMagnitude$j$hasBaseQuantityKindEither; }

        const qudt_BaseDimensionMagnitude$j$hasBaseQuantityKind = _qudt_BaseDimensionMagnitude$j$hasBaseQuantityKindEither.unsafeCoerce();
        const _qudt_BaseDimensionMagnitude$j$vectorMagnitudeEither: purify.Either<rdfjsResource.Resource.ValueError, number> = _resource.values(dataFactory.namedNode("http://qudt.org/schema/qudt/vectorMagnitude"), { unique: true }).head().chain(_value => _value.toNumber());
        if (_qudt_BaseDimensionMagnitude$j$vectorMagnitudeEither.isLeft()) { return _qudt_BaseDimensionMagnitude$j$vectorMagnitudeEither; }

        const qudt_BaseDimensionMagnitude$j$vectorMagnitude = _qudt_BaseDimensionMagnitude$j$vectorMagnitudeEither.unsafeCoerce();
        return purify.Either.of({ ..._super0, identifier, qudt_BaseDimensionMagnitude$j$hasBaseQuantityKind, qudt_BaseDimensionMagnitude$j$vectorMagnitude })
    }

    export function fromRdf(parameters: Parameters<typeof Base_Dimension$W$Magnitude._propertiesFromRdf>[0]): purify.Either<rdfjsResource.Resource.ValueError, Base_Dimension$W$Magnitude> {
        return Base_Dimension$W$Magnitude._propertiesFromRdf(parameters).map(properties => new Base_Dimension$W$Magnitude(properties));
    }

    export let fromRdfType: rdfjs.NamedNode<string> = dataFactory.namedNode("http://qudt.org/schema/qudt/BaseDimensionMagnitude");

    export function jsonSchema() {
        return zodToJsonSchema(baseDimensionWMagnitudeJsonZodSchema());
    }

    export function baseDimensionWMagnitudeJsonUiSchema(parameters?: { scopePrefix?: string }) {
        const scopePrefix = parameters?.scopePrefix ?? "#";
        return { "elements": [ QUDT_Concept.qudtConceptJsonUiSchema({ scopePrefix }), Quantity_Kind.quantityKindJsonUiSchema({ scopePrefix: `${scopePrefix}/properties/qudt_BaseDimensionMagnitude$j$hasBaseQuantityKind` }), { scope: `${scopePrefix}/properties/qudt_BaseDimensionMagnitude$j$vectorMagnitude`, type: "Control" } ], label: "Base Dimension Magnitude", type: "Group" }
    }

    export function baseDimensionWMagnitudeJsonZodSchema() {
        return QUDT_Concept.qudtConceptJsonZodSchema().merge(zod.object({ "@id": zod.string().min(1),"type": zod.literal("Base_Dimension$W$Magnitude"),"qudt_BaseDimensionMagnitude$j$hasBaseQuantityKind": Quantity_Kind.quantityKindJsonZodSchema(),"qudt_BaseDimensionMagnitude$j$vectorMagnitude": zod.number() }));
    }

    export function sparqlConstructQuery(parameters?: { ignoreRdfType?: boolean; prefixes?: { [prefix: string]: string }; subject?: sparqljs.Triple["subject"]; } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type">): sparqljs.ConstructQuery {
        const { ignoreRdfType, subject, ...queryParameters } = parameters ?? {}

        return { ...queryParameters, prefixes: parameters?.prefixes ?? {}, queryType: "CONSTRUCT", template: (queryParameters.template ?? []).concat(Base_Dimension$W$Magnitude.sparqlConstructTemplateTriples({ ignoreRdfType, subject })), type: "query", where: (queryParameters.where ?? []).concat(Base_Dimension$W$Magnitude.sparqlWherePatterns({ ignoreRdfType, subject })) };
    }

    export function sparqlConstructQueryString(parameters?: { ignoreRdfType?: boolean; subject?: sparqljs.Triple["subject"]; variablePrefix?: string; } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type"> & sparqljs.GeneratorOptions): string {
        return new sparqljs.Generator(parameters).stringify(Base_Dimension$W$Magnitude.sparqlConstructQuery(parameters));
    }

    export function sparqlConstructTemplateTriples(parameters?: { ignoreRdfType?: boolean; subject?: sparqljs.Triple["subject"], variablePrefix?: string }): readonly sparqljs.Triple[] {
        const subject = parameters?.subject ?? dataFactory.variable!("baseDimensionWMagnitude");
        const variablePrefix = parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "baseDimensionWMagnitude");
        return [...QUDT_Concept.sparqlConstructTemplateTriples({ ignoreRdfType: true, subject, variablePrefix }), ...(parameters?.ignoreRdfType ? [] : [{ subject, predicate: dataFactory.namedNode("http://www.w3.org/1999/02/22-rdf-syntax-ns#type"), object: dataFactory.variable!(`${variablePrefix}RdfType`) }]), { object: dataFactory.variable!(`${variablePrefix}QudtBaseDimensionMagnitudeJHasBaseQuantityKind`), predicate: dataFactory.namedNode("http://qudt.org/schema/qudt/hasBaseQuantityKind"), subject }, ...Quantity_Kind.sparqlConstructTemplateTriples({ ignoreRdfType: true, subject: dataFactory.variable!(`${variablePrefix}QudtBaseDimensionMagnitudeJHasBaseQuantityKind`), variablePrefix: `${variablePrefix}QudtBaseDimensionMagnitudeJHasBaseQuantityKind` }), { object: dataFactory.variable!(`${variablePrefix}QudtBaseDimensionMagnitudeJVectorMagnitude`), predicate: dataFactory.namedNode("http://qudt.org/schema/qudt/vectorMagnitude"), subject }];
    }

    export function sparqlWherePatterns(parameters: { ignoreRdfType?: boolean; subject?: sparqljs.Triple["subject"], variablePrefix?: string }): readonly sparqljs.Pattern[] {
        const subject = parameters?.subject ?? dataFactory.variable!("baseDimensionWMagnitude");
        const variablePrefix = parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "baseDimensionWMagnitude");
        return [...QUDT_Concept.sparqlWherePatterns({ ignoreRdfType: true, subject, variablePrefix }), ...(parameters?.ignoreRdfType ? [] : [{ triples: [{ subject, predicate: dataFactory.namedNode("http://www.w3.org/1999/02/22-rdf-syntax-ns#type"), object: dataFactory.namedNode("http://qudt.org/schema/qudt/BaseDimensionMagnitude") }], type: "bgp" as const }, { triples: [{ subject, predicate: dataFactory.namedNode("http://www.w3.org/1999/02/22-rdf-syntax-ns#type"), object: dataFactory.variable!(`${variablePrefix}RdfType`) }], type: "bgp" as const }]), { triples: [{ object: dataFactory.variable!(`${variablePrefix}QudtBaseDimensionMagnitudeJHasBaseQuantityKind`), predicate: dataFactory.namedNode("http://qudt.org/schema/qudt/hasBaseQuantityKind"), subject }], type: "bgp" }, ...Quantity_Kind.sparqlWherePatterns({ ignoreRdfType: true, subject: dataFactory.variable!(`${variablePrefix}QudtBaseDimensionMagnitudeJHasBaseQuantityKind`), variablePrefix: `${variablePrefix}QudtBaseDimensionMagnitudeJHasBaseQuantityKind` }), { triples: [{ object: dataFactory.variable!(`${variablePrefix}QudtBaseDimensionMagnitudeJVectorMagnitude`), predicate: dataFactory.namedNode("http://qudt.org/schema/qudt/vectorMagnitude"), subject }], type: "bgp" }];
    }
}
/**
 * Aspect Class
 */
export class Aspect_Class {
    private _identifier: (rdfjs.BlankNode | rdfjs.NamedNode) | undefined;
    readonly type = "Aspect_Class";

    constructor(parameters: { readonly identifier?: (rdfjs.BlankNode | rdfjs.NamedNode) | string }) {
        if (typeof parameters.identifier === "object") { this._identifier = parameters.identifier; } else if (typeof parameters.identifier === "string") { this._identifier = dataFactory.namedNode(parameters.identifier); } else if (typeof parameters.identifier === "undefined") { } else { this._identifier =( parameters.identifier) as never;
         }
    }

    get identifier(): (rdfjs.BlankNode | rdfjs.NamedNode) {
        if (typeof this._identifier === "undefined") { this._identifier = dataFactory.blankNode(); } return this._identifier;
    }

    equals(other: Aspect_Class): EqualsResult {
        return (booleanEquals)(this.identifier, other.identifier).mapLeft(propertyValuesUnequal => ({ left: this, right: other, propertyName: "identifier", propertyValuesUnequal, type: "Property" as const })).chain(() => (strictEquals)(this.type, other.type).mapLeft(propertyValuesUnequal => ({ left: this, right: other, propertyName: "type", propertyValuesUnequal, type: "Property" as const })));
    }

    hash<HasherT extends { update: (message: string | number[] | ArrayBuffer | Uint8Array) => void; }>(_hasher: HasherT): HasherT {
        _hasher.update(this.identifier.value);
        _hasher.update(this.type);
        this.hashShaclProperties(_hasher);
        return _hasher;
    }

    protected hashShaclProperties<HasherT extends { update: (message: string | number[] | ArrayBuffer | Uint8Array) => void; }>(_hasher: HasherT): HasherT {
        return _hasher;
    }

    toJson(): { readonly "@id": string; readonly "type": "Aspect_Class" } {
        return JSON.parse(JSON.stringify({ "@id": this.identifier.termType === "BlankNode" ? `_:${this.identifier.value}` : this.identifier.value,type: this.type } satisfies ReturnType<Aspect_Class["toJson"]>));
    }

    toRdf({ ignoreRdfType, mutateGraph, resourceSet }: { ignoreRdfType?: boolean; mutateGraph?: rdfjsResource.MutableResource.MutateGraph, resourceSet: rdfjsResource.MutableResourceSet }): rdfjsResource.MutableResource {
        const _resource = resourceSet.mutableResource(this.identifier, { mutateGraph });
        if (!ignoreRdfType) { _resource.add(_resource.dataFactory.namedNode("http://www.w3.org/1999/02/22-rdf-syntax-ns#type"), _resource.dataFactory.namedNode("http://qudt.org/schema/qudt/AspectClass")); }

        return _resource;
    }

    toString(): string {
        return JSON.stringify(this.toJson());
    }
}

export namespace Aspect_Class {
    export function _propertiesFromJson(_json: unknown): purify.Either<zod.ZodError, { identifier: (rdfjs.BlankNode | rdfjs.NamedNode); }> {
        const _jsonSafeParseResult = jsonZodSchema().safeParse(_json);
        if (!_jsonSafeParseResult.success) { return purify.Left(_jsonSafeParseResult.error); }

        const _jsonObject = _jsonSafeParseResult.data;
        const identifier = (_jsonObject["@id"].startsWith("_:") ? dataFactory.blankNode(_jsonObject["@id"].substring(2)) : dataFactory.namedNode(_jsonObject["@id"]));
        return purify.Either.of({ identifier })
    }

    export function fromJson(json: unknown): purify.Either<zod.ZodError, Aspect_Class> {
        return Aspect_Class._propertiesFromJson(json).map(properties => new Aspect_Class(properties));
    }

    export function _propertiesFromRdf({ ignoreRdfType: _ignoreRdfType, languageIn: _languageIn, resource: _resource,
        // @ts-ignore
        ..._context }: { [_index: string]: any; ignoreRdfType?: boolean; languageIn?: readonly string[]; resource: rdfjsResource.Resource; }): purify.Either<rdfjsResource.Resource.ValueError, { identifier: (rdfjs.BlankNode | rdfjs.NamedNode); }> {
        if (!_ignoreRdfType && !_resource.isInstanceOf(dataFactory.namedNode("http://qudt.org/schema/qudt/AspectClass"))) { return purify.Left(new rdfjsResource.Resource.ValueError({ focusResource: _resource, message: `${rdfjsResource.Resource.Identifier.toString(_resource.identifier)} has unexpected RDF type (expected http://qudt.org/schema/qudt/AspectClass)`, predicate: dataFactory.namedNode("http://qudt.org/schema/qudt/AspectClass") })); }

        const identifier = _resource.identifier
        return purify.Either.of({ identifier })
    }

    export function fromRdf(parameters: Parameters<typeof Aspect_Class._propertiesFromRdf>[0]): purify.Either<rdfjsResource.Resource.ValueError, Aspect_Class> {
        return Aspect_Class._propertiesFromRdf(parameters).map(properties => new Aspect_Class(properties));
    }

    export let fromRdfType: rdfjs.NamedNode<string> = dataFactory.namedNode("http://qudt.org/schema/qudt/AspectClass");

    export function jsonSchema() {
        return zodToJsonSchema(jsonZodSchema());
    }

    export function jsonUiSchema(parameters?: { scopePrefix?: string }) {
        const scopePrefix = parameters?.scopePrefix ?? "#";
        return { "elements": [ { label: "Identifier", scope: `${scopePrefix}/properties/@id`, type: "Control" }, { rule: { condition: { schema: { const: "Aspect_Class" }, scope: `${scopePrefix}/properties/type` }, effect: "HIDE" }, scope: `${scopePrefix}/properties/type`, type: "Control" } ], label: "Aspect Class", type: "Group" }
    }

    export function jsonZodSchema() {
        return zod.object({ "@id": zod.string().min(1),"type": zod.literal("Aspect_Class") });
    }

    export function sparqlConstructQuery(parameters?: { ignoreRdfType?: boolean; prefixes?: { [prefix: string]: string }; subject?: sparqljs.Triple["subject"]; } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type">): sparqljs.ConstructQuery {
        const { ignoreRdfType, subject, ...queryParameters } = parameters ?? {}

        return { ...queryParameters, prefixes: parameters?.prefixes ?? {}, queryType: "CONSTRUCT", template: (queryParameters.template ?? []).concat(Aspect_Class.sparqlConstructTemplateTriples({ ignoreRdfType, subject })), type: "query", where: (queryParameters.where ?? []).concat(Aspect_Class.sparqlWherePatterns({ ignoreRdfType, subject })) };
    }

    export function sparqlConstructQueryString(parameters?: { ignoreRdfType?: boolean; subject?: sparqljs.Triple["subject"]; variablePrefix?: string; } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type"> & sparqljs.GeneratorOptions): string {
        return new sparqljs.Generator(parameters).stringify(Aspect_Class.sparqlConstructQuery(parameters));
    }

    export function sparqlConstructTemplateTriples(parameters?: { ignoreRdfType?: boolean; subject?: sparqljs.Triple["subject"], variablePrefix?: string }): readonly sparqljs.Triple[] {
        const subject = parameters?.subject ?? dataFactory.variable!("aspectClass");
        const variablePrefix = parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "aspectClass");
        return [...(parameters?.ignoreRdfType ? [] : [{ subject, predicate: dataFactory.namedNode("http://www.w3.org/1999/02/22-rdf-syntax-ns#type"), object: dataFactory.variable!(`${variablePrefix}RdfType`) }])];
    }

    export function sparqlWherePatterns(parameters: { ignoreRdfType?: boolean; subject?: sparqljs.Triple["subject"], variablePrefix?: string }): readonly sparqljs.Pattern[] {
        const subject = parameters?.subject ?? dataFactory.variable!("aspectClass");
        const variablePrefix = parameters?.variablePrefix ?? (subject.termType === "Variable" ? subject.value : "aspectClass");
        return [...(parameters?.ignoreRdfType ? [] : [{ triples: [{ subject, predicate: dataFactory.namedNode("http://www.w3.org/1999/02/22-rdf-syntax-ns#type"), object: dataFactory.namedNode("http://qudt.org/schema/qudt/AspectClass") }], type: "bgp" as const }, { triples: [{ subject, predicate: dataFactory.namedNode("http://www.w3.org/1999/02/22-rdf-syntax-ns#type"), object: dataFactory.variable!(`${variablePrefix}RdfType`) }], type: "bgp" as const }])];
    }
}

    

